// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zera_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zera_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zera_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "txn.pb.h"
#include "validator.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zera_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zera_5fapi_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zera_5fapi_2eproto;
namespace zera_api {
class ActivityRequest;
struct ActivityRequestDefaultTypeInternal;
extern ActivityRequestDefaultTypeInternal _ActivityRequest_default_instance_;
class BalanceRequest;
struct BalanceRequestDefaultTypeInternal;
extern BalanceRequestDefaultTypeInternal _BalanceRequest_default_instance_;
class BalanceResponse;
struct BalanceResponseDefaultTypeInternal;
extern BalanceResponseDefaultTypeInternal _BalanceResponse_default_instance_;
class BaseFeeRequest;
struct BaseFeeRequestDefaultTypeInternal;
extern BaseFeeRequestDefaultTypeInternal _BaseFeeRequest_default_instance_;
class BaseFeeResponse;
struct BaseFeeResponseDefaultTypeInternal;
extern BaseFeeResponseDefaultTypeInternal _BaseFeeResponse_default_instance_;
class BlockRequest;
struct BlockRequestDefaultTypeInternal;
extern BlockRequestDefaultTypeInternal _BlockRequest_default_instance_;
class BlockResponse;
struct BlockResponseDefaultTypeInternal;
extern BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
class ContractFeeRequest;
struct ContractFeeRequestDefaultTypeInternal;
extern ContractFeeRequestDefaultTypeInternal _ContractFeeRequest_default_instance_;
class ContractFeeResponse;
struct ContractFeeResponseDefaultTypeInternal;
extern ContractFeeResponseDefaultTypeInternal _ContractFeeResponse_default_instance_;
class DatabaseRequest;
struct DatabaseRequestDefaultTypeInternal;
extern DatabaseRequestDefaultTypeInternal _DatabaseRequest_default_instance_;
class DatabaseResponse;
struct DatabaseResponseDefaultTypeInternal;
extern DatabaseResponseDefaultTypeInternal _DatabaseResponse_default_instance_;
class DenominationRequest;
struct DenominationRequestDefaultTypeInternal;
extern DenominationRequestDefaultTypeInternal _DenominationRequest_default_instance_;
class DenominationResponse;
struct DenominationResponseDefaultTypeInternal;
extern DenominationResponseDefaultTypeInternal _DenominationResponse_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class ItemRequest;
struct ItemRequestDefaultTypeInternal;
extern ItemRequestDefaultTypeInternal _ItemRequest_default_instance_;
class ItemResponse;
struct ItemResponseDefaultTypeInternal;
extern ItemResponseDefaultTypeInternal _ItemResponse_default_instance_;
class NonceRequest;
struct NonceRequestDefaultTypeInternal;
extern NonceRequestDefaultTypeInternal _NonceRequest_default_instance_;
class NonceResponse;
struct NonceResponseDefaultTypeInternal;
extern NonceResponseDefaultTypeInternal _NonceResponse_default_instance_;
class ProposalLedgerRequest;
struct ProposalLedgerRequestDefaultTypeInternal;
extern ProposalLedgerRequestDefaultTypeInternal _ProposalLedgerRequest_default_instance_;
class ProposalLedgerResponse;
struct ProposalLedgerResponseDefaultTypeInternal;
extern ProposalLedgerResponseDefaultTypeInternal _ProposalLedgerResponse_default_instance_;
class SmartContractEventsResponse;
struct SmartContractEventsResponseDefaultTypeInternal;
extern SmartContractEventsResponseDefaultTypeInternal _SmartContractEventsResponse_default_instance_;
class SmartContractSubscription;
struct SmartContractSubscriptionDefaultTypeInternal;
extern SmartContractSubscriptionDefaultTypeInternal _SmartContractSubscription_default_instance_;
class SmartContractSubscription_SubscibersEntry_DoNotUse;
struct SmartContractSubscription_SubscibersEntry_DoNotUseDefaultTypeInternal;
extern SmartContractSubscription_SubscibersEntry_DoNotUseDefaultTypeInternal _SmartContractSubscription_SubscibersEntry_DoNotUse_default_instance_;
class Subscriber;
struct SubscriberDefaultTypeInternal;
extern SubscriberDefaultTypeInternal _Subscriber_default_instance_;
class TokenFeeInfo;
struct TokenFeeInfoDefaultTypeInternal;
extern TokenFeeInfoDefaultTypeInternal _TokenFeeInfo_default_instance_;
class TokenFeeInfoRequest;
struct TokenFeeInfoRequestDefaultTypeInternal;
extern TokenFeeInfoRequestDefaultTypeInternal _TokenFeeInfoRequest_default_instance_;
class TokenFeeInfoResponse;
struct TokenFeeInfoResponseDefaultTypeInternal;
extern TokenFeeInfoResponseDefaultTypeInternal _TokenFeeInfoResponse_default_instance_;
class WalletChange;
struct WalletChangeDefaultTypeInternal;
extern WalletChangeDefaultTypeInternal _WalletChange_default_instance_;
}  // namespace zera_api
PROTOBUF_NAMESPACE_OPEN
template<> ::zera_api::ActivityRequest* Arena::CreateMaybeMessage<::zera_api::ActivityRequest>(Arena*);
template<> ::zera_api::BalanceRequest* Arena::CreateMaybeMessage<::zera_api::BalanceRequest>(Arena*);
template<> ::zera_api::BalanceResponse* Arena::CreateMaybeMessage<::zera_api::BalanceResponse>(Arena*);
template<> ::zera_api::BaseFeeRequest* Arena::CreateMaybeMessage<::zera_api::BaseFeeRequest>(Arena*);
template<> ::zera_api::BaseFeeResponse* Arena::CreateMaybeMessage<::zera_api::BaseFeeResponse>(Arena*);
template<> ::zera_api::BlockRequest* Arena::CreateMaybeMessage<::zera_api::BlockRequest>(Arena*);
template<> ::zera_api::BlockResponse* Arena::CreateMaybeMessage<::zera_api::BlockResponse>(Arena*);
template<> ::zera_api::ContractFeeRequest* Arena::CreateMaybeMessage<::zera_api::ContractFeeRequest>(Arena*);
template<> ::zera_api::ContractFeeResponse* Arena::CreateMaybeMessage<::zera_api::ContractFeeResponse>(Arena*);
template<> ::zera_api::DatabaseRequest* Arena::CreateMaybeMessage<::zera_api::DatabaseRequest>(Arena*);
template<> ::zera_api::DatabaseResponse* Arena::CreateMaybeMessage<::zera_api::DatabaseResponse>(Arena*);
template<> ::zera_api::DenominationRequest* Arena::CreateMaybeMessage<::zera_api::DenominationRequest>(Arena*);
template<> ::zera_api::DenominationResponse* Arena::CreateMaybeMessage<::zera_api::DenominationResponse>(Arena*);
template<> ::zera_api::Item* Arena::CreateMaybeMessage<::zera_api::Item>(Arena*);
template<> ::zera_api::ItemRequest* Arena::CreateMaybeMessage<::zera_api::ItemRequest>(Arena*);
template<> ::zera_api::ItemResponse* Arena::CreateMaybeMessage<::zera_api::ItemResponse>(Arena*);
template<> ::zera_api::NonceRequest* Arena::CreateMaybeMessage<::zera_api::NonceRequest>(Arena*);
template<> ::zera_api::NonceResponse* Arena::CreateMaybeMessage<::zera_api::NonceResponse>(Arena*);
template<> ::zera_api::ProposalLedgerRequest* Arena::CreateMaybeMessage<::zera_api::ProposalLedgerRequest>(Arena*);
template<> ::zera_api::ProposalLedgerResponse* Arena::CreateMaybeMessage<::zera_api::ProposalLedgerResponse>(Arena*);
template<> ::zera_api::SmartContractEventsResponse* Arena::CreateMaybeMessage<::zera_api::SmartContractEventsResponse>(Arena*);
template<> ::zera_api::SmartContractSubscription* Arena::CreateMaybeMessage<::zera_api::SmartContractSubscription>(Arena*);
template<> ::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse>(Arena*);
template<> ::zera_api::Subscriber* Arena::CreateMaybeMessage<::zera_api::Subscriber>(Arena*);
template<> ::zera_api::TokenFeeInfo* Arena::CreateMaybeMessage<::zera_api::TokenFeeInfo>(Arena*);
template<> ::zera_api::TokenFeeInfoRequest* Arena::CreateMaybeMessage<::zera_api::TokenFeeInfoRequest>(Arena*);
template<> ::zera_api::TokenFeeInfoResponse* Arena::CreateMaybeMessage<::zera_api::TokenFeeInfoResponse>(Arena*);
template<> ::zera_api::WalletChange* Arena::CreateMaybeMessage<::zera_api::WalletChange>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zera_api {

enum CONFIRMATION_LEVEL : int {
  PROCESSED = 0,
  FINALIZED = 1,
  CONFIRMED = 2,
  CONFIRMATION_LEVEL_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CONFIRMATION_LEVEL_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CONFIRMATION_LEVEL_IsValid(int value);
constexpr CONFIRMATION_LEVEL CONFIRMATION_LEVEL_MIN = PROCESSED;
constexpr CONFIRMATION_LEVEL CONFIRMATION_LEVEL_MAX = CONFIRMED;
constexpr int CONFIRMATION_LEVEL_ARRAYSIZE = CONFIRMATION_LEVEL_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CONFIRMATION_LEVEL_descriptor();
template<typename T>
inline const std::string& CONFIRMATION_LEVEL_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CONFIRMATION_LEVEL>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CONFIRMATION_LEVEL_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CONFIRMATION_LEVEL_descriptor(), enum_t_value);
}
inline bool CONFIRMATION_LEVEL_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CONFIRMATION_LEVEL* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CONFIRMATION_LEVEL>(
    CONFIRMATION_LEVEL_descriptor(), name, value);
}
enum DATABASE_TYPE : int {
  UNKNOWN = 0,
  CONTRACTS = 1,
  HASH_INDEX = 2,
  CONTRACT_SUPPLY = 3,
  SMART_CONTRACTS = 4,
  VALIDATORS = 5,
  BLOCKS = 6,
  HEADERS = 7,
  TRANSACTIONS = 8,
  CONTRACT_ITEMS = 9,
  VALIDATOR_UNBONDING = 10,
  PROPOSAL_LEDGER = 11,
  PROPOSALS = 12,
  CURRENCY_EQUIVALENTS = 13,
  EXPENSE_RATIO = 14,
  ATTESTATION = 15,
  CONFIRMED_BLOCKS = 16,
  DATABASE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DATABASE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DATABASE_TYPE_IsValid(int value);
constexpr DATABASE_TYPE DATABASE_TYPE_MIN = UNKNOWN;
constexpr DATABASE_TYPE DATABASE_TYPE_MAX = CONFIRMED_BLOCKS;
constexpr int DATABASE_TYPE_ARRAYSIZE = DATABASE_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DATABASE_TYPE_descriptor();
template<typename T>
inline const std::string& DATABASE_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DATABASE_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DATABASE_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DATABASE_TYPE_descriptor(), enum_t_value);
}
inline bool DATABASE_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DATABASE_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DATABASE_TYPE>(
    DATABASE_TYPE_descriptor(), name, value);
}
enum PROPOSAL_TYPE : int {
  ALL_PROPOSALS = 0,
  ALL_LEDGERS = 1,
  PROPOSAL_BY_ID = 2,
  LEDGER_BY_ID = 3,
  PROPOSAL_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PROPOSAL_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PROPOSAL_TYPE_IsValid(int value);
constexpr PROPOSAL_TYPE PROPOSAL_TYPE_MIN = ALL_PROPOSALS;
constexpr PROPOSAL_TYPE PROPOSAL_TYPE_MAX = LEDGER_BY_ID;
constexpr int PROPOSAL_TYPE_ARRAYSIZE = PROPOSAL_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PROPOSAL_TYPE_descriptor();
template<typename T>
inline const std::string& PROPOSAL_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PROPOSAL_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PROPOSAL_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PROPOSAL_TYPE_descriptor(), enum_t_value);
}
inline bool PROPOSAL_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PROPOSAL_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PROPOSAL_TYPE>(
    PROPOSAL_TYPE_descriptor(), name, value);
}
// ===================================================================

class ProposalLedgerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.ProposalLedgerRequest) */ {
 public:
  inline ProposalLedgerRequest() : ProposalLedgerRequest(nullptr) {}
  ~ProposalLedgerRequest() override;
  explicit PROTOBUF_CONSTEXPR ProposalLedgerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProposalLedgerRequest(const ProposalLedgerRequest& from);
  ProposalLedgerRequest(ProposalLedgerRequest&& from) noexcept
    : ProposalLedgerRequest() {
    *this = ::std::move(from);
  }

  inline ProposalLedgerRequest& operator=(const ProposalLedgerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalLedgerRequest& operator=(ProposalLedgerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalLedgerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalLedgerRequest* internal_default_instance() {
    return reinterpret_cast<const ProposalLedgerRequest*>(
               &_ProposalLedgerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ProposalLedgerRequest& a, ProposalLedgerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalLedgerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalLedgerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProposalLedgerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProposalLedgerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProposalLedgerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProposalLedgerRequest& from) {
    ProposalLedgerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalLedgerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.ProposalLedgerRequest";
  }
  protected:
  explicit ProposalLedgerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .zera_api.DATABASE_TYPE type = 1;
  void clear_type();
  ::zera_api::DATABASE_TYPE type() const;
  void set_type(::zera_api::DATABASE_TYPE value);
  private:
  ::zera_api::DATABASE_TYPE _internal_type() const;
  void _internal_set_type(::zera_api::DATABASE_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.ProposalLedgerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ProposalLedgerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.ProposalLedgerResponse) */ {
 public:
  inline ProposalLedgerResponse() : ProposalLedgerResponse(nullptr) {}
  ~ProposalLedgerResponse() override;
  explicit PROTOBUF_CONSTEXPR ProposalLedgerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProposalLedgerResponse(const ProposalLedgerResponse& from);
  ProposalLedgerResponse(ProposalLedgerResponse&& from) noexcept
    : ProposalLedgerResponse() {
    *this = ::std::move(from);
  }

  inline ProposalLedgerResponse& operator=(const ProposalLedgerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalLedgerResponse& operator=(ProposalLedgerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalLedgerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalLedgerResponse* internal_default_instance() {
    return reinterpret_cast<const ProposalLedgerResponse*>(
               &_ProposalLedgerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProposalLedgerResponse& a, ProposalLedgerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalLedgerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalLedgerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProposalLedgerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProposalLedgerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProposalLedgerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProposalLedgerResponse& from) {
    ProposalLedgerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalLedgerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.ProposalLedgerResponse";
  }
  protected:
  explicit ProposalLedgerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedgerKeysFieldNumber = 1,
    kLedgerValuesFieldNumber = 2,
    kProposalKeysFieldNumber = 3,
    kProposalValuesFieldNumber = 4,
    kWalletsKeysFieldNumber = 5,
    kWalletsValuesFieldNumber = 6,
    kTempKeysFieldNumber = 7,
    kTempValuesFieldNumber = 8,
    kVotedKeysFieldNumber = 9,
    kVotedValuesFieldNumber = 10,
  };
  // repeated string ledger_keys = 1;
  int ledger_keys_size() const;
  private:
  int _internal_ledger_keys_size() const;
  public:
  void clear_ledger_keys();
  const std::string& ledger_keys(int index) const;
  std::string* mutable_ledger_keys(int index);
  void set_ledger_keys(int index, const std::string& value);
  void set_ledger_keys(int index, std::string&& value);
  void set_ledger_keys(int index, const char* value);
  void set_ledger_keys(int index, const char* value, size_t size);
  std::string* add_ledger_keys();
  void add_ledger_keys(const std::string& value);
  void add_ledger_keys(std::string&& value);
  void add_ledger_keys(const char* value);
  void add_ledger_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ledger_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ledger_keys();
  private:
  const std::string& _internal_ledger_keys(int index) const;
  std::string* _internal_add_ledger_keys();
  public:

  // repeated string ledger_values = 2;
  int ledger_values_size() const;
  private:
  int _internal_ledger_values_size() const;
  public:
  void clear_ledger_values();
  const std::string& ledger_values(int index) const;
  std::string* mutable_ledger_values(int index);
  void set_ledger_values(int index, const std::string& value);
  void set_ledger_values(int index, std::string&& value);
  void set_ledger_values(int index, const char* value);
  void set_ledger_values(int index, const char* value, size_t size);
  std::string* add_ledger_values();
  void add_ledger_values(const std::string& value);
  void add_ledger_values(std::string&& value);
  void add_ledger_values(const char* value);
  void add_ledger_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ledger_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ledger_values();
  private:
  const std::string& _internal_ledger_values(int index) const;
  std::string* _internal_add_ledger_values();
  public:

  // repeated string proposal_keys = 3;
  int proposal_keys_size() const;
  private:
  int _internal_proposal_keys_size() const;
  public:
  void clear_proposal_keys();
  const std::string& proposal_keys(int index) const;
  std::string* mutable_proposal_keys(int index);
  void set_proposal_keys(int index, const std::string& value);
  void set_proposal_keys(int index, std::string&& value);
  void set_proposal_keys(int index, const char* value);
  void set_proposal_keys(int index, const char* value, size_t size);
  std::string* add_proposal_keys();
  void add_proposal_keys(const std::string& value);
  void add_proposal_keys(std::string&& value);
  void add_proposal_keys(const char* value);
  void add_proposal_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proposal_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proposal_keys();
  private:
  const std::string& _internal_proposal_keys(int index) const;
  std::string* _internal_add_proposal_keys();
  public:

  // repeated string proposal_values = 4;
  int proposal_values_size() const;
  private:
  int _internal_proposal_values_size() const;
  public:
  void clear_proposal_values();
  const std::string& proposal_values(int index) const;
  std::string* mutable_proposal_values(int index);
  void set_proposal_values(int index, const std::string& value);
  void set_proposal_values(int index, std::string&& value);
  void set_proposal_values(int index, const char* value);
  void set_proposal_values(int index, const char* value, size_t size);
  std::string* add_proposal_values();
  void add_proposal_values(const std::string& value);
  void add_proposal_values(std::string&& value);
  void add_proposal_values(const char* value);
  void add_proposal_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proposal_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proposal_values();
  private:
  const std::string& _internal_proposal_values(int index) const;
  std::string* _internal_add_proposal_values();
  public:

  // repeated string wallets_keys = 5;
  int wallets_keys_size() const;
  private:
  int _internal_wallets_keys_size() const;
  public:
  void clear_wallets_keys();
  const std::string& wallets_keys(int index) const;
  std::string* mutable_wallets_keys(int index);
  void set_wallets_keys(int index, const std::string& value);
  void set_wallets_keys(int index, std::string&& value);
  void set_wallets_keys(int index, const char* value);
  void set_wallets_keys(int index, const char* value, size_t size);
  std::string* add_wallets_keys();
  void add_wallets_keys(const std::string& value);
  void add_wallets_keys(std::string&& value);
  void add_wallets_keys(const char* value);
  void add_wallets_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wallets_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wallets_keys();
  private:
  const std::string& _internal_wallets_keys(int index) const;
  std::string* _internal_add_wallets_keys();
  public:

  // repeated string wallets_values = 6;
  int wallets_values_size() const;
  private:
  int _internal_wallets_values_size() const;
  public:
  void clear_wallets_values();
  const std::string& wallets_values(int index) const;
  std::string* mutable_wallets_values(int index);
  void set_wallets_values(int index, const std::string& value);
  void set_wallets_values(int index, std::string&& value);
  void set_wallets_values(int index, const char* value);
  void set_wallets_values(int index, const char* value, size_t size);
  std::string* add_wallets_values();
  void add_wallets_values(const std::string& value);
  void add_wallets_values(std::string&& value);
  void add_wallets_values(const char* value);
  void add_wallets_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wallets_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wallets_values();
  private:
  const std::string& _internal_wallets_values(int index) const;
  std::string* _internal_add_wallets_values();
  public:

  // repeated string temp_keys = 7;
  int temp_keys_size() const;
  private:
  int _internal_temp_keys_size() const;
  public:
  void clear_temp_keys();
  const std::string& temp_keys(int index) const;
  std::string* mutable_temp_keys(int index);
  void set_temp_keys(int index, const std::string& value);
  void set_temp_keys(int index, std::string&& value);
  void set_temp_keys(int index, const char* value);
  void set_temp_keys(int index, const char* value, size_t size);
  std::string* add_temp_keys();
  void add_temp_keys(const std::string& value);
  void add_temp_keys(std::string&& value);
  void add_temp_keys(const char* value);
  void add_temp_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& temp_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_temp_keys();
  private:
  const std::string& _internal_temp_keys(int index) const;
  std::string* _internal_add_temp_keys();
  public:

  // repeated string temp_values = 8;
  int temp_values_size() const;
  private:
  int _internal_temp_values_size() const;
  public:
  void clear_temp_values();
  const std::string& temp_values(int index) const;
  std::string* mutable_temp_values(int index);
  void set_temp_values(int index, const std::string& value);
  void set_temp_values(int index, std::string&& value);
  void set_temp_values(int index, const char* value);
  void set_temp_values(int index, const char* value, size_t size);
  std::string* add_temp_values();
  void add_temp_values(const std::string& value);
  void add_temp_values(std::string&& value);
  void add_temp_values(const char* value);
  void add_temp_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& temp_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_temp_values();
  private:
  const std::string& _internal_temp_values(int index) const;
  std::string* _internal_add_temp_values();
  public:

  // repeated string voted_keys = 9;
  int voted_keys_size() const;
  private:
  int _internal_voted_keys_size() const;
  public:
  void clear_voted_keys();
  const std::string& voted_keys(int index) const;
  std::string* mutable_voted_keys(int index);
  void set_voted_keys(int index, const std::string& value);
  void set_voted_keys(int index, std::string&& value);
  void set_voted_keys(int index, const char* value);
  void set_voted_keys(int index, const char* value, size_t size);
  std::string* add_voted_keys();
  void add_voted_keys(const std::string& value);
  void add_voted_keys(std::string&& value);
  void add_voted_keys(const char* value);
  void add_voted_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& voted_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_voted_keys();
  private:
  const std::string& _internal_voted_keys(int index) const;
  std::string* _internal_add_voted_keys();
  public:

  // repeated string voted_values = 10;
  int voted_values_size() const;
  private:
  int _internal_voted_values_size() const;
  public:
  void clear_voted_values();
  const std::string& voted_values(int index) const;
  std::string* mutable_voted_values(int index);
  void set_voted_values(int index, const std::string& value);
  void set_voted_values(int index, std::string&& value);
  void set_voted_values(int index, const char* value);
  void set_voted_values(int index, const char* value, size_t size);
  std::string* add_voted_values();
  void add_voted_values(const std::string& value);
  void add_voted_values(std::string&& value);
  void add_voted_values(const char* value);
  void add_voted_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& voted_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_voted_values();
  private:
  const std::string& _internal_voted_values(int index) const;
  std::string* _internal_add_voted_values();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.ProposalLedgerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ledger_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ledger_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proposal_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proposal_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wallets_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wallets_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> temp_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> temp_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> voted_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> voted_values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class BlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.BlockRequest) */ {
 public:
  inline BlockRequest() : BlockRequest(nullptr) {}
  ~BlockRequest() override;
  explicit PROTOBUF_CONSTEXPR BlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRequest(const BlockRequest& from);
  BlockRequest(BlockRequest&& from) noexcept
    : BlockRequest() {
    *this = ::std::move(from);
  }

  inline BlockRequest& operator=(const BlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRequest& operator=(BlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRequest& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kBlockHeight = 1,
    kBlockHash = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const BlockRequest* internal_default_instance() {
    return reinterpret_cast<const BlockRequest*>(
               &_BlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BlockRequest& a, BlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockRequest& from) {
    BlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.BlockRequest";
  }
  protected:
  explicit BlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodedFieldNumber = 3,
    kBlockHeightFieldNumber = 1,
    kBlockHashFieldNumber = 2,
  };
  // bool encoded = 3;
  void clear_encoded();
  bool encoded() const;
  void set_encoded(bool value);
  private:
  bool _internal_encoded() const;
  void _internal_set_encoded(bool value);
  public:

  // uint64 block_height = 1;
  bool has_block_height() const;
  private:
  bool _internal_has_block_height() const;
  public:
  void clear_block_height();
  uint64_t block_height() const;
  void set_block_height(uint64_t value);
  private:
  uint64_t _internal_block_height() const;
  void _internal_set_block_height(uint64_t value);
  public:

  // string block_hash = 2;
  bool has_block_hash() const;
  private:
  bool _internal_has_block_hash() const;
  public:
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:zera_api.BlockRequest)
 private:
  class _Internal;
  void set_has_block_height();
  void set_has_block_hash();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool encoded_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t block_height_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class BlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.BlockResponse) */ {
 public:
  inline BlockResponse() : BlockResponse(nullptr) {}
  ~BlockResponse() override;
  explicit PROTOBUF_CONSTEXPR BlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockResponse(const BlockResponse& from);
  BlockResponse(BlockResponse&& from) noexcept
    : BlockResponse() {
    *this = ::std::move(from);
  }

  inline BlockResponse& operator=(const BlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockResponse& operator=(BlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockResponse* internal_default_instance() {
    return reinterpret_cast<const BlockResponse*>(
               &_BlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BlockResponse& a, BlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockResponse& from) {
    BlockResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.BlockResponse";
  }
  protected:
  explicit BlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .zera_validator.Block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::zera_validator::Block& block() const;
  PROTOBUF_NODISCARD ::zera_validator::Block* release_block();
  ::zera_validator::Block* mutable_block();
  void set_allocated_block(::zera_validator::Block* block);
  private:
  const ::zera_validator::Block& _internal_block() const;
  ::zera_validator::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::zera_validator::Block* block);
  ::zera_validator::Block* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:zera_api.BlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::zera_validator::Block* block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class NonceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.NonceRequest) */ {
 public:
  inline NonceRequest() : NonceRequest(nullptr) {}
  ~NonceRequest() override;
  explicit PROTOBUF_CONSTEXPR NonceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NonceRequest(const NonceRequest& from);
  NonceRequest(NonceRequest&& from) noexcept
    : NonceRequest() {
    *this = ::std::move(from);
  }

  inline NonceRequest& operator=(const NonceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NonceRequest& operator=(NonceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NonceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NonceRequest* internal_default_instance() {
    return reinterpret_cast<const NonceRequest*>(
               &_NonceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NonceRequest& a, NonceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NonceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NonceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NonceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NonceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NonceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NonceRequest& from) {
    NonceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NonceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.NonceRequest";
  }
  protected:
  explicit NonceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletAddressFieldNumber = 1,
    kEncodedFieldNumber = 3,
  };
  // bytes wallet_address = 1;
  void clear_wallet_address();
  const std::string& wallet_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wallet_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wallet_address();
  PROTOBUF_NODISCARD std::string* release_wallet_address();
  void set_allocated_wallet_address(std::string* wallet_address);
  private:
  const std::string& _internal_wallet_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet_address(const std::string& value);
  std::string* _internal_mutable_wallet_address();
  public:

  // bool encoded = 3;
  void clear_encoded();
  bool encoded() const;
  void set_encoded(bool value);
  private:
  bool _internal_encoded() const;
  void _internal_set_encoded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.NonceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_address_;
    bool encoded_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class NonceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.NonceResponse) */ {
 public:
  inline NonceResponse() : NonceResponse(nullptr) {}
  ~NonceResponse() override;
  explicit PROTOBUF_CONSTEXPR NonceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NonceResponse(const NonceResponse& from);
  NonceResponse(NonceResponse&& from) noexcept
    : NonceResponse() {
    *this = ::std::move(from);
  }

  inline NonceResponse& operator=(const NonceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NonceResponse& operator=(NonceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NonceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NonceResponse* internal_default_instance() {
    return reinterpret_cast<const NonceResponse*>(
               &_NonceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NonceResponse& a, NonceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NonceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NonceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NonceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NonceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NonceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NonceResponse& from) {
    NonceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NonceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.NonceResponse";
  }
  protected:
  explicit NonceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint64 nonce = 1;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.NonceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class BalanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.BalanceRequest) */ {
 public:
  inline BalanceRequest() : BalanceRequest(nullptr) {}
  ~BalanceRequest() override;
  explicit PROTOBUF_CONSTEXPR BalanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BalanceRequest(const BalanceRequest& from);
  BalanceRequest(BalanceRequest&& from) noexcept
    : BalanceRequest() {
    *this = ::std::move(from);
  }

  inline BalanceRequest& operator=(const BalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceRequest& operator=(BalanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BalanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BalanceRequest* internal_default_instance() {
    return reinterpret_cast<const BalanceRequest*>(
               &_BalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BalanceRequest& a, BalanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BalanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BalanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BalanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BalanceRequest& from) {
    BalanceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.BalanceRequest";
  }
  protected:
  explicit BalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletAddressFieldNumber = 1,
    kContractIdFieldNumber = 2,
    kEncodedFieldNumber = 3,
  };
  // bytes wallet_address = 1;
  void clear_wallet_address();
  const std::string& wallet_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wallet_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wallet_address();
  PROTOBUF_NODISCARD std::string* release_wallet_address();
  void set_allocated_wallet_address(std::string* wallet_address);
  private:
  const std::string& _internal_wallet_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet_address(const std::string& value);
  std::string* _internal_mutable_wallet_address();
  public:

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bool encoded = 3;
  void clear_encoded();
  bool encoded() const;
  void set_encoded(bool value);
  private:
  bool _internal_encoded() const;
  void _internal_set_encoded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.BalanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    bool encoded_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class BalanceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.BalanceResponse) */ {
 public:
  inline BalanceResponse() : BalanceResponse(nullptr) {}
  ~BalanceResponse() override;
  explicit PROTOBUF_CONSTEXPR BalanceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BalanceResponse(const BalanceResponse& from);
  BalanceResponse(BalanceResponse&& from) noexcept
    : BalanceResponse() {
    *this = ::std::move(from);
  }

  inline BalanceResponse& operator=(const BalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceResponse& operator=(BalanceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BalanceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BalanceResponse* internal_default_instance() {
    return reinterpret_cast<const BalanceResponse*>(
               &_BalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BalanceResponse& a, BalanceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BalanceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BalanceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BalanceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BalanceResponse& from) {
    BalanceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.BalanceResponse";
  }
  protected:
  explicit BalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceFieldNumber = 1,
    kDenominationFieldNumber = 2,
    kRateFieldNumber = 3,
  };
  // string balance = 1;
  void clear_balance();
  const std::string& balance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_balance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* balance);
  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(const std::string& value);
  std::string* _internal_mutable_balance();
  public:

  // string denomination = 2;
  void clear_denomination();
  const std::string& denomination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_denomination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_denomination();
  PROTOBUF_NODISCARD std::string* release_denomination();
  void set_allocated_denomination(std::string* denomination);
  private:
  const std::string& _internal_denomination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denomination(const std::string& value);
  std::string* _internal_mutable_denomination();
  public:

  // string rate = 3;
  void clear_rate();
  const std::string& rate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rate();
  PROTOBUF_NODISCARD std::string* release_rate();
  void set_allocated_rate(std::string* rate);
  private:
  const std::string& _internal_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate(const std::string& value);
  std::string* _internal_mutable_rate();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.BalanceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denomination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ContractFeeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.ContractFeeRequest) */ {
 public:
  inline ContractFeeRequest() : ContractFeeRequest(nullptr) {}
  ~ContractFeeRequest() override;
  explicit PROTOBUF_CONSTEXPR ContractFeeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractFeeRequest(const ContractFeeRequest& from);
  ContractFeeRequest(ContractFeeRequest&& from) noexcept
    : ContractFeeRequest() {
    *this = ::std::move(from);
  }

  inline ContractFeeRequest& operator=(const ContractFeeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractFeeRequest& operator=(ContractFeeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractFeeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractFeeRequest* internal_default_instance() {
    return reinterpret_cast<const ContractFeeRequest*>(
               &_ContractFeeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ContractFeeRequest& a, ContractFeeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractFeeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractFeeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractFeeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractFeeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractFeeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractFeeRequest& from) {
    ContractFeeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractFeeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.ContractFeeRequest";
  }
  protected:
  explicit ContractFeeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.ContractFeeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ContractFeeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.ContractFeeResponse) */ {
 public:
  inline ContractFeeResponse() : ContractFeeResponse(nullptr) {}
  ~ContractFeeResponse() override;
  explicit PROTOBUF_CONSTEXPR ContractFeeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractFeeResponse(const ContractFeeResponse& from);
  ContractFeeResponse(ContractFeeResponse&& from) noexcept
    : ContractFeeResponse() {
    *this = ::std::move(from);
  }

  inline ContractFeeResponse& operator=(const ContractFeeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractFeeResponse& operator=(ContractFeeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractFeeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractFeeResponse* internal_default_instance() {
    return reinterpret_cast<const ContractFeeResponse*>(
               &_ContractFeeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ContractFeeResponse& a, ContractFeeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractFeeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractFeeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractFeeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractFeeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractFeeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractFeeResponse& from) {
    ContractFeeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractFeeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.ContractFeeResponse";
  }
  protected:
  explicit ContractFeeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedFeeInstrumentFieldNumber = 2,
    kFeeFieldNumber = 3,
    kContractFeeTypeFieldNumber = 1,
  };
  // repeated string allowed_fee_instrument = 2;
  int allowed_fee_instrument_size() const;
  private:
  int _internal_allowed_fee_instrument_size() const;
  public:
  void clear_allowed_fee_instrument();
  const std::string& allowed_fee_instrument(int index) const;
  std::string* mutable_allowed_fee_instrument(int index);
  void set_allowed_fee_instrument(int index, const std::string& value);
  void set_allowed_fee_instrument(int index, std::string&& value);
  void set_allowed_fee_instrument(int index, const char* value);
  void set_allowed_fee_instrument(int index, const char* value, size_t size);
  std::string* add_allowed_fee_instrument();
  void add_allowed_fee_instrument(const std::string& value);
  void add_allowed_fee_instrument(std::string&& value);
  void add_allowed_fee_instrument(const char* value);
  void add_allowed_fee_instrument(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowed_fee_instrument() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowed_fee_instrument();
  private:
  const std::string& _internal_allowed_fee_instrument(int index) const;
  std::string* _internal_add_allowed_fee_instrument();
  public:

  // string fee = 3;
  void clear_fee();
  const std::string& fee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* fee);
  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(const std::string& value);
  std::string* _internal_mutable_fee();
  public:

  // .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 1;
  void clear_contract_fee_type();
  ::zera_txn::CONTRACT_FEE_TYPE contract_fee_type() const;
  void set_contract_fee_type(::zera_txn::CONTRACT_FEE_TYPE value);
  private:
  ::zera_txn::CONTRACT_FEE_TYPE _internal_contract_fee_type() const;
  void _internal_set_contract_fee_type(::zera_txn::CONTRACT_FEE_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.ContractFeeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowed_fee_instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    int contract_fee_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class BaseFeeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.BaseFeeRequest) */ {
 public:
  inline BaseFeeRequest() : BaseFeeRequest(nullptr) {}
  ~BaseFeeRequest() override;
  explicit PROTOBUF_CONSTEXPR BaseFeeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseFeeRequest(const BaseFeeRequest& from);
  BaseFeeRequest(BaseFeeRequest&& from) noexcept
    : BaseFeeRequest() {
    *this = ::std::move(from);
  }

  inline BaseFeeRequest& operator=(const BaseFeeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseFeeRequest& operator=(BaseFeeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseFeeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseFeeRequest* internal_default_instance() {
    return reinterpret_cast<const BaseFeeRequest*>(
               &_BaseFeeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BaseFeeRequest& a, BaseFeeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseFeeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseFeeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseFeeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseFeeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseFeeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseFeeRequest& from) {
    BaseFeeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseFeeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.BaseFeeRequest";
  }
  protected:
  explicit BaseFeeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kTxnTypeFieldNumber = 2,
  };
  // optional .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  PROTOBUF_NODISCARD ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // .zera_txn.TRANSACTION_TYPE txn_type = 2;
  void clear_txn_type();
  ::zera_txn::TRANSACTION_TYPE txn_type() const;
  void set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  private:
  ::zera_txn::TRANSACTION_TYPE _internal_txn_type() const;
  void _internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.BaseFeeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::zera_txn::PublicKey* public_key_;
    int txn_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class BaseFeeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.BaseFeeResponse) */ {
 public:
  inline BaseFeeResponse() : BaseFeeResponse(nullptr) {}
  ~BaseFeeResponse() override;
  explicit PROTOBUF_CONSTEXPR BaseFeeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseFeeResponse(const BaseFeeResponse& from);
  BaseFeeResponse(BaseFeeResponse&& from) noexcept
    : BaseFeeResponse() {
    *this = ::std::move(from);
  }

  inline BaseFeeResponse& operator=(const BaseFeeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseFeeResponse& operator=(BaseFeeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseFeeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseFeeResponse* internal_default_instance() {
    return reinterpret_cast<const BaseFeeResponse*>(
               &_BaseFeeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BaseFeeResponse& a, BaseFeeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseFeeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseFeeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseFeeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseFeeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseFeeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseFeeResponse& from) {
    BaseFeeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseFeeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.BaseFeeResponse";
  }
  protected:
  explicit BaseFeeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFeeFieldNumber = 1,
    kByteFeeFieldNumber = 2,
  };
  // string key_fee = 1;
  void clear_key_fee();
  const std::string& key_fee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_fee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_fee();
  PROTOBUF_NODISCARD std::string* release_key_fee();
  void set_allocated_key_fee(std::string* key_fee);
  private:
  const std::string& _internal_key_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_fee(const std::string& value);
  std::string* _internal_mutable_key_fee();
  public:

  // string byte_fee = 2;
  void clear_byte_fee();
  const std::string& byte_fee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_byte_fee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_byte_fee();
  PROTOBUF_NODISCARD std::string* release_byte_fee();
  void set_allocated_byte_fee(std::string* byte_fee);
  private:
  const std::string& _internal_byte_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_byte_fee(const std::string& value);
  std::string* _internal_mutable_byte_fee();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.BaseFeeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr byte_fee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class TokenFeeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.TokenFeeInfo) */ {
 public:
  inline TokenFeeInfo() : TokenFeeInfo(nullptr) {}
  ~TokenFeeInfo() override;
  explicit PROTOBUF_CONSTEXPR TokenFeeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenFeeInfo(const TokenFeeInfo& from);
  TokenFeeInfo(TokenFeeInfo&& from) noexcept
    : TokenFeeInfo() {
    *this = ::std::move(from);
  }

  inline TokenFeeInfo& operator=(const TokenFeeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenFeeInfo& operator=(TokenFeeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenFeeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenFeeInfo* internal_default_instance() {
    return reinterpret_cast<const TokenFeeInfo*>(
               &_TokenFeeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TokenFeeInfo& a, TokenFeeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenFeeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenFeeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenFeeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenFeeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenFeeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenFeeInfo& from) {
    TokenFeeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenFeeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.TokenFeeInfo";
  }
  protected:
  explicit TokenFeeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kRateFieldNumber = 2,
    kDenominationFieldNumber = 4,
    kContractFeesFieldNumber = 5,
    kAuthorizedFieldNumber = 3,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string rate = 2;
  void clear_rate();
  const std::string& rate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rate();
  PROTOBUF_NODISCARD std::string* release_rate();
  void set_allocated_rate(std::string* rate);
  private:
  const std::string& _internal_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate(const std::string& value);
  std::string* _internal_mutable_rate();
  public:

  // string denomination = 4;
  void clear_denomination();
  const std::string& denomination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_denomination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_denomination();
  PROTOBUF_NODISCARD std::string* release_denomination();
  void set_allocated_denomination(std::string* denomination);
  private:
  const std::string& _internal_denomination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denomination(const std::string& value);
  std::string* _internal_mutable_denomination();
  public:

  // optional .zera_txn.ContractFees contract_fees = 5;
  bool has_contract_fees() const;
  private:
  bool _internal_has_contract_fees() const;
  public:
  void clear_contract_fees();
  const ::zera_txn::ContractFees& contract_fees() const;
  PROTOBUF_NODISCARD ::zera_txn::ContractFees* release_contract_fees();
  ::zera_txn::ContractFees* mutable_contract_fees();
  void set_allocated_contract_fees(::zera_txn::ContractFees* contract_fees);
  private:
  const ::zera_txn::ContractFees& _internal_contract_fees() const;
  ::zera_txn::ContractFees* _internal_mutable_contract_fees();
  public:
  void unsafe_arena_set_allocated_contract_fees(
      ::zera_txn::ContractFees* contract_fees);
  ::zera_txn::ContractFees* unsafe_arena_release_contract_fees();

  // bool authorized = 3;
  void clear_authorized();
  bool authorized() const;
  void set_authorized(bool value);
  private:
  bool _internal_authorized() const;
  void _internal_set_authorized(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.TokenFeeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denomination_;
    ::zera_txn::ContractFees* contract_fees_;
    bool authorized_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class TokenFeeInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.TokenFeeInfoRequest) */ {
 public:
  inline TokenFeeInfoRequest() : TokenFeeInfoRequest(nullptr) {}
  ~TokenFeeInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR TokenFeeInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenFeeInfoRequest(const TokenFeeInfoRequest& from);
  TokenFeeInfoRequest(TokenFeeInfoRequest&& from) noexcept
    : TokenFeeInfoRequest() {
    *this = ::std::move(from);
  }

  inline TokenFeeInfoRequest& operator=(const TokenFeeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenFeeInfoRequest& operator=(TokenFeeInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenFeeInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenFeeInfoRequest* internal_default_instance() {
    return reinterpret_cast<const TokenFeeInfoRequest*>(
               &_TokenFeeInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TokenFeeInfoRequest& a, TokenFeeInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenFeeInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenFeeInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenFeeInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenFeeInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenFeeInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenFeeInfoRequest& from) {
    TokenFeeInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenFeeInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.TokenFeeInfoRequest";
  }
  protected:
  explicit TokenFeeInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdsFieldNumber = 1,
  };
  // repeated string contract_ids = 1;
  int contract_ids_size() const;
  private:
  int _internal_contract_ids_size() const;
  public:
  void clear_contract_ids();
  const std::string& contract_ids(int index) const;
  std::string* mutable_contract_ids(int index);
  void set_contract_ids(int index, const std::string& value);
  void set_contract_ids(int index, std::string&& value);
  void set_contract_ids(int index, const char* value);
  void set_contract_ids(int index, const char* value, size_t size);
  std::string* add_contract_ids();
  void add_contract_ids(const std::string& value);
  void add_contract_ids(std::string&& value);
  void add_contract_ids(const char* value);
  void add_contract_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& contract_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_contract_ids();
  private:
  const std::string& _internal_contract_ids(int index) const;
  std::string* _internal_add_contract_ids();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.TokenFeeInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> contract_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class TokenFeeInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.TokenFeeInfoResponse) */ {
 public:
  inline TokenFeeInfoResponse() : TokenFeeInfoResponse(nullptr) {}
  ~TokenFeeInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR TokenFeeInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenFeeInfoResponse(const TokenFeeInfoResponse& from);
  TokenFeeInfoResponse(TokenFeeInfoResponse&& from) noexcept
    : TokenFeeInfoResponse() {
    *this = ::std::move(from);
  }

  inline TokenFeeInfoResponse& operator=(const TokenFeeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenFeeInfoResponse& operator=(TokenFeeInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenFeeInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenFeeInfoResponse* internal_default_instance() {
    return reinterpret_cast<const TokenFeeInfoResponse*>(
               &_TokenFeeInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TokenFeeInfoResponse& a, TokenFeeInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenFeeInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenFeeInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenFeeInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenFeeInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenFeeInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenFeeInfoResponse& from) {
    TokenFeeInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenFeeInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.TokenFeeInfoResponse";
  }
  protected:
  explicit TokenFeeInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 1,
  };
  // repeated .zera_api.TokenFeeInfo tokens = 1;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::zera_api::TokenFeeInfo* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::TokenFeeInfo >*
      mutable_tokens();
  private:
  const ::zera_api::TokenFeeInfo& _internal_tokens(int index) const;
  ::zera_api::TokenFeeInfo* _internal_add_tokens();
  public:
  const ::zera_api::TokenFeeInfo& tokens(int index) const;
  ::zera_api::TokenFeeInfo* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::TokenFeeInfo >&
      tokens() const;

  // @@protoc_insertion_point(class_scope:zera_api.TokenFeeInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::TokenFeeInfo > tokens_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  explicit PROTOBUF_CONSTEXPR Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Item& from) {
    Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.Item";
  }
  protected:
  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kItemIdFieldNumber = 2,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string item_id = 2;
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.ItemRequest) */ {
 public:
  inline ItemRequest() : ItemRequest(nullptr) {}
  ~ItemRequest() override;
  explicit PROTOBUF_CONSTEXPR ItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemRequest(const ItemRequest& from);
  ItemRequest(ItemRequest&& from) noexcept
    : ItemRequest() {
    *this = ::std::move(from);
  }

  inline ItemRequest& operator=(const ItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemRequest& operator=(ItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemRequest* internal_default_instance() {
    return reinterpret_cast<const ItemRequest*>(
               &_ItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ItemRequest& a, ItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemRequest& from) {
    ItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.ItemRequest";
  }
  protected:
  explicit ItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletAddressFieldNumber = 1,
    kEncodedFieldNumber = 2,
  };
  // bytes wallet_address = 1;
  void clear_wallet_address();
  const std::string& wallet_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wallet_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wallet_address();
  PROTOBUF_NODISCARD std::string* release_wallet_address();
  void set_allocated_wallet_address(std::string* wallet_address);
  private:
  const std::string& _internal_wallet_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet_address(const std::string& value);
  std::string* _internal_mutable_wallet_address();
  public:

  // bool encoded = 2;
  void clear_encoded();
  bool encoded() const;
  void set_encoded(bool value);
  private:
  bool _internal_encoded() const;
  void _internal_set_encoded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.ItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_address_;
    bool encoded_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.ItemResponse) */ {
 public:
  inline ItemResponse() : ItemResponse(nullptr) {}
  ~ItemResponse() override;
  explicit PROTOBUF_CONSTEXPR ItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemResponse(const ItemResponse& from);
  ItemResponse(ItemResponse&& from) noexcept
    : ItemResponse() {
    *this = ::std::move(from);
  }

  inline ItemResponse& operator=(const ItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemResponse& operator=(ItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemResponse* internal_default_instance() {
    return reinterpret_cast<const ItemResponse*>(
               &_ItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ItemResponse& a, ItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemResponse& from) {
    ItemResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.ItemResponse";
  }
  protected:
  explicit ItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .zera_api.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::zera_api::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::Item >*
      mutable_items();
  private:
  const ::zera_api::Item& _internal_items(int index) const;
  ::zera_api::Item* _internal_add_items();
  public:
  const ::zera_api::Item& items(int index) const;
  ::zera_api::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:zera_api.ItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::Item > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DenominationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.DenominationRequest) */ {
 public:
  inline DenominationRequest() : DenominationRequest(nullptr) {}
  ~DenominationRequest() override;
  explicit PROTOBUF_CONSTEXPR DenominationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DenominationRequest(const DenominationRequest& from);
  DenominationRequest(DenominationRequest&& from) noexcept
    : DenominationRequest() {
    *this = ::std::move(from);
  }

  inline DenominationRequest& operator=(const DenominationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenominationRequest& operator=(DenominationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenominationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DenominationRequest* internal_default_instance() {
    return reinterpret_cast<const DenominationRequest*>(
               &_DenominationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DenominationRequest& a, DenominationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DenominationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenominationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DenominationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DenominationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DenominationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DenominationRequest& from) {
    DenominationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DenominationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.DenominationRequest";
  }
  protected:
  explicit DenominationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.DenominationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DenominationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.DenominationResponse) */ {
 public:
  inline DenominationResponse() : DenominationResponse(nullptr) {}
  ~DenominationResponse() override;
  explicit PROTOBUF_CONSTEXPR DenominationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DenominationResponse(const DenominationResponse& from);
  DenominationResponse(DenominationResponse&& from) noexcept
    : DenominationResponse() {
    *this = ::std::move(from);
  }

  inline DenominationResponse& operator=(const DenominationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenominationResponse& operator=(DenominationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenominationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DenominationResponse* internal_default_instance() {
    return reinterpret_cast<const DenominationResponse*>(
               &_DenominationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DenominationResponse& a, DenominationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DenominationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenominationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DenominationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DenominationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DenominationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DenominationResponse& from) {
    DenominationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DenominationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.DenominationResponse";
  }
  protected:
  explicit DenominationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenominationFieldNumber = 1,
  };
  // string denomination = 1;
  void clear_denomination();
  const std::string& denomination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_denomination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_denomination();
  PROTOBUF_NODISCARD std::string* release_denomination();
  void set_allocated_denomination(std::string* denomination);
  private:
  const std::string& _internal_denomination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denomination(const std::string& value);
  std::string* _internal_mutable_denomination();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.DenominationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denomination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.DatabaseRequest) */ {
 public:
  inline DatabaseRequest() : DatabaseRequest(nullptr) {}
  ~DatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR DatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatabaseRequest(const DatabaseRequest& from);
  DatabaseRequest(DatabaseRequest&& from) noexcept
    : DatabaseRequest() {
    *this = ::std::move(from);
  }

  inline DatabaseRequest& operator=(const DatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseRequest& operator=(DatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const DatabaseRequest*>(
               &_DatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DatabaseRequest& a, DatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatabaseRequest& from) {
    DatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.DatabaseRequest";
  }
  protected:
  explicit DatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .zera_api.DATABASE_TYPE type = 1;
  void clear_type();
  ::zera_api::DATABASE_TYPE type() const;
  void set_type(::zera_api::DATABASE_TYPE value);
  private:
  ::zera_api::DATABASE_TYPE _internal_type() const;
  void _internal_set_type(::zera_api::DATABASE_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.DatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DatabaseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.DatabaseResponse) */ {
 public:
  inline DatabaseResponse() : DatabaseResponse(nullptr) {}
  ~DatabaseResponse() override;
  explicit PROTOBUF_CONSTEXPR DatabaseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatabaseResponse(const DatabaseResponse& from);
  DatabaseResponse(DatabaseResponse&& from) noexcept
    : DatabaseResponse() {
    *this = ::std::move(from);
  }

  inline DatabaseResponse& operator=(const DatabaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseResponse& operator=(DatabaseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseResponse* internal_default_instance() {
    return reinterpret_cast<const DatabaseResponse*>(
               &_DatabaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DatabaseResponse& a, DatabaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatabaseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatabaseResponse& from) {
    DatabaseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.DatabaseResponse";
  }
  protected:
  explicit DatabaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.DatabaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ActivityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.ActivityRequest) */ {
 public:
  inline ActivityRequest() : ActivityRequest(nullptr) {}
  ~ActivityRequest() override;
  explicit PROTOBUF_CONSTEXPR ActivityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActivityRequest(const ActivityRequest& from);
  ActivityRequest(ActivityRequest&& from) noexcept
    : ActivityRequest() {
    *this = ::std::move(from);
  }

  inline ActivityRequest& operator=(const ActivityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivityRequest& operator=(ActivityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivityRequest* internal_default_instance() {
    return reinterpret_cast<const ActivityRequest*>(
               &_ActivityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ActivityRequest& a, ActivityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActivityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActivityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActivityRequest& from) {
    ActivityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.ActivityRequest";
  }
  protected:
  explicit ActivityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmartContractIdFieldNumber = 1,
    kHostFieldNumber = 4,
    kSignatureFieldNumber = 8,
    kPublicKeyFieldNumber = 7,
    kInstanceFieldNumber = 2,
    kLevelFieldNumber = 3,
    kPortFieldNumber = 5,
    kNonceFieldNumber = 9,
    kSubscribeFieldNumber = 6,
  };
  // string smart_contract_id = 1;
  void clear_smart_contract_id();
  const std::string& smart_contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smart_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smart_contract_id();
  PROTOBUF_NODISCARD std::string* release_smart_contract_id();
  void set_allocated_smart_contract_id(std::string* smart_contract_id);
  private:
  const std::string& _internal_smart_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smart_contract_id(const std::string& value);
  std::string* _internal_mutable_smart_contract_id();
  public:

  // string host = 4;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // bytes signature = 8;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_txn.PublicKey public_key = 7;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  PROTOBUF_NODISCARD ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // uint64 instance = 2;
  void clear_instance();
  uint64_t instance() const;
  void set_instance(uint64_t value);
  private:
  uint64_t _internal_instance() const;
  void _internal_set_instance(uint64_t value);
  public:

  // .zera_api.CONFIRMATION_LEVEL level = 3;
  void clear_level();
  ::zera_api::CONFIRMATION_LEVEL level() const;
  void set_level(::zera_api::CONFIRMATION_LEVEL value);
  private:
  ::zera_api::CONFIRMATION_LEVEL _internal_level() const;
  void _internal_set_level(::zera_api::CONFIRMATION_LEVEL value);
  public:

  // int32 port = 5;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // uint64 nonce = 9;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // bool subscribe = 6;
  void clear_subscribe();
  bool subscribe() const;
  void set_subscribe(bool value);
  private:
  bool _internal_subscribe() const;
  void _internal_set_subscribe(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.ActivityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smart_contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::zera_txn::PublicKey* public_key_;
    uint64_t instance_;
    int level_;
    int32_t port_;
    uint64_t nonce_;
    bool subscribe_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SmartContractEventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.SmartContractEventsResponse) */ {
 public:
  inline SmartContractEventsResponse() : SmartContractEventsResponse(nullptr) {}
  ~SmartContractEventsResponse() override;
  explicit PROTOBUF_CONSTEXPR SmartContractEventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContractEventsResponse(const SmartContractEventsResponse& from);
  SmartContractEventsResponse(SmartContractEventsResponse&& from) noexcept
    : SmartContractEventsResponse() {
    *this = ::std::move(from);
  }

  inline SmartContractEventsResponse& operator=(const SmartContractEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContractEventsResponse& operator=(SmartContractEventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContractEventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContractEventsResponse* internal_default_instance() {
    return reinterpret_cast<const SmartContractEventsResponse*>(
               &_SmartContractEventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SmartContractEventsResponse& a, SmartContractEventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContractEventsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContractEventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContractEventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContractEventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartContractEventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmartContractEventsResponse& from) {
    SmartContractEventsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContractEventsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.SmartContractEventsResponse";
  }
  protected:
  explicit SmartContractEventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmartContractFieldNumber = 1,
    kStorageFeeFieldNumber = 5,
    kEventDataFieldNumber = 7,
    kFunctionFieldNumber = 8,
    kBlockHashFieldNumber = 11,
    kTxnHashFieldNumber = 12,
    kSignatureFieldNumber = 14,
    kCallerFieldNumber = 6,
    kTimestampFieldNumber = 10,
    kPublicKeyFieldNumber = 13,
    kInstanceFieldNumber = 2,
    kGasUsedFieldNumber = 3,
    kGasApprovedFieldNumber = 4,
    kBlockHeightFieldNumber = 9,
  };
  // string smart_contract = 1;
  void clear_smart_contract();
  const std::string& smart_contract() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smart_contract(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smart_contract();
  PROTOBUF_NODISCARD std::string* release_smart_contract();
  void set_allocated_smart_contract(std::string* smart_contract);
  private:
  const std::string& _internal_smart_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smart_contract(const std::string& value);
  std::string* _internal_mutable_smart_contract();
  public:

  // string storage_fee = 5;
  void clear_storage_fee();
  const std::string& storage_fee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_storage_fee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_storage_fee();
  PROTOBUF_NODISCARD std::string* release_storage_fee();
  void set_allocated_storage_fee(std::string* storage_fee);
  private:
  const std::string& _internal_storage_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storage_fee(const std::string& value);
  std::string* _internal_mutable_storage_fee();
  public:

  // bytes event_data = 7;
  void clear_event_data();
  const std::string& event_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_data();
  PROTOBUF_NODISCARD std::string* release_event_data();
  void set_allocated_event_data(std::string* event_data);
  private:
  const std::string& _internal_event_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_data(const std::string& value);
  std::string* _internal_mutable_event_data();
  public:

  // string function = 8;
  void clear_function();
  const std::string& function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function();
  PROTOBUF_NODISCARD std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // string block_hash = 11;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // string txn_hash = 12;
  void clear_txn_hash();
  const std::string& txn_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txn_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txn_hash();
  PROTOBUF_NODISCARD std::string* release_txn_hash();
  void set_allocated_txn_hash(std::string* txn_hash);
  private:
  const std::string& _internal_txn_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txn_hash(const std::string& value);
  std::string* _internal_mutable_txn_hash();
  public:

  // bytes signature = 14;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_txn.PublicKey caller = 6;
  bool has_caller() const;
  private:
  bool _internal_has_caller() const;
  public:
  void clear_caller();
  const ::zera_txn::PublicKey& caller() const;
  PROTOBUF_NODISCARD ::zera_txn::PublicKey* release_caller();
  ::zera_txn::PublicKey* mutable_caller();
  void set_allocated_caller(::zera_txn::PublicKey* caller);
  private:
  const ::zera_txn::PublicKey& _internal_caller() const;
  ::zera_txn::PublicKey* _internal_mutable_caller();
  public:
  void unsafe_arena_set_allocated_caller(
      ::zera_txn::PublicKey* caller);
  ::zera_txn::PublicKey* unsafe_arena_release_caller();

  // .google.protobuf.Timestamp timestamp = 10;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .zera_txn.PublicKey public_key = 13;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  PROTOBUF_NODISCARD ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // uint64 instance = 2;
  void clear_instance();
  uint64_t instance() const;
  void set_instance(uint64_t value);
  private:
  uint64_t _internal_instance() const;
  void _internal_set_instance(uint64_t value);
  public:

  // uint64 gas_used = 3;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint64 gas_approved = 4;
  void clear_gas_approved();
  uint64_t gas_approved() const;
  void set_gas_approved(uint64_t value);
  private:
  uint64_t _internal_gas_approved() const;
  void _internal_set_gas_approved(uint64_t value);
  public:

  // uint64 block_height = 9;
  void clear_block_height();
  uint64_t block_height() const;
  void set_block_height(uint64_t value);
  private:
  uint64_t _internal_block_height() const;
  void _internal_set_block_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.SmartContractEventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smart_contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storage_fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txn_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::zera_txn::PublicKey* caller_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::zera_txn::PublicKey* public_key_;
    uint64_t instance_;
    uint64_t gas_used_;
    uint64_t gas_approved_;
    uint64_t block_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SmartContractSubscription_SubscibersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SmartContractSubscription_SubscibersEntry_DoNotUse, 
    std::string, ::zera_api::Subscriber,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SmartContractSubscription_SubscibersEntry_DoNotUse, 
    std::string, ::zera_api::Subscriber,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SmartContractSubscription_SubscibersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SmartContractSubscription_SubscibersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SmartContractSubscription_SubscibersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SmartContractSubscription_SubscibersEntry_DoNotUse& other);
  static const SmartContractSubscription_SubscibersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SmartContractSubscription_SubscibersEntry_DoNotUse*>(&_SmartContractSubscription_SubscibersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_api.SmartContractSubscription.SubscibersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_zera_5fapi_2eproto;
};

// -------------------------------------------------------------------

class SmartContractSubscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.SmartContractSubscription) */ {
 public:
  inline SmartContractSubscription() : SmartContractSubscription(nullptr) {}
  ~SmartContractSubscription() override;
  explicit PROTOBUF_CONSTEXPR SmartContractSubscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContractSubscription(const SmartContractSubscription& from);
  SmartContractSubscription(SmartContractSubscription&& from) noexcept
    : SmartContractSubscription() {
    *this = ::std::move(from);
  }

  inline SmartContractSubscription& operator=(const SmartContractSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContractSubscription& operator=(SmartContractSubscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContractSubscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContractSubscription* internal_default_instance() {
    return reinterpret_cast<const SmartContractSubscription*>(
               &_SmartContractSubscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SmartContractSubscription& a, SmartContractSubscription& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContractSubscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContractSubscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContractSubscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContractSubscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartContractSubscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmartContractSubscription& from) {
    SmartContractSubscription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContractSubscription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.SmartContractSubscription";
  }
  protected:
  explicit SmartContractSubscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSubscibersFieldNumber = 1,
  };
  // map<string, .zera_api.Subscriber> subscibers = 1;
  int subscibers_size() const;
  private:
  int _internal_subscibers_size() const;
  public:
  void clear_subscibers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >&
      _internal_subscibers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >*
      _internal_mutable_subscibers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >&
      subscibers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >*
      mutable_subscibers();

  // @@protoc_insertion_point(class_scope:zera_api.SmartContractSubscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SmartContractSubscription_SubscibersEntry_DoNotUse,
        std::string, ::zera_api::Subscriber,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> subscibers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class Subscriber final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.Subscriber) */ {
 public:
  inline Subscriber() : Subscriber(nullptr) {}
  ~Subscriber() override;
  explicit PROTOBUF_CONSTEXPR Subscriber(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscriber(const Subscriber& from);
  Subscriber(Subscriber&& from) noexcept
    : Subscriber() {
    *this = ::std::move(from);
  }

  inline Subscriber& operator=(const Subscriber& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscriber& operator=(Subscriber&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscriber& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscriber* internal_default_instance() {
    return reinterpret_cast<const Subscriber*>(
               &_Subscriber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Subscriber& a, Subscriber& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscriber* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscriber* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscriber* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subscriber>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subscriber& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Subscriber& from) {
    Subscriber::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscriber* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.Subscriber";
  }
  protected:
  explicit Subscriber(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 2,
    kLevelFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .zera_api.CONFIRMATION_LEVEL level = 1;
  void clear_level();
  ::zera_api::CONFIRMATION_LEVEL level() const;
  void set_level(::zera_api::CONFIRMATION_LEVEL value);
  private:
  ::zera_api::CONFIRMATION_LEVEL _internal_level() const;
  void _internal_set_level(::zera_api::CONFIRMATION_LEVEL value);
  public:

  // int32 port = 3;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_api.Subscriber)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    int level_;
    int32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// -------------------------------------------------------------------

class WalletChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_api.WalletChange) */ {
 public:
  inline WalletChange() : WalletChange(nullptr) {}
  ~WalletChange() override;
  explicit PROTOBUF_CONSTEXPR WalletChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalletChange(const WalletChange& from);
  WalletChange(WalletChange&& from) noexcept
    : WalletChange() {
    *this = ::std::move(from);
  }

  inline WalletChange& operator=(const WalletChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalletChange& operator=(WalletChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalletChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalletChange* internal_default_instance() {
    return reinterpret_cast<const WalletChange*>(
               &_WalletChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(WalletChange& a, WalletChange& b) {
    a.Swap(&b);
  }
  inline void Swap(WalletChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalletChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalletChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalletChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalletChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WalletChange& from) {
    WalletChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalletChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_api.WalletChange";
  }
  protected:
  explicit WalletChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdsFieldNumber = 2,
    kOldBalancesFieldNumber = 3,
    kNewBalancesFieldNumber = 4,
    kWalletAddressFieldNumber = 1,
  };
  // repeated string contract_ids = 2;
  int contract_ids_size() const;
  private:
  int _internal_contract_ids_size() const;
  public:
  void clear_contract_ids();
  const std::string& contract_ids(int index) const;
  std::string* mutable_contract_ids(int index);
  void set_contract_ids(int index, const std::string& value);
  void set_contract_ids(int index, std::string&& value);
  void set_contract_ids(int index, const char* value);
  void set_contract_ids(int index, const char* value, size_t size);
  std::string* add_contract_ids();
  void add_contract_ids(const std::string& value);
  void add_contract_ids(std::string&& value);
  void add_contract_ids(const char* value);
  void add_contract_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& contract_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_contract_ids();
  private:
  const std::string& _internal_contract_ids(int index) const;
  std::string* _internal_add_contract_ids();
  public:

  // repeated string old_balances = 3;
  int old_balances_size() const;
  private:
  int _internal_old_balances_size() const;
  public:
  void clear_old_balances();
  const std::string& old_balances(int index) const;
  std::string* mutable_old_balances(int index);
  void set_old_balances(int index, const std::string& value);
  void set_old_balances(int index, std::string&& value);
  void set_old_balances(int index, const char* value);
  void set_old_balances(int index, const char* value, size_t size);
  std::string* add_old_balances();
  void add_old_balances(const std::string& value);
  void add_old_balances(std::string&& value);
  void add_old_balances(const char* value);
  void add_old_balances(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& old_balances() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_old_balances();
  private:
  const std::string& _internal_old_balances(int index) const;
  std::string* _internal_add_old_balances();
  public:

  // repeated string new_balances = 4;
  int new_balances_size() const;
  private:
  int _internal_new_balances_size() const;
  public:
  void clear_new_balances();
  const std::string& new_balances(int index) const;
  std::string* mutable_new_balances(int index);
  void set_new_balances(int index, const std::string& value);
  void set_new_balances(int index, std::string&& value);
  void set_new_balances(int index, const char* value);
  void set_new_balances(int index, const char* value, size_t size);
  std::string* add_new_balances();
  void add_new_balances(const std::string& value);
  void add_new_balances(std::string&& value);
  void add_new_balances(const char* value);
  void add_new_balances(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& new_balances() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_new_balances();
  private:
  const std::string& _internal_new_balances(int index) const;
  std::string* _internal_add_new_balances();
  public:

  // bytes wallet_address = 1;
  void clear_wallet_address();
  const std::string& wallet_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wallet_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wallet_address();
  PROTOBUF_NODISCARD std::string* release_wallet_address();
  void set_allocated_wallet_address(std::string* wallet_address);
  private:
  const std::string& _internal_wallet_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet_address(const std::string& value);
  std::string* _internal_mutable_wallet_address();
  public:

  // @@protoc_insertion_point(class_scope:zera_api.WalletChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> contract_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> old_balances_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> new_balances_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zera_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProposalLedgerRequest

// .zera_api.DATABASE_TYPE type = 1;
inline void ProposalLedgerRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::zera_api::DATABASE_TYPE ProposalLedgerRequest::_internal_type() const {
  return static_cast< ::zera_api::DATABASE_TYPE >(_impl_.type_);
}
inline ::zera_api::DATABASE_TYPE ProposalLedgerRequest::type() const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerRequest.type)
  return _internal_type();
}
inline void ProposalLedgerRequest::_internal_set_type(::zera_api::DATABASE_TYPE value) {
  
  _impl_.type_ = value;
}
inline void ProposalLedgerRequest::set_type(::zera_api::DATABASE_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerRequest.type)
}

// string key = 2;
inline void ProposalLedgerRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ProposalLedgerRequest::key() const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalLedgerRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerRequest.key)
}
inline std::string* ProposalLedgerRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerRequest.key)
  return _s;
}
inline const std::string& ProposalLedgerRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ProposalLedgerRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalLedgerRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalLedgerRequest::release_key() {
  // @@protoc_insertion_point(field_release:zera_api.ProposalLedgerRequest.key)
  return _impl_.key_.Release();
}
inline void ProposalLedgerRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.ProposalLedgerRequest.key)
}

// -------------------------------------------------------------------

// ProposalLedgerResponse

// repeated string ledger_keys = 1;
inline int ProposalLedgerResponse::_internal_ledger_keys_size() const {
  return _impl_.ledger_keys_.size();
}
inline int ProposalLedgerResponse::ledger_keys_size() const {
  return _internal_ledger_keys_size();
}
inline void ProposalLedgerResponse::clear_ledger_keys() {
  _impl_.ledger_keys_.Clear();
}
inline std::string* ProposalLedgerResponse::add_ledger_keys() {
  std::string* _s = _internal_add_ledger_keys();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.ledger_keys)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_ledger_keys(int index) const {
  return _impl_.ledger_keys_.Get(index);
}
inline const std::string& ProposalLedgerResponse::ledger_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.ledger_keys)
  return _internal_ledger_keys(index);
}
inline std::string* ProposalLedgerResponse::mutable_ledger_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.ledger_keys)
  return _impl_.ledger_keys_.Mutable(index);
}
inline void ProposalLedgerResponse::set_ledger_keys(int index, const std::string& value) {
  _impl_.ledger_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.ledger_keys)
}
inline void ProposalLedgerResponse::set_ledger_keys(int index, std::string&& value) {
  _impl_.ledger_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.ledger_keys)
}
inline void ProposalLedgerResponse::set_ledger_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ledger_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.ledger_keys)
}
inline void ProposalLedgerResponse::set_ledger_keys(int index, const char* value, size_t size) {
  _impl_.ledger_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.ledger_keys)
}
inline std::string* ProposalLedgerResponse::_internal_add_ledger_keys() {
  return _impl_.ledger_keys_.Add();
}
inline void ProposalLedgerResponse::add_ledger_keys(const std::string& value) {
  _impl_.ledger_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.ledger_keys)
}
inline void ProposalLedgerResponse::add_ledger_keys(std::string&& value) {
  _impl_.ledger_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.ledger_keys)
}
inline void ProposalLedgerResponse::add_ledger_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ledger_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.ledger_keys)
}
inline void ProposalLedgerResponse::add_ledger_keys(const char* value, size_t size) {
  _impl_.ledger_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.ledger_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::ledger_keys() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.ledger_keys)
  return _impl_.ledger_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_ledger_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.ledger_keys)
  return &_impl_.ledger_keys_;
}

// repeated string ledger_values = 2;
inline int ProposalLedgerResponse::_internal_ledger_values_size() const {
  return _impl_.ledger_values_.size();
}
inline int ProposalLedgerResponse::ledger_values_size() const {
  return _internal_ledger_values_size();
}
inline void ProposalLedgerResponse::clear_ledger_values() {
  _impl_.ledger_values_.Clear();
}
inline std::string* ProposalLedgerResponse::add_ledger_values() {
  std::string* _s = _internal_add_ledger_values();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.ledger_values)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_ledger_values(int index) const {
  return _impl_.ledger_values_.Get(index);
}
inline const std::string& ProposalLedgerResponse::ledger_values(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.ledger_values)
  return _internal_ledger_values(index);
}
inline std::string* ProposalLedgerResponse::mutable_ledger_values(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.ledger_values)
  return _impl_.ledger_values_.Mutable(index);
}
inline void ProposalLedgerResponse::set_ledger_values(int index, const std::string& value) {
  _impl_.ledger_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.ledger_values)
}
inline void ProposalLedgerResponse::set_ledger_values(int index, std::string&& value) {
  _impl_.ledger_values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.ledger_values)
}
inline void ProposalLedgerResponse::set_ledger_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ledger_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.ledger_values)
}
inline void ProposalLedgerResponse::set_ledger_values(int index, const char* value, size_t size) {
  _impl_.ledger_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.ledger_values)
}
inline std::string* ProposalLedgerResponse::_internal_add_ledger_values() {
  return _impl_.ledger_values_.Add();
}
inline void ProposalLedgerResponse::add_ledger_values(const std::string& value) {
  _impl_.ledger_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.ledger_values)
}
inline void ProposalLedgerResponse::add_ledger_values(std::string&& value) {
  _impl_.ledger_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.ledger_values)
}
inline void ProposalLedgerResponse::add_ledger_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ledger_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.ledger_values)
}
inline void ProposalLedgerResponse::add_ledger_values(const char* value, size_t size) {
  _impl_.ledger_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.ledger_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::ledger_values() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.ledger_values)
  return _impl_.ledger_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_ledger_values() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.ledger_values)
  return &_impl_.ledger_values_;
}

// repeated string proposal_keys = 3;
inline int ProposalLedgerResponse::_internal_proposal_keys_size() const {
  return _impl_.proposal_keys_.size();
}
inline int ProposalLedgerResponse::proposal_keys_size() const {
  return _internal_proposal_keys_size();
}
inline void ProposalLedgerResponse::clear_proposal_keys() {
  _impl_.proposal_keys_.Clear();
}
inline std::string* ProposalLedgerResponse::add_proposal_keys() {
  std::string* _s = _internal_add_proposal_keys();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.proposal_keys)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_proposal_keys(int index) const {
  return _impl_.proposal_keys_.Get(index);
}
inline const std::string& ProposalLedgerResponse::proposal_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.proposal_keys)
  return _internal_proposal_keys(index);
}
inline std::string* ProposalLedgerResponse::mutable_proposal_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.proposal_keys)
  return _impl_.proposal_keys_.Mutable(index);
}
inline void ProposalLedgerResponse::set_proposal_keys(int index, const std::string& value) {
  _impl_.proposal_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.proposal_keys)
}
inline void ProposalLedgerResponse::set_proposal_keys(int index, std::string&& value) {
  _impl_.proposal_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.proposal_keys)
}
inline void ProposalLedgerResponse::set_proposal_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proposal_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.proposal_keys)
}
inline void ProposalLedgerResponse::set_proposal_keys(int index, const char* value, size_t size) {
  _impl_.proposal_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.proposal_keys)
}
inline std::string* ProposalLedgerResponse::_internal_add_proposal_keys() {
  return _impl_.proposal_keys_.Add();
}
inline void ProposalLedgerResponse::add_proposal_keys(const std::string& value) {
  _impl_.proposal_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.proposal_keys)
}
inline void ProposalLedgerResponse::add_proposal_keys(std::string&& value) {
  _impl_.proposal_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.proposal_keys)
}
inline void ProposalLedgerResponse::add_proposal_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proposal_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.proposal_keys)
}
inline void ProposalLedgerResponse::add_proposal_keys(const char* value, size_t size) {
  _impl_.proposal_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.proposal_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::proposal_keys() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.proposal_keys)
  return _impl_.proposal_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_proposal_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.proposal_keys)
  return &_impl_.proposal_keys_;
}

// repeated string proposal_values = 4;
inline int ProposalLedgerResponse::_internal_proposal_values_size() const {
  return _impl_.proposal_values_.size();
}
inline int ProposalLedgerResponse::proposal_values_size() const {
  return _internal_proposal_values_size();
}
inline void ProposalLedgerResponse::clear_proposal_values() {
  _impl_.proposal_values_.Clear();
}
inline std::string* ProposalLedgerResponse::add_proposal_values() {
  std::string* _s = _internal_add_proposal_values();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.proposal_values)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_proposal_values(int index) const {
  return _impl_.proposal_values_.Get(index);
}
inline const std::string& ProposalLedgerResponse::proposal_values(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.proposal_values)
  return _internal_proposal_values(index);
}
inline std::string* ProposalLedgerResponse::mutable_proposal_values(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.proposal_values)
  return _impl_.proposal_values_.Mutable(index);
}
inline void ProposalLedgerResponse::set_proposal_values(int index, const std::string& value) {
  _impl_.proposal_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.proposal_values)
}
inline void ProposalLedgerResponse::set_proposal_values(int index, std::string&& value) {
  _impl_.proposal_values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.proposal_values)
}
inline void ProposalLedgerResponse::set_proposal_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proposal_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.proposal_values)
}
inline void ProposalLedgerResponse::set_proposal_values(int index, const char* value, size_t size) {
  _impl_.proposal_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.proposal_values)
}
inline std::string* ProposalLedgerResponse::_internal_add_proposal_values() {
  return _impl_.proposal_values_.Add();
}
inline void ProposalLedgerResponse::add_proposal_values(const std::string& value) {
  _impl_.proposal_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.proposal_values)
}
inline void ProposalLedgerResponse::add_proposal_values(std::string&& value) {
  _impl_.proposal_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.proposal_values)
}
inline void ProposalLedgerResponse::add_proposal_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proposal_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.proposal_values)
}
inline void ProposalLedgerResponse::add_proposal_values(const char* value, size_t size) {
  _impl_.proposal_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.proposal_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::proposal_values() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.proposal_values)
  return _impl_.proposal_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_proposal_values() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.proposal_values)
  return &_impl_.proposal_values_;
}

// repeated string wallets_keys = 5;
inline int ProposalLedgerResponse::_internal_wallets_keys_size() const {
  return _impl_.wallets_keys_.size();
}
inline int ProposalLedgerResponse::wallets_keys_size() const {
  return _internal_wallets_keys_size();
}
inline void ProposalLedgerResponse::clear_wallets_keys() {
  _impl_.wallets_keys_.Clear();
}
inline std::string* ProposalLedgerResponse::add_wallets_keys() {
  std::string* _s = _internal_add_wallets_keys();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.wallets_keys)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_wallets_keys(int index) const {
  return _impl_.wallets_keys_.Get(index);
}
inline const std::string& ProposalLedgerResponse::wallets_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.wallets_keys)
  return _internal_wallets_keys(index);
}
inline std::string* ProposalLedgerResponse::mutable_wallets_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.wallets_keys)
  return _impl_.wallets_keys_.Mutable(index);
}
inline void ProposalLedgerResponse::set_wallets_keys(int index, const std::string& value) {
  _impl_.wallets_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.wallets_keys)
}
inline void ProposalLedgerResponse::set_wallets_keys(int index, std::string&& value) {
  _impl_.wallets_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.wallets_keys)
}
inline void ProposalLedgerResponse::set_wallets_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wallets_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.wallets_keys)
}
inline void ProposalLedgerResponse::set_wallets_keys(int index, const char* value, size_t size) {
  _impl_.wallets_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.wallets_keys)
}
inline std::string* ProposalLedgerResponse::_internal_add_wallets_keys() {
  return _impl_.wallets_keys_.Add();
}
inline void ProposalLedgerResponse::add_wallets_keys(const std::string& value) {
  _impl_.wallets_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.wallets_keys)
}
inline void ProposalLedgerResponse::add_wallets_keys(std::string&& value) {
  _impl_.wallets_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.wallets_keys)
}
inline void ProposalLedgerResponse::add_wallets_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wallets_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.wallets_keys)
}
inline void ProposalLedgerResponse::add_wallets_keys(const char* value, size_t size) {
  _impl_.wallets_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.wallets_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::wallets_keys() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.wallets_keys)
  return _impl_.wallets_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_wallets_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.wallets_keys)
  return &_impl_.wallets_keys_;
}

// repeated string wallets_values = 6;
inline int ProposalLedgerResponse::_internal_wallets_values_size() const {
  return _impl_.wallets_values_.size();
}
inline int ProposalLedgerResponse::wallets_values_size() const {
  return _internal_wallets_values_size();
}
inline void ProposalLedgerResponse::clear_wallets_values() {
  _impl_.wallets_values_.Clear();
}
inline std::string* ProposalLedgerResponse::add_wallets_values() {
  std::string* _s = _internal_add_wallets_values();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.wallets_values)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_wallets_values(int index) const {
  return _impl_.wallets_values_.Get(index);
}
inline const std::string& ProposalLedgerResponse::wallets_values(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.wallets_values)
  return _internal_wallets_values(index);
}
inline std::string* ProposalLedgerResponse::mutable_wallets_values(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.wallets_values)
  return _impl_.wallets_values_.Mutable(index);
}
inline void ProposalLedgerResponse::set_wallets_values(int index, const std::string& value) {
  _impl_.wallets_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.wallets_values)
}
inline void ProposalLedgerResponse::set_wallets_values(int index, std::string&& value) {
  _impl_.wallets_values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.wallets_values)
}
inline void ProposalLedgerResponse::set_wallets_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wallets_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.wallets_values)
}
inline void ProposalLedgerResponse::set_wallets_values(int index, const char* value, size_t size) {
  _impl_.wallets_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.wallets_values)
}
inline std::string* ProposalLedgerResponse::_internal_add_wallets_values() {
  return _impl_.wallets_values_.Add();
}
inline void ProposalLedgerResponse::add_wallets_values(const std::string& value) {
  _impl_.wallets_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.wallets_values)
}
inline void ProposalLedgerResponse::add_wallets_values(std::string&& value) {
  _impl_.wallets_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.wallets_values)
}
inline void ProposalLedgerResponse::add_wallets_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wallets_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.wallets_values)
}
inline void ProposalLedgerResponse::add_wallets_values(const char* value, size_t size) {
  _impl_.wallets_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.wallets_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::wallets_values() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.wallets_values)
  return _impl_.wallets_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_wallets_values() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.wallets_values)
  return &_impl_.wallets_values_;
}

// repeated string temp_keys = 7;
inline int ProposalLedgerResponse::_internal_temp_keys_size() const {
  return _impl_.temp_keys_.size();
}
inline int ProposalLedgerResponse::temp_keys_size() const {
  return _internal_temp_keys_size();
}
inline void ProposalLedgerResponse::clear_temp_keys() {
  _impl_.temp_keys_.Clear();
}
inline std::string* ProposalLedgerResponse::add_temp_keys() {
  std::string* _s = _internal_add_temp_keys();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.temp_keys)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_temp_keys(int index) const {
  return _impl_.temp_keys_.Get(index);
}
inline const std::string& ProposalLedgerResponse::temp_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.temp_keys)
  return _internal_temp_keys(index);
}
inline std::string* ProposalLedgerResponse::mutable_temp_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.temp_keys)
  return _impl_.temp_keys_.Mutable(index);
}
inline void ProposalLedgerResponse::set_temp_keys(int index, const std::string& value) {
  _impl_.temp_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.temp_keys)
}
inline void ProposalLedgerResponse::set_temp_keys(int index, std::string&& value) {
  _impl_.temp_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.temp_keys)
}
inline void ProposalLedgerResponse::set_temp_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.temp_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.temp_keys)
}
inline void ProposalLedgerResponse::set_temp_keys(int index, const char* value, size_t size) {
  _impl_.temp_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.temp_keys)
}
inline std::string* ProposalLedgerResponse::_internal_add_temp_keys() {
  return _impl_.temp_keys_.Add();
}
inline void ProposalLedgerResponse::add_temp_keys(const std::string& value) {
  _impl_.temp_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.temp_keys)
}
inline void ProposalLedgerResponse::add_temp_keys(std::string&& value) {
  _impl_.temp_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.temp_keys)
}
inline void ProposalLedgerResponse::add_temp_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.temp_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.temp_keys)
}
inline void ProposalLedgerResponse::add_temp_keys(const char* value, size_t size) {
  _impl_.temp_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.temp_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::temp_keys() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.temp_keys)
  return _impl_.temp_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_temp_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.temp_keys)
  return &_impl_.temp_keys_;
}

// repeated string temp_values = 8;
inline int ProposalLedgerResponse::_internal_temp_values_size() const {
  return _impl_.temp_values_.size();
}
inline int ProposalLedgerResponse::temp_values_size() const {
  return _internal_temp_values_size();
}
inline void ProposalLedgerResponse::clear_temp_values() {
  _impl_.temp_values_.Clear();
}
inline std::string* ProposalLedgerResponse::add_temp_values() {
  std::string* _s = _internal_add_temp_values();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.temp_values)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_temp_values(int index) const {
  return _impl_.temp_values_.Get(index);
}
inline const std::string& ProposalLedgerResponse::temp_values(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.temp_values)
  return _internal_temp_values(index);
}
inline std::string* ProposalLedgerResponse::mutable_temp_values(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.temp_values)
  return _impl_.temp_values_.Mutable(index);
}
inline void ProposalLedgerResponse::set_temp_values(int index, const std::string& value) {
  _impl_.temp_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.temp_values)
}
inline void ProposalLedgerResponse::set_temp_values(int index, std::string&& value) {
  _impl_.temp_values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.temp_values)
}
inline void ProposalLedgerResponse::set_temp_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.temp_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.temp_values)
}
inline void ProposalLedgerResponse::set_temp_values(int index, const char* value, size_t size) {
  _impl_.temp_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.temp_values)
}
inline std::string* ProposalLedgerResponse::_internal_add_temp_values() {
  return _impl_.temp_values_.Add();
}
inline void ProposalLedgerResponse::add_temp_values(const std::string& value) {
  _impl_.temp_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.temp_values)
}
inline void ProposalLedgerResponse::add_temp_values(std::string&& value) {
  _impl_.temp_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.temp_values)
}
inline void ProposalLedgerResponse::add_temp_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.temp_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.temp_values)
}
inline void ProposalLedgerResponse::add_temp_values(const char* value, size_t size) {
  _impl_.temp_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.temp_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::temp_values() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.temp_values)
  return _impl_.temp_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_temp_values() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.temp_values)
  return &_impl_.temp_values_;
}

// repeated string voted_keys = 9;
inline int ProposalLedgerResponse::_internal_voted_keys_size() const {
  return _impl_.voted_keys_.size();
}
inline int ProposalLedgerResponse::voted_keys_size() const {
  return _internal_voted_keys_size();
}
inline void ProposalLedgerResponse::clear_voted_keys() {
  _impl_.voted_keys_.Clear();
}
inline std::string* ProposalLedgerResponse::add_voted_keys() {
  std::string* _s = _internal_add_voted_keys();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.voted_keys)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_voted_keys(int index) const {
  return _impl_.voted_keys_.Get(index);
}
inline const std::string& ProposalLedgerResponse::voted_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.voted_keys)
  return _internal_voted_keys(index);
}
inline std::string* ProposalLedgerResponse::mutable_voted_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.voted_keys)
  return _impl_.voted_keys_.Mutable(index);
}
inline void ProposalLedgerResponse::set_voted_keys(int index, const std::string& value) {
  _impl_.voted_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.voted_keys)
}
inline void ProposalLedgerResponse::set_voted_keys(int index, std::string&& value) {
  _impl_.voted_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.voted_keys)
}
inline void ProposalLedgerResponse::set_voted_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.voted_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.voted_keys)
}
inline void ProposalLedgerResponse::set_voted_keys(int index, const char* value, size_t size) {
  _impl_.voted_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.voted_keys)
}
inline std::string* ProposalLedgerResponse::_internal_add_voted_keys() {
  return _impl_.voted_keys_.Add();
}
inline void ProposalLedgerResponse::add_voted_keys(const std::string& value) {
  _impl_.voted_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.voted_keys)
}
inline void ProposalLedgerResponse::add_voted_keys(std::string&& value) {
  _impl_.voted_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.voted_keys)
}
inline void ProposalLedgerResponse::add_voted_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.voted_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.voted_keys)
}
inline void ProposalLedgerResponse::add_voted_keys(const char* value, size_t size) {
  _impl_.voted_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.voted_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::voted_keys() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.voted_keys)
  return _impl_.voted_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_voted_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.voted_keys)
  return &_impl_.voted_keys_;
}

// repeated string voted_values = 10;
inline int ProposalLedgerResponse::_internal_voted_values_size() const {
  return _impl_.voted_values_.size();
}
inline int ProposalLedgerResponse::voted_values_size() const {
  return _internal_voted_values_size();
}
inline void ProposalLedgerResponse::clear_voted_values() {
  _impl_.voted_values_.Clear();
}
inline std::string* ProposalLedgerResponse::add_voted_values() {
  std::string* _s = _internal_add_voted_values();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ProposalLedgerResponse.voted_values)
  return _s;
}
inline const std::string& ProposalLedgerResponse::_internal_voted_values(int index) const {
  return _impl_.voted_values_.Get(index);
}
inline const std::string& ProposalLedgerResponse::voted_values(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ProposalLedgerResponse.voted_values)
  return _internal_voted_values(index);
}
inline std::string* ProposalLedgerResponse::mutable_voted_values(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ProposalLedgerResponse.voted_values)
  return _impl_.voted_values_.Mutable(index);
}
inline void ProposalLedgerResponse::set_voted_values(int index, const std::string& value) {
  _impl_.voted_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.voted_values)
}
inline void ProposalLedgerResponse::set_voted_values(int index, std::string&& value) {
  _impl_.voted_values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ProposalLedgerResponse.voted_values)
}
inline void ProposalLedgerResponse::set_voted_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.voted_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ProposalLedgerResponse.voted_values)
}
inline void ProposalLedgerResponse::set_voted_values(int index, const char* value, size_t size) {
  _impl_.voted_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ProposalLedgerResponse.voted_values)
}
inline std::string* ProposalLedgerResponse::_internal_add_voted_values() {
  return _impl_.voted_values_.Add();
}
inline void ProposalLedgerResponse::add_voted_values(const std::string& value) {
  _impl_.voted_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.voted_values)
}
inline void ProposalLedgerResponse::add_voted_values(std::string&& value) {
  _impl_.voted_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ProposalLedgerResponse.voted_values)
}
inline void ProposalLedgerResponse::add_voted_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.voted_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ProposalLedgerResponse.voted_values)
}
inline void ProposalLedgerResponse::add_voted_values(const char* value, size_t size) {
  _impl_.voted_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ProposalLedgerResponse.voted_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedgerResponse::voted_values() const {
  // @@protoc_insertion_point(field_list:zera_api.ProposalLedgerResponse.voted_values)
  return _impl_.voted_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedgerResponse::mutable_voted_values() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ProposalLedgerResponse.voted_values)
  return &_impl_.voted_values_;
}

// -------------------------------------------------------------------

// BlockRequest

// uint64 block_height = 1;
inline bool BlockRequest::_internal_has_block_height() const {
  return payload_case() == kBlockHeight;
}
inline bool BlockRequest::has_block_height() const {
  return _internal_has_block_height();
}
inline void BlockRequest::set_has_block_height() {
  _impl_._oneof_case_[0] = kBlockHeight;
}
inline void BlockRequest::clear_block_height() {
  if (_internal_has_block_height()) {
    _impl_.payload_.block_height_ = uint64_t{0u};
    clear_has_payload();
  }
}
inline uint64_t BlockRequest::_internal_block_height() const {
  if (_internal_has_block_height()) {
    return _impl_.payload_.block_height_;
  }
  return uint64_t{0u};
}
inline void BlockRequest::_internal_set_block_height(uint64_t value) {
  if (!_internal_has_block_height()) {
    clear_payload();
    set_has_block_height();
  }
  _impl_.payload_.block_height_ = value;
}
inline uint64_t BlockRequest::block_height() const {
  // @@protoc_insertion_point(field_get:zera_api.BlockRequest.block_height)
  return _internal_block_height();
}
inline void BlockRequest::set_block_height(uint64_t value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:zera_api.BlockRequest.block_height)
}

// string block_hash = 2;
inline bool BlockRequest::_internal_has_block_hash() const {
  return payload_case() == kBlockHash;
}
inline bool BlockRequest::has_block_hash() const {
  return _internal_has_block_hash();
}
inline void BlockRequest::set_has_block_hash() {
  _impl_._oneof_case_[0] = kBlockHash;
}
inline void BlockRequest::clear_block_hash() {
  if (_internal_has_block_hash()) {
    _impl_.payload_.block_hash_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& BlockRequest::block_hash() const {
  // @@protoc_insertion_point(field_get:zera_api.BlockRequest.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline void BlockRequest::set_block_hash(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_block_hash()) {
    clear_payload();
    set_has_block_hash();
    _impl_.payload_.block_hash_.InitDefault();
  }
  _impl_.payload_.block_hash_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.BlockRequest.block_hash)
}
inline std::string* BlockRequest::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:zera_api.BlockRequest.block_hash)
  return _s;
}
inline const std::string& BlockRequest::_internal_block_hash() const {
  if (_internal_has_block_hash()) {
    return _impl_.payload_.block_hash_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void BlockRequest::_internal_set_block_hash(const std::string& value) {
  if (!_internal_has_block_hash()) {
    clear_payload();
    set_has_block_hash();
    _impl_.payload_.block_hash_.InitDefault();
  }
  _impl_.payload_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRequest::_internal_mutable_block_hash() {
  if (!_internal_has_block_hash()) {
    clear_payload();
    set_has_block_hash();
    _impl_.payload_.block_hash_.InitDefault();
  }
  return _impl_.payload_.block_hash_.Mutable(      GetArenaForAllocation());
}
inline std::string* BlockRequest::release_block_hash() {
  // @@protoc_insertion_point(field_release:zera_api.BlockRequest.block_hash)
  if (_internal_has_block_hash()) {
    clear_has_payload();
    return _impl_.payload_.block_hash_.Release();
  } else {
    return nullptr;
  }
}
inline void BlockRequest::set_allocated_block_hash(std::string* block_hash) {
  if (has_payload()) {
    clear_payload();
  }
  if (block_hash != nullptr) {
    set_has_block_hash();
    _impl_.payload_.block_hash_.InitAllocated(block_hash, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:zera_api.BlockRequest.block_hash)
}

// bool encoded = 3;
inline void BlockRequest::clear_encoded() {
  _impl_.encoded_ = false;
}
inline bool BlockRequest::_internal_encoded() const {
  return _impl_.encoded_;
}
inline bool BlockRequest::encoded() const {
  // @@protoc_insertion_point(field_get:zera_api.BlockRequest.encoded)
  return _internal_encoded();
}
inline void BlockRequest::_internal_set_encoded(bool value) {
  
  _impl_.encoded_ = value;
}
inline void BlockRequest::set_encoded(bool value) {
  _internal_set_encoded(value);
  // @@protoc_insertion_point(field_set:zera_api.BlockRequest.encoded)
}

inline bool BlockRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void BlockRequest::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline BlockRequest::PayloadCase BlockRequest::payload_case() const {
  return BlockRequest::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BlockResponse

// .zera_validator.Block block = 1;
inline bool BlockResponse::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool BlockResponse::has_block() const {
  return _internal_has_block();
}
inline const ::zera_validator::Block& BlockResponse::_internal_block() const {
  const ::zera_validator::Block* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_validator::Block&>(
      ::zera_validator::_Block_default_instance_);
}
inline const ::zera_validator::Block& BlockResponse::block() const {
  // @@protoc_insertion_point(field_get:zera_api.BlockResponse.block)
  return _internal_block();
}
inline void BlockResponse::unsafe_arena_set_allocated_block(
    ::zera_validator::Block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_api.BlockResponse.block)
}
inline ::zera_validator::Block* BlockResponse::release_block() {
  
  ::zera_validator::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_validator::Block* BlockResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:zera_api.BlockResponse.block)
  
  ::zera_validator::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::zera_validator::Block* BlockResponse::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_validator::Block>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::zera_validator::Block* BlockResponse::mutable_block() {
  ::zera_validator::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:zera_api.BlockResponse.block)
  return _msg;
}
inline void BlockResponse::set_allocated_block(::zera_validator::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:zera_api.BlockResponse.block)
}

// -------------------------------------------------------------------

// NonceRequest

// bytes wallet_address = 1;
inline void NonceRequest::clear_wallet_address() {
  _impl_.wallet_address_.ClearToEmpty();
}
inline const std::string& NonceRequest::wallet_address() const {
  // @@protoc_insertion_point(field_get:zera_api.NonceRequest.wallet_address)
  return _internal_wallet_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NonceRequest::set_wallet_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wallet_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.NonceRequest.wallet_address)
}
inline std::string* NonceRequest::mutable_wallet_address() {
  std::string* _s = _internal_mutable_wallet_address();
  // @@protoc_insertion_point(field_mutable:zera_api.NonceRequest.wallet_address)
  return _s;
}
inline const std::string& NonceRequest::_internal_wallet_address() const {
  return _impl_.wallet_address_.Get();
}
inline void NonceRequest::_internal_set_wallet_address(const std::string& value) {
  
  _impl_.wallet_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NonceRequest::_internal_mutable_wallet_address() {
  
  return _impl_.wallet_address_.Mutable(GetArenaForAllocation());
}
inline std::string* NonceRequest::release_wallet_address() {
  // @@protoc_insertion_point(field_release:zera_api.NonceRequest.wallet_address)
  return _impl_.wallet_address_.Release();
}
inline void NonceRequest::set_allocated_wallet_address(std::string* wallet_address) {
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  _impl_.wallet_address_.SetAllocated(wallet_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wallet_address_.IsDefault()) {
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.NonceRequest.wallet_address)
}

// bool encoded = 3;
inline void NonceRequest::clear_encoded() {
  _impl_.encoded_ = false;
}
inline bool NonceRequest::_internal_encoded() const {
  return _impl_.encoded_;
}
inline bool NonceRequest::encoded() const {
  // @@protoc_insertion_point(field_get:zera_api.NonceRequest.encoded)
  return _internal_encoded();
}
inline void NonceRequest::_internal_set_encoded(bool value) {
  
  _impl_.encoded_ = value;
}
inline void NonceRequest::set_encoded(bool value) {
  _internal_set_encoded(value);
  // @@protoc_insertion_point(field_set:zera_api.NonceRequest.encoded)
}

// -------------------------------------------------------------------

// NonceResponse

// uint64 nonce = 1;
inline void NonceResponse::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t NonceResponse::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t NonceResponse::nonce() const {
  // @@protoc_insertion_point(field_get:zera_api.NonceResponse.nonce)
  return _internal_nonce();
}
inline void NonceResponse::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void NonceResponse::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:zera_api.NonceResponse.nonce)
}

// -------------------------------------------------------------------

// BalanceRequest

// bytes wallet_address = 1;
inline void BalanceRequest::clear_wallet_address() {
  _impl_.wallet_address_.ClearToEmpty();
}
inline const std::string& BalanceRequest::wallet_address() const {
  // @@protoc_insertion_point(field_get:zera_api.BalanceRequest.wallet_address)
  return _internal_wallet_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BalanceRequest::set_wallet_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wallet_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.BalanceRequest.wallet_address)
}
inline std::string* BalanceRequest::mutable_wallet_address() {
  std::string* _s = _internal_mutable_wallet_address();
  // @@protoc_insertion_point(field_mutable:zera_api.BalanceRequest.wallet_address)
  return _s;
}
inline const std::string& BalanceRequest::_internal_wallet_address() const {
  return _impl_.wallet_address_.Get();
}
inline void BalanceRequest::_internal_set_wallet_address(const std::string& value) {
  
  _impl_.wallet_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceRequest::_internal_mutable_wallet_address() {
  
  return _impl_.wallet_address_.Mutable(GetArenaForAllocation());
}
inline std::string* BalanceRequest::release_wallet_address() {
  // @@protoc_insertion_point(field_release:zera_api.BalanceRequest.wallet_address)
  return _impl_.wallet_address_.Release();
}
inline void BalanceRequest::set_allocated_wallet_address(std::string* wallet_address) {
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  _impl_.wallet_address_.SetAllocated(wallet_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wallet_address_.IsDefault()) {
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.BalanceRequest.wallet_address)
}

// string contract_id = 2;
inline void BalanceRequest::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& BalanceRequest::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_api.BalanceRequest.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BalanceRequest::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.BalanceRequest.contract_id)
}
inline std::string* BalanceRequest::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_api.BalanceRequest.contract_id)
  return _s;
}
inline const std::string& BalanceRequest::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void BalanceRequest::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceRequest::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BalanceRequest::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_api.BalanceRequest.contract_id)
  return _impl_.contract_id_.Release();
}
inline void BalanceRequest::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.BalanceRequest.contract_id)
}

// bool encoded = 3;
inline void BalanceRequest::clear_encoded() {
  _impl_.encoded_ = false;
}
inline bool BalanceRequest::_internal_encoded() const {
  return _impl_.encoded_;
}
inline bool BalanceRequest::encoded() const {
  // @@protoc_insertion_point(field_get:zera_api.BalanceRequest.encoded)
  return _internal_encoded();
}
inline void BalanceRequest::_internal_set_encoded(bool value) {
  
  _impl_.encoded_ = value;
}
inline void BalanceRequest::set_encoded(bool value) {
  _internal_set_encoded(value);
  // @@protoc_insertion_point(field_set:zera_api.BalanceRequest.encoded)
}

// -------------------------------------------------------------------

// BalanceResponse

// string balance = 1;
inline void BalanceResponse::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& BalanceResponse::balance() const {
  // @@protoc_insertion_point(field_get:zera_api.BalanceResponse.balance)
  return _internal_balance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BalanceResponse::set_balance(ArgT0&& arg0, ArgT... args) {
 
 _impl_.balance_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.BalanceResponse.balance)
}
inline std::string* BalanceResponse::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:zera_api.BalanceResponse.balance)
  return _s;
}
inline const std::string& BalanceResponse::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void BalanceResponse::_internal_set_balance(const std::string& value) {
  
  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceResponse::_internal_mutable_balance() {
  
  return _impl_.balance_.Mutable(GetArenaForAllocation());
}
inline std::string* BalanceResponse::release_balance() {
  // @@protoc_insertion_point(field_release:zera_api.BalanceResponse.balance)
  return _impl_.balance_.Release();
}
inline void BalanceResponse::set_allocated_balance(std::string* balance) {
  if (balance != nullptr) {
    
  } else {
    
  }
  _impl_.balance_.SetAllocated(balance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.balance_.IsDefault()) {
    _impl_.balance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.BalanceResponse.balance)
}

// string denomination = 2;
inline void BalanceResponse::clear_denomination() {
  _impl_.denomination_.ClearToEmpty();
}
inline const std::string& BalanceResponse::denomination() const {
  // @@protoc_insertion_point(field_get:zera_api.BalanceResponse.denomination)
  return _internal_denomination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BalanceResponse::set_denomination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.denomination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.BalanceResponse.denomination)
}
inline std::string* BalanceResponse::mutable_denomination() {
  std::string* _s = _internal_mutable_denomination();
  // @@protoc_insertion_point(field_mutable:zera_api.BalanceResponse.denomination)
  return _s;
}
inline const std::string& BalanceResponse::_internal_denomination() const {
  return _impl_.denomination_.Get();
}
inline void BalanceResponse::_internal_set_denomination(const std::string& value) {
  
  _impl_.denomination_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceResponse::_internal_mutable_denomination() {
  
  return _impl_.denomination_.Mutable(GetArenaForAllocation());
}
inline std::string* BalanceResponse::release_denomination() {
  // @@protoc_insertion_point(field_release:zera_api.BalanceResponse.denomination)
  return _impl_.denomination_.Release();
}
inline void BalanceResponse::set_allocated_denomination(std::string* denomination) {
  if (denomination != nullptr) {
    
  } else {
    
  }
  _impl_.denomination_.SetAllocated(denomination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.denomination_.IsDefault()) {
    _impl_.denomination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.BalanceResponse.denomination)
}

// string rate = 3;
inline void BalanceResponse::clear_rate() {
  _impl_.rate_.ClearToEmpty();
}
inline const std::string& BalanceResponse::rate() const {
  // @@protoc_insertion_point(field_get:zera_api.BalanceResponse.rate)
  return _internal_rate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BalanceResponse::set_rate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.BalanceResponse.rate)
}
inline std::string* BalanceResponse::mutable_rate() {
  std::string* _s = _internal_mutable_rate();
  // @@protoc_insertion_point(field_mutable:zera_api.BalanceResponse.rate)
  return _s;
}
inline const std::string& BalanceResponse::_internal_rate() const {
  return _impl_.rate_.Get();
}
inline void BalanceResponse::_internal_set_rate(const std::string& value) {
  
  _impl_.rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceResponse::_internal_mutable_rate() {
  
  return _impl_.rate_.Mutable(GetArenaForAllocation());
}
inline std::string* BalanceResponse::release_rate() {
  // @@protoc_insertion_point(field_release:zera_api.BalanceResponse.rate)
  return _impl_.rate_.Release();
}
inline void BalanceResponse::set_allocated_rate(std::string* rate) {
  if (rate != nullptr) {
    
  } else {
    
  }
  _impl_.rate_.SetAllocated(rate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rate_.IsDefault()) {
    _impl_.rate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.BalanceResponse.rate)
}

// -------------------------------------------------------------------

// ContractFeeRequest

// string contract_id = 1;
inline void ContractFeeRequest::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ContractFeeRequest::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_api.ContractFeeRequest.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFeeRequest::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.ContractFeeRequest.contract_id)
}
inline std::string* ContractFeeRequest::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_api.ContractFeeRequest.contract_id)
  return _s;
}
inline const std::string& ContractFeeRequest::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void ContractFeeRequest::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFeeRequest::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFeeRequest::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_api.ContractFeeRequest.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ContractFeeRequest::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.ContractFeeRequest.contract_id)
}

// -------------------------------------------------------------------

// ContractFeeResponse

// .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 1;
inline void ContractFeeResponse::clear_contract_fee_type() {
  _impl_.contract_fee_type_ = 0;
}
inline ::zera_txn::CONTRACT_FEE_TYPE ContractFeeResponse::_internal_contract_fee_type() const {
  return static_cast< ::zera_txn::CONTRACT_FEE_TYPE >(_impl_.contract_fee_type_);
}
inline ::zera_txn::CONTRACT_FEE_TYPE ContractFeeResponse::contract_fee_type() const {
  // @@protoc_insertion_point(field_get:zera_api.ContractFeeResponse.contract_fee_type)
  return _internal_contract_fee_type();
}
inline void ContractFeeResponse::_internal_set_contract_fee_type(::zera_txn::CONTRACT_FEE_TYPE value) {
  
  _impl_.contract_fee_type_ = value;
}
inline void ContractFeeResponse::set_contract_fee_type(::zera_txn::CONTRACT_FEE_TYPE value) {
  _internal_set_contract_fee_type(value);
  // @@protoc_insertion_point(field_set:zera_api.ContractFeeResponse.contract_fee_type)
}

// repeated string allowed_fee_instrument = 2;
inline int ContractFeeResponse::_internal_allowed_fee_instrument_size() const {
  return _impl_.allowed_fee_instrument_.size();
}
inline int ContractFeeResponse::allowed_fee_instrument_size() const {
  return _internal_allowed_fee_instrument_size();
}
inline void ContractFeeResponse::clear_allowed_fee_instrument() {
  _impl_.allowed_fee_instrument_.Clear();
}
inline std::string* ContractFeeResponse::add_allowed_fee_instrument() {
  std::string* _s = _internal_add_allowed_fee_instrument();
  // @@protoc_insertion_point(field_add_mutable:zera_api.ContractFeeResponse.allowed_fee_instrument)
  return _s;
}
inline const std::string& ContractFeeResponse::_internal_allowed_fee_instrument(int index) const {
  return _impl_.allowed_fee_instrument_.Get(index);
}
inline const std::string& ContractFeeResponse::allowed_fee_instrument(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ContractFeeResponse.allowed_fee_instrument)
  return _internal_allowed_fee_instrument(index);
}
inline std::string* ContractFeeResponse::mutable_allowed_fee_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ContractFeeResponse.allowed_fee_instrument)
  return _impl_.allowed_fee_instrument_.Mutable(index);
}
inline void ContractFeeResponse::set_allowed_fee_instrument(int index, const std::string& value) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.ContractFeeResponse.allowed_fee_instrument)
}
inline void ContractFeeResponse::set_allowed_fee_instrument(int index, std::string&& value) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.ContractFeeResponse.allowed_fee_instrument)
}
inline void ContractFeeResponse::set_allowed_fee_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.ContractFeeResponse.allowed_fee_instrument)
}
inline void ContractFeeResponse::set_allowed_fee_instrument(int index, const char* value, size_t size) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.ContractFeeResponse.allowed_fee_instrument)
}
inline std::string* ContractFeeResponse::_internal_add_allowed_fee_instrument() {
  return _impl_.allowed_fee_instrument_.Add();
}
inline void ContractFeeResponse::add_allowed_fee_instrument(const std::string& value) {
  _impl_.allowed_fee_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.ContractFeeResponse.allowed_fee_instrument)
}
inline void ContractFeeResponse::add_allowed_fee_instrument(std::string&& value) {
  _impl_.allowed_fee_instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.ContractFeeResponse.allowed_fee_instrument)
}
inline void ContractFeeResponse::add_allowed_fee_instrument(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_fee_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.ContractFeeResponse.allowed_fee_instrument)
}
inline void ContractFeeResponse::add_allowed_fee_instrument(const char* value, size_t size) {
  _impl_.allowed_fee_instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.ContractFeeResponse.allowed_fee_instrument)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContractFeeResponse::allowed_fee_instrument() const {
  // @@protoc_insertion_point(field_list:zera_api.ContractFeeResponse.allowed_fee_instrument)
  return _impl_.allowed_fee_instrument_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContractFeeResponse::mutable_allowed_fee_instrument() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ContractFeeResponse.allowed_fee_instrument)
  return &_impl_.allowed_fee_instrument_;
}

// string fee = 3;
inline void ContractFeeResponse::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& ContractFeeResponse::fee() const {
  // @@protoc_insertion_point(field_get:zera_api.ContractFeeResponse.fee)
  return _internal_fee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFeeResponse::set_fee(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.ContractFeeResponse.fee)
}
inline std::string* ContractFeeResponse::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:zera_api.ContractFeeResponse.fee)
  return _s;
}
inline const std::string& ContractFeeResponse::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void ContractFeeResponse::_internal_set_fee(const std::string& value) {
  
  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFeeResponse::_internal_mutable_fee() {
  
  return _impl_.fee_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFeeResponse::release_fee() {
  // @@protoc_insertion_point(field_release:zera_api.ContractFeeResponse.fee)
  return _impl_.fee_.Release();
}
inline void ContractFeeResponse::set_allocated_fee(std::string* fee) {
  if (fee != nullptr) {
    
  } else {
    
  }
  _impl_.fee_.SetAllocated(fee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_.IsDefault()) {
    _impl_.fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.ContractFeeResponse.fee)
}

// -------------------------------------------------------------------

// BaseFeeRequest

// optional .zera_txn.PublicKey public_key = 1;
inline bool BaseFeeRequest::_internal_has_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public_key_ != nullptr);
  return value;
}
inline bool BaseFeeRequest::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& BaseFeeRequest::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = _impl_.public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::PublicKey&>(
      ::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& BaseFeeRequest::public_key() const {
  // @@protoc_insertion_point(field_get:zera_api.BaseFeeRequest.public_key)
  return _internal_public_key();
}
inline void BaseFeeRequest::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  _impl_.public_key_ = public_key;
  if (public_key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_api.BaseFeeRequest.public_key)
}
inline ::zera_txn::PublicKey* BaseFeeRequest::release_public_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::PublicKey* BaseFeeRequest::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_api.BaseFeeRequest.public_key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* BaseFeeRequest::_internal_mutable_public_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArenaForAllocation());
    _impl_.public_key_ = p;
  }
  return _impl_.public_key_;
}
inline ::zera_txn::PublicKey* BaseFeeRequest::mutable_public_key() {
  ::zera_txn::PublicKey* _msg = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:zera_api.BaseFeeRequest.public_key)
  return _msg;
}
inline void BaseFeeRequest::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key));
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_api.BaseFeeRequest.public_key)
}

// .zera_txn.TRANSACTION_TYPE txn_type = 2;
inline void BaseFeeRequest::clear_txn_type() {
  _impl_.txn_type_ = 0;
}
inline ::zera_txn::TRANSACTION_TYPE BaseFeeRequest::_internal_txn_type() const {
  return static_cast< ::zera_txn::TRANSACTION_TYPE >(_impl_.txn_type_);
}
inline ::zera_txn::TRANSACTION_TYPE BaseFeeRequest::txn_type() const {
  // @@protoc_insertion_point(field_get:zera_api.BaseFeeRequest.txn_type)
  return _internal_txn_type();
}
inline void BaseFeeRequest::_internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  
  _impl_.txn_type_ = value;
}
inline void BaseFeeRequest::set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  _internal_set_txn_type(value);
  // @@protoc_insertion_point(field_set:zera_api.BaseFeeRequest.txn_type)
}

// -------------------------------------------------------------------

// BaseFeeResponse

// string key_fee = 1;
inline void BaseFeeResponse::clear_key_fee() {
  _impl_.key_fee_.ClearToEmpty();
}
inline const std::string& BaseFeeResponse::key_fee() const {
  // @@protoc_insertion_point(field_get:zera_api.BaseFeeResponse.key_fee)
  return _internal_key_fee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseFeeResponse::set_key_fee(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_fee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.BaseFeeResponse.key_fee)
}
inline std::string* BaseFeeResponse::mutable_key_fee() {
  std::string* _s = _internal_mutable_key_fee();
  // @@protoc_insertion_point(field_mutable:zera_api.BaseFeeResponse.key_fee)
  return _s;
}
inline const std::string& BaseFeeResponse::_internal_key_fee() const {
  return _impl_.key_fee_.Get();
}
inline void BaseFeeResponse::_internal_set_key_fee(const std::string& value) {
  
  _impl_.key_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseFeeResponse::_internal_mutable_key_fee() {
  
  return _impl_.key_fee_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseFeeResponse::release_key_fee() {
  // @@protoc_insertion_point(field_release:zera_api.BaseFeeResponse.key_fee)
  return _impl_.key_fee_.Release();
}
inline void BaseFeeResponse::set_allocated_key_fee(std::string* key_fee) {
  if (key_fee != nullptr) {
    
  } else {
    
  }
  _impl_.key_fee_.SetAllocated(key_fee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_fee_.IsDefault()) {
    _impl_.key_fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.BaseFeeResponse.key_fee)
}

// string byte_fee = 2;
inline void BaseFeeResponse::clear_byte_fee() {
  _impl_.byte_fee_.ClearToEmpty();
}
inline const std::string& BaseFeeResponse::byte_fee() const {
  // @@protoc_insertion_point(field_get:zera_api.BaseFeeResponse.byte_fee)
  return _internal_byte_fee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseFeeResponse::set_byte_fee(ArgT0&& arg0, ArgT... args) {
 
 _impl_.byte_fee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.BaseFeeResponse.byte_fee)
}
inline std::string* BaseFeeResponse::mutable_byte_fee() {
  std::string* _s = _internal_mutable_byte_fee();
  // @@protoc_insertion_point(field_mutable:zera_api.BaseFeeResponse.byte_fee)
  return _s;
}
inline const std::string& BaseFeeResponse::_internal_byte_fee() const {
  return _impl_.byte_fee_.Get();
}
inline void BaseFeeResponse::_internal_set_byte_fee(const std::string& value) {
  
  _impl_.byte_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseFeeResponse::_internal_mutable_byte_fee() {
  
  return _impl_.byte_fee_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseFeeResponse::release_byte_fee() {
  // @@protoc_insertion_point(field_release:zera_api.BaseFeeResponse.byte_fee)
  return _impl_.byte_fee_.Release();
}
inline void BaseFeeResponse::set_allocated_byte_fee(std::string* byte_fee) {
  if (byte_fee != nullptr) {
    
  } else {
    
  }
  _impl_.byte_fee_.SetAllocated(byte_fee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.byte_fee_.IsDefault()) {
    _impl_.byte_fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.BaseFeeResponse.byte_fee)
}

// -------------------------------------------------------------------

// TokenFeeInfo

// string contract_id = 1;
inline void TokenFeeInfo::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& TokenFeeInfo::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_api.TokenFeeInfo.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenFeeInfo::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.TokenFeeInfo.contract_id)
}
inline std::string* TokenFeeInfo::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_api.TokenFeeInfo.contract_id)
  return _s;
}
inline const std::string& TokenFeeInfo::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void TokenFeeInfo::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenFeeInfo::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenFeeInfo::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_api.TokenFeeInfo.contract_id)
  return _impl_.contract_id_.Release();
}
inline void TokenFeeInfo::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.TokenFeeInfo.contract_id)
}

// string rate = 2;
inline void TokenFeeInfo::clear_rate() {
  _impl_.rate_.ClearToEmpty();
}
inline const std::string& TokenFeeInfo::rate() const {
  // @@protoc_insertion_point(field_get:zera_api.TokenFeeInfo.rate)
  return _internal_rate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenFeeInfo::set_rate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.TokenFeeInfo.rate)
}
inline std::string* TokenFeeInfo::mutable_rate() {
  std::string* _s = _internal_mutable_rate();
  // @@protoc_insertion_point(field_mutable:zera_api.TokenFeeInfo.rate)
  return _s;
}
inline const std::string& TokenFeeInfo::_internal_rate() const {
  return _impl_.rate_.Get();
}
inline void TokenFeeInfo::_internal_set_rate(const std::string& value) {
  
  _impl_.rate_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenFeeInfo::_internal_mutable_rate() {
  
  return _impl_.rate_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenFeeInfo::release_rate() {
  // @@protoc_insertion_point(field_release:zera_api.TokenFeeInfo.rate)
  return _impl_.rate_.Release();
}
inline void TokenFeeInfo::set_allocated_rate(std::string* rate) {
  if (rate != nullptr) {
    
  } else {
    
  }
  _impl_.rate_.SetAllocated(rate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rate_.IsDefault()) {
    _impl_.rate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.TokenFeeInfo.rate)
}

// bool authorized = 3;
inline void TokenFeeInfo::clear_authorized() {
  _impl_.authorized_ = false;
}
inline bool TokenFeeInfo::_internal_authorized() const {
  return _impl_.authorized_;
}
inline bool TokenFeeInfo::authorized() const {
  // @@protoc_insertion_point(field_get:zera_api.TokenFeeInfo.authorized)
  return _internal_authorized();
}
inline void TokenFeeInfo::_internal_set_authorized(bool value) {
  
  _impl_.authorized_ = value;
}
inline void TokenFeeInfo::set_authorized(bool value) {
  _internal_set_authorized(value);
  // @@protoc_insertion_point(field_set:zera_api.TokenFeeInfo.authorized)
}

// string denomination = 4;
inline void TokenFeeInfo::clear_denomination() {
  _impl_.denomination_.ClearToEmpty();
}
inline const std::string& TokenFeeInfo::denomination() const {
  // @@protoc_insertion_point(field_get:zera_api.TokenFeeInfo.denomination)
  return _internal_denomination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenFeeInfo::set_denomination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.denomination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.TokenFeeInfo.denomination)
}
inline std::string* TokenFeeInfo::mutable_denomination() {
  std::string* _s = _internal_mutable_denomination();
  // @@protoc_insertion_point(field_mutable:zera_api.TokenFeeInfo.denomination)
  return _s;
}
inline const std::string& TokenFeeInfo::_internal_denomination() const {
  return _impl_.denomination_.Get();
}
inline void TokenFeeInfo::_internal_set_denomination(const std::string& value) {
  
  _impl_.denomination_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenFeeInfo::_internal_mutable_denomination() {
  
  return _impl_.denomination_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenFeeInfo::release_denomination() {
  // @@protoc_insertion_point(field_release:zera_api.TokenFeeInfo.denomination)
  return _impl_.denomination_.Release();
}
inline void TokenFeeInfo::set_allocated_denomination(std::string* denomination) {
  if (denomination != nullptr) {
    
  } else {
    
  }
  _impl_.denomination_.SetAllocated(denomination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.denomination_.IsDefault()) {
    _impl_.denomination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.TokenFeeInfo.denomination)
}

// optional .zera_txn.ContractFees contract_fees = 5;
inline bool TokenFeeInfo::_internal_has_contract_fees() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contract_fees_ != nullptr);
  return value;
}
inline bool TokenFeeInfo::has_contract_fees() const {
  return _internal_has_contract_fees();
}
inline const ::zera_txn::ContractFees& TokenFeeInfo::_internal_contract_fees() const {
  const ::zera_txn::ContractFees* p = _impl_.contract_fees_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::ContractFees&>(
      ::zera_txn::_ContractFees_default_instance_);
}
inline const ::zera_txn::ContractFees& TokenFeeInfo::contract_fees() const {
  // @@protoc_insertion_point(field_get:zera_api.TokenFeeInfo.contract_fees)
  return _internal_contract_fees();
}
inline void TokenFeeInfo::unsafe_arena_set_allocated_contract_fees(
    ::zera_txn::ContractFees* contract_fees) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_fees_);
  }
  _impl_.contract_fees_ = contract_fees;
  if (contract_fees) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_api.TokenFeeInfo.contract_fees)
}
inline ::zera_txn::ContractFees* TokenFeeInfo::release_contract_fees() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zera_txn::ContractFees* temp = _impl_.contract_fees_;
  _impl_.contract_fees_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::ContractFees* TokenFeeInfo::unsafe_arena_release_contract_fees() {
  // @@protoc_insertion_point(field_release:zera_api.TokenFeeInfo.contract_fees)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zera_txn::ContractFees* temp = _impl_.contract_fees_;
  _impl_.contract_fees_ = nullptr;
  return temp;
}
inline ::zera_txn::ContractFees* TokenFeeInfo::_internal_mutable_contract_fees() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contract_fees_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::ContractFees>(GetArenaForAllocation());
    _impl_.contract_fees_ = p;
  }
  return _impl_.contract_fees_;
}
inline ::zera_txn::ContractFees* TokenFeeInfo::mutable_contract_fees() {
  ::zera_txn::ContractFees* _msg = _internal_mutable_contract_fees();
  // @@protoc_insertion_point(field_mutable:zera_api.TokenFeeInfo.contract_fees)
  return _msg;
}
inline void TokenFeeInfo::set_allocated_contract_fees(::zera_txn::ContractFees* contract_fees) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_fees_);
  }
  if (contract_fees) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contract_fees));
    if (message_arena != submessage_arena) {
      contract_fees = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_fees, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contract_fees_ = contract_fees;
  // @@protoc_insertion_point(field_set_allocated:zera_api.TokenFeeInfo.contract_fees)
}

// -------------------------------------------------------------------

// TokenFeeInfoRequest

// repeated string contract_ids = 1;
inline int TokenFeeInfoRequest::_internal_contract_ids_size() const {
  return _impl_.contract_ids_.size();
}
inline int TokenFeeInfoRequest::contract_ids_size() const {
  return _internal_contract_ids_size();
}
inline void TokenFeeInfoRequest::clear_contract_ids() {
  _impl_.contract_ids_.Clear();
}
inline std::string* TokenFeeInfoRequest::add_contract_ids() {
  std::string* _s = _internal_add_contract_ids();
  // @@protoc_insertion_point(field_add_mutable:zera_api.TokenFeeInfoRequest.contract_ids)
  return _s;
}
inline const std::string& TokenFeeInfoRequest::_internal_contract_ids(int index) const {
  return _impl_.contract_ids_.Get(index);
}
inline const std::string& TokenFeeInfoRequest::contract_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.TokenFeeInfoRequest.contract_ids)
  return _internal_contract_ids(index);
}
inline std::string* TokenFeeInfoRequest::mutable_contract_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.TokenFeeInfoRequest.contract_ids)
  return _impl_.contract_ids_.Mutable(index);
}
inline void TokenFeeInfoRequest::set_contract_ids(int index, const std::string& value) {
  _impl_.contract_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.TokenFeeInfoRequest.contract_ids)
}
inline void TokenFeeInfoRequest::set_contract_ids(int index, std::string&& value) {
  _impl_.contract_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.TokenFeeInfoRequest.contract_ids)
}
inline void TokenFeeInfoRequest::set_contract_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.contract_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.TokenFeeInfoRequest.contract_ids)
}
inline void TokenFeeInfoRequest::set_contract_ids(int index, const char* value, size_t size) {
  _impl_.contract_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.TokenFeeInfoRequest.contract_ids)
}
inline std::string* TokenFeeInfoRequest::_internal_add_contract_ids() {
  return _impl_.contract_ids_.Add();
}
inline void TokenFeeInfoRequest::add_contract_ids(const std::string& value) {
  _impl_.contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.TokenFeeInfoRequest.contract_ids)
}
inline void TokenFeeInfoRequest::add_contract_ids(std::string&& value) {
  _impl_.contract_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.TokenFeeInfoRequest.contract_ids)
}
inline void TokenFeeInfoRequest::add_contract_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.TokenFeeInfoRequest.contract_ids)
}
inline void TokenFeeInfoRequest::add_contract_ids(const char* value, size_t size) {
  _impl_.contract_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.TokenFeeInfoRequest.contract_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TokenFeeInfoRequest::contract_ids() const {
  // @@protoc_insertion_point(field_list:zera_api.TokenFeeInfoRequest.contract_ids)
  return _impl_.contract_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TokenFeeInfoRequest::mutable_contract_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.TokenFeeInfoRequest.contract_ids)
  return &_impl_.contract_ids_;
}

// -------------------------------------------------------------------

// TokenFeeInfoResponse

// repeated .zera_api.TokenFeeInfo tokens = 1;
inline int TokenFeeInfoResponse::_internal_tokens_size() const {
  return _impl_.tokens_.size();
}
inline int TokenFeeInfoResponse::tokens_size() const {
  return _internal_tokens_size();
}
inline void TokenFeeInfoResponse::clear_tokens() {
  _impl_.tokens_.Clear();
}
inline ::zera_api::TokenFeeInfo* TokenFeeInfoResponse::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.TokenFeeInfoResponse.tokens)
  return _impl_.tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::TokenFeeInfo >*
TokenFeeInfoResponse::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.TokenFeeInfoResponse.tokens)
  return &_impl_.tokens_;
}
inline const ::zera_api::TokenFeeInfo& TokenFeeInfoResponse::_internal_tokens(int index) const {
  return _impl_.tokens_.Get(index);
}
inline const ::zera_api::TokenFeeInfo& TokenFeeInfoResponse::tokens(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.TokenFeeInfoResponse.tokens)
  return _internal_tokens(index);
}
inline ::zera_api::TokenFeeInfo* TokenFeeInfoResponse::_internal_add_tokens() {
  return _impl_.tokens_.Add();
}
inline ::zera_api::TokenFeeInfo* TokenFeeInfoResponse::add_tokens() {
  ::zera_api::TokenFeeInfo* _add = _internal_add_tokens();
  // @@protoc_insertion_point(field_add:zera_api.TokenFeeInfoResponse.tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::TokenFeeInfo >&
TokenFeeInfoResponse::tokens() const {
  // @@protoc_insertion_point(field_list:zera_api.TokenFeeInfoResponse.tokens)
  return _impl_.tokens_;
}

// -------------------------------------------------------------------

// Item

// string contract_id = 1;
inline void Item::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& Item::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_api.Item.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.Item.contract_id)
}
inline std::string* Item::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_api.Item.contract_id)
  return _s;
}
inline const std::string& Item::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void Item::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_api.Item.contract_id)
  return _impl_.contract_id_.Release();
}
inline void Item::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.Item.contract_id)
}

// string item_id = 2;
inline void Item::clear_item_id() {
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& Item::item_id() const {
  // @@protoc_insertion_point(field_get:zera_api.Item.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.Item.item_id)
}
inline std::string* Item::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:zera_api.Item.item_id)
  return _s;
}
inline const std::string& Item::_internal_item_id() const {
  return _impl_.item_id_.Get();
}
inline void Item::_internal_set_item_id(const std::string& value) {
  
  _impl_.item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_item_id() {
  
  return _impl_.item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_item_id() {
  // @@protoc_insertion_point(field_release:zera_api.Item.item_id)
  return _impl_.item_id_.Release();
}
inline void Item::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  _impl_.item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.Item.item_id)
}

// -------------------------------------------------------------------

// ItemRequest

// bytes wallet_address = 1;
inline void ItemRequest::clear_wallet_address() {
  _impl_.wallet_address_.ClearToEmpty();
}
inline const std::string& ItemRequest::wallet_address() const {
  // @@protoc_insertion_point(field_get:zera_api.ItemRequest.wallet_address)
  return _internal_wallet_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemRequest::set_wallet_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wallet_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.ItemRequest.wallet_address)
}
inline std::string* ItemRequest::mutable_wallet_address() {
  std::string* _s = _internal_mutable_wallet_address();
  // @@protoc_insertion_point(field_mutable:zera_api.ItemRequest.wallet_address)
  return _s;
}
inline const std::string& ItemRequest::_internal_wallet_address() const {
  return _impl_.wallet_address_.Get();
}
inline void ItemRequest::_internal_set_wallet_address(const std::string& value) {
  
  _impl_.wallet_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemRequest::_internal_mutable_wallet_address() {
  
  return _impl_.wallet_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemRequest::release_wallet_address() {
  // @@protoc_insertion_point(field_release:zera_api.ItemRequest.wallet_address)
  return _impl_.wallet_address_.Release();
}
inline void ItemRequest::set_allocated_wallet_address(std::string* wallet_address) {
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  _impl_.wallet_address_.SetAllocated(wallet_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wallet_address_.IsDefault()) {
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.ItemRequest.wallet_address)
}

// bool encoded = 2;
inline void ItemRequest::clear_encoded() {
  _impl_.encoded_ = false;
}
inline bool ItemRequest::_internal_encoded() const {
  return _impl_.encoded_;
}
inline bool ItemRequest::encoded() const {
  // @@protoc_insertion_point(field_get:zera_api.ItemRequest.encoded)
  return _internal_encoded();
}
inline void ItemRequest::_internal_set_encoded(bool value) {
  
  _impl_.encoded_ = value;
}
inline void ItemRequest::set_encoded(bool value) {
  _internal_set_encoded(value);
  // @@protoc_insertion_point(field_set:zera_api.ItemRequest.encoded)
}

// -------------------------------------------------------------------

// ItemResponse

// repeated .zera_api.Item items = 1;
inline int ItemResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ItemResponse::items_size() const {
  return _internal_items_size();
}
inline void ItemResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::zera_api::Item* ItemResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.ItemResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::Item >*
ItemResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.ItemResponse.items)
  return &_impl_.items_;
}
inline const ::zera_api::Item& ItemResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::zera_api::Item& ItemResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.ItemResponse.items)
  return _internal_items(index);
}
inline ::zera_api::Item* ItemResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::zera_api::Item* ItemResponse::add_items() {
  ::zera_api::Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:zera_api.ItemResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_api::Item >&
ItemResponse::items() const {
  // @@protoc_insertion_point(field_list:zera_api.ItemResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// DenominationRequest

// string contract_id = 1;
inline void DenominationRequest::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& DenominationRequest::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_api.DenominationRequest.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DenominationRequest::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.DenominationRequest.contract_id)
}
inline std::string* DenominationRequest::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_api.DenominationRequest.contract_id)
  return _s;
}
inline const std::string& DenominationRequest::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void DenominationRequest::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DenominationRequest::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DenominationRequest::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_api.DenominationRequest.contract_id)
  return _impl_.contract_id_.Release();
}
inline void DenominationRequest::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.DenominationRequest.contract_id)
}

// -------------------------------------------------------------------

// DenominationResponse

// string denomination = 1;
inline void DenominationResponse::clear_denomination() {
  _impl_.denomination_.ClearToEmpty();
}
inline const std::string& DenominationResponse::denomination() const {
  // @@protoc_insertion_point(field_get:zera_api.DenominationResponse.denomination)
  return _internal_denomination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DenominationResponse::set_denomination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.denomination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.DenominationResponse.denomination)
}
inline std::string* DenominationResponse::mutable_denomination() {
  std::string* _s = _internal_mutable_denomination();
  // @@protoc_insertion_point(field_mutable:zera_api.DenominationResponse.denomination)
  return _s;
}
inline const std::string& DenominationResponse::_internal_denomination() const {
  return _impl_.denomination_.Get();
}
inline void DenominationResponse::_internal_set_denomination(const std::string& value) {
  
  _impl_.denomination_.Set(value, GetArenaForAllocation());
}
inline std::string* DenominationResponse::_internal_mutable_denomination() {
  
  return _impl_.denomination_.Mutable(GetArenaForAllocation());
}
inline std::string* DenominationResponse::release_denomination() {
  // @@protoc_insertion_point(field_release:zera_api.DenominationResponse.denomination)
  return _impl_.denomination_.Release();
}
inline void DenominationResponse::set_allocated_denomination(std::string* denomination) {
  if (denomination != nullptr) {
    
  } else {
    
  }
  _impl_.denomination_.SetAllocated(denomination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.denomination_.IsDefault()) {
    _impl_.denomination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.DenominationResponse.denomination)
}

// -------------------------------------------------------------------

// DatabaseRequest

// .zera_api.DATABASE_TYPE type = 1;
inline void DatabaseRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::zera_api::DATABASE_TYPE DatabaseRequest::_internal_type() const {
  return static_cast< ::zera_api::DATABASE_TYPE >(_impl_.type_);
}
inline ::zera_api::DATABASE_TYPE DatabaseRequest::type() const {
  // @@protoc_insertion_point(field_get:zera_api.DatabaseRequest.type)
  return _internal_type();
}
inline void DatabaseRequest::_internal_set_type(::zera_api::DATABASE_TYPE value) {
  
  _impl_.type_ = value;
}
inline void DatabaseRequest::set_type(::zera_api::DATABASE_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zera_api.DatabaseRequest.type)
}

// string key = 2;
inline void DatabaseRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DatabaseRequest::key() const {
  // @@protoc_insertion_point(field_get:zera_api.DatabaseRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.DatabaseRequest.key)
}
inline std::string* DatabaseRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:zera_api.DatabaseRequest.key)
  return _s;
}
inline const std::string& DatabaseRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void DatabaseRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseRequest::release_key() {
  // @@protoc_insertion_point(field_release:zera_api.DatabaseRequest.key)
  return _impl_.key_.Release();
}
inline void DatabaseRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.DatabaseRequest.key)
}

// -------------------------------------------------------------------

// DatabaseResponse

// string value = 1;
inline void DatabaseResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& DatabaseResponse::value() const {
  // @@protoc_insertion_point(field_get:zera_api.DatabaseResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.DatabaseResponse.value)
}
inline std::string* DatabaseResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:zera_api.DatabaseResponse.value)
  return _s;
}
inline const std::string& DatabaseResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void DatabaseResponse::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseResponse::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseResponse::release_value() {
  // @@protoc_insertion_point(field_release:zera_api.DatabaseResponse.value)
  return _impl_.value_.Release();
}
inline void DatabaseResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.DatabaseResponse.value)
}

// -------------------------------------------------------------------

// ActivityRequest

// string smart_contract_id = 1;
inline void ActivityRequest::clear_smart_contract_id() {
  _impl_.smart_contract_id_.ClearToEmpty();
}
inline const std::string& ActivityRequest::smart_contract_id() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.smart_contract_id)
  return _internal_smart_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActivityRequest::set_smart_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.smart_contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.ActivityRequest.smart_contract_id)
}
inline std::string* ActivityRequest::mutable_smart_contract_id() {
  std::string* _s = _internal_mutable_smart_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_api.ActivityRequest.smart_contract_id)
  return _s;
}
inline const std::string& ActivityRequest::_internal_smart_contract_id() const {
  return _impl_.smart_contract_id_.Get();
}
inline void ActivityRequest::_internal_set_smart_contract_id(const std::string& value) {
  
  _impl_.smart_contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActivityRequest::_internal_mutable_smart_contract_id() {
  
  return _impl_.smart_contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ActivityRequest::release_smart_contract_id() {
  // @@protoc_insertion_point(field_release:zera_api.ActivityRequest.smart_contract_id)
  return _impl_.smart_contract_id_.Release();
}
inline void ActivityRequest::set_allocated_smart_contract_id(std::string* smart_contract_id) {
  if (smart_contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.smart_contract_id_.SetAllocated(smart_contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smart_contract_id_.IsDefault()) {
    _impl_.smart_contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.ActivityRequest.smart_contract_id)
}

// uint64 instance = 2;
inline void ActivityRequest::clear_instance() {
  _impl_.instance_ = uint64_t{0u};
}
inline uint64_t ActivityRequest::_internal_instance() const {
  return _impl_.instance_;
}
inline uint64_t ActivityRequest::instance() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.instance)
  return _internal_instance();
}
inline void ActivityRequest::_internal_set_instance(uint64_t value) {
  
  _impl_.instance_ = value;
}
inline void ActivityRequest::set_instance(uint64_t value) {
  _internal_set_instance(value);
  // @@protoc_insertion_point(field_set:zera_api.ActivityRequest.instance)
}

// .zera_api.CONFIRMATION_LEVEL level = 3;
inline void ActivityRequest::clear_level() {
  _impl_.level_ = 0;
}
inline ::zera_api::CONFIRMATION_LEVEL ActivityRequest::_internal_level() const {
  return static_cast< ::zera_api::CONFIRMATION_LEVEL >(_impl_.level_);
}
inline ::zera_api::CONFIRMATION_LEVEL ActivityRequest::level() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.level)
  return _internal_level();
}
inline void ActivityRequest::_internal_set_level(::zera_api::CONFIRMATION_LEVEL value) {
  
  _impl_.level_ = value;
}
inline void ActivityRequest::set_level(::zera_api::CONFIRMATION_LEVEL value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:zera_api.ActivityRequest.level)
}

// string host = 4;
inline void ActivityRequest::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& ActivityRequest::host() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActivityRequest::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.ActivityRequest.host)
}
inline std::string* ActivityRequest::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:zera_api.ActivityRequest.host)
  return _s;
}
inline const std::string& ActivityRequest::_internal_host() const {
  return _impl_.host_.Get();
}
inline void ActivityRequest::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* ActivityRequest::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* ActivityRequest::release_host() {
  // @@protoc_insertion_point(field_release:zera_api.ActivityRequest.host)
  return _impl_.host_.Release();
}
inline void ActivityRequest::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.ActivityRequest.host)
}

// int32 port = 5;
inline void ActivityRequest::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t ActivityRequest::_internal_port() const {
  return _impl_.port_;
}
inline int32_t ActivityRequest::port() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.port)
  return _internal_port();
}
inline void ActivityRequest::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void ActivityRequest::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:zera_api.ActivityRequest.port)
}

// bool subscribe = 6;
inline void ActivityRequest::clear_subscribe() {
  _impl_.subscribe_ = false;
}
inline bool ActivityRequest::_internal_subscribe() const {
  return _impl_.subscribe_;
}
inline bool ActivityRequest::subscribe() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.subscribe)
  return _internal_subscribe();
}
inline void ActivityRequest::_internal_set_subscribe(bool value) {
  
  _impl_.subscribe_ = value;
}
inline void ActivityRequest::set_subscribe(bool value) {
  _internal_set_subscribe(value);
  // @@protoc_insertion_point(field_set:zera_api.ActivityRequest.subscribe)
}

// .zera_txn.PublicKey public_key = 7;
inline bool ActivityRequest::_internal_has_public_key() const {
  return this != internal_default_instance() && _impl_.public_key_ != nullptr;
}
inline bool ActivityRequest::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& ActivityRequest::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = _impl_.public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::PublicKey&>(
      ::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& ActivityRequest::public_key() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.public_key)
  return _internal_public_key();
}
inline void ActivityRequest::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  _impl_.public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_api.ActivityRequest.public_key)
}
inline ::zera_txn::PublicKey* ActivityRequest::release_public_key() {
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::PublicKey* ActivityRequest::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_api.ActivityRequest.public_key)
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* ActivityRequest::_internal_mutable_public_key() {
  
  if (_impl_.public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArenaForAllocation());
    _impl_.public_key_ = p;
  }
  return _impl_.public_key_;
}
inline ::zera_txn::PublicKey* ActivityRequest::mutable_public_key() {
  ::zera_txn::PublicKey* _msg = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:zera_api.ActivityRequest.public_key)
  return _msg;
}
inline void ActivityRequest::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key));
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_api.ActivityRequest.public_key)
}

// bytes signature = 8;
inline void ActivityRequest::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& ActivityRequest::signature() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActivityRequest::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.ActivityRequest.signature)
}
inline std::string* ActivityRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:zera_api.ActivityRequest.signature)
  return _s;
}
inline const std::string& ActivityRequest::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void ActivityRequest::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* ActivityRequest::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* ActivityRequest::release_signature() {
  // @@protoc_insertion_point(field_release:zera_api.ActivityRequest.signature)
  return _impl_.signature_.Release();
}
inline void ActivityRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.ActivityRequest.signature)
}

// uint64 nonce = 9;
inline void ActivityRequest::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t ActivityRequest::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t ActivityRequest::nonce() const {
  // @@protoc_insertion_point(field_get:zera_api.ActivityRequest.nonce)
  return _internal_nonce();
}
inline void ActivityRequest::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void ActivityRequest::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:zera_api.ActivityRequest.nonce)
}

// -------------------------------------------------------------------

// SmartContractEventsResponse

// string smart_contract = 1;
inline void SmartContractEventsResponse::clear_smart_contract() {
  _impl_.smart_contract_.ClearToEmpty();
}
inline const std::string& SmartContractEventsResponse::smart_contract() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.smart_contract)
  return _internal_smart_contract();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractEventsResponse::set_smart_contract(ArgT0&& arg0, ArgT... args) {
 
 _impl_.smart_contract_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.smart_contract)
}
inline std::string* SmartContractEventsResponse::mutable_smart_contract() {
  std::string* _s = _internal_mutable_smart_contract();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.smart_contract)
  return _s;
}
inline const std::string& SmartContractEventsResponse::_internal_smart_contract() const {
  return _impl_.smart_contract_.Get();
}
inline void SmartContractEventsResponse::_internal_set_smart_contract(const std::string& value) {
  
  _impl_.smart_contract_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::_internal_mutable_smart_contract() {
  
  return _impl_.smart_contract_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::release_smart_contract() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.smart_contract)
  return _impl_.smart_contract_.Release();
}
inline void SmartContractEventsResponse::set_allocated_smart_contract(std::string* smart_contract) {
  if (smart_contract != nullptr) {
    
  } else {
    
  }
  _impl_.smart_contract_.SetAllocated(smart_contract, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smart_contract_.IsDefault()) {
    _impl_.smart_contract_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.smart_contract)
}

// uint64 instance = 2;
inline void SmartContractEventsResponse::clear_instance() {
  _impl_.instance_ = uint64_t{0u};
}
inline uint64_t SmartContractEventsResponse::_internal_instance() const {
  return _impl_.instance_;
}
inline uint64_t SmartContractEventsResponse::instance() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.instance)
  return _internal_instance();
}
inline void SmartContractEventsResponse::_internal_set_instance(uint64_t value) {
  
  _impl_.instance_ = value;
}
inline void SmartContractEventsResponse::set_instance(uint64_t value) {
  _internal_set_instance(value);
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.instance)
}

// uint64 gas_used = 3;
inline void SmartContractEventsResponse::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t SmartContractEventsResponse::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t SmartContractEventsResponse::gas_used() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.gas_used)
  return _internal_gas_used();
}
inline void SmartContractEventsResponse::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void SmartContractEventsResponse::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.gas_used)
}

// uint64 gas_approved = 4;
inline void SmartContractEventsResponse::clear_gas_approved() {
  _impl_.gas_approved_ = uint64_t{0u};
}
inline uint64_t SmartContractEventsResponse::_internal_gas_approved() const {
  return _impl_.gas_approved_;
}
inline uint64_t SmartContractEventsResponse::gas_approved() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.gas_approved)
  return _internal_gas_approved();
}
inline void SmartContractEventsResponse::_internal_set_gas_approved(uint64_t value) {
  
  _impl_.gas_approved_ = value;
}
inline void SmartContractEventsResponse::set_gas_approved(uint64_t value) {
  _internal_set_gas_approved(value);
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.gas_approved)
}

// string storage_fee = 5;
inline void SmartContractEventsResponse::clear_storage_fee() {
  _impl_.storage_fee_.ClearToEmpty();
}
inline const std::string& SmartContractEventsResponse::storage_fee() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.storage_fee)
  return _internal_storage_fee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractEventsResponse::set_storage_fee(ArgT0&& arg0, ArgT... args) {
 
 _impl_.storage_fee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.storage_fee)
}
inline std::string* SmartContractEventsResponse::mutable_storage_fee() {
  std::string* _s = _internal_mutable_storage_fee();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.storage_fee)
  return _s;
}
inline const std::string& SmartContractEventsResponse::_internal_storage_fee() const {
  return _impl_.storage_fee_.Get();
}
inline void SmartContractEventsResponse::_internal_set_storage_fee(const std::string& value) {
  
  _impl_.storage_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::_internal_mutable_storage_fee() {
  
  return _impl_.storage_fee_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::release_storage_fee() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.storage_fee)
  return _impl_.storage_fee_.Release();
}
inline void SmartContractEventsResponse::set_allocated_storage_fee(std::string* storage_fee) {
  if (storage_fee != nullptr) {
    
  } else {
    
  }
  _impl_.storage_fee_.SetAllocated(storage_fee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.storage_fee_.IsDefault()) {
    _impl_.storage_fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.storage_fee)
}

// .zera_txn.PublicKey caller = 6;
inline bool SmartContractEventsResponse::_internal_has_caller() const {
  return this != internal_default_instance() && _impl_.caller_ != nullptr;
}
inline bool SmartContractEventsResponse::has_caller() const {
  return _internal_has_caller();
}
inline const ::zera_txn::PublicKey& SmartContractEventsResponse::_internal_caller() const {
  const ::zera_txn::PublicKey* p = _impl_.caller_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::PublicKey&>(
      ::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& SmartContractEventsResponse::caller() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.caller)
  return _internal_caller();
}
inline void SmartContractEventsResponse::unsafe_arena_set_allocated_caller(
    ::zera_txn::PublicKey* caller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caller_);
  }
  _impl_.caller_ = caller;
  if (caller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_api.SmartContractEventsResponse.caller)
}
inline ::zera_txn::PublicKey* SmartContractEventsResponse::release_caller() {
  
  ::zera_txn::PublicKey* temp = _impl_.caller_;
  _impl_.caller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::PublicKey* SmartContractEventsResponse::unsafe_arena_release_caller() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.caller)
  
  ::zera_txn::PublicKey* temp = _impl_.caller_;
  _impl_.caller_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* SmartContractEventsResponse::_internal_mutable_caller() {
  
  if (_impl_.caller_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArenaForAllocation());
    _impl_.caller_ = p;
  }
  return _impl_.caller_;
}
inline ::zera_txn::PublicKey* SmartContractEventsResponse::mutable_caller() {
  ::zera_txn::PublicKey* _msg = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.caller)
  return _msg;
}
inline void SmartContractEventsResponse::set_allocated_caller(::zera_txn::PublicKey* caller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caller_);
  }
  if (caller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caller));
    if (message_arena != submessage_arena) {
      caller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caller, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.caller_ = caller;
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.caller)
}

// bytes event_data = 7;
inline void SmartContractEventsResponse::clear_event_data() {
  _impl_.event_data_.ClearToEmpty();
}
inline const std::string& SmartContractEventsResponse::event_data() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.event_data)
  return _internal_event_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractEventsResponse::set_event_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.event_data)
}
inline std::string* SmartContractEventsResponse::mutable_event_data() {
  std::string* _s = _internal_mutable_event_data();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.event_data)
  return _s;
}
inline const std::string& SmartContractEventsResponse::_internal_event_data() const {
  return _impl_.event_data_.Get();
}
inline void SmartContractEventsResponse::_internal_set_event_data(const std::string& value) {
  
  _impl_.event_data_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::_internal_mutable_event_data() {
  
  return _impl_.event_data_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::release_event_data() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.event_data)
  return _impl_.event_data_.Release();
}
inline void SmartContractEventsResponse::set_allocated_event_data(std::string* event_data) {
  if (event_data != nullptr) {
    
  } else {
    
  }
  _impl_.event_data_.SetAllocated(event_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_data_.IsDefault()) {
    _impl_.event_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.event_data)
}

// string function = 8;
inline void SmartContractEventsResponse::clear_function() {
  _impl_.function_.ClearToEmpty();
}
inline const std::string& SmartContractEventsResponse::function() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.function)
  return _internal_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractEventsResponse::set_function(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.function)
}
inline std::string* SmartContractEventsResponse::mutable_function() {
  std::string* _s = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.function)
  return _s;
}
inline const std::string& SmartContractEventsResponse::_internal_function() const {
  return _impl_.function_.Get();
}
inline void SmartContractEventsResponse::_internal_set_function(const std::string& value) {
  
  _impl_.function_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::_internal_mutable_function() {
  
  return _impl_.function_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::release_function() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.function)
  return _impl_.function_.Release();
}
inline void SmartContractEventsResponse::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    
  } else {
    
  }
  _impl_.function_.SetAllocated(function, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_.IsDefault()) {
    _impl_.function_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.function)
}

// uint64 block_height = 9;
inline void SmartContractEventsResponse::clear_block_height() {
  _impl_.block_height_ = uint64_t{0u};
}
inline uint64_t SmartContractEventsResponse::_internal_block_height() const {
  return _impl_.block_height_;
}
inline uint64_t SmartContractEventsResponse::block_height() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.block_height)
  return _internal_block_height();
}
inline void SmartContractEventsResponse::_internal_set_block_height(uint64_t value) {
  
  _impl_.block_height_ = value;
}
inline void SmartContractEventsResponse::set_block_height(uint64_t value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.block_height)
}

// .google.protobuf.Timestamp timestamp = 10;
inline bool SmartContractEventsResponse::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool SmartContractEventsResponse::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SmartContractEventsResponse::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SmartContractEventsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.timestamp)
  return _internal_timestamp();
}
inline void SmartContractEventsResponse::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_api.SmartContractEventsResponse.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SmartContractEventsResponse::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SmartContractEventsResponse::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SmartContractEventsResponse::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SmartContractEventsResponse::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.timestamp)
  return _msg;
}
inline void SmartContractEventsResponse::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.timestamp)
}

// string block_hash = 11;
inline void SmartContractEventsResponse::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& SmartContractEventsResponse::block_hash() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractEventsResponse::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.block_hash)
}
inline std::string* SmartContractEventsResponse::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.block_hash)
  return _s;
}
inline const std::string& SmartContractEventsResponse::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void SmartContractEventsResponse::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::release_block_hash() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.block_hash)
  return _impl_.block_hash_.Release();
}
inline void SmartContractEventsResponse::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.block_hash)
}

// string txn_hash = 12;
inline void SmartContractEventsResponse::clear_txn_hash() {
  _impl_.txn_hash_.ClearToEmpty();
}
inline const std::string& SmartContractEventsResponse::txn_hash() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.txn_hash)
  return _internal_txn_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractEventsResponse::set_txn_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txn_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.txn_hash)
}
inline std::string* SmartContractEventsResponse::mutable_txn_hash() {
  std::string* _s = _internal_mutable_txn_hash();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.txn_hash)
  return _s;
}
inline const std::string& SmartContractEventsResponse::_internal_txn_hash() const {
  return _impl_.txn_hash_.Get();
}
inline void SmartContractEventsResponse::_internal_set_txn_hash(const std::string& value) {
  
  _impl_.txn_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::_internal_mutable_txn_hash() {
  
  return _impl_.txn_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::release_txn_hash() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.txn_hash)
  return _impl_.txn_hash_.Release();
}
inline void SmartContractEventsResponse::set_allocated_txn_hash(std::string* txn_hash) {
  if (txn_hash != nullptr) {
    
  } else {
    
  }
  _impl_.txn_hash_.SetAllocated(txn_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txn_hash_.IsDefault()) {
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.txn_hash)
}

// .zera_txn.PublicKey public_key = 13;
inline bool SmartContractEventsResponse::_internal_has_public_key() const {
  return this != internal_default_instance() && _impl_.public_key_ != nullptr;
}
inline bool SmartContractEventsResponse::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& SmartContractEventsResponse::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = _impl_.public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::PublicKey&>(
      ::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& SmartContractEventsResponse::public_key() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.public_key)
  return _internal_public_key();
}
inline void SmartContractEventsResponse::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  _impl_.public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_api.SmartContractEventsResponse.public_key)
}
inline ::zera_txn::PublicKey* SmartContractEventsResponse::release_public_key() {
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::PublicKey* SmartContractEventsResponse::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.public_key)
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* SmartContractEventsResponse::_internal_mutable_public_key() {
  
  if (_impl_.public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArenaForAllocation());
    _impl_.public_key_ = p;
  }
  return _impl_.public_key_;
}
inline ::zera_txn::PublicKey* SmartContractEventsResponse::mutable_public_key() {
  ::zera_txn::PublicKey* _msg = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.public_key)
  return _msg;
}
inline void SmartContractEventsResponse::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key));
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.public_key)
}

// bytes signature = 14;
inline void SmartContractEventsResponse::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& SmartContractEventsResponse::signature() const {
  // @@protoc_insertion_point(field_get:zera_api.SmartContractEventsResponse.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractEventsResponse::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.SmartContractEventsResponse.signature)
}
inline std::string* SmartContractEventsResponse::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:zera_api.SmartContractEventsResponse.signature)
  return _s;
}
inline const std::string& SmartContractEventsResponse::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void SmartContractEventsResponse::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractEventsResponse::release_signature() {
  // @@protoc_insertion_point(field_release:zera_api.SmartContractEventsResponse.signature)
  return _impl_.signature_.Release();
}
inline void SmartContractEventsResponse::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.SmartContractEventsResponse.signature)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SmartContractSubscription

// map<string, .zera_api.Subscriber> subscibers = 1;
inline int SmartContractSubscription::_internal_subscibers_size() const {
  return _impl_.subscibers_.size();
}
inline int SmartContractSubscription::subscibers_size() const {
  return _internal_subscibers_size();
}
inline void SmartContractSubscription::clear_subscibers() {
  _impl_.subscibers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >&
SmartContractSubscription::_internal_subscibers() const {
  return _impl_.subscibers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >&
SmartContractSubscription::subscibers() const {
  // @@protoc_insertion_point(field_map:zera_api.SmartContractSubscription.subscibers)
  return _internal_subscibers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >*
SmartContractSubscription::_internal_mutable_subscibers() {
  return _impl_.subscibers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >*
SmartContractSubscription::mutable_subscibers() {
  // @@protoc_insertion_point(field_mutable_map:zera_api.SmartContractSubscription.subscibers)
  return _internal_mutable_subscibers();
}

// -------------------------------------------------------------------

// Subscriber

// .zera_api.CONFIRMATION_LEVEL level = 1;
inline void Subscriber::clear_level() {
  _impl_.level_ = 0;
}
inline ::zera_api::CONFIRMATION_LEVEL Subscriber::_internal_level() const {
  return static_cast< ::zera_api::CONFIRMATION_LEVEL >(_impl_.level_);
}
inline ::zera_api::CONFIRMATION_LEVEL Subscriber::level() const {
  // @@protoc_insertion_point(field_get:zera_api.Subscriber.level)
  return _internal_level();
}
inline void Subscriber::_internal_set_level(::zera_api::CONFIRMATION_LEVEL value) {
  
  _impl_.level_ = value;
}
inline void Subscriber::set_level(::zera_api::CONFIRMATION_LEVEL value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:zera_api.Subscriber.level)
}

// string host = 2;
inline void Subscriber::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& Subscriber::host() const {
  // @@protoc_insertion_point(field_get:zera_api.Subscriber.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscriber::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.Subscriber.host)
}
inline std::string* Subscriber::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:zera_api.Subscriber.host)
  return _s;
}
inline const std::string& Subscriber::_internal_host() const {
  return _impl_.host_.Get();
}
inline void Subscriber::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* Subscriber::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* Subscriber::release_host() {
  // @@protoc_insertion_point(field_release:zera_api.Subscriber.host)
  return _impl_.host_.Release();
}
inline void Subscriber::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.Subscriber.host)
}

// int32 port = 3;
inline void Subscriber::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t Subscriber::_internal_port() const {
  return _impl_.port_;
}
inline int32_t Subscriber::port() const {
  // @@protoc_insertion_point(field_get:zera_api.Subscriber.port)
  return _internal_port();
}
inline void Subscriber::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void Subscriber::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:zera_api.Subscriber.port)
}

// -------------------------------------------------------------------

// WalletChange

// bytes wallet_address = 1;
inline void WalletChange::clear_wallet_address() {
  _impl_.wallet_address_.ClearToEmpty();
}
inline const std::string& WalletChange::wallet_address() const {
  // @@protoc_insertion_point(field_get:zera_api.WalletChange.wallet_address)
  return _internal_wallet_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletChange::set_wallet_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wallet_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_api.WalletChange.wallet_address)
}
inline std::string* WalletChange::mutable_wallet_address() {
  std::string* _s = _internal_mutable_wallet_address();
  // @@protoc_insertion_point(field_mutable:zera_api.WalletChange.wallet_address)
  return _s;
}
inline const std::string& WalletChange::_internal_wallet_address() const {
  return _impl_.wallet_address_.Get();
}
inline void WalletChange::_internal_set_wallet_address(const std::string& value) {
  
  _impl_.wallet_address_.Set(value, GetArenaForAllocation());
}
inline std::string* WalletChange::_internal_mutable_wallet_address() {
  
  return _impl_.wallet_address_.Mutable(GetArenaForAllocation());
}
inline std::string* WalletChange::release_wallet_address() {
  // @@protoc_insertion_point(field_release:zera_api.WalletChange.wallet_address)
  return _impl_.wallet_address_.Release();
}
inline void WalletChange::set_allocated_wallet_address(std::string* wallet_address) {
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  _impl_.wallet_address_.SetAllocated(wallet_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wallet_address_.IsDefault()) {
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_api.WalletChange.wallet_address)
}

// repeated string contract_ids = 2;
inline int WalletChange::_internal_contract_ids_size() const {
  return _impl_.contract_ids_.size();
}
inline int WalletChange::contract_ids_size() const {
  return _internal_contract_ids_size();
}
inline void WalletChange::clear_contract_ids() {
  _impl_.contract_ids_.Clear();
}
inline std::string* WalletChange::add_contract_ids() {
  std::string* _s = _internal_add_contract_ids();
  // @@protoc_insertion_point(field_add_mutable:zera_api.WalletChange.contract_ids)
  return _s;
}
inline const std::string& WalletChange::_internal_contract_ids(int index) const {
  return _impl_.contract_ids_.Get(index);
}
inline const std::string& WalletChange::contract_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.WalletChange.contract_ids)
  return _internal_contract_ids(index);
}
inline std::string* WalletChange::mutable_contract_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.WalletChange.contract_ids)
  return _impl_.contract_ids_.Mutable(index);
}
inline void WalletChange::set_contract_ids(int index, const std::string& value) {
  _impl_.contract_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.WalletChange.contract_ids)
}
inline void WalletChange::set_contract_ids(int index, std::string&& value) {
  _impl_.contract_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.WalletChange.contract_ids)
}
inline void WalletChange::set_contract_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.contract_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.WalletChange.contract_ids)
}
inline void WalletChange::set_contract_ids(int index, const char* value, size_t size) {
  _impl_.contract_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.WalletChange.contract_ids)
}
inline std::string* WalletChange::_internal_add_contract_ids() {
  return _impl_.contract_ids_.Add();
}
inline void WalletChange::add_contract_ids(const std::string& value) {
  _impl_.contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.WalletChange.contract_ids)
}
inline void WalletChange::add_contract_ids(std::string&& value) {
  _impl_.contract_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.WalletChange.contract_ids)
}
inline void WalletChange::add_contract_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.WalletChange.contract_ids)
}
inline void WalletChange::add_contract_ids(const char* value, size_t size) {
  _impl_.contract_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.WalletChange.contract_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WalletChange::contract_ids() const {
  // @@protoc_insertion_point(field_list:zera_api.WalletChange.contract_ids)
  return _impl_.contract_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WalletChange::mutable_contract_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.WalletChange.contract_ids)
  return &_impl_.contract_ids_;
}

// repeated string old_balances = 3;
inline int WalletChange::_internal_old_balances_size() const {
  return _impl_.old_balances_.size();
}
inline int WalletChange::old_balances_size() const {
  return _internal_old_balances_size();
}
inline void WalletChange::clear_old_balances() {
  _impl_.old_balances_.Clear();
}
inline std::string* WalletChange::add_old_balances() {
  std::string* _s = _internal_add_old_balances();
  // @@protoc_insertion_point(field_add_mutable:zera_api.WalletChange.old_balances)
  return _s;
}
inline const std::string& WalletChange::_internal_old_balances(int index) const {
  return _impl_.old_balances_.Get(index);
}
inline const std::string& WalletChange::old_balances(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.WalletChange.old_balances)
  return _internal_old_balances(index);
}
inline std::string* WalletChange::mutable_old_balances(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.WalletChange.old_balances)
  return _impl_.old_balances_.Mutable(index);
}
inline void WalletChange::set_old_balances(int index, const std::string& value) {
  _impl_.old_balances_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.WalletChange.old_balances)
}
inline void WalletChange::set_old_balances(int index, std::string&& value) {
  _impl_.old_balances_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.WalletChange.old_balances)
}
inline void WalletChange::set_old_balances(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.old_balances_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.WalletChange.old_balances)
}
inline void WalletChange::set_old_balances(int index, const char* value, size_t size) {
  _impl_.old_balances_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.WalletChange.old_balances)
}
inline std::string* WalletChange::_internal_add_old_balances() {
  return _impl_.old_balances_.Add();
}
inline void WalletChange::add_old_balances(const std::string& value) {
  _impl_.old_balances_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.WalletChange.old_balances)
}
inline void WalletChange::add_old_balances(std::string&& value) {
  _impl_.old_balances_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.WalletChange.old_balances)
}
inline void WalletChange::add_old_balances(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.old_balances_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.WalletChange.old_balances)
}
inline void WalletChange::add_old_balances(const char* value, size_t size) {
  _impl_.old_balances_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.WalletChange.old_balances)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WalletChange::old_balances() const {
  // @@protoc_insertion_point(field_list:zera_api.WalletChange.old_balances)
  return _impl_.old_balances_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WalletChange::mutable_old_balances() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.WalletChange.old_balances)
  return &_impl_.old_balances_;
}

// repeated string new_balances = 4;
inline int WalletChange::_internal_new_balances_size() const {
  return _impl_.new_balances_.size();
}
inline int WalletChange::new_balances_size() const {
  return _internal_new_balances_size();
}
inline void WalletChange::clear_new_balances() {
  _impl_.new_balances_.Clear();
}
inline std::string* WalletChange::add_new_balances() {
  std::string* _s = _internal_add_new_balances();
  // @@protoc_insertion_point(field_add_mutable:zera_api.WalletChange.new_balances)
  return _s;
}
inline const std::string& WalletChange::_internal_new_balances(int index) const {
  return _impl_.new_balances_.Get(index);
}
inline const std::string& WalletChange::new_balances(int index) const {
  // @@protoc_insertion_point(field_get:zera_api.WalletChange.new_balances)
  return _internal_new_balances(index);
}
inline std::string* WalletChange::mutable_new_balances(int index) {
  // @@protoc_insertion_point(field_mutable:zera_api.WalletChange.new_balances)
  return _impl_.new_balances_.Mutable(index);
}
inline void WalletChange::set_new_balances(int index, const std::string& value) {
  _impl_.new_balances_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_api.WalletChange.new_balances)
}
inline void WalletChange::set_new_balances(int index, std::string&& value) {
  _impl_.new_balances_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_api.WalletChange.new_balances)
}
inline void WalletChange::set_new_balances(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.new_balances_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_api.WalletChange.new_balances)
}
inline void WalletChange::set_new_balances(int index, const char* value, size_t size) {
  _impl_.new_balances_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_api.WalletChange.new_balances)
}
inline std::string* WalletChange::_internal_add_new_balances() {
  return _impl_.new_balances_.Add();
}
inline void WalletChange::add_new_balances(const std::string& value) {
  _impl_.new_balances_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_api.WalletChange.new_balances)
}
inline void WalletChange::add_new_balances(std::string&& value) {
  _impl_.new_balances_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_api.WalletChange.new_balances)
}
inline void WalletChange::add_new_balances(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.new_balances_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_api.WalletChange.new_balances)
}
inline void WalletChange::add_new_balances(const char* value, size_t size) {
  _impl_.new_balances_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_api.WalletChange.new_balances)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WalletChange::new_balances() const {
  // @@protoc_insertion_point(field_list:zera_api.WalletChange.new_balances)
  return _impl_.new_balances_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WalletChange::mutable_new_balances() {
  // @@protoc_insertion_point(field_mutable_list:zera_api.WalletChange.new_balances)
  return &_impl_.new_balances_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zera_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zera_api::CONFIRMATION_LEVEL> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_api::CONFIRMATION_LEVEL>() {
  return ::zera_api::CONFIRMATION_LEVEL_descriptor();
}
template <> struct is_proto_enum< ::zera_api::DATABASE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_api::DATABASE_TYPE>() {
  return ::zera_api::DATABASE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::zera_api::PROPOSAL_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_api::PROPOSAL_TYPE>() {
  return ::zera_api::PROPOSAL_TYPE_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zera_5fapi_2eproto
