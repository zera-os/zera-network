// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: validator.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_validator_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_validator_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/empty.pb.h>
#include "txn.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_validator_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_validator_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[81]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_validator_2eproto;
namespace zera_validator {
class AllowanceState;
class AllowanceStateDefaultTypeInternal;
extern AllowanceStateDefaultTypeInternal _AllowanceState_default_instance_;
class AttestationLedger;
class AttestationLedgerDefaultTypeInternal;
extern AttestationLedgerDefaultTypeInternal _AttestationLedger_default_instance_;
class AttestationLedger_BlockAttestationResponsesEntry_DoNotUse;
class AttestationLedger_BlockAttestationResponsesEntry_DoNotUseDefaultTypeInternal;
extern AttestationLedger_BlockAttestationResponsesEntry_DoNotUseDefaultTypeInternal _AttestationLedger_BlockAttestationResponsesEntry_DoNotUse_default_instance_;
class AttestationLedger_ValidatorSupportEntry_DoNotUse;
class AttestationLedger_ValidatorSupportEntry_DoNotUseDefaultTypeInternal;
extern AttestationLedger_ValidatorSupportEntry_DoNotUseDefaultTypeInternal _AttestationLedger_ValidatorSupportEntry_DoNotUse_default_instance_;
class AttestationSupport;
class AttestationSupportDefaultTypeInternal;
extern AttestationSupportDefaultTypeInternal _AttestationSupport_default_instance_;
class AuthorizedFee;
class AuthorizedFeeDefaultTypeInternal;
extern AuthorizedFeeDefaultTypeInternal _AuthorizedFee_default_instance_;
class BalanceRequest;
class BalanceRequestDefaultTypeInternal;
extern BalanceRequestDefaultTypeInternal _BalanceRequest_default_instance_;
class BalanceResponse;
class BalanceResponseDefaultTypeInternal;
extern BalanceResponseDefaultTypeInternal _BalanceResponse_default_instance_;
class BalanceTracker;
class BalanceTrackerDefaultTypeInternal;
extern BalanceTrackerDefaultTypeInternal _BalanceTracker_default_instance_;
class BalanceTracker_WalletBalancesEntry_DoNotUse;
class BalanceTracker_WalletBalancesEntry_DoNotUseDefaultTypeInternal;
extern BalanceTracker_WalletBalancesEntry_DoNotUseDefaultTypeInternal _BalanceTracker_WalletBalancesEntry_DoNotUse_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockAttestation;
class BlockAttestationDefaultTypeInternal;
extern BlockAttestationDefaultTypeInternal _BlockAttestation_default_instance_;
class BlockAttestationResponse;
class BlockAttestationResponseDefaultTypeInternal;
extern BlockAttestationResponseDefaultTypeInternal _BlockAttestationResponse_default_instance_;
class BlockBatch;
class BlockBatchDefaultTypeInternal;
extern BlockBatchDefaultTypeInternal _BlockBatch_default_instance_;
class BlockHeader;
class BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class BlockSync;
class BlockSyncDefaultTypeInternal;
extern BlockSyncDefaultTypeInternal _BlockSync_default_instance_;
class ComplianceData;
class ComplianceDataDefaultTypeInternal;
extern ComplianceDataDefaultTypeInternal _ComplianceData_default_instance_;
class ComplianceLevels;
class ComplianceLevelsDefaultTypeInternal;
extern ComplianceLevelsDefaultTypeInternal _ComplianceLevels_default_instance_;
class ContractPrice;
class ContractPriceDefaultTypeInternal;
extern ContractPriceDefaultTypeInternal _ContractPrice_default_instance_;
class CurrencyRate;
class CurrencyRateDefaultTypeInternal;
extern CurrencyRateDefaultTypeInternal _CurrencyRate_default_instance_;
class DataChunk;
class DataChunkDefaultTypeInternal;
extern DataChunkDefaultTypeInternal _DataChunk_default_instance_;
class DelegateWallets;
class DelegateWalletsDefaultTypeInternal;
extern DelegateWalletsDefaultTypeInternal _DelegateWallets_default_instance_;
class Delegated;
class DelegatedDefaultTypeInternal;
extern DelegatedDefaultTypeInternal _Delegated_default_instance_;
class DelegatedFees;
class DelegatedFeesDefaultTypeInternal;
extern DelegatedFeesDefaultTypeInternal _DelegatedFees_default_instance_;
class DelegatedRecipient;
class DelegatedRecipientDefaultTypeInternal;
extern DelegatedRecipientDefaultTypeInternal _DelegatedRecipient_default_instance_;
class DelegatedRecipient_DelegationsEntry_DoNotUse;
class DelegatedRecipient_DelegationsEntry_DoNotUseDefaultTypeInternal;
extern DelegatedRecipient_DelegationsEntry_DoNotUseDefaultTypeInternal _DelegatedRecipient_DelegationsEntry_DoNotUse_default_instance_;
class Delegated_ProposalsEntry_DoNotUse;
class Delegated_ProposalsEntry_DoNotUseDefaultTypeInternal;
extern Delegated_ProposalsEntry_DoNotUseDefaultTypeInternal _Delegated_ProposalsEntry_DoNotUse_default_instance_;
class DelegateeWallets;
class DelegateeWalletsDefaultTypeInternal;
extern DelegateeWalletsDefaultTypeInternal _DelegateeWallets_default_instance_;
class Delegatees;
class DelegateesDefaultTypeInternal;
extern DelegateesDefaultTypeInternal _Delegatees_default_instance_;
class Delegatees_DelegatedWalletsEntry_DoNotUse;
class Delegatees_DelegatedWalletsEntry_DoNotUseDefaultTypeInternal;
extern Delegatees_DelegatedWalletsEntry_DoNotUseDefaultTypeInternal _Delegatees_DelegatedWalletsEntry_DoNotUse_default_instance_;
class DelegationFees;
class DelegationFeesDefaultTypeInternal;
extern DelegationFeesDefaultTypeInternal _DelegationFees_default_instance_;
class DelegationFees_AuthorizedFeesEntry_DoNotUse;
class DelegationFees_AuthorizedFeesEntry_DoNotUseDefaultTypeInternal;
extern DelegationFees_AuthorizedFeesEntry_DoNotUseDefaultTypeInternal _DelegationFees_AuthorizedFeesEntry_DoNotUse_default_instance_;
class Delegator;
class DelegatorDefaultTypeInternal;
extern DelegatorDefaultTypeInternal _Delegator_default_instance_;
class Delegators;
class DelegatorsDefaultTypeInternal;
extern DelegatorsDefaultTypeInternal _Delegators_default_instance_;
class ExpenseTracker;
class ExpenseTrackerDefaultTypeInternal;
extern ExpenseTrackerDefaultTypeInternal _ExpenseTracker_default_instance_;
class IndexerOption;
class IndexerOptionDefaultTypeInternal;
extern IndexerOptionDefaultTypeInternal _IndexerOption_default_instance_;
class IndexerVote;
class IndexerVoteDefaultTypeInternal;
extern IndexerVoteDefaultTypeInternal _IndexerVote_default_instance_;
class IndexerVotingRequest;
class IndexerVotingRequestDefaultTypeInternal;
extern IndexerVotingRequestDefaultTypeInternal _IndexerVotingRequest_default_instance_;
class IndexerVotingResponse;
class IndexerVotingResponseDefaultTypeInternal;
extern IndexerVotingResponseDefaultTypeInternal _IndexerVotingResponse_default_instance_;
class Item;
class ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class NFT;
class NFTDefaultTypeInternal;
extern NFTDefaultTypeInternal _NFT_default_instance_;
class NonceRequest;
class NonceRequestDefaultTypeInternal;
extern NonceRequestDefaultTypeInternal _NonceRequest_default_instance_;
class NonceResponse;
class NonceResponseDefaultTypeInternal;
extern NonceResponseDefaultTypeInternal _NonceResponse_default_instance_;
class PreProcessedWallets;
class PreProcessedWalletsDefaultTypeInternal;
extern PreProcessedWalletsDefaultTypeInternal _PreProcessedWallets_default_instance_;
class ProcessLedger;
class ProcessLedgerDefaultTypeInternal;
extern ProcessLedgerDefaultTypeInternal _ProcessLedger_default_instance_;
class Proposal;
class ProposalDefaultTypeInternal;
extern ProposalDefaultTypeInternal _Proposal_default_instance_;
class ProposalLedger;
class ProposalLedgerDefaultTypeInternal;
extern ProposalLedgerDefaultTypeInternal _ProposalLedger_default_instance_;
class ProposalProcess;
class ProposalProcessDefaultTypeInternal;
extern ProposalProcessDefaultTypeInternal _ProposalProcess_default_instance_;
class ProposalWalletRecieve;
class ProposalWalletRecieveDefaultTypeInternal;
extern ProposalWalletRecieveDefaultTypeInternal _ProposalWalletRecieve_default_instance_;
class ProposalWalletSend;
class ProposalWalletSendDefaultTypeInternal;
extern ProposalWalletSendDefaultTypeInternal _ProposalWalletSend_default_instance_;
class Proposal_NoEntry_DoNotUse;
class Proposal_NoEntry_DoNotUseDefaultTypeInternal;
extern Proposal_NoEntry_DoNotUseDefaultTypeInternal _Proposal_NoEntry_DoNotUse_default_instance_;
class Proposal_OptionsEntry_DoNotUse;
class Proposal_OptionsEntry_DoNotUseDefaultTypeInternal;
extern Proposal_OptionsEntry_DoNotUseDefaultTypeInternal _Proposal_OptionsEntry_DoNotUse_default_instance_;
class Proposal_VotersEntry_DoNotUse;
class Proposal_VotersEntry_DoNotUseDefaultTypeInternal;
extern Proposal_VotersEntry_DoNotUseDefaultTypeInternal _Proposal_VotersEntry_DoNotUse_default_instance_;
class Proposal_YesEntry_DoNotUse;
class Proposal_YesEntry_DoNotUseDefaultTypeInternal;
extern Proposal_YesEntry_DoNotUseDefaultTypeInternal _Proposal_YesEntry_DoNotUse_default_instance_;
class QuashLedger;
class QuashLedgerDefaultTypeInternal;
extern QuashLedgerDefaultTypeInternal _QuashLedger_default_instance_;
class QuashLookup;
class QuashLookupDefaultTypeInternal;
extern QuashLookupDefaultTypeInternal _QuashLookup_default_instance_;
class RestrictedSymbols;
class RestrictedSymbolsDefaultTypeInternal;
extern RestrictedSymbolsDefaultTypeInternal _RestrictedSymbols_default_instance_;
class SlashedRequest;
class SlashedRequestDefaultTypeInternal;
extern SlashedRequestDefaultTypeInternal _SlashedRequest_default_instance_;
class SlashedToken;
class SlashedTokenDefaultTypeInternal;
extern SlashedTokenDefaultTypeInternal _SlashedToken_default_instance_;
class SlashedValidator;
class SlashedValidatorDefaultTypeInternal;
extern SlashedValidatorDefaultTypeInternal _SlashedValidator_default_instance_;
class StakeMultipliers;
class StakeMultipliersDefaultTypeInternal;
extern StakeMultipliersDefaultTypeInternal _StakeMultipliers_default_instance_;
class StakeMultipliers_ContractMultipliersEntry_DoNotUse;
class StakeMultipliers_ContractMultipliersEntry_DoNotUseDefaultTypeInternal;
extern StakeMultipliers_ContractMultipliersEntry_DoNotUseDefaultTypeInternal _StakeMultipliers_ContractMultipliersEntry_DoNotUse_default_instance_;
class TXN;
class TXNDefaultTypeInternal;
extern TXNDefaultTypeInternal _TXN_default_instance_;
class TXNGossip;
class TXNGossipDefaultTypeInternal;
extern TXNGossipDefaultTypeInternal _TXNGossip_default_instance_;
class TXNTracker;
class TXNTrackerDefaultTypeInternal;
extern TXNTrackerDefaultTypeInternal _TXNTracker_default_instance_;
class TokenLookup;
class TokenLookupDefaultTypeInternal;
extern TokenLookupDefaultTypeInternal _TokenLookup_default_instance_;
class ValidatorArchive;
class ValidatorArchiveDefaultTypeInternal;
extern ValidatorArchiveDefaultTypeInternal _ValidatorArchive_default_instance_;
class ValidatorArchive_ValidatorsEntry_DoNotUse;
class ValidatorArchive_ValidatorsEntry_DoNotUseDefaultTypeInternal;
extern ValidatorArchive_ValidatorsEntry_DoNotUseDefaultTypeInternal _ValidatorArchive_ValidatorsEntry_DoNotUse_default_instance_;
class ValidatorBalance;
class ValidatorBalanceDefaultTypeInternal;
extern ValidatorBalanceDefaultTypeInternal _ValidatorBalance_default_instance_;
class ValidatorSupport;
class ValidatorSupportDefaultTypeInternal;
extern ValidatorSupportDefaultTypeInternal _ValidatorSupport_default_instance_;
class ValidatorSync;
class ValidatorSyncDefaultTypeInternal;
extern ValidatorSyncDefaultTypeInternal _ValidatorSync_default_instance_;
class ValidatorSyncRequest;
class ValidatorSyncRequestDefaultTypeInternal;
extern ValidatorSyncRequestDefaultTypeInternal _ValidatorSyncRequest_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
class VoteWallet;
class VoteWalletDefaultTypeInternal;
extern VoteWalletDefaultTypeInternal _VoteWallet_default_instance_;
class VoteWallet_ProposalVotesEntry_DoNotUse;
class VoteWallet_ProposalVotesEntry_DoNotUseDefaultTypeInternal;
extern VoteWallet_ProposalVotesEntry_DoNotUseDefaultTypeInternal _VoteWallet_ProposalVotesEntry_DoNotUse_default_instance_;
class Vote_VoteEntry_DoNotUse;
class Vote_VoteEntry_DoNotUseDefaultTypeInternal;
extern Vote_VoteEntry_DoNotUseDefaultTypeInternal _Vote_VoteEntry_DoNotUse_default_instance_;
class Voter;
class VoterDefaultTypeInternal;
extern VoterDefaultTypeInternal _Voter_default_instance_;
class WalletItems;
class WalletItemsDefaultTypeInternal;
extern WalletItemsDefaultTypeInternal _WalletItems_default_instance_;
class WalletLookup;
class WalletLookupDefaultTypeInternal;
extern WalletLookupDefaultTypeInternal _WalletLookup_default_instance_;
class WalletLookup_ComplianceEntry_DoNotUse;
class WalletLookup_ComplianceEntry_DoNotUseDefaultTypeInternal;
extern WalletLookup_ComplianceEntry_DoNotUseDefaultTypeInternal _WalletLookup_ComplianceEntry_DoNotUse_default_instance_;
class ZeraGovernanceAuth;
class ZeraGovernanceAuthDefaultTypeInternal;
extern ZeraGovernanceAuthDefaultTypeInternal _ZeraGovernanceAuth_default_instance_;
}  // namespace zera_validator
PROTOBUF_NAMESPACE_OPEN
template<> ::zera_validator::AllowanceState* Arena::CreateMaybeMessage<::zera_validator::AllowanceState>(Arena*);
template<> ::zera_validator::AttestationLedger* Arena::CreateMaybeMessage<::zera_validator::AttestationLedger>(Arena*);
template<> ::zera_validator::AttestationLedger_BlockAttestationResponsesEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::AttestationLedger_BlockAttestationResponsesEntry_DoNotUse>(Arena*);
template<> ::zera_validator::AttestationLedger_ValidatorSupportEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::AttestationLedger_ValidatorSupportEntry_DoNotUse>(Arena*);
template<> ::zera_validator::AttestationSupport* Arena::CreateMaybeMessage<::zera_validator::AttestationSupport>(Arena*);
template<> ::zera_validator::AuthorizedFee* Arena::CreateMaybeMessage<::zera_validator::AuthorizedFee>(Arena*);
template<> ::zera_validator::BalanceRequest* Arena::CreateMaybeMessage<::zera_validator::BalanceRequest>(Arena*);
template<> ::zera_validator::BalanceResponse* Arena::CreateMaybeMessage<::zera_validator::BalanceResponse>(Arena*);
template<> ::zera_validator::BalanceTracker* Arena::CreateMaybeMessage<::zera_validator::BalanceTracker>(Arena*);
template<> ::zera_validator::BalanceTracker_WalletBalancesEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::BalanceTracker_WalletBalancesEntry_DoNotUse>(Arena*);
template<> ::zera_validator::Block* Arena::CreateMaybeMessage<::zera_validator::Block>(Arena*);
template<> ::zera_validator::BlockAttestation* Arena::CreateMaybeMessage<::zera_validator::BlockAttestation>(Arena*);
template<> ::zera_validator::BlockAttestationResponse* Arena::CreateMaybeMessage<::zera_validator::BlockAttestationResponse>(Arena*);
template<> ::zera_validator::BlockBatch* Arena::CreateMaybeMessage<::zera_validator::BlockBatch>(Arena*);
template<> ::zera_validator::BlockHeader* Arena::CreateMaybeMessage<::zera_validator::BlockHeader>(Arena*);
template<> ::zera_validator::BlockSync* Arena::CreateMaybeMessage<::zera_validator::BlockSync>(Arena*);
template<> ::zera_validator::ComplianceData* Arena::CreateMaybeMessage<::zera_validator::ComplianceData>(Arena*);
template<> ::zera_validator::ComplianceLevels* Arena::CreateMaybeMessage<::zera_validator::ComplianceLevels>(Arena*);
template<> ::zera_validator::ContractPrice* Arena::CreateMaybeMessage<::zera_validator::ContractPrice>(Arena*);
template<> ::zera_validator::CurrencyRate* Arena::CreateMaybeMessage<::zera_validator::CurrencyRate>(Arena*);
template<> ::zera_validator::DataChunk* Arena::CreateMaybeMessage<::zera_validator::DataChunk>(Arena*);
template<> ::zera_validator::DelegateWallets* Arena::CreateMaybeMessage<::zera_validator::DelegateWallets>(Arena*);
template<> ::zera_validator::Delegated* Arena::CreateMaybeMessage<::zera_validator::Delegated>(Arena*);
template<> ::zera_validator::DelegatedFees* Arena::CreateMaybeMessage<::zera_validator::DelegatedFees>(Arena*);
template<> ::zera_validator::DelegatedRecipient* Arena::CreateMaybeMessage<::zera_validator::DelegatedRecipient>(Arena*);
template<> ::zera_validator::DelegatedRecipient_DelegationsEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::DelegatedRecipient_DelegationsEntry_DoNotUse>(Arena*);
template<> ::zera_validator::Delegated_ProposalsEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::Delegated_ProposalsEntry_DoNotUse>(Arena*);
template<> ::zera_validator::DelegateeWallets* Arena::CreateMaybeMessage<::zera_validator::DelegateeWallets>(Arena*);
template<> ::zera_validator::Delegatees* Arena::CreateMaybeMessage<::zera_validator::Delegatees>(Arena*);
template<> ::zera_validator::Delegatees_DelegatedWalletsEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::Delegatees_DelegatedWalletsEntry_DoNotUse>(Arena*);
template<> ::zera_validator::DelegationFees* Arena::CreateMaybeMessage<::zera_validator::DelegationFees>(Arena*);
template<> ::zera_validator::DelegationFees_AuthorizedFeesEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::DelegationFees_AuthorizedFeesEntry_DoNotUse>(Arena*);
template<> ::zera_validator::Delegator* Arena::CreateMaybeMessage<::zera_validator::Delegator>(Arena*);
template<> ::zera_validator::Delegators* Arena::CreateMaybeMessage<::zera_validator::Delegators>(Arena*);
template<> ::zera_validator::ExpenseTracker* Arena::CreateMaybeMessage<::zera_validator::ExpenseTracker>(Arena*);
template<> ::zera_validator::IndexerOption* Arena::CreateMaybeMessage<::zera_validator::IndexerOption>(Arena*);
template<> ::zera_validator::IndexerVote* Arena::CreateMaybeMessage<::zera_validator::IndexerVote>(Arena*);
template<> ::zera_validator::IndexerVotingRequest* Arena::CreateMaybeMessage<::zera_validator::IndexerVotingRequest>(Arena*);
template<> ::zera_validator::IndexerVotingResponse* Arena::CreateMaybeMessage<::zera_validator::IndexerVotingResponse>(Arena*);
template<> ::zera_validator::Item* Arena::CreateMaybeMessage<::zera_validator::Item>(Arena*);
template<> ::zera_validator::NFT* Arena::CreateMaybeMessage<::zera_validator::NFT>(Arena*);
template<> ::zera_validator::NonceRequest* Arena::CreateMaybeMessage<::zera_validator::NonceRequest>(Arena*);
template<> ::zera_validator::NonceResponse* Arena::CreateMaybeMessage<::zera_validator::NonceResponse>(Arena*);
template<> ::zera_validator::PreProcessedWallets* Arena::CreateMaybeMessage<::zera_validator::PreProcessedWallets>(Arena*);
template<> ::zera_validator::ProcessLedger* Arena::CreateMaybeMessage<::zera_validator::ProcessLedger>(Arena*);
template<> ::zera_validator::Proposal* Arena::CreateMaybeMessage<::zera_validator::Proposal>(Arena*);
template<> ::zera_validator::ProposalLedger* Arena::CreateMaybeMessage<::zera_validator::ProposalLedger>(Arena*);
template<> ::zera_validator::ProposalProcess* Arena::CreateMaybeMessage<::zera_validator::ProposalProcess>(Arena*);
template<> ::zera_validator::ProposalWalletRecieve* Arena::CreateMaybeMessage<::zera_validator::ProposalWalletRecieve>(Arena*);
template<> ::zera_validator::ProposalWalletSend* Arena::CreateMaybeMessage<::zera_validator::ProposalWalletSend>(Arena*);
template<> ::zera_validator::Proposal_NoEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::Proposal_NoEntry_DoNotUse>(Arena*);
template<> ::zera_validator::Proposal_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::Proposal_OptionsEntry_DoNotUse>(Arena*);
template<> ::zera_validator::Proposal_VotersEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::Proposal_VotersEntry_DoNotUse>(Arena*);
template<> ::zera_validator::Proposal_YesEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::Proposal_YesEntry_DoNotUse>(Arena*);
template<> ::zera_validator::QuashLedger* Arena::CreateMaybeMessage<::zera_validator::QuashLedger>(Arena*);
template<> ::zera_validator::QuashLookup* Arena::CreateMaybeMessage<::zera_validator::QuashLookup>(Arena*);
template<> ::zera_validator::RestrictedSymbols* Arena::CreateMaybeMessage<::zera_validator::RestrictedSymbols>(Arena*);
template<> ::zera_validator::SlashedRequest* Arena::CreateMaybeMessage<::zera_validator::SlashedRequest>(Arena*);
template<> ::zera_validator::SlashedToken* Arena::CreateMaybeMessage<::zera_validator::SlashedToken>(Arena*);
template<> ::zera_validator::SlashedValidator* Arena::CreateMaybeMessage<::zera_validator::SlashedValidator>(Arena*);
template<> ::zera_validator::StakeMultipliers* Arena::CreateMaybeMessage<::zera_validator::StakeMultipliers>(Arena*);
template<> ::zera_validator::StakeMultipliers_ContractMultipliersEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::StakeMultipliers_ContractMultipliersEntry_DoNotUse>(Arena*);
template<> ::zera_validator::TXN* Arena::CreateMaybeMessage<::zera_validator::TXN>(Arena*);
template<> ::zera_validator::TXNGossip* Arena::CreateMaybeMessage<::zera_validator::TXNGossip>(Arena*);
template<> ::zera_validator::TXNTracker* Arena::CreateMaybeMessage<::zera_validator::TXNTracker>(Arena*);
template<> ::zera_validator::TokenLookup* Arena::CreateMaybeMessage<::zera_validator::TokenLookup>(Arena*);
template<> ::zera_validator::ValidatorArchive* Arena::CreateMaybeMessage<::zera_validator::ValidatorArchive>(Arena*);
template<> ::zera_validator::ValidatorArchive_ValidatorsEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::ValidatorArchive_ValidatorsEntry_DoNotUse>(Arena*);
template<> ::zera_validator::ValidatorBalance* Arena::CreateMaybeMessage<::zera_validator::ValidatorBalance>(Arena*);
template<> ::zera_validator::ValidatorSupport* Arena::CreateMaybeMessage<::zera_validator::ValidatorSupport>(Arena*);
template<> ::zera_validator::ValidatorSync* Arena::CreateMaybeMessage<::zera_validator::ValidatorSync>(Arena*);
template<> ::zera_validator::ValidatorSyncRequest* Arena::CreateMaybeMessage<::zera_validator::ValidatorSyncRequest>(Arena*);
template<> ::zera_validator::Vote* Arena::CreateMaybeMessage<::zera_validator::Vote>(Arena*);
template<> ::zera_validator::VoteWallet* Arena::CreateMaybeMessage<::zera_validator::VoteWallet>(Arena*);
template<> ::zera_validator::VoteWallet_ProposalVotesEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::VoteWallet_ProposalVotesEntry_DoNotUse>(Arena*);
template<> ::zera_validator::Vote_VoteEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::Vote_VoteEntry_DoNotUse>(Arena*);
template<> ::zera_validator::Voter* Arena::CreateMaybeMessage<::zera_validator::Voter>(Arena*);
template<> ::zera_validator::WalletItems* Arena::CreateMaybeMessage<::zera_validator::WalletItems>(Arena*);
template<> ::zera_validator::WalletLookup* Arena::CreateMaybeMessage<::zera_validator::WalletLookup>(Arena*);
template<> ::zera_validator::WalletLookup_ComplianceEntry_DoNotUse* Arena::CreateMaybeMessage<::zera_validator::WalletLookup_ComplianceEntry_DoNotUse>(Arena*);
template<> ::zera_validator::ZeraGovernanceAuth* Arena::CreateMaybeMessage<::zera_validator::ZeraGovernanceAuth>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zera_validator {

// ===================================================================

class AllowanceState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.AllowanceState) */ {
 public:
  inline AllowanceState() : AllowanceState(nullptr) {};
  virtual ~AllowanceState();

  AllowanceState(const AllowanceState& from);
  AllowanceState(AllowanceState&& from) noexcept
    : AllowanceState() {
    *this = ::std::move(from);
  }

  inline AllowanceState& operator=(const AllowanceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowanceState& operator=(AllowanceState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AllowanceState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllowanceState* internal_default_instance() {
    return reinterpret_cast<const AllowanceState*>(
               &_AllowanceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AllowanceState& a, AllowanceState& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowanceState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowanceState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllowanceState* New() const final {
    return CreateMaybeMessage<AllowanceState>(nullptr);
  }

  AllowanceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllowanceState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AllowanceState& from);
  void MergeFrom(const AllowanceState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllowanceState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.AllowanceState";
  }
  protected:
  explicit AllowanceState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedCurrencyEquivelentFieldNumber = 1,
    kAllowedAmountFieldNumber = 2,
    kPeriodEndFieldNumber = 5,
    kStartTimeFieldNumber = 6,
    kPeriodMonthsFieldNumber = 3,
    kPeriodSecondsFieldNumber = 4,
    kNonceFieldNumber = 7,
    kAuthorizeFieldNumber = 8,
  };
  // string allowed_currency_equivelent = 1;
  bool has_allowed_currency_equivelent() const;
  private:
  bool _internal_has_allowed_currency_equivelent() const;
  public:
  void clear_allowed_currency_equivelent();
  const std::string& allowed_currency_equivelent() const;
  void set_allowed_currency_equivelent(const std::string& value);
  void set_allowed_currency_equivelent(std::string&& value);
  void set_allowed_currency_equivelent(const char* value);
  void set_allowed_currency_equivelent(const char* value, size_t size);
  std::string* mutable_allowed_currency_equivelent();
  std::string* release_allowed_currency_equivelent();
  void set_allocated_allowed_currency_equivelent(std::string* allowed_currency_equivelent);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_allowed_currency_equivelent();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_allowed_currency_equivelent(
      std::string* allowed_currency_equivelent);
  private:
  const std::string& _internal_allowed_currency_equivelent() const;
  void _internal_set_allowed_currency_equivelent(const std::string& value);
  std::string* _internal_mutable_allowed_currency_equivelent();
  public:

  // string allowed_amount = 2;
  bool has_allowed_amount() const;
  private:
  bool _internal_has_allowed_amount() const;
  public:
  void clear_allowed_amount();
  const std::string& allowed_amount() const;
  void set_allowed_amount(const std::string& value);
  void set_allowed_amount(std::string&& value);
  void set_allowed_amount(const char* value);
  void set_allowed_amount(const char* value, size_t size);
  std::string* mutable_allowed_amount();
  std::string* release_allowed_amount();
  void set_allocated_allowed_amount(std::string* allowed_amount);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_allowed_amount();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_allowed_amount(
      std::string* allowed_amount);
  private:
  const std::string& _internal_allowed_amount() const;
  void _internal_set_allowed_amount(const std::string& value);
  std::string* _internal_mutable_allowed_amount();
  public:

  // .google.protobuf.Timestamp period_end = 5;
  bool has_period_end() const;
  private:
  bool _internal_has_period_end() const;
  public:
  void clear_period_end();
  const PROTOBUF_NAMESPACE_ID::Timestamp& period_end() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_period_end();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_period_end();
  void set_allocated_period_end(PROTOBUF_NAMESPACE_ID::Timestamp* period_end);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_period_end() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_period_end();
  public:
  void unsafe_arena_set_allocated_period_end(
      PROTOBUF_NAMESPACE_ID::Timestamp* period_end);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_period_end();

  // .google.protobuf.Timestamp start_time = 6;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // uint32 period_months = 3;
  bool has_period_months() const;
  private:
  bool _internal_has_period_months() const;
  public:
  void clear_period_months();
  ::PROTOBUF_NAMESPACE_ID::uint32 period_months() const;
  void set_period_months(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_period_months() const;
  void _internal_set_period_months(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 period_seconds = 4;
  bool has_period_seconds() const;
  private:
  bool _internal_has_period_seconds() const;
  public:
  void clear_period_seconds();
  ::PROTOBUF_NAMESPACE_ID::uint32 period_seconds() const;
  void set_period_seconds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_period_seconds() const;
  void _internal_set_period_seconds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint64 nonce = 7;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool authorize = 8;
  void clear_authorize();
  bool authorize() const;
  void set_authorize(bool value);
  private:
  bool _internal_authorize() const;
  void _internal_set_authorize(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.AllowanceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allowed_currency_equivelent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allowed_amount_;
  PROTOBUF_NAMESPACE_ID::Timestamp* period_end_;
  PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 period_months_;
  ::PROTOBUF_NAMESPACE_ID::uint32 period_seconds_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  bool authorize_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class StakeMultipliers_ContractMultipliersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StakeMultipliers_ContractMultipliersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StakeMultipliers_ContractMultipliersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StakeMultipliers_ContractMultipliersEntry_DoNotUse();
  StakeMultipliers_ContractMultipliersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StakeMultipliers_ContractMultipliersEntry_DoNotUse& other);
  static const StakeMultipliers_ContractMultipliersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StakeMultipliers_ContractMultipliersEntry_DoNotUse*>(&_StakeMultipliers_ContractMultipliersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.StakeMultipliers.ContractMultipliersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.StakeMultipliers.ContractMultipliersEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[1];
  }

  public:
};

// -------------------------------------------------------------------

class StakeMultipliers PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.StakeMultipliers) */ {
 public:
  inline StakeMultipliers() : StakeMultipliers(nullptr) {};
  virtual ~StakeMultipliers();

  StakeMultipliers(const StakeMultipliers& from);
  StakeMultipliers(StakeMultipliers&& from) noexcept
    : StakeMultipliers() {
    *this = ::std::move(from);
  }

  inline StakeMultipliers& operator=(const StakeMultipliers& from) {
    CopyFrom(from);
    return *this;
  }
  inline StakeMultipliers& operator=(StakeMultipliers&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StakeMultipliers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StakeMultipliers* internal_default_instance() {
    return reinterpret_cast<const StakeMultipliers*>(
               &_StakeMultipliers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StakeMultipliers& a, StakeMultipliers& b) {
    a.Swap(&b);
  }
  inline void Swap(StakeMultipliers* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StakeMultipliers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StakeMultipliers* New() const final {
    return CreateMaybeMessage<StakeMultipliers>(nullptr);
  }

  StakeMultipliers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StakeMultipliers>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StakeMultipliers& from);
  void MergeFrom(const StakeMultipliers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StakeMultipliers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.StakeMultipliers";
  }
  protected:
  explicit StakeMultipliers(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kContractMultipliersFieldNumber = 1,
    kDefaultMultiplierFieldNumber = 2,
  };
  // map<string, string> contract_multipliers = 1;
  int contract_multipliers_size() const;
  private:
  int _internal_contract_multipliers_size() const;
  public:
  void clear_contract_multipliers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_contract_multipliers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_contract_multipliers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      contract_multipliers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_contract_multipliers();

  // string default_multiplier = 2;
  void clear_default_multiplier();
  const std::string& default_multiplier() const;
  void set_default_multiplier(const std::string& value);
  void set_default_multiplier(std::string&& value);
  void set_default_multiplier(const char* value);
  void set_default_multiplier(const char* value, size_t size);
  std::string* mutable_default_multiplier();
  std::string* release_default_multiplier();
  void set_allocated_default_multiplier(std::string* default_multiplier);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_default_multiplier();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_default_multiplier(
      std::string* default_multiplier);
  private:
  const std::string& _internal_default_multiplier() const;
  void _internal_set_default_multiplier(const std::string& value);
  std::string* _internal_mutable_default_multiplier();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.StakeMultipliers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StakeMultipliers_ContractMultipliersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > contract_multipliers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_multiplier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ValidatorArchive_ValidatorsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidatorArchive_ValidatorsEntry_DoNotUse, 
    std::string, ::zera_validator::ValidatorBalance,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidatorArchive_ValidatorsEntry_DoNotUse, 
    std::string, ::zera_validator::ValidatorBalance,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ValidatorArchive_ValidatorsEntry_DoNotUse();
  ValidatorArchive_ValidatorsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ValidatorArchive_ValidatorsEntry_DoNotUse& other);
  static const ValidatorArchive_ValidatorsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ValidatorArchive_ValidatorsEntry_DoNotUse*>(&_ValidatorArchive_ValidatorsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.ValidatorArchive.ValidatorsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class ValidatorArchive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ValidatorArchive) */ {
 public:
  inline ValidatorArchive() : ValidatorArchive(nullptr) {};
  virtual ~ValidatorArchive();

  ValidatorArchive(const ValidatorArchive& from);
  ValidatorArchive(ValidatorArchive&& from) noexcept
    : ValidatorArchive() {
    *this = ::std::move(from);
  }

  inline ValidatorArchive& operator=(const ValidatorArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorArchive& operator=(ValidatorArchive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorArchive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorArchive* internal_default_instance() {
    return reinterpret_cast<const ValidatorArchive*>(
               &_ValidatorArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ValidatorArchive& a, ValidatorArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorArchive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidatorArchive* New() const final {
    return CreateMaybeMessage<ValidatorArchive>(nullptr);
  }

  ValidatorArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorArchive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorArchive& from);
  void MergeFrom(const ValidatorArchive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorArchive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ValidatorArchive";
  }
  protected:
  explicit ValidatorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValidatorsFieldNumber = 1,
    kTotalBalanceFieldNumber = 2,
  };
  // map<string, .zera_validator.ValidatorBalance> validators = 1;
  int validators_size() const;
  private:
  int _internal_validators_size() const;
  public:
  void clear_validators();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ValidatorBalance >&
      _internal_validators() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ValidatorBalance >*
      _internal_mutable_validators();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ValidatorBalance >&
      validators() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ValidatorBalance >*
      mutable_validators();

  // string total_balance = 2;
  void clear_total_balance();
  const std::string& total_balance() const;
  void set_total_balance(const std::string& value);
  void set_total_balance(std::string&& value);
  void set_total_balance(const char* value);
  void set_total_balance(const char* value, size_t size);
  std::string* mutable_total_balance();
  std::string* release_total_balance();
  void set_allocated_total_balance(std::string* total_balance);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_total_balance();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_total_balance(
      std::string* total_balance);
  private:
  const std::string& _internal_total_balance() const;
  void _internal_set_total_balance(const std::string& value);
  std::string* _internal_mutable_total_balance();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.ValidatorArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ValidatorArchive_ValidatorsEntry_DoNotUse,
      std::string, ::zera_validator::ValidatorBalance,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > validators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_balance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ValidatorBalance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ValidatorBalance) */ {
 public:
  inline ValidatorBalance() : ValidatorBalance(nullptr) {};
  virtual ~ValidatorBalance();

  ValidatorBalance(const ValidatorBalance& from);
  ValidatorBalance(ValidatorBalance&& from) noexcept
    : ValidatorBalance() {
    *this = ::std::move(from);
  }

  inline ValidatorBalance& operator=(const ValidatorBalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorBalance& operator=(ValidatorBalance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorBalance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorBalance* internal_default_instance() {
    return reinterpret_cast<const ValidatorBalance*>(
               &_ValidatorBalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ValidatorBalance& a, ValidatorBalance& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorBalance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorBalance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidatorBalance* New() const final {
    return CreateMaybeMessage<ValidatorBalance>(nullptr);
  }

  ValidatorBalance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorBalance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorBalance& from);
  void MergeFrom(const ValidatorBalance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorBalance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ValidatorBalance";
  }
  protected:
  explicit ValidatorBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalBalanceFieldNumber = 2,
    kPublicKeyFieldNumber = 1,
  };
  // string total_balance = 2;
  void clear_total_balance();
  const std::string& total_balance() const;
  void set_total_balance(const std::string& value);
  void set_total_balance(std::string&& value);
  void set_total_balance(const char* value);
  void set_total_balance(const char* value, size_t size);
  std::string* mutable_total_balance();
  std::string* release_total_balance();
  void set_allocated_total_balance(std::string* total_balance);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_total_balance();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_total_balance(
      std::string* total_balance);
  private:
  const std::string& _internal_total_balance() const;
  void _internal_set_total_balance(const std::string& value);
  std::string* _internal_mutable_total_balance();
  public:

  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // @@protoc_insertion_point(class_scope:zera_validator.ValidatorBalance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_balance_;
  ::zera_txn::PublicKey* public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class BlockAttestationResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.BlockAttestationResponse) */ {
 public:
  inline BlockAttestationResponse() : BlockAttestationResponse(nullptr) {};
  virtual ~BlockAttestationResponse();

  BlockAttestationResponse(const BlockAttestationResponse& from);
  BlockAttestationResponse(BlockAttestationResponse&& from) noexcept
    : BlockAttestationResponse() {
    *this = ::std::move(from);
  }

  inline BlockAttestationResponse& operator=(const BlockAttestationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockAttestationResponse& operator=(BlockAttestationResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockAttestationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockAttestationResponse* internal_default_instance() {
    return reinterpret_cast<const BlockAttestationResponse*>(
               &_BlockAttestationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlockAttestationResponse& a, BlockAttestationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockAttestationResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockAttestationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockAttestationResponse* New() const final {
    return CreateMaybeMessage<BlockAttestationResponse>(nullptr);
  }

  BlockAttestationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockAttestationResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockAttestationResponse& from);
  void MergeFrom(const BlockAttestationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockAttestationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.BlockAttestationResponse";
  }
  protected:
  explicit BlockAttestationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorSupportFieldNumber = 4,
    kSignatureFieldNumber = 6,
    kSupportedBlockFieldNumber = 3,
    kPublicKeyFieldNumber = 5,
    kSupportFieldNumber = 1,
    kNoPreferenceFieldNumber = 2,
    kConfirmedFieldNumber = 7,
  };
  // repeated .zera_validator.ValidatorSupport validator_support = 4;
  int validator_support_size() const;
  private:
  int _internal_validator_support_size() const;
  public:
  void clear_validator_support();
  ::zera_validator::ValidatorSupport* mutable_validator_support(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >*
      mutable_validator_support();
  private:
  const ::zera_validator::ValidatorSupport& _internal_validator_support(int index) const;
  ::zera_validator::ValidatorSupport* _internal_add_validator_support();
  public:
  const ::zera_validator::ValidatorSupport& validator_support(int index) const;
  ::zera_validator::ValidatorSupport* add_validator_support();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >&
      validator_support() const;

  // bytes signature = 6;
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_validator.Block supported_block = 3;
  bool has_supported_block() const;
  private:
  bool _internal_has_supported_block() const;
  public:
  void clear_supported_block();
  const ::zera_validator::Block& supported_block() const;
  ::zera_validator::Block* release_supported_block();
  ::zera_validator::Block* mutable_supported_block();
  void set_allocated_supported_block(::zera_validator::Block* supported_block);
  private:
  const ::zera_validator::Block& _internal_supported_block() const;
  ::zera_validator::Block* _internal_mutable_supported_block();
  public:
  void unsafe_arena_set_allocated_supported_block(
      ::zera_validator::Block* supported_block);
  ::zera_validator::Block* unsafe_arena_release_supported_block();

  // .zera_txn.PublicKey public_key = 5;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // bool support = 1;
  void clear_support();
  bool support() const;
  void set_support(bool value);
  private:
  bool _internal_support() const;
  void _internal_set_support(bool value);
  public:

  // bool no_preference = 2;
  void clear_no_preference();
  bool no_preference() const;
  void set_no_preference(bool value);
  private:
  bool _internal_no_preference() const;
  void _internal_set_no_preference(bool value);
  public:

  // bool confirmed = 7;
  void clear_confirmed();
  bool confirmed() const;
  void set_confirmed(bool value);
  private:
  bool _internal_confirmed() const;
  void _internal_set_confirmed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.BlockAttestationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport > validator_support_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::zera_validator::Block* supported_block_;
  ::zera_txn::PublicKey* public_key_;
  bool support_;
  bool no_preference_;
  bool confirmed_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class BlockAttestation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.BlockAttestation) */ {
 public:
  inline BlockAttestation() : BlockAttestation(nullptr) {};
  virtual ~BlockAttestation();

  BlockAttestation(const BlockAttestation& from);
  BlockAttestation(BlockAttestation&& from) noexcept
    : BlockAttestation() {
    *this = ::std::move(from);
  }

  inline BlockAttestation& operator=(const BlockAttestation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockAttestation& operator=(BlockAttestation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockAttestation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockAttestation* internal_default_instance() {
    return reinterpret_cast<const BlockAttestation*>(
               &_BlockAttestation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BlockAttestation& a, BlockAttestation& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockAttestation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockAttestation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockAttestation* New() const final {
    return CreateMaybeMessage<BlockAttestation>(nullptr);
  }

  BlockAttestation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockAttestation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockAttestation& from);
  void MergeFrom(const BlockAttestation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockAttestation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.BlockAttestation";
  }
  protected:
  explicit BlockAttestation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorSupportFieldNumber = 4,
    kBlockHashFieldNumber = 1,
    kPreviousBlockHashFieldNumber = 3,
    kSignatureFieldNumber = 6,
    kPublicKeyFieldNumber = 5,
    kBlockHeightFieldNumber = 2,
    kConfirmedFieldNumber = 7,
  };
  // repeated .zera_validator.ValidatorSupport validator_support = 4;
  int validator_support_size() const;
  private:
  int _internal_validator_support_size() const;
  public:
  void clear_validator_support();
  ::zera_validator::ValidatorSupport* mutable_validator_support(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >*
      mutable_validator_support();
  private:
  const ::zera_validator::ValidatorSupport& _internal_validator_support(int index) const;
  ::zera_validator::ValidatorSupport* _internal_add_validator_support();
  public:
  const ::zera_validator::ValidatorSupport& validator_support(int index) const;
  ::zera_validator::ValidatorSupport* add_validator_support();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >&
      validator_support() const;

  // bytes block_hash = 1;
  void clear_block_hash();
  const std::string& block_hash() const;
  void set_block_hash(const std::string& value);
  void set_block_hash(std::string&& value);
  void set_block_hash(const char* value);
  void set_block_hash(const void* value, size_t size);
  std::string* mutable_block_hash();
  std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_block_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_block_hash(
      std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // bytes previous_block_hash = 3;
  void clear_previous_block_hash();
  const std::string& previous_block_hash() const;
  void set_previous_block_hash(const std::string& value);
  void set_previous_block_hash(std::string&& value);
  void set_previous_block_hash(const char* value);
  void set_previous_block_hash(const void* value, size_t size);
  std::string* mutable_previous_block_hash();
  std::string* release_previous_block_hash();
  void set_allocated_previous_block_hash(std::string* previous_block_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_previous_block_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_previous_block_hash(
      std::string* previous_block_hash);
  private:
  const std::string& _internal_previous_block_hash() const;
  void _internal_set_previous_block_hash(const std::string& value);
  std::string* _internal_mutable_previous_block_hash();
  public:

  // bytes signature = 6;
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_txn.PublicKey public_key = 5;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // uint32 block_height = 2;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool confirmed = 7;
  void clear_confirmed();
  bool confirmed() const;
  void set_confirmed(bool value);
  private:
  bool _internal_confirmed() const;
  void _internal_set_confirmed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.BlockAttestation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport > validator_support_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_block_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::zera_txn::PublicKey* public_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 block_height_;
  bool confirmed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class AttestationLedger_BlockAttestationResponsesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AttestationLedger_BlockAttestationResponsesEntry_DoNotUse, 
    std::string, ::zera_validator::AttestationSupport,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AttestationLedger_BlockAttestationResponsesEntry_DoNotUse, 
    std::string, ::zera_validator::AttestationSupport,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  AttestationLedger_BlockAttestationResponsesEntry_DoNotUse();
  AttestationLedger_BlockAttestationResponsesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AttestationLedger_BlockAttestationResponsesEntry_DoNotUse& other);
  static const AttestationLedger_BlockAttestationResponsesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AttestationLedger_BlockAttestationResponsesEntry_DoNotUse*>(&_AttestationLedger_BlockAttestationResponsesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.AttestationLedger.BlockAttestationResponsesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[8];
  }

  public:
};

// -------------------------------------------------------------------

class AttestationLedger_ValidatorSupportEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AttestationLedger_ValidatorSupportEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AttestationLedger_ValidatorSupportEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  AttestationLedger_ValidatorSupportEntry_DoNotUse();
  AttestationLedger_ValidatorSupportEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AttestationLedger_ValidatorSupportEntry_DoNotUse& other);
  static const AttestationLedger_ValidatorSupportEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AttestationLedger_ValidatorSupportEntry_DoNotUse*>(&_AttestationLedger_ValidatorSupportEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.AttestationLedger.ValidatorSupportEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.AttestationLedger.ValidatorSupportEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[9];
  }

  public:
};

// -------------------------------------------------------------------

class AttestationLedger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.AttestationLedger) */ {
 public:
  inline AttestationLedger() : AttestationLedger(nullptr) {};
  virtual ~AttestationLedger();

  AttestationLedger(const AttestationLedger& from);
  AttestationLedger(AttestationLedger&& from) noexcept
    : AttestationLedger() {
    *this = ::std::move(from);
  }

  inline AttestationLedger& operator=(const AttestationLedger& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttestationLedger& operator=(AttestationLedger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AttestationLedger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttestationLedger* internal_default_instance() {
    return reinterpret_cast<const AttestationLedger*>(
               &_AttestationLedger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AttestationLedger& a, AttestationLedger& b) {
    a.Swap(&b);
  }
  inline void Swap(AttestationLedger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttestationLedger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AttestationLedger* New() const final {
    return CreateMaybeMessage<AttestationLedger>(nullptr);
  }

  AttestationLedger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AttestationLedger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AttestationLedger& from);
  void MergeFrom(const AttestationLedger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttestationLedger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.AttestationLedger";
  }
  protected:
  explicit AttestationLedger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBlockAttestationResponsesFieldNumber = 1,
    kValidatorSupportFieldNumber = 2,
  };
  // map<string, .zera_validator.AttestationSupport> block_attestation_responses = 1;
  int block_attestation_responses_size() const;
  private:
  int _internal_block_attestation_responses_size() const;
  public:
  void clear_block_attestation_responses();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::AttestationSupport >&
      _internal_block_attestation_responses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::AttestationSupport >*
      _internal_mutable_block_attestation_responses();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::AttestationSupport >&
      block_attestation_responses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::AttestationSupport >*
      mutable_block_attestation_responses();

  // map<string, string> validator_support = 2;
  int validator_support_size() const;
  private:
  int _internal_validator_support_size() const;
  public:
  void clear_validator_support();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_validator_support() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_validator_support();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      validator_support() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_validator_support();

  // @@protoc_insertion_point(class_scope:zera_validator.AttestationLedger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AttestationLedger_BlockAttestationResponsesEntry_DoNotUse,
      std::string, ::zera_validator::AttestationSupport,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > block_attestation_responses_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AttestationLedger_ValidatorSupportEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > validator_support_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class AttestationSupport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.AttestationSupport) */ {
 public:
  inline AttestationSupport() : AttestationSupport(nullptr) {};
  virtual ~AttestationSupport();

  AttestationSupport(const AttestationSupport& from);
  AttestationSupport(AttestationSupport&& from) noexcept
    : AttestationSupport() {
    *this = ::std::move(from);
  }

  inline AttestationSupport& operator=(const AttestationSupport& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttestationSupport& operator=(AttestationSupport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AttestationSupport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttestationSupport* internal_default_instance() {
    return reinterpret_cast<const AttestationSupport*>(
               &_AttestationSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AttestationSupport& a, AttestationSupport& b) {
    a.Swap(&b);
  }
  inline void Swap(AttestationSupport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttestationSupport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AttestationSupport* New() const final {
    return CreateMaybeMessage<AttestationSupport>(nullptr);
  }

  AttestationSupport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AttestationSupport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AttestationSupport& from);
  void MergeFrom(const AttestationSupport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttestationSupport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.AttestationSupport";
  }
  protected:
  explicit AttestationSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorSupportFieldNumber = 1,
    kSupportedBlockFieldNumber = 2,
  };
  // repeated .zera_validator.ValidatorSupport validator_support = 1;
  int validator_support_size() const;
  private:
  int _internal_validator_support_size() const;
  public:
  void clear_validator_support();
  ::zera_validator::ValidatorSupport* mutable_validator_support(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >*
      mutable_validator_support();
  private:
  const ::zera_validator::ValidatorSupport& _internal_validator_support(int index) const;
  ::zera_validator::ValidatorSupport* _internal_add_validator_support();
  public:
  const ::zera_validator::ValidatorSupport& validator_support(int index) const;
  ::zera_validator::ValidatorSupport* add_validator_support();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >&
      validator_support() const;

  // .zera_validator.Block supported_block = 2;
  bool has_supported_block() const;
  private:
  bool _internal_has_supported_block() const;
  public:
  void clear_supported_block();
  const ::zera_validator::Block& supported_block() const;
  ::zera_validator::Block* release_supported_block();
  ::zera_validator::Block* mutable_supported_block();
  void set_allocated_supported_block(::zera_validator::Block* supported_block);
  private:
  const ::zera_validator::Block& _internal_supported_block() const;
  ::zera_validator::Block* _internal_mutable_supported_block();
  public:
  void unsafe_arena_set_allocated_supported_block(
      ::zera_validator::Block* supported_block);
  ::zera_validator::Block* unsafe_arena_release_supported_block();

  // @@protoc_insertion_point(class_scope:zera_validator.AttestationSupport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport > validator_support_;
  ::zera_validator::Block* supported_block_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ValidatorSupport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ValidatorSupport) */ {
 public:
  inline ValidatorSupport() : ValidatorSupport(nullptr) {};
  virtual ~ValidatorSupport();

  ValidatorSupport(const ValidatorSupport& from);
  ValidatorSupport(ValidatorSupport&& from) noexcept
    : ValidatorSupport() {
    *this = ::std::move(from);
  }

  inline ValidatorSupport& operator=(const ValidatorSupport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorSupport& operator=(ValidatorSupport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorSupport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorSupport* internal_default_instance() {
    return reinterpret_cast<const ValidatorSupport*>(
               &_ValidatorSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ValidatorSupport& a, ValidatorSupport& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorSupport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorSupport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidatorSupport* New() const final {
    return CreateMaybeMessage<ValidatorSupport>(nullptr);
  }

  ValidatorSupport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorSupport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorSupport& from);
  void MergeFrom(const ValidatorSupport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorSupport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ValidatorSupport";
  }
  protected:
  explicit ValidatorSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 2,
    kPublicKeyFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // bytes signature = 2;
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:zera_validator.ValidatorSupport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::zera_txn::PublicKey* public_key_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class NonceRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.NonceRequest) */ {
 public:
  inline NonceRequest() : NonceRequest(nullptr) {};
  virtual ~NonceRequest();

  NonceRequest(const NonceRequest& from);
  NonceRequest(NonceRequest&& from) noexcept
    : NonceRequest() {
    *this = ::std::move(from);
  }

  inline NonceRequest& operator=(const NonceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NonceRequest& operator=(NonceRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NonceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NonceRequest* internal_default_instance() {
    return reinterpret_cast<const NonceRequest*>(
               &_NonceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NonceRequest& a, NonceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NonceRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NonceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NonceRequest* New() const final {
    return CreateMaybeMessage<NonceRequest>(nullptr);
  }

  NonceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NonceRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NonceRequest& from);
  void MergeFrom(const NonceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NonceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.NonceRequest";
  }
  protected:
  explicit NonceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletAddressFieldNumber = 1,
  };
  // bytes wallet_address = 1;
  void clear_wallet_address();
  const std::string& wallet_address() const;
  void set_wallet_address(const std::string& value);
  void set_wallet_address(std::string&& value);
  void set_wallet_address(const char* value);
  void set_wallet_address(const void* value, size_t size);
  std::string* mutable_wallet_address();
  std::string* release_wallet_address();
  void set_allocated_wallet_address(std::string* wallet_address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_wallet_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_wallet_address(
      std::string* wallet_address);
  private:
  const std::string& _internal_wallet_address() const;
  void _internal_set_wallet_address(const std::string& value);
  std::string* _internal_mutable_wallet_address();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.NonceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class NonceResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.NonceResponse) */ {
 public:
  inline NonceResponse() : NonceResponse(nullptr) {};
  virtual ~NonceResponse();

  NonceResponse(const NonceResponse& from);
  NonceResponse(NonceResponse&& from) noexcept
    : NonceResponse() {
    *this = ::std::move(from);
  }

  inline NonceResponse& operator=(const NonceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NonceResponse& operator=(NonceResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NonceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NonceResponse* internal_default_instance() {
    return reinterpret_cast<const NonceResponse*>(
               &_NonceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NonceResponse& a, NonceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NonceResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NonceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NonceResponse* New() const final {
    return CreateMaybeMessage<NonceResponse>(nullptr);
  }

  NonceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NonceResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NonceResponse& from);
  void MergeFrom(const NonceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NonceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.NonceResponse";
  }
  protected:
  explicit NonceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint64 nonce = 1;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.NonceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class DataChunk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.DataChunk) */ {
 public:
  inline DataChunk() : DataChunk(nullptr) {};
  virtual ~DataChunk();

  DataChunk(const DataChunk& from);
  DataChunk(DataChunk&& from) noexcept
    : DataChunk() {
    *this = ::std::move(from);
  }

  inline DataChunk& operator=(const DataChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChunk& operator=(DataChunk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataChunk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataChunk* internal_default_instance() {
    return reinterpret_cast<const DataChunk*>(
               &_DataChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DataChunk& a, DataChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChunk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataChunk* New() const final {
    return CreateMaybeMessage<DataChunk>(nullptr);
  }

  DataChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataChunk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataChunk& from);
  void MergeFrom(const DataChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.DataChunk";
  }
  protected:
  explicit DataChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkDataFieldNumber = 1,
    kChunkNumberFieldNumber = 2,
    kTotalChunksFieldNumber = 3,
  };
  // bytes chunk_data = 1;
  void clear_chunk_data();
  const std::string& chunk_data() const;
  void set_chunk_data(const std::string& value);
  void set_chunk_data(std::string&& value);
  void set_chunk_data(const char* value);
  void set_chunk_data(const void* value, size_t size);
  std::string* mutable_chunk_data();
  std::string* release_chunk_data();
  void set_allocated_chunk_data(std::string* chunk_data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_chunk_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_chunk_data(
      std::string* chunk_data);
  private:
  const std::string& _internal_chunk_data() const;
  void _internal_set_chunk_data(const std::string& value);
  std::string* _internal_mutable_chunk_data();
  public:

  // int32 chunk_number = 2;
  void clear_chunk_number();
  ::PROTOBUF_NAMESPACE_ID::int32 chunk_number() const;
  void set_chunk_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_chunk_number() const;
  void _internal_set_chunk_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 total_chunks = 3;
  bool has_total_chunks() const;
  private:
  bool _internal_has_total_chunks() const;
  public:
  void clear_total_chunks();
  ::PROTOBUF_NAMESPACE_ID::int32 total_chunks() const;
  void set_total_chunks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_total_chunks() const;
  void _internal_set_total_chunks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.DataChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_data_;
  ::PROTOBUF_NAMESPACE_ID::int32 chunk_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_chunks_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ValidatorSyncRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ValidatorSyncRequest) */ {
 public:
  inline ValidatorSyncRequest() : ValidatorSyncRequest(nullptr) {};
  virtual ~ValidatorSyncRequest();

  ValidatorSyncRequest(const ValidatorSyncRequest& from);
  ValidatorSyncRequest(ValidatorSyncRequest&& from) noexcept
    : ValidatorSyncRequest() {
    *this = ::std::move(from);
  }

  inline ValidatorSyncRequest& operator=(const ValidatorSyncRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorSyncRequest& operator=(ValidatorSyncRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorSyncRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorSyncRequest* internal_default_instance() {
    return reinterpret_cast<const ValidatorSyncRequest*>(
               &_ValidatorSyncRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ValidatorSyncRequest& a, ValidatorSyncRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorSyncRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorSyncRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidatorSyncRequest* New() const final {
    return CreateMaybeMessage<ValidatorSyncRequest>(nullptr);
  }

  ValidatorSyncRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorSyncRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorSyncRequest& from);
  void MergeFrom(const ValidatorSyncRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorSyncRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ValidatorSyncRequest";
  }
  protected:
  explicit ValidatorSyncRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 2,
    kPublicKeyFieldNumber = 1,
  };
  // bytes signature = 2;
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // @@protoc_insertion_point(class_scope:zera_validator.ValidatorSyncRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::zera_txn::PublicKey* public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ValidatorSync PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ValidatorSync) */ {
 public:
  inline ValidatorSync() : ValidatorSync(nullptr) {};
  virtual ~ValidatorSync();

  ValidatorSync(const ValidatorSync& from);
  ValidatorSync(ValidatorSync&& from) noexcept
    : ValidatorSync() {
    *this = ::std::move(from);
  }

  inline ValidatorSync& operator=(const ValidatorSync& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorSync& operator=(ValidatorSync&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorSync& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorSync* internal_default_instance() {
    return reinterpret_cast<const ValidatorSync*>(
               &_ValidatorSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ValidatorSync& a, ValidatorSync& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorSync* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorSync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidatorSync* New() const final {
    return CreateMaybeMessage<ValidatorSync>(nullptr);
  }

  ValidatorSync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorSync>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorSync& from);
  void MergeFrom(const ValidatorSync& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorSync* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ValidatorSync";
  }
  protected:
  explicit ValidatorSync(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorsFieldNumber = 1,
    kSignatureFieldNumber = 2,
    kPublicKeyFieldNumber = 3,
  };
  // repeated .zera_txn.Validator validators = 1;
  int validators_size() const;
  private:
  int _internal_validators_size() const;
  public:
  void clear_validators();
  ::zera_txn::Validator* mutable_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Validator >*
      mutable_validators();
  private:
  const ::zera_txn::Validator& _internal_validators(int index) const;
  ::zera_txn::Validator* _internal_add_validators();
  public:
  const ::zera_txn::Validator& validators(int index) const;
  ::zera_txn::Validator* add_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Validator >&
      validators() const;

  // bytes signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_txn.PublicKey public_key = 3;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // @@protoc_insertion_point(class_scope:zera_validator.ValidatorSync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Validator > validators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::zera_txn::PublicKey* public_key_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class BlockSync PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.BlockSync) */ {
 public:
  inline BlockSync() : BlockSync(nullptr) {};
  virtual ~BlockSync();

  BlockSync(const BlockSync& from);
  BlockSync(BlockSync&& from) noexcept
    : BlockSync() {
    *this = ::std::move(from);
  }

  inline BlockSync& operator=(const BlockSync& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockSync& operator=(BlockSync&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockSync& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockSync* internal_default_instance() {
    return reinterpret_cast<const BlockSync*>(
               &_BlockSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BlockSync& a, BlockSync& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockSync* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockSync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockSync* New() const final {
    return CreateMaybeMessage<BlockSync>(nullptr);
  }

  BlockSync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockSync>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockSync& from);
  void MergeFrom(const BlockSync& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockSync* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.BlockSync";
  }
  protected:
  explicit BlockSync(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastKeyFieldNumber = 1,
    kSignatureFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
    kAmountFieldNumber = 2,
  };
  // bytes last_key = 1;
  void clear_last_key();
  const std::string& last_key() const;
  void set_last_key(const std::string& value);
  void set_last_key(std::string&& value);
  void set_last_key(const char* value);
  void set_last_key(const void* value, size_t size);
  std::string* mutable_last_key();
  std::string* release_last_key();
  void set_allocated_last_key(std::string* last_key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_last_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_last_key(
      std::string* last_key);
  private:
  const std::string& _internal_last_key() const;
  void _internal_set_last_key(const std::string& value);
  std::string* _internal_mutable_last_key();
  public:

  // bytes signature = 3;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_txn.PublicKey public_key = 4;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // uint64 amount = 2;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::uint64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.BlockSync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::zera_txn::PublicKey* public_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 amount_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.BlockHeader) */ {
 public:
  inline BlockHeader() : BlockHeader(nullptr) {};
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const final {
    return CreateMaybeMessage<BlockHeader>(nullptr);
  }

  BlockHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.BlockHeader";
  }
  protected:
  explicit BlockHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreviousBlockHashFieldNumber = 2,
    kHashFieldNumber = 3,
    kFeeAddressFieldNumber = 7,
    kSignatureFieldNumber = 8,
    kMerkleRootFieldNumber = 9,
    kTimestampFieldNumber = 4,
    kPublicKeyFieldNumber = 10,
    kVersionFieldNumber = 1,
    kNonceFieldNumber = 5,
    kBlockHeightFieldNumber = 6,
  };
  // bytes previous_block_hash = 2;
  bool has_previous_block_hash() const;
  private:
  bool _internal_has_previous_block_hash() const;
  public:
  void clear_previous_block_hash();
  const std::string& previous_block_hash() const;
  void set_previous_block_hash(const std::string& value);
  void set_previous_block_hash(std::string&& value);
  void set_previous_block_hash(const char* value);
  void set_previous_block_hash(const void* value, size_t size);
  std::string* mutable_previous_block_hash();
  std::string* release_previous_block_hash();
  void set_allocated_previous_block_hash(std::string* previous_block_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_previous_block_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_previous_block_hash(
      std::string* previous_block_hash);
  private:
  const std::string& _internal_previous_block_hash() const;
  void _internal_set_previous_block_hash(const std::string& value);
  std::string* _internal_mutable_previous_block_hash();
  public:

  // bytes hash = 3;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hash(
      std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // bytes fee_address = 7;
  void clear_fee_address();
  const std::string& fee_address() const;
  void set_fee_address(const std::string& value);
  void set_fee_address(std::string&& value);
  void set_fee_address(const char* value);
  void set_fee_address(const void* value, size_t size);
  std::string* mutable_fee_address();
  std::string* release_fee_address();
  void set_allocated_fee_address(std::string* fee_address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_fee_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_fee_address(
      std::string* fee_address);
  private:
  const std::string& _internal_fee_address() const;
  void _internal_set_fee_address(const std::string& value);
  std::string* _internal_mutable_fee_address();
  public:

  // bytes signature = 8;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes merkle_root = 9;
  bool has_merkle_root() const;
  private:
  bool _internal_has_merkle_root() const;
  public:
  void clear_merkle_root();
  const std::string& merkle_root() const;
  void set_merkle_root(const std::string& value);
  void set_merkle_root(std::string&& value);
  void set_merkle_root(const char* value);
  void set_merkle_root(const void* value, size_t size);
  std::string* mutable_merkle_root();
  std::string* release_merkle_root();
  void set_allocated_merkle_root(std::string* merkle_root);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_merkle_root();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_merkle_root(
      std::string* merkle_root);
  private:
  const std::string& _internal_merkle_root() const;
  void _internal_set_merkle_root(const std::string& value);
  std::string* _internal_mutable_merkle_root();
  public:

  // .google.protobuf.Timestamp timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .zera_txn.PublicKey public_key = 10;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // uint64 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 nonce = 5;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 block_height = 6;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.BlockHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_block_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merkle_root_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::zera_txn::PublicKey* public_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 version_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Block PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Block) */ {
 public:
  inline Block() : Block(nullptr) {};
  virtual ~Block();

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(nullptr);
  }

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Block";
  }
  protected:
  explicit Block(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlashedValidatorsFieldNumber = 6,
    kSignatureFieldNumber = 4,
    kBlockHeaderFieldNumber = 1,
    kTransactionsFieldNumber = 2,
    kPublicKeyFieldNumber = 5,
  };
  // repeated .zera_validator.SlashedValidator slashed_validators = 6;
  int slashed_validators_size() const;
  private:
  int _internal_slashed_validators_size() const;
  public:
  void clear_slashed_validators();
  ::zera_validator::SlashedValidator* mutable_slashed_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedValidator >*
      mutable_slashed_validators();
  private:
  const ::zera_validator::SlashedValidator& _internal_slashed_validators(int index) const;
  ::zera_validator::SlashedValidator* _internal_add_slashed_validators();
  public:
  const ::zera_validator::SlashedValidator& slashed_validators(int index) const;
  ::zera_validator::SlashedValidator* add_slashed_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedValidator >&
      slashed_validators() const;

  // bytes signature = 4;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_validator.BlockHeader block_header = 1;
  bool has_block_header() const;
  private:
  bool _internal_has_block_header() const;
  public:
  void clear_block_header();
  const ::zera_validator::BlockHeader& block_header() const;
  ::zera_validator::BlockHeader* release_block_header();
  ::zera_validator::BlockHeader* mutable_block_header();
  void set_allocated_block_header(::zera_validator::BlockHeader* block_header);
  private:
  const ::zera_validator::BlockHeader& _internal_block_header() const;
  ::zera_validator::BlockHeader* _internal_mutable_block_header();
  public:
  void unsafe_arena_set_allocated_block_header(
      ::zera_validator::BlockHeader* block_header);
  ::zera_validator::BlockHeader* unsafe_arena_release_block_header();

  // .zera_txn.TXNS transactions = 2;
  bool has_transactions() const;
  private:
  bool _internal_has_transactions() const;
  public:
  void clear_transactions();
  const ::zera_txn::TXNS& transactions() const;
  ::zera_txn::TXNS* release_transactions();
  ::zera_txn::TXNS* mutable_transactions();
  void set_allocated_transactions(::zera_txn::TXNS* transactions);
  private:
  const ::zera_txn::TXNS& _internal_transactions() const;
  ::zera_txn::TXNS* _internal_mutable_transactions();
  public:
  void unsafe_arena_set_allocated_transactions(
      ::zera_txn::TXNS* transactions);
  ::zera_txn::TXNS* unsafe_arena_release_transactions();

  // .zera_txn.PublicKey public_key = 5;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // @@protoc_insertion_point(class_scope:zera_validator.Block)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedValidator > slashed_validators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::zera_validator::BlockHeader* block_header_;
  ::zera_txn::TXNS* transactions_;
  ::zera_txn::PublicKey* public_key_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class SlashedValidator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.SlashedValidator) */ {
 public:
  inline SlashedValidator() : SlashedValidator(nullptr) {};
  virtual ~SlashedValidator();

  SlashedValidator(const SlashedValidator& from);
  SlashedValidator(SlashedValidator&& from) noexcept
    : SlashedValidator() {
    *this = ::std::move(from);
  }

  inline SlashedValidator& operator=(const SlashedValidator& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlashedValidator& operator=(SlashedValidator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SlashedValidator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SlashedValidator* internal_default_instance() {
    return reinterpret_cast<const SlashedValidator*>(
               &_SlashedValidator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SlashedValidator& a, SlashedValidator& b) {
    a.Swap(&b);
  }
  inline void Swap(SlashedValidator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlashedValidator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SlashedValidator* New() const final {
    return CreateMaybeMessage<SlashedValidator>(nullptr);
  }

  SlashedValidator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SlashedValidator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SlashedValidator& from);
  void MergeFrom(const SlashedValidator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SlashedValidator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.SlashedValidator";
  }
  protected:
  explicit SlashedValidator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlashedTokensFieldNumber = 3,
    kSlashedBlockHashFieldNumber = 2,
    kPublicKeyFieldNumber = 1,
  };
  // repeated .zera_validator.SlashedToken slashed_tokens = 3;
  int slashed_tokens_size() const;
  private:
  int _internal_slashed_tokens_size() const;
  public:
  void clear_slashed_tokens();
  ::zera_validator::SlashedToken* mutable_slashed_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedToken >*
      mutable_slashed_tokens();
  private:
  const ::zera_validator::SlashedToken& _internal_slashed_tokens(int index) const;
  ::zera_validator::SlashedToken* _internal_add_slashed_tokens();
  public:
  const ::zera_validator::SlashedToken& slashed_tokens(int index) const;
  ::zera_validator::SlashedToken* add_slashed_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedToken >&
      slashed_tokens() const;

  // bytes slashed_block_hash = 2;
  void clear_slashed_block_hash();
  const std::string& slashed_block_hash() const;
  void set_slashed_block_hash(const std::string& value);
  void set_slashed_block_hash(std::string&& value);
  void set_slashed_block_hash(const char* value);
  void set_slashed_block_hash(const void* value, size_t size);
  std::string* mutable_slashed_block_hash();
  std::string* release_slashed_block_hash();
  void set_allocated_slashed_block_hash(std::string* slashed_block_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_slashed_block_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_slashed_block_hash(
      std::string* slashed_block_hash);
  private:
  const std::string& _internal_slashed_block_hash() const;
  void _internal_set_slashed_block_hash(const std::string& value);
  std::string* _internal_mutable_slashed_block_hash();
  public:

  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // @@protoc_insertion_point(class_scope:zera_validator.SlashedValidator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedToken > slashed_tokens_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slashed_block_hash_;
  ::zera_txn::PublicKey* public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class SlashedRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.SlashedRequest) */ {
 public:
  inline SlashedRequest() : SlashedRequest(nullptr) {};
  virtual ~SlashedRequest();

  SlashedRequest(const SlashedRequest& from);
  SlashedRequest(SlashedRequest&& from) noexcept
    : SlashedRequest() {
    *this = ::std::move(from);
  }

  inline SlashedRequest& operator=(const SlashedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlashedRequest& operator=(SlashedRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SlashedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SlashedRequest* internal_default_instance() {
    return reinterpret_cast<const SlashedRequest*>(
               &_SlashedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SlashedRequest& a, SlashedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SlashedRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlashedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SlashedRequest* New() const final {
    return CreateMaybeMessage<SlashedRequest>(nullptr);
  }

  SlashedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SlashedRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SlashedRequest& from);
  void MergeFrom(const SlashedRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SlashedRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.SlashedRequest";
  }
  protected:
  explicit SlashedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlashedBlockHashFieldNumber = 1,
  };
  // bytes slashed_block_hash = 1;
  void clear_slashed_block_hash();
  const std::string& slashed_block_hash() const;
  void set_slashed_block_hash(const std::string& value);
  void set_slashed_block_hash(std::string&& value);
  void set_slashed_block_hash(const char* value);
  void set_slashed_block_hash(const void* value, size_t size);
  std::string* mutable_slashed_block_hash();
  std::string* release_slashed_block_hash();
  void set_allocated_slashed_block_hash(std::string* slashed_block_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_slashed_block_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_slashed_block_hash(
      std::string* slashed_block_hash);
  private:
  const std::string& _internal_slashed_block_hash() const;
  void _internal_set_slashed_block_hash(const std::string& value);
  std::string* _internal_mutable_slashed_block_hash();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.SlashedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slashed_block_hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class SlashedToken PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.SlashedToken) */ {
 public:
  inline SlashedToken() : SlashedToken(nullptr) {};
  virtual ~SlashedToken();

  SlashedToken(const SlashedToken& from);
  SlashedToken(SlashedToken&& from) noexcept
    : SlashedToken() {
    *this = ::std::move(from);
  }

  inline SlashedToken& operator=(const SlashedToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlashedToken& operator=(SlashedToken&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SlashedToken& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SlashedToken* internal_default_instance() {
    return reinterpret_cast<const SlashedToken*>(
               &_SlashedToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SlashedToken& a, SlashedToken& b) {
    a.Swap(&b);
  }
  inline void Swap(SlashedToken* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlashedToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SlashedToken* New() const final {
    return CreateMaybeMessage<SlashedToken>(nullptr);
  }

  SlashedToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SlashedToken>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SlashedToken& from);
  void MergeFrom(const SlashedToken& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SlashedToken* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.SlashedToken";
  }
  protected:
  explicit SlashedToken(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  void set_contract_id(const std::string& value);
  void set_contract_id(std::string&& value);
  void set_contract_id(const char* value);
  void set_contract_id(const char* value, size_t size);
  std::string* mutable_contract_id();
  std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_contract_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_contract_id(
      std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  void set_amount(const std::string& value);
  void set_amount(std::string&& value);
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  std::string* mutable_amount();
  std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_amount();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_amount(
      std::string* amount);
  private:
  const std::string& _internal_amount() const;
  void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.SlashedToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class BlockBatch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.BlockBatch) */ {
 public:
  inline BlockBatch() : BlockBatch(nullptr) {};
  virtual ~BlockBatch();

  BlockBatch(const BlockBatch& from);
  BlockBatch(BlockBatch&& from) noexcept
    : BlockBatch() {
    *this = ::std::move(from);
  }

  inline BlockBatch& operator=(const BlockBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBatch& operator=(BlockBatch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockBatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockBatch* internal_default_instance() {
    return reinterpret_cast<const BlockBatch*>(
               &_BlockBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BlockBatch& a, BlockBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBatch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockBatch* New() const final {
    return CreateMaybeMessage<BlockBatch>(nullptr);
  }

  BlockBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockBatch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockBatch& from);
  void MergeFrom(const BlockBatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.BlockBatch";
  }
  protected:
  explicit BlockBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
    kSignatureFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
    kLastBlockFieldNumber = 2,
  };
  // repeated .zera_validator.Block blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::zera_validator::Block* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Block >*
      mutable_blocks();
  private:
  const ::zera_validator::Block& _internal_blocks(int index) const;
  ::zera_validator::Block* _internal_add_blocks();
  public:
  const ::zera_validator::Block& blocks(int index) const;
  ::zera_validator::Block* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Block >&
      blocks() const;

  // bytes signature = 3;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .zera_txn.PublicKey public_key = 4;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // bool last_block = 2;
  void clear_last_block();
  bool last_block() const;
  void set_last_block(bool value);
  private:
  bool _internal_last_block() const;
  void _internal_set_last_block(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.BlockBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Block > blocks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::zera_txn::PublicKey* public_key_;
  bool last_block_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class NFT PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.NFT) */ {
 public:
  inline NFT() : NFT(nullptr) {};
  virtual ~NFT();

  NFT(const NFT& from);
  NFT(NFT&& from) noexcept
    : NFT() {
    *this = ::std::move(from);
  }

  inline NFT& operator=(const NFT& from) {
    CopyFrom(from);
    return *this;
  }
  inline NFT& operator=(NFT&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NFT& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NFT* internal_default_instance() {
    return reinterpret_cast<const NFT*>(
               &_NFT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(NFT& a, NFT& b) {
    a.Swap(&b);
  }
  inline void Swap(NFT* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NFT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NFT* New() const final {
    return CreateMaybeMessage<NFT>(nullptr);
  }

  NFT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NFT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NFT& from);
  void MergeFrom(const NFT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NFT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.NFT";
  }
  protected:
  explicit NFT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHolderAddressFieldNumber = 1,
    kContractIdFieldNumber = 2,
    kItemIdFieldNumber = 3,
    kVotingWeightFieldNumber = 4,
    kContractFeesFieldNumber = 5,
  };
  // bytes holder_address = 1;
  void clear_holder_address();
  const std::string& holder_address() const;
  void set_holder_address(const std::string& value);
  void set_holder_address(std::string&& value);
  void set_holder_address(const char* value);
  void set_holder_address(const void* value, size_t size);
  std::string* mutable_holder_address();
  std::string* release_holder_address();
  void set_allocated_holder_address(std::string* holder_address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_holder_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_holder_address(
      std::string* holder_address);
  private:
  const std::string& _internal_holder_address() const;
  void _internal_set_holder_address(const std::string& value);
  std::string* _internal_mutable_holder_address();
  public:

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  void set_contract_id(const std::string& value);
  void set_contract_id(std::string&& value);
  void set_contract_id(const char* value);
  void set_contract_id(const char* value, size_t size);
  std::string* mutable_contract_id();
  std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_contract_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_contract_id(
      std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string item_id = 3;
  void clear_item_id();
  const std::string& item_id() const;
  void set_item_id(const std::string& value);
  void set_item_id(std::string&& value);
  void set_item_id(const char* value);
  void set_item_id(const char* value, size_t size);
  std::string* mutable_item_id();
  std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_item_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_item_id(
      std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // string voting_weight = 4;
  bool has_voting_weight() const;
  private:
  bool _internal_has_voting_weight() const;
  public:
  void clear_voting_weight();
  const std::string& voting_weight() const;
  void set_voting_weight(const std::string& value);
  void set_voting_weight(std::string&& value);
  void set_voting_weight(const char* value);
  void set_voting_weight(const char* value, size_t size);
  std::string* mutable_voting_weight();
  std::string* release_voting_weight();
  void set_allocated_voting_weight(std::string* voting_weight);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_voting_weight();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_voting_weight(
      std::string* voting_weight);
  private:
  const std::string& _internal_voting_weight() const;
  void _internal_set_voting_weight(const std::string& value);
  std::string* _internal_mutable_voting_weight();
  public:

  // .zera_txn.ItemContractFees contract_fees = 5;
  bool has_contract_fees() const;
  private:
  bool _internal_has_contract_fees() const;
  public:
  void clear_contract_fees();
  const ::zera_txn::ItemContractFees& contract_fees() const;
  ::zera_txn::ItemContractFees* release_contract_fees();
  ::zera_txn::ItemContractFees* mutable_contract_fees();
  void set_allocated_contract_fees(::zera_txn::ItemContractFees* contract_fees);
  private:
  const ::zera_txn::ItemContractFees& _internal_contract_fees() const;
  ::zera_txn::ItemContractFees* _internal_mutable_contract_fees();
  public:
  void unsafe_arena_set_allocated_contract_fees(
      ::zera_txn::ItemContractFees* contract_fees);
  ::zera_txn::ItemContractFees* unsafe_arena_release_contract_fees();

  // @@protoc_insertion_point(class_scope:zera_validator.NFT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr holder_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voting_weight_;
  ::zera_txn::ItemContractFees* contract_fees_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Item PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Item) */ {
 public:
  inline Item() : Item(nullptr) {};
  virtual ~Item();

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Item* New() const final {
    return CreateMaybeMessage<Item>(nullptr);
  }

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Item";
  }
  protected:
  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kItemIdFieldNumber = 2,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  void set_contract_id(const std::string& value);
  void set_contract_id(std::string&& value);
  void set_contract_id(const char* value);
  void set_contract_id(const char* value, size_t size);
  std::string* mutable_contract_id();
  std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_contract_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_contract_id(
      std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string item_id = 2;
  void clear_item_id();
  const std::string& item_id() const;
  void set_item_id(const std::string& value);
  void set_item_id(std::string&& value);
  void set_item_id(const char* value);
  void set_item_id(const char* value, size_t size);
  std::string* mutable_item_id();
  std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_item_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_item_id(
      std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class WalletItems PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.WalletItems) */ {
 public:
  inline WalletItems() : WalletItems(nullptr) {};
  virtual ~WalletItems();

  WalletItems(const WalletItems& from);
  WalletItems(WalletItems&& from) noexcept
    : WalletItems() {
    *this = ::std::move(from);
  }

  inline WalletItems& operator=(const WalletItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalletItems& operator=(WalletItems&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WalletItems& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WalletItems* internal_default_instance() {
    return reinterpret_cast<const WalletItems*>(
               &_WalletItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(WalletItems& a, WalletItems& b) {
    a.Swap(&b);
  }
  inline void Swap(WalletItems* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalletItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WalletItems* New() const final {
    return CreateMaybeMessage<WalletItems>(nullptr);
  }

  WalletItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WalletItems>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WalletItems& from);
  void MergeFrom(const WalletItems& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalletItems* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.WalletItems";
  }
  protected:
  explicit WalletItems(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .zera_validator.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::zera_validator::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Item >*
      mutable_items();
  private:
  const ::zera_validator::Item& _internal_items(int index) const;
  ::zera_validator::Item* _internal_add_items();
  public:
  const ::zera_validator::Item& items(int index) const;
  ::zera_validator::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:zera_validator.WalletItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Item > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ProcessLedger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ProcessLedger) */ {
 public:
  inline ProcessLedger() : ProcessLedger(nullptr) {};
  virtual ~ProcessLedger();

  ProcessLedger(const ProcessLedger& from);
  ProcessLedger(ProcessLedger&& from) noexcept
    : ProcessLedger() {
    *this = ::std::move(from);
  }

  inline ProcessLedger& operator=(const ProcessLedger& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessLedger& operator=(ProcessLedger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcessLedger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessLedger* internal_default_instance() {
    return reinterpret_cast<const ProcessLedger*>(
               &_ProcessLedger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ProcessLedger& a, ProcessLedger& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessLedger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessLedger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessLedger* New() const final {
    return CreateMaybeMessage<ProcessLedger>(nullptr);
  }

  ProcessLedger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessLedger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcessLedger& from);
  void MergeFrom(const ProcessLedger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessLedger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ProcessLedger";
  }
  protected:
  explicit ProcessLedger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCycleContractIdsFieldNumber = 1,
    kProposalIdsFieldNumber = 2,
  };
  // repeated bytes cycle_contract_ids = 1;
  int cycle_contract_ids_size() const;
  private:
  int _internal_cycle_contract_ids_size() const;
  public:
  void clear_cycle_contract_ids();
  const std::string& cycle_contract_ids(int index) const;
  std::string* mutable_cycle_contract_ids(int index);
  void set_cycle_contract_ids(int index, const std::string& value);
  void set_cycle_contract_ids(int index, std::string&& value);
  void set_cycle_contract_ids(int index, const char* value);
  void set_cycle_contract_ids(int index, const void* value, size_t size);
  std::string* add_cycle_contract_ids();
  void add_cycle_contract_ids(const std::string& value);
  void add_cycle_contract_ids(std::string&& value);
  void add_cycle_contract_ids(const char* value);
  void add_cycle_contract_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cycle_contract_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cycle_contract_ids();
  private:
  const std::string& _internal_cycle_contract_ids(int index) const;
  std::string* _internal_add_cycle_contract_ids();
  public:

  // repeated bytes proposal_ids = 2;
  int proposal_ids_size() const;
  private:
  int _internal_proposal_ids_size() const;
  public:
  void clear_proposal_ids();
  const std::string& proposal_ids(int index) const;
  std::string* mutable_proposal_ids(int index);
  void set_proposal_ids(int index, const std::string& value);
  void set_proposal_ids(int index, std::string&& value);
  void set_proposal_ids(int index, const char* value);
  void set_proposal_ids(int index, const void* value, size_t size);
  std::string* add_proposal_ids();
  void add_proposal_ids(const std::string& value);
  void add_proposal_ids(std::string&& value);
  void add_proposal_ids(const char* value);
  void add_proposal_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proposal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proposal_ids();
  private:
  const std::string& _internal_proposal_ids(int index) const;
  std::string* _internal_add_proposal_ids();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.ProcessLedger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cycle_contract_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proposal_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ProposalLedger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ProposalLedger) */ {
 public:
  inline ProposalLedger() : ProposalLedger(nullptr) {};
  virtual ~ProposalLedger();

  ProposalLedger(const ProposalLedger& from);
  ProposalLedger(ProposalLedger&& from) noexcept
    : ProposalLedger() {
    *this = ::std::move(from);
  }

  inline ProposalLedger& operator=(const ProposalLedger& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalLedger& operator=(ProposalLedger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProposalLedger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProposalLedger* internal_default_instance() {
    return reinterpret_cast<const ProposalLedger*>(
               &_ProposalLedger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ProposalLedger& a, ProposalLedger& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalLedger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalLedger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposalLedger* New() const final {
    return CreateMaybeMessage<ProposalLedger>(nullptr);
  }

  ProposalLedger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposalLedger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProposalLedger& from);
  void MergeFrom(const ProposalLedger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalLedger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ProposalLedger";
  }
  protected:
  explicit ProposalLedger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalIdsFieldNumber = 1,
    kPendingProposalIdsFieldNumber = 2,
    kProcessProposalIdsFieldNumber = 3,
    kCycleEndDateFieldNumber = 5,
    kCycleStartDateFieldNumber = 6,
    kStageEndDateFieldNumber = 7,
    kStageStartDateFieldNumber = 8,
    kStageFieldNumber = 4,
    kBreakFieldNumber = 9,
  };
  // repeated bytes proposal_ids = 1;
  int proposal_ids_size() const;
  private:
  int _internal_proposal_ids_size() const;
  public:
  void clear_proposal_ids();
  const std::string& proposal_ids(int index) const;
  std::string* mutable_proposal_ids(int index);
  void set_proposal_ids(int index, const std::string& value);
  void set_proposal_ids(int index, std::string&& value);
  void set_proposal_ids(int index, const char* value);
  void set_proposal_ids(int index, const void* value, size_t size);
  std::string* add_proposal_ids();
  void add_proposal_ids(const std::string& value);
  void add_proposal_ids(std::string&& value);
  void add_proposal_ids(const char* value);
  void add_proposal_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proposal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proposal_ids();
  private:
  const std::string& _internal_proposal_ids(int index) const;
  std::string* _internal_add_proposal_ids();
  public:

  // repeated bytes pending_proposal_ids = 2;
  int pending_proposal_ids_size() const;
  private:
  int _internal_pending_proposal_ids_size() const;
  public:
  void clear_pending_proposal_ids();
  const std::string& pending_proposal_ids(int index) const;
  std::string* mutable_pending_proposal_ids(int index);
  void set_pending_proposal_ids(int index, const std::string& value);
  void set_pending_proposal_ids(int index, std::string&& value);
  void set_pending_proposal_ids(int index, const char* value);
  void set_pending_proposal_ids(int index, const void* value, size_t size);
  std::string* add_pending_proposal_ids();
  void add_pending_proposal_ids(const std::string& value);
  void add_pending_proposal_ids(std::string&& value);
  void add_pending_proposal_ids(const char* value);
  void add_pending_proposal_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& pending_proposal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_pending_proposal_ids();
  private:
  const std::string& _internal_pending_proposal_ids(int index) const;
  std::string* _internal_add_pending_proposal_ids();
  public:

  // repeated bytes process_proposal_ids = 3;
  int process_proposal_ids_size() const;
  private:
  int _internal_process_proposal_ids_size() const;
  public:
  void clear_process_proposal_ids();
  const std::string& process_proposal_ids(int index) const;
  std::string* mutable_process_proposal_ids(int index);
  void set_process_proposal_ids(int index, const std::string& value);
  void set_process_proposal_ids(int index, std::string&& value);
  void set_process_proposal_ids(int index, const char* value);
  void set_process_proposal_ids(int index, const void* value, size_t size);
  std::string* add_process_proposal_ids();
  void add_process_proposal_ids(const std::string& value);
  void add_process_proposal_ids(std::string&& value);
  void add_process_proposal_ids(const char* value);
  void add_process_proposal_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& process_proposal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_process_proposal_ids();
  private:
  const std::string& _internal_process_proposal_ids(int index) const;
  std::string* _internal_add_process_proposal_ids();
  public:

  // .google.protobuf.Timestamp cycle_end_date = 5;
  bool has_cycle_end_date() const;
  private:
  bool _internal_has_cycle_end_date() const;
  public:
  void clear_cycle_end_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& cycle_end_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_cycle_end_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cycle_end_date();
  void set_allocated_cycle_end_date(PROTOBUF_NAMESPACE_ID::Timestamp* cycle_end_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cycle_end_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cycle_end_date();
  public:
  void unsafe_arena_set_allocated_cycle_end_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* cycle_end_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cycle_end_date();

  // .google.protobuf.Timestamp cycle_start_date = 6;
  bool has_cycle_start_date() const;
  private:
  bool _internal_has_cycle_start_date() const;
  public:
  void clear_cycle_start_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& cycle_start_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_cycle_start_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cycle_start_date();
  void set_allocated_cycle_start_date(PROTOBUF_NAMESPACE_ID::Timestamp* cycle_start_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cycle_start_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cycle_start_date();
  public:
  void unsafe_arena_set_allocated_cycle_start_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* cycle_start_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cycle_start_date();

  // .google.protobuf.Timestamp stage_end_date = 7;
  bool has_stage_end_date() const;
  private:
  bool _internal_has_stage_end_date() const;
  public:
  void clear_stage_end_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& stage_end_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_stage_end_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_stage_end_date();
  void set_allocated_stage_end_date(PROTOBUF_NAMESPACE_ID::Timestamp* stage_end_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_stage_end_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_stage_end_date();
  public:
  void unsafe_arena_set_allocated_stage_end_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* stage_end_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_stage_end_date();

  // .google.protobuf.Timestamp stage_start_date = 8;
  bool has_stage_start_date() const;
  private:
  bool _internal_has_stage_start_date() const;
  public:
  void clear_stage_start_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& stage_start_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_stage_start_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_stage_start_date();
  void set_allocated_stage_start_date(PROTOBUF_NAMESPACE_ID::Timestamp* stage_start_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_stage_start_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_stage_start_date();
  public:
  void unsafe_arena_set_allocated_stage_start_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* stage_start_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_stage_start_date();

  // uint32 stage = 4;
  void clear_stage();
  ::PROTOBUF_NAMESPACE_ID::uint32 stage() const;
  void set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stage() const;
  void _internal_set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool break = 9;
  void clear_break_();
  bool break_() const;
  void set_break_(bool value);
  private:
  bool _internal_break_() const;
  void _internal_set_break_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.ProposalLedger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proposal_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> pending_proposal_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> process_proposal_ids_;
  PROTOBUF_NAMESPACE_ID::Timestamp* cycle_end_date_;
  PROTOBUF_NAMESPACE_ID::Timestamp* cycle_start_date_;
  PROTOBUF_NAMESPACE_ID::Timestamp* stage_end_date_;
  PROTOBUF_NAMESPACE_ID::Timestamp* stage_start_date_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stage_;
  bool break__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Vote_VoteEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Vote_VoteEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Vote_VoteEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Vote_VoteEntry_DoNotUse();
  Vote_VoteEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Vote_VoteEntry_DoNotUse& other);
  static const Vote_VoteEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Vote_VoteEntry_DoNotUse*>(&_Vote_VoteEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Vote.VoteEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Vote.VoteEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[30];
  }

  public:
};

// -------------------------------------------------------------------

class Vote PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Vote) */ {
 public:
  inline Vote() : Vote(nullptr) {};
  virtual ~Vote();

  Vote(const Vote& from);
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(Vote* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const final {
    return CreateMaybeMessage<Vote>(nullptr);
  }

  Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Vote";
  }
  protected:
  explicit Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVoteFieldNumber = 1,
  };
  // map<string, string> vote = 1;
  int vote_size() const;
  private:
  int _internal_vote_size() const;
  public:
  void clear_vote();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_vote() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_vote();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      vote() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_vote();

  // @@protoc_insertion_point(class_scope:zera_validator.Vote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Vote_VoteEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > vote_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Voter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Voter) */ {
 public:
  inline Voter() : Voter(nullptr) {};
  virtual ~Voter();

  Voter(const Voter& from);
  Voter(Voter&& from) noexcept
    : Voter() {
    *this = ::std::move(from);
  }

  inline Voter& operator=(const Voter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Voter& operator=(Voter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Voter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Voter* internal_default_instance() {
    return reinterpret_cast<const Voter*>(
               &_Voter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Voter& a, Voter& b) {
    a.Swap(&b);
  }
  inline void Swap(Voter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Voter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Voter* New() const final {
    return CreateMaybeMessage<Voter>(nullptr);
  }

  Voter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Voter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Voter& from);
  void MergeFrom(const Voter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Voter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Voter";
  }
  protected:
  explicit Voter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionFieldNumber = 2,
    kSupportFieldNumber = 1,
    kDelegatedFieldNumber = 3,
  };
  // uint32 option = 2;
  bool has_option() const;
  private:
  bool _internal_has_option() const;
  public:
  void clear_option();
  ::PROTOBUF_NAMESPACE_ID::uint32 option() const;
  void set_option(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_option() const;
  void _internal_set_option(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool support = 1;
  bool has_support() const;
  private:
  bool _internal_has_support() const;
  public:
  void clear_support();
  bool support() const;
  void set_support(bool value);
  private:
  bool _internal_support() const;
  void _internal_set_support(bool value);
  public:

  // bool delegated = 3;
  void clear_delegated();
  bool delegated() const;
  void set_delegated(bool value);
  private:
  bool _internal_delegated() const;
  void _internal_set_delegated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.Voter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 option_;
  bool support_;
  bool delegated_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class VoteWallet_ProposalVotesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VoteWallet_ProposalVotesEntry_DoNotUse, 
    std::string, ::zera_validator::Voter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VoteWallet_ProposalVotesEntry_DoNotUse, 
    std::string, ::zera_validator::Voter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  VoteWallet_ProposalVotesEntry_DoNotUse();
  VoteWallet_ProposalVotesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const VoteWallet_ProposalVotesEntry_DoNotUse& other);
  static const VoteWallet_ProposalVotesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const VoteWallet_ProposalVotesEntry_DoNotUse*>(&_VoteWallet_ProposalVotesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.VoteWallet.ProposalVotesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[33];
  }

  public:
};

// -------------------------------------------------------------------

class VoteWallet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.VoteWallet) */ {
 public:
  inline VoteWallet() : VoteWallet(nullptr) {};
  virtual ~VoteWallet();

  VoteWallet(const VoteWallet& from);
  VoteWallet(VoteWallet&& from) noexcept
    : VoteWallet() {
    *this = ::std::move(from);
  }

  inline VoteWallet& operator=(const VoteWallet& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteWallet& operator=(VoteWallet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VoteWallet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoteWallet* internal_default_instance() {
    return reinterpret_cast<const VoteWallet*>(
               &_VoteWallet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(VoteWallet& a, VoteWallet& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteWallet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteWallet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoteWallet* New() const final {
    return CreateMaybeMessage<VoteWallet>(nullptr);
  }

  VoteWallet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoteWallet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VoteWallet& from);
  void MergeFrom(const VoteWallet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteWallet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.VoteWallet";
  }
  protected:
  explicit VoteWallet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kProposalVotesFieldNumber = 1,
  };
  // map<string, .zera_validator.Voter> proposal_votes = 1;
  int proposal_votes_size() const;
  private:
  int _internal_proposal_votes_size() const;
  public:
  void clear_proposal_votes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >&
      _internal_proposal_votes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >*
      _internal_mutable_proposal_votes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >&
      proposal_votes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >*
      mutable_proposal_votes();

  // @@protoc_insertion_point(class_scope:zera_validator.VoteWallet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      VoteWallet_ProposalVotesEntry_DoNotUse,
      std::string, ::zera_validator::Voter,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > proposal_votes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Proposal_YesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_YesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_YesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Proposal_YesEntry_DoNotUse();
  Proposal_YesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Proposal_YesEntry_DoNotUse& other);
  static const Proposal_YesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Proposal_YesEntry_DoNotUse*>(&_Proposal_YesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Proposal.YesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Proposal.YesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[35];
  }

  public:
};

// -------------------------------------------------------------------

class Proposal_NoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_NoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_NoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Proposal_NoEntry_DoNotUse();
  Proposal_NoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Proposal_NoEntry_DoNotUse& other);
  static const Proposal_NoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Proposal_NoEntry_DoNotUse*>(&_Proposal_NoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Proposal.NoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Proposal.NoEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[36];
  }

  public:
};

// -------------------------------------------------------------------

class Proposal_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_OptionsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_OptionsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Proposal_OptionsEntry_DoNotUse();
  Proposal_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Proposal_OptionsEntry_DoNotUse& other);
  static const Proposal_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Proposal_OptionsEntry_DoNotUse*>(&_Proposal_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[37];
  }

  public:
};

// -------------------------------------------------------------------

class Proposal_VotersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_VotersEntry_DoNotUse, 
    std::string, ::zera_validator::Voter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_VotersEntry_DoNotUse, 
    std::string, ::zera_validator::Voter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Proposal_VotersEntry_DoNotUse();
  Proposal_VotersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Proposal_VotersEntry_DoNotUse& other);
  static const Proposal_VotersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Proposal_VotersEntry_DoNotUse*>(&_Proposal_VotersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Proposal.VotersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[38];
  }

  public:
};

// -------------------------------------------------------------------

class Proposal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Proposal) */ {
 public:
  inline Proposal() : Proposal(nullptr) {};
  virtual ~Proposal();

  Proposal(const Proposal& from);
  Proposal(Proposal&& from) noexcept
    : Proposal() {
    *this = ::std::move(from);
  }

  inline Proposal& operator=(const Proposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proposal& operator=(Proposal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Proposal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Proposal* internal_default_instance() {
    return reinterpret_cast<const Proposal*>(
               &_Proposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Proposal& a, Proposal& b) {
    a.Swap(&b);
  }
  inline void Swap(Proposal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proposal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Proposal* New() const final {
    return CreateMaybeMessage<Proposal>(nullptr);
  }

  Proposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Proposal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Proposal& from);
  void MergeFrom(const Proposal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proposal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Proposal";
  }
  protected:
  explicit Proposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kYesFieldNumber = 4,
    kNoFieldNumber = 5,
    kOptionsFieldNumber = 6,
    kVotersFieldNumber = 11,
    kGovernanceTxnFieldNumber = 17,
    kContractIdFieldNumber = 1,
    kFeeFieldNumber = 8,
    kFeeIdFieldNumber = 9,
    kWalletFieldNumber = 10,
    kStartDateFieldNumber = 12,
    kEndDateFieldNumber = 13,
    kPublicKeyFieldNumber = 14,
    kStageFieldNumber = 7,
    kOptionsSetFieldNumber = 15,
    kNumberOfOptionsFieldNumber = 16,
  };
  // map<string, string> yes = 4;
  int yes_size() const;
  private:
  int _internal_yes_size() const;
  public:
  void clear_yes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_yes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_yes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      yes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_yes();

  // map<string, string> no = 5;
  int no_size() const;
  private:
  int _internal_no_size() const;
  public:
  void clear_no();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_no() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_no();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      no() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_no();

  // map<uint32, .zera_validator.Vote> options = 6;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote >*
      mutable_options();

  // map<string, .zera_validator.Voter> voters = 11;
  int voters_size() const;
  private:
  int _internal_voters_size() const;
  public:
  void clear_voters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >&
      _internal_voters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >*
      _internal_mutable_voters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >&
      voters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >*
      mutable_voters();

  // repeated .zera_txn.GovernanceTXN governance_txn = 17;
  int governance_txn_size() const;
  private:
  int _internal_governance_txn_size() const;
  public:
  void clear_governance_txn();
  ::zera_txn::GovernanceTXN* mutable_governance_txn(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN >*
      mutable_governance_txn();
  private:
  const ::zera_txn::GovernanceTXN& _internal_governance_txn(int index) const;
  ::zera_txn::GovernanceTXN* _internal_add_governance_txn();
  public:
  const ::zera_txn::GovernanceTXN& governance_txn(int index) const;
  ::zera_txn::GovernanceTXN* add_governance_txn();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN >&
      governance_txn() const;

  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  void set_contract_id(const std::string& value);
  void set_contract_id(std::string&& value);
  void set_contract_id(const char* value);
  void set_contract_id(const char* value, size_t size);
  std::string* mutable_contract_id();
  std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_contract_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_contract_id(
      std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string fee = 8;
  void clear_fee();
  const std::string& fee() const;
  void set_fee(const std::string& value);
  void set_fee(std::string&& value);
  void set_fee(const char* value);
  void set_fee(const char* value, size_t size);
  std::string* mutable_fee();
  std::string* release_fee();
  void set_allocated_fee(std::string* fee);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_fee();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_fee(
      std::string* fee);
  private:
  const std::string& _internal_fee() const;
  void _internal_set_fee(const std::string& value);
  std::string* _internal_mutable_fee();
  public:

  // string fee_id = 9;
  void clear_fee_id();
  const std::string& fee_id() const;
  void set_fee_id(const std::string& value);
  void set_fee_id(std::string&& value);
  void set_fee_id(const char* value);
  void set_fee_id(const char* value, size_t size);
  std::string* mutable_fee_id();
  std::string* release_fee_id();
  void set_allocated_fee_id(std::string* fee_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_fee_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_fee_id(
      std::string* fee_id);
  private:
  const std::string& _internal_fee_id() const;
  void _internal_set_fee_id(const std::string& value);
  std::string* _internal_mutable_fee_id();
  public:

  // bytes wallet = 10;
  void clear_wallet();
  const std::string& wallet() const;
  void set_wallet(const std::string& value);
  void set_wallet(std::string&& value);
  void set_wallet(const char* value);
  void set_wallet(const void* value, size_t size);
  std::string* mutable_wallet();
  std::string* release_wallet();
  void set_allocated_wallet(std::string* wallet);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_wallet();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_wallet(
      std::string* wallet);
  private:
  const std::string& _internal_wallet() const;
  void _internal_set_wallet(const std::string& value);
  std::string* _internal_mutable_wallet();
  public:

  // .google.protobuf.Timestamp start_date = 12;
  bool has_start_date() const;
  private:
  bool _internal_has_start_date() const;
  public:
  void clear_start_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& start_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_start_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_date();
  void set_allocated_start_date(PROTOBUF_NAMESPACE_ID::Timestamp* start_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_date();
  public:
  void unsafe_arena_set_allocated_start_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* start_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_date();

  // .google.protobuf.Timestamp end_date = 13;
  bool has_end_date() const;
  private:
  bool _internal_has_end_date() const;
  public:
  void clear_end_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& end_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_end_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_date();
  void set_allocated_end_date(PROTOBUF_NAMESPACE_ID::Timestamp* end_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_date();
  public:
  void unsafe_arena_set_allocated_end_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* end_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_date();

  // .zera_txn.PublicKey public_key = 14;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // uint32 stage = 7;
  void clear_stage();
  ::PROTOBUF_NAMESPACE_ID::uint32 stage() const;
  void set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stage() const;
  void _internal_set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool options_set = 15;
  void clear_options_set();
  bool options_set() const;
  void set_options_set(bool value);
  private:
  bool _internal_options_set() const;
  void _internal_set_options_set(bool value);
  public:

  // uint32 number_of_options = 16;
  void clear_number_of_options();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_options() const;
  void set_number_of_options(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_number_of_options() const;
  void _internal_set_number_of_options(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.Proposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Proposal_YesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > yes_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Proposal_NoEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > no_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Proposal_OptionsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > options_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Proposal_VotersEntry_DoNotUse,
      std::string, ::zera_validator::Voter,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > voters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN > governance_txn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_;
  PROTOBUF_NAMESPACE_ID::Timestamp* start_date_;
  PROTOBUF_NAMESPACE_ID::Timestamp* end_date_;
  ::zera_txn::PublicKey* public_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stage_;
  bool options_set_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_options_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ProposalWalletRecieve PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ProposalWalletRecieve) */ {
 public:
  inline ProposalWalletRecieve() : ProposalWalletRecieve(nullptr) {};
  virtual ~ProposalWalletRecieve();

  ProposalWalletRecieve(const ProposalWalletRecieve& from);
  ProposalWalletRecieve(ProposalWalletRecieve&& from) noexcept
    : ProposalWalletRecieve() {
    *this = ::std::move(from);
  }

  inline ProposalWalletRecieve& operator=(const ProposalWalletRecieve& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalWalletRecieve& operator=(ProposalWalletRecieve&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProposalWalletRecieve& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProposalWalletRecieve* internal_default_instance() {
    return reinterpret_cast<const ProposalWalletRecieve*>(
               &_ProposalWalletRecieve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ProposalWalletRecieve& a, ProposalWalletRecieve& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalWalletRecieve* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalWalletRecieve* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposalWalletRecieve* New() const final {
    return CreateMaybeMessage<ProposalWalletRecieve>(nullptr);
  }

  ProposalWalletRecieve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposalWalletRecieve>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProposalWalletRecieve& from);
  void MergeFrom(const ProposalWalletRecieve& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalWalletRecieve* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ProposalWalletRecieve";
  }
  protected:
  explicit ProposalWalletRecieve(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletAdrFieldNumber = 2,
    kContractIdFieldNumber = 3,
    kAmountFieldNumber = 4,
    kBaseFieldNumber = 1,
  };
  // bytes wallet_adr = 2;
  void clear_wallet_adr();
  const std::string& wallet_adr() const;
  void set_wallet_adr(const std::string& value);
  void set_wallet_adr(std::string&& value);
  void set_wallet_adr(const char* value);
  void set_wallet_adr(const void* value, size_t size);
  std::string* mutable_wallet_adr();
  std::string* release_wallet_adr();
  void set_allocated_wallet_adr(std::string* wallet_adr);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_wallet_adr();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_wallet_adr(
      std::string* wallet_adr);
  private:
  const std::string& _internal_wallet_adr() const;
  void _internal_set_wallet_adr(const std::string& value);
  std::string* _internal_mutable_wallet_adr();
  public:

  // string contract_id = 3;
  void clear_contract_id();
  const std::string& contract_id() const;
  void set_contract_id(const std::string& value);
  void set_contract_id(std::string&& value);
  void set_contract_id(const char* value);
  void set_contract_id(const char* value, size_t size);
  std::string* mutable_contract_id();
  std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_contract_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_contract_id(
      std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string amount = 4;
  void clear_amount();
  const std::string& amount() const;
  void set_amount(const std::string& value);
  void set_amount(std::string&& value);
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  std::string* mutable_amount();
  std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_amount();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_amount(
      std::string* amount);
  private:
  const std::string& _internal_amount() const;
  void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_validator.ProposalWalletRecieve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_adr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  ::zera_txn::BaseTXN* base_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ProposalWalletSend PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ProposalWalletSend) */ {
 public:
  inline ProposalWalletSend() : ProposalWalletSend(nullptr) {};
  virtual ~ProposalWalletSend();

  ProposalWalletSend(const ProposalWalletSend& from);
  ProposalWalletSend(ProposalWalletSend&& from) noexcept
    : ProposalWalletSend() {
    *this = ::std::move(from);
  }

  inline ProposalWalletSend& operator=(const ProposalWalletSend& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalWalletSend& operator=(ProposalWalletSend&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProposalWalletSend& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProposalWalletSend* internal_default_instance() {
    return reinterpret_cast<const ProposalWalletSend*>(
               &_ProposalWalletSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ProposalWalletSend& a, ProposalWalletSend& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalWalletSend* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalWalletSend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposalWalletSend* New() const final {
    return CreateMaybeMessage<ProposalWalletSend>(nullptr);
  }

  ProposalWalletSend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposalWalletSend>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProposalWalletSend& from);
  void MergeFrom(const ProposalWalletSend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalWalletSend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ProposalWalletSend";
  }
  protected:
  explicit ProposalWalletSend(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientWalletFieldNumber = 4,
    kAmountsFieldNumber = 5,
    kWalletAdrFieldNumber = 2,
    kContractIdFieldNumber = 3,
    kBaseFieldNumber = 1,
  };
  // repeated bytes recipient_wallet = 4;
  int recipient_wallet_size() const;
  private:
  int _internal_recipient_wallet_size() const;
  public:
  void clear_recipient_wallet();
  const std::string& recipient_wallet(int index) const;
  std::string* mutable_recipient_wallet(int index);
  void set_recipient_wallet(int index, const std::string& value);
  void set_recipient_wallet(int index, std::string&& value);
  void set_recipient_wallet(int index, const char* value);
  void set_recipient_wallet(int index, const void* value, size_t size);
  std::string* add_recipient_wallet();
  void add_recipient_wallet(const std::string& value);
  void add_recipient_wallet(std::string&& value);
  void add_recipient_wallet(const char* value);
  void add_recipient_wallet(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recipient_wallet() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recipient_wallet();
  private:
  const std::string& _internal_recipient_wallet(int index) const;
  std::string* _internal_add_recipient_wallet();
  public:

  // repeated string amounts = 5;
  int amounts_size() const;
  private:
  int _internal_amounts_size() const;
  public:
  void clear_amounts();
  const std::string& amounts(int index) const;
  std::string* mutable_amounts(int index);
  void set_amounts(int index, const std::string& value);
  void set_amounts(int index, std::string&& value);
  void set_amounts(int index, const char* value);
  void set_amounts(int index, const char* value, size_t size);
  std::string* add_amounts();
  void add_amounts(const std::string& value);
  void add_amounts(std::string&& value);
  void add_amounts(const char* value);
  void add_amounts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& amounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_amounts();
  private:
  const std::string& _internal_amounts(int index) const;
  std::string* _internal_add_amounts();
  public:

  // bytes wallet_adr = 2;
  void clear_wallet_adr();
  const std::string& wallet_adr() const;
  void set_wallet_adr(const std::string& value);
  void set_wallet_adr(std::string&& value);
  void set_wallet_adr(const char* value);
  void set_wallet_adr(const void* value, size_t size);
  std::string* mutable_wallet_adr();
  std::string* release_wallet_adr();
  void set_allocated_wallet_adr(std::string* wallet_adr);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_wallet_adr();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_wallet_adr(
      std::string* wallet_adr);
  private:
  const std::string& _internal_wallet_adr() const;
  void _internal_set_wallet_adr(const std::string& value);
  std::string* _internal_mutable_wallet_adr();
  public:

  // string contract_id = 3;
  void clear_contract_id();
  const std::string& contract_id() const;
  void set_contract_id(const std::string& value);
  void set_contract_id(std::string&& value);
  void set_contract_id(const char* value);
  void set_contract_id(const char* value, size_t size);
  std::string* mutable_contract_id();
  std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_contract_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_contract_id(
      std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_validator.ProposalWalletSend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recipient_wallet_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> amounts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_adr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::zera_txn::BaseTXN* base_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class CurrencyRate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.CurrencyRate) */ {
 public:
  inline CurrencyRate() : CurrencyRate(nullptr) {};
  virtual ~CurrencyRate();

  CurrencyRate(const CurrencyRate& from);
  CurrencyRate(CurrencyRate&& from) noexcept
    : CurrencyRate() {
    *this = ::std::move(from);
  }

  inline CurrencyRate& operator=(const CurrencyRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyRate& operator=(CurrencyRate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CurrencyRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurrencyRate* internal_default_instance() {
    return reinterpret_cast<const CurrencyRate*>(
               &_CurrencyRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CurrencyRate& a, CurrencyRate& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyRate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurrencyRate* New() const final {
    return CreateMaybeMessage<CurrencyRate>(nullptr);
  }

  CurrencyRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurrencyRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CurrencyRate& from);
  void MergeFrom(const CurrencyRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.CurrencyRate";
  }
  protected:
  explicit CurrencyRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRateFieldNumber = 2,
    kMaxStakeFieldNumber = 3,
    kQualifiedFieldNumber = 1,
  };
  // string rate = 2;
  void clear_rate();
  const std::string& rate() const;
  void set_rate(const std::string& value);
  void set_rate(std::string&& value);
  void set_rate(const char* value);
  void set_rate(const char* value, size_t size);
  std::string* mutable_rate();
  std::string* release_rate();
  void set_allocated_rate(std::string* rate);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_rate();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_rate(
      std::string* rate);
  private:
  const std::string& _internal_rate() const;
  void _internal_set_rate(const std::string& value);
  std::string* _internal_mutable_rate();
  public:

  // string max_stake = 3;
  bool has_max_stake() const;
  private:
  bool _internal_has_max_stake() const;
  public:
  void clear_max_stake();
  const std::string& max_stake() const;
  void set_max_stake(const std::string& value);
  void set_max_stake(std::string&& value);
  void set_max_stake(const char* value);
  void set_max_stake(const char* value, size_t size);
  std::string* mutable_max_stake();
  std::string* release_max_stake();
  void set_allocated_max_stake(std::string* max_stake);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_max_stake();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_max_stake(
      std::string* max_stake);
  private:
  const std::string& _internal_max_stake() const;
  void _internal_set_max_stake(const std::string& value);
  std::string* _internal_mutable_max_stake();
  public:

  // bool qualified = 1;
  void clear_qualified();
  bool qualified() const;
  void set_qualified(bool value);
  private:
  bool _internal_qualified() const;
  void _internal_set_qualified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.CurrencyRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_stake_;
  bool qualified_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ExpenseTracker PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ExpenseTracker) */ {
 public:
  inline ExpenseTracker() : ExpenseTracker(nullptr) {};
  virtual ~ExpenseTracker();

  ExpenseTracker(const ExpenseTracker& from);
  ExpenseTracker(ExpenseTracker&& from) noexcept
    : ExpenseTracker() {
    *this = ::std::move(from);
  }

  inline ExpenseTracker& operator=(const ExpenseTracker& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpenseTracker& operator=(ExpenseTracker&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExpenseTracker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExpenseTracker* internal_default_instance() {
    return reinterpret_cast<const ExpenseTracker*>(
               &_ExpenseTracker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ExpenseTracker& a, ExpenseTracker& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpenseTracker* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpenseTracker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExpenseTracker* New() const final {
    return CreateMaybeMessage<ExpenseTracker>(nullptr);
  }

  ExpenseTracker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExpenseTracker>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExpenseTracker& from);
  void MergeFrom(const ExpenseTracker& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpenseTracker* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ExpenseTracker";
  }
  protected:
  explicit ExpenseTracker(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDayFieldNumber = 1,
    kMonthFieldNumber = 2,
  };
  // int32 day = 1;
  void clear_day();
  ::PROTOBUF_NAMESPACE_ID::int32 day() const;
  void set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_day() const;
  void _internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 month = 2;
  void clear_month();
  ::PROTOBUF_NAMESPACE_ID::int32 month() const;
  void set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_month() const;
  void _internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.ExpenseTracker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 day_;
  ::PROTOBUF_NAMESPACE_ID::int32 month_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class RestrictedSymbols PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.RestrictedSymbols) */ {
 public:
  inline RestrictedSymbols() : RestrictedSymbols(nullptr) {};
  virtual ~RestrictedSymbols();

  RestrictedSymbols(const RestrictedSymbols& from);
  RestrictedSymbols(RestrictedSymbols&& from) noexcept
    : RestrictedSymbols() {
    *this = ::std::move(from);
  }

  inline RestrictedSymbols& operator=(const RestrictedSymbols& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestrictedSymbols& operator=(RestrictedSymbols&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RestrictedSymbols& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestrictedSymbols* internal_default_instance() {
    return reinterpret_cast<const RestrictedSymbols*>(
               &_RestrictedSymbols_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(RestrictedSymbols& a, RestrictedSymbols& b) {
    a.Swap(&b);
  }
  inline void Swap(RestrictedSymbols* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestrictedSymbols* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RestrictedSymbols* New() const final {
    return CreateMaybeMessage<RestrictedSymbols>(nullptr);
  }

  RestrictedSymbols* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RestrictedSymbols>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RestrictedSymbols& from);
  void MergeFrom(const RestrictedSymbols& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestrictedSymbols* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.RestrictedSymbols";
  }
  protected:
  explicit RestrictedSymbols(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolsFieldNumber = 1,
  };
  // repeated string symbols = 1;
  int symbols_size() const;
  private:
  int _internal_symbols_size() const;
  public:
  void clear_symbols();
  const std::string& symbols(int index) const;
  std::string* mutable_symbols(int index);
  void set_symbols(int index, const std::string& value);
  void set_symbols(int index, std::string&& value);
  void set_symbols(int index, const char* value);
  void set_symbols(int index, const char* value, size_t size);
  std::string* add_symbols();
  void add_symbols(const std::string& value);
  void add_symbols(std::string&& value);
  void add_symbols(const char* value);
  void add_symbols(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& symbols() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_symbols();
  private:
  const std::string& _internal_symbols(int index) const;
  std::string* _internal_add_symbols();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.RestrictedSymbols)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> symbols_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class IndexerVotingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.IndexerVotingRequest) */ {
 public:
  inline IndexerVotingRequest() : IndexerVotingRequest(nullptr) {};
  virtual ~IndexerVotingRequest();

  IndexerVotingRequest(const IndexerVotingRequest& from);
  IndexerVotingRequest(IndexerVotingRequest&& from) noexcept
    : IndexerVotingRequest() {
    *this = ::std::move(from);
  }

  inline IndexerVotingRequest& operator=(const IndexerVotingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexerVotingRequest& operator=(IndexerVotingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndexerVotingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexerVotingRequest* internal_default_instance() {
    return reinterpret_cast<const IndexerVotingRequest*>(
               &_IndexerVotingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(IndexerVotingRequest& a, IndexerVotingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexerVotingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexerVotingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexerVotingRequest* New() const final {
    return CreateMaybeMessage<IndexerVotingRequest>(nullptr);
  }

  IndexerVotingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexerVotingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndexerVotingRequest& from);
  void MergeFrom(const IndexerVotingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexerVotingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.IndexerVotingRequest";
  }
  protected:
  explicit IndexerVotingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalIdFieldNumber = 1,
  };
  // bytes proposal_id = 1;
  void clear_proposal_id();
  const std::string& proposal_id() const;
  void set_proposal_id(const std::string& value);
  void set_proposal_id(std::string&& value);
  void set_proposal_id(const char* value);
  void set_proposal_id(const void* value, size_t size);
  std::string* mutable_proposal_id();
  std::string* release_proposal_id();
  void set_allocated_proposal_id(std::string* proposal_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_proposal_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_proposal_id(
      std::string* proposal_id);
  private:
  const std::string& _internal_proposal_id() const;
  void _internal_set_proposal_id(const std::string& value);
  std::string* _internal_mutable_proposal_id();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.IndexerVotingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposal_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class IndexerOption PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.IndexerOption) */ {
 public:
  inline IndexerOption() : IndexerOption(nullptr) {};
  virtual ~IndexerOption();

  IndexerOption(const IndexerOption& from);
  IndexerOption(IndexerOption&& from) noexcept
    : IndexerOption() {
    *this = ::std::move(from);
  }

  inline IndexerOption& operator=(const IndexerOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexerOption& operator=(IndexerOption&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndexerOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexerOption* internal_default_instance() {
    return reinterpret_cast<const IndexerOption*>(
               &_IndexerOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(IndexerOption& a, IndexerOption& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexerOption* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexerOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexerOption* New() const final {
    return CreateMaybeMessage<IndexerOption>(nullptr);
  }

  IndexerOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexerOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndexerOption& from);
  void MergeFrom(const IndexerOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexerOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.IndexerOption";
  }
  protected:
  explicit IndexerOption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVotesFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // repeated .zera_validator.IndexerVote votes = 1;
  int votes_size() const;
  private:
  int _internal_votes_size() const;
  public:
  void clear_votes();
  ::zera_validator::IndexerVote* mutable_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >*
      mutable_votes();
  private:
  const ::zera_validator::IndexerVote& _internal_votes(int index) const;
  ::zera_validator::IndexerVote* _internal_add_votes();
  public:
  const ::zera_validator::IndexerVote& votes(int index) const;
  ::zera_validator::IndexerVote* add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >&
      votes() const;

  // uint32 index = 2;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.IndexerOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote > votes_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class IndexerVote PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.IndexerVote) */ {
 public:
  inline IndexerVote() : IndexerVote(nullptr) {};
  virtual ~IndexerVote();

  IndexerVote(const IndexerVote& from);
  IndexerVote(IndexerVote&& from) noexcept
    : IndexerVote() {
    *this = ::std::move(from);
  }

  inline IndexerVote& operator=(const IndexerVote& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexerVote& operator=(IndexerVote&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndexerVote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexerVote* internal_default_instance() {
    return reinterpret_cast<const IndexerVote*>(
               &_IndexerVote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(IndexerVote& a, IndexerVote& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexerVote* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexerVote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexerVote* New() const final {
    return CreateMaybeMessage<IndexerVote>(nullptr);
  }

  IndexerVote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexerVote>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndexerVote& from);
  void MergeFrom(const IndexerVote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexerVote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.IndexerVote";
  }
  protected:
  explicit IndexerVote(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  void set_contract_id(const std::string& value);
  void set_contract_id(std::string&& value);
  void set_contract_id(const char* value);
  void set_contract_id(const char* value, size_t size);
  std::string* mutable_contract_id();
  std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_contract_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_contract_id(
      std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  void set_amount(const std::string& value);
  void set_amount(std::string&& value);
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  std::string* mutable_amount();
  std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_amount();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_amount(
      std::string* amount);
  private:
  const std::string& _internal_amount() const;
  void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.IndexerVote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class IndexerVotingResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.IndexerVotingResponse) */ {
 public:
  inline IndexerVotingResponse() : IndexerVotingResponse(nullptr) {};
  virtual ~IndexerVotingResponse();

  IndexerVotingResponse(const IndexerVotingResponse& from);
  IndexerVotingResponse(IndexerVotingResponse&& from) noexcept
    : IndexerVotingResponse() {
    *this = ::std::move(from);
  }

  inline IndexerVotingResponse& operator=(const IndexerVotingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexerVotingResponse& operator=(IndexerVotingResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndexerVotingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexerVotingResponse* internal_default_instance() {
    return reinterpret_cast<const IndexerVotingResponse*>(
               &_IndexerVotingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(IndexerVotingResponse& a, IndexerVotingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexerVotingResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexerVotingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexerVotingResponse* New() const final {
    return CreateMaybeMessage<IndexerVotingResponse>(nullptr);
  }

  IndexerVotingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexerVotingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndexerVotingResponse& from);
  void MergeFrom(const IndexerVotingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexerVotingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.IndexerVotingResponse";
  }
  protected:
  explicit IndexerVotingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportFieldNumber = 1,
    kAgainstFieldNumber = 2,
    kOptionsFieldNumber = 3,
    kStageFieldNumber = 4,
  };
  // repeated .zera_validator.IndexerVote support = 1;
  int support_size() const;
  private:
  int _internal_support_size() const;
  public:
  void clear_support();
  ::zera_validator::IndexerVote* mutable_support(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >*
      mutable_support();
  private:
  const ::zera_validator::IndexerVote& _internal_support(int index) const;
  ::zera_validator::IndexerVote* _internal_add_support();
  public:
  const ::zera_validator::IndexerVote& support(int index) const;
  ::zera_validator::IndexerVote* add_support();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >&
      support() const;

  // repeated .zera_validator.IndexerVote against = 2;
  int against_size() const;
  private:
  int _internal_against_size() const;
  public:
  void clear_against();
  ::zera_validator::IndexerVote* mutable_against(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >*
      mutable_against();
  private:
  const ::zera_validator::IndexerVote& _internal_against(int index) const;
  ::zera_validator::IndexerVote* _internal_add_against();
  public:
  const ::zera_validator::IndexerVote& against(int index) const;
  ::zera_validator::IndexerVote* add_against();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >&
      against() const;

  // repeated .zera_validator.IndexerOption options = 3;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  ::zera_validator::IndexerOption* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerOption >*
      mutable_options();
  private:
  const ::zera_validator::IndexerOption& _internal_options(int index) const;
  ::zera_validator::IndexerOption* _internal_add_options();
  public:
  const ::zera_validator::IndexerOption& options(int index) const;
  ::zera_validator::IndexerOption* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerOption >&
      options() const;

  // uint32 stage = 4;
  void clear_stage();
  ::PROTOBUF_NAMESPACE_ID::uint32 stage() const;
  void set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stage() const;
  void _internal_set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.IndexerVotingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote > support_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote > against_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerOption > options_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class DelegationFees_AuthorizedFeesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DelegationFees_AuthorizedFeesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DelegationFees_AuthorizedFeesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  DelegationFees_AuthorizedFeesEntry_DoNotUse();
  DelegationFees_AuthorizedFeesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DelegationFees_AuthorizedFeesEntry_DoNotUse& other);
  static const DelegationFees_AuthorizedFeesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DelegationFees_AuthorizedFeesEntry_DoNotUse*>(&_DelegationFees_AuthorizedFeesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.DelegationFees.AuthorizedFeesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.DelegationFees.AuthorizedFeesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[49];
  }

  public:
};

// -------------------------------------------------------------------

class DelegationFees PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.DelegationFees) */ {
 public:
  inline DelegationFees() : DelegationFees(nullptr) {};
  virtual ~DelegationFees();

  DelegationFees(const DelegationFees& from);
  DelegationFees(DelegationFees&& from) noexcept
    : DelegationFees() {
    *this = ::std::move(from);
  }

  inline DelegationFees& operator=(const DelegationFees& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegationFees& operator=(DelegationFees&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DelegationFees& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DelegationFees* internal_default_instance() {
    return reinterpret_cast<const DelegationFees*>(
               &_DelegationFees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(DelegationFees& a, DelegationFees& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegationFees* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegationFees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegationFees* New() const final {
    return CreateMaybeMessage<DelegationFees>(nullptr);
  }

  DelegationFees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegationFees>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DelegationFees& from);
  void MergeFrom(const DelegationFees& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegationFees* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.DelegationFees";
  }
  protected:
  explicit DelegationFees(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizedFeesFieldNumber = 3,
  };
  // map<string, string> authorized_fees = 3;
  int authorized_fees_size() const;
  private:
  int _internal_authorized_fees_size() const;
  public:
  void clear_authorized_fees();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_authorized_fees() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_authorized_fees();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      authorized_fees() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_authorized_fees();

  // @@protoc_insertion_point(class_scope:zera_validator.DelegationFees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DelegationFees_AuthorizedFeesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > authorized_fees_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class AuthorizedFee PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.AuthorizedFee) */ {
 public:
  inline AuthorizedFee() : AuthorizedFee(nullptr) {};
  virtual ~AuthorizedFee();

  AuthorizedFee(const AuthorizedFee& from);
  AuthorizedFee(AuthorizedFee&& from) noexcept
    : AuthorizedFee() {
    *this = ::std::move(from);
  }

  inline AuthorizedFee& operator=(const AuthorizedFee& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizedFee& operator=(AuthorizedFee&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AuthorizedFee& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthorizedFee* internal_default_instance() {
    return reinterpret_cast<const AuthorizedFee*>(
               &_AuthorizedFee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(AuthorizedFee& a, AuthorizedFee& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizedFee* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizedFee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthorizedFee* New() const final {
    return CreateMaybeMessage<AuthorizedFee>(nullptr);
  }

  AuthorizedFee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthorizedFee>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AuthorizedFee& from);
  void MergeFrom(const AuthorizedFee& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizedFee* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.AuthorizedFee";
  }
  protected:
  explicit AuthorizedFee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizedAmountFieldNumber = 2,
    kPriorityFieldNumber = 1,
  };
  // string authorized_amount = 2;
  void clear_authorized_amount();
  const std::string& authorized_amount() const;
  void set_authorized_amount(const std::string& value);
  void set_authorized_amount(std::string&& value);
  void set_authorized_amount(const char* value);
  void set_authorized_amount(const char* value, size_t size);
  std::string* mutable_authorized_amount();
  std::string* release_authorized_amount();
  void set_allocated_authorized_amount(std::string* authorized_amount);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_authorized_amount();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_authorized_amount(
      std::string* authorized_amount);
  private:
  const std::string& _internal_authorized_amount() const;
  void _internal_set_authorized_amount(const std::string& value);
  std::string* _internal_mutable_authorized_amount();
  public:

  // uint32 priority = 1;
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::uint32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.AuthorizedFee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorized_amount_;
  ::PROTOBUF_NAMESPACE_ID::uint32 priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Delegator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Delegator) */ {
 public:
  inline Delegator() : Delegator(nullptr) {};
  virtual ~Delegator();

  Delegator(const Delegator& from);
  Delegator(Delegator&& from) noexcept
    : Delegator() {
    *this = ::std::move(from);
  }

  inline Delegator& operator=(const Delegator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Delegator& operator=(Delegator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Delegator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delegator* internal_default_instance() {
    return reinterpret_cast<const Delegator*>(
               &_Delegator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(Delegator& a, Delegator& b) {
    a.Swap(&b);
  }
  inline void Swap(Delegator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Delegator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Delegator* New() const final {
    return CreateMaybeMessage<Delegator>(nullptr);
  }

  Delegator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Delegator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Delegator& from);
  void MergeFrom(const Delegator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delegator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Delegator";
  }
  protected:
  explicit Delegator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kPriorityFieldNumber = 2,
  };
  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // uint32 priority = 2;
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::uint32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.Delegator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zera_txn::PublicKey* public_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class DelegatedFees PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.DelegatedFees) */ {
 public:
  inline DelegatedFees() : DelegatedFees(nullptr) {};
  virtual ~DelegatedFees();

  DelegatedFees(const DelegatedFees& from);
  DelegatedFees(DelegatedFees&& from) noexcept
    : DelegatedFees() {
    *this = ::std::move(from);
  }

  inline DelegatedFees& operator=(const DelegatedFees& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatedFees& operator=(DelegatedFees&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DelegatedFees& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DelegatedFees* internal_default_instance() {
    return reinterpret_cast<const DelegatedFees*>(
               &_DelegatedFees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(DelegatedFees& a, DelegatedFees& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatedFees* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatedFees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegatedFees* New() const final {
    return CreateMaybeMessage<DelegatedFees>(nullptr);
  }

  DelegatedFees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegatedFees>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DelegatedFees& from);
  void MergeFrom(const DelegatedFees& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatedFees* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.DelegatedFees";
  }
  protected:
  explicit DelegatedFees(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdsFieldNumber = 1,
  };
  // repeated string contract_ids = 1;
  int contract_ids_size() const;
  private:
  int _internal_contract_ids_size() const;
  public:
  void clear_contract_ids();
  const std::string& contract_ids(int index) const;
  std::string* mutable_contract_ids(int index);
  void set_contract_ids(int index, const std::string& value);
  void set_contract_ids(int index, std::string&& value);
  void set_contract_ids(int index, const char* value);
  void set_contract_ids(int index, const char* value, size_t size);
  std::string* add_contract_ids();
  void add_contract_ids(const std::string& value);
  void add_contract_ids(std::string&& value);
  void add_contract_ids(const char* value);
  void add_contract_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& contract_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_contract_ids();
  private:
  const std::string& _internal_contract_ids(int index) const;
  std::string* _internal_add_contract_ids();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.DelegatedFees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> contract_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Delegators PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Delegators) */ {
 public:
  inline Delegators() : Delegators(nullptr) {};
  virtual ~Delegators();

  Delegators(const Delegators& from);
  Delegators(Delegators&& from) noexcept
    : Delegators() {
    *this = ::std::move(from);
  }

  inline Delegators& operator=(const Delegators& from) {
    CopyFrom(from);
    return *this;
  }
  inline Delegators& operator=(Delegators&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Delegators& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delegators* internal_default_instance() {
    return reinterpret_cast<const Delegators*>(
               &_Delegators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(Delegators& a, Delegators& b) {
    a.Swap(&b);
  }
  inline void Swap(Delegators* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Delegators* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Delegators* New() const final {
    return CreateMaybeMessage<Delegators>(nullptr);
  }

  Delegators* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Delegators>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Delegators& from);
  void MergeFrom(const Delegators& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delegators* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Delegators";
  }
  protected:
  explicit Delegators(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatorFieldNumber = 1,
  };
  // repeated .zera_validator.Delegator delegator = 1;
  int delegator_size() const;
  private:
  int _internal_delegator_size() const;
  public:
  void clear_delegator();
  ::zera_validator::Delegator* mutable_delegator(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Delegator >*
      mutable_delegator();
  private:
  const ::zera_validator::Delegator& _internal_delegator(int index) const;
  ::zera_validator::Delegator* _internal_add_delegator();
  public:
  const ::zera_validator::Delegator& delegator(int index) const;
  ::zera_validator::Delegator* add_delegator();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Delegator >&
      delegator() const;

  // @@protoc_insertion_point(class_scope:zera_validator.Delegators)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Delegator > delegator_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class DelegatedRecipient_DelegationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DelegatedRecipient_DelegationsEntry_DoNotUse, 
    std::string, ::zera_validator::Delegators,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DelegatedRecipient_DelegationsEntry_DoNotUse, 
    std::string, ::zera_validator::Delegators,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  DelegatedRecipient_DelegationsEntry_DoNotUse();
  DelegatedRecipient_DelegationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DelegatedRecipient_DelegationsEntry_DoNotUse& other);
  static const DelegatedRecipient_DelegationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DelegatedRecipient_DelegationsEntry_DoNotUse*>(&_DelegatedRecipient_DelegationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.DelegatedRecipient.DelegationsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[55];
  }

  public:
};

// -------------------------------------------------------------------

class DelegatedRecipient PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.DelegatedRecipient) */ {
 public:
  inline DelegatedRecipient() : DelegatedRecipient(nullptr) {};
  virtual ~DelegatedRecipient();

  DelegatedRecipient(const DelegatedRecipient& from);
  DelegatedRecipient(DelegatedRecipient&& from) noexcept
    : DelegatedRecipient() {
    *this = ::std::move(from);
  }

  inline DelegatedRecipient& operator=(const DelegatedRecipient& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatedRecipient& operator=(DelegatedRecipient&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DelegatedRecipient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DelegatedRecipient* internal_default_instance() {
    return reinterpret_cast<const DelegatedRecipient*>(
               &_DelegatedRecipient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(DelegatedRecipient& a, DelegatedRecipient& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatedRecipient* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatedRecipient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegatedRecipient* New() const final {
    return CreateMaybeMessage<DelegatedRecipient>(nullptr);
  }

  DelegatedRecipient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegatedRecipient>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DelegatedRecipient& from);
  void MergeFrom(const DelegatedRecipient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatedRecipient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.DelegatedRecipient";
  }
  protected:
  explicit DelegatedRecipient(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDelegationsFieldNumber = 1,
  };
  // map<string, .zera_validator.Delegators> delegations = 1;
  int delegations_size() const;
  private:
  int _internal_delegations_size() const;
  public:
  void clear_delegations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Delegators >&
      _internal_delegations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Delegators >*
      _internal_mutable_delegations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Delegators >&
      delegations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Delegators >*
      mutable_delegations();

  // @@protoc_insertion_point(class_scope:zera_validator.DelegatedRecipient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DelegatedRecipient_DelegationsEntry_DoNotUse,
      std::string, ::zera_validator::Delegators,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > delegations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Delegated_ProposalsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Delegated_ProposalsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::uint32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Delegated_ProposalsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::uint32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    0 > SuperType;
  Delegated_ProposalsEntry_DoNotUse();
  Delegated_ProposalsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Delegated_ProposalsEntry_DoNotUse& other);
  static const Delegated_ProposalsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Delegated_ProposalsEntry_DoNotUse*>(&_Delegated_ProposalsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Delegated.ProposalsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[57];
  }

  public:
};

// -------------------------------------------------------------------

class Delegated PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Delegated) */ {
 public:
  inline Delegated() : Delegated(nullptr) {};
  virtual ~Delegated();

  Delegated(const Delegated& from);
  Delegated(Delegated&& from) noexcept
    : Delegated() {
    *this = ::std::move(from);
  }

  inline Delegated& operator=(const Delegated& from) {
    CopyFrom(from);
    return *this;
  }
  inline Delegated& operator=(Delegated&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Delegated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delegated* internal_default_instance() {
    return reinterpret_cast<const Delegated*>(
               &_Delegated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(Delegated& a, Delegated& b) {
    a.Swap(&b);
  }
  inline void Swap(Delegated* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Delegated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Delegated* New() const final {
    return CreateMaybeMessage<Delegated>(nullptr);
  }

  Delegated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Delegated>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Delegated& from);
  void MergeFrom(const Delegated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delegated* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Delegated";
  }
  protected:
  explicit Delegated(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kProposalsFieldNumber = 1,
  };
  // map<string, uint32> proposals = 1;
  int proposals_size() const;
  private:
  int _internal_proposals_size() const;
  public:
  void clear_proposals();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_proposals();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::uint32 >&
      proposals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_proposals();

  // @@protoc_insertion_point(class_scope:zera_validator.Delegated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Delegated_ProposalsEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::uint32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      0 > proposals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class DelegateeWallets PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.DelegateeWallets) */ {
 public:
  inline DelegateeWallets() : DelegateeWallets(nullptr) {};
  virtual ~DelegateeWallets();

  DelegateeWallets(const DelegateeWallets& from);
  DelegateeWallets(DelegateeWallets&& from) noexcept
    : DelegateeWallets() {
    *this = ::std::move(from);
  }

  inline DelegateeWallets& operator=(const DelegateeWallets& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegateeWallets& operator=(DelegateeWallets&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DelegateeWallets& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DelegateeWallets* internal_default_instance() {
    return reinterpret_cast<const DelegateeWallets*>(
               &_DelegateeWallets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(DelegateeWallets& a, DelegateeWallets& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegateeWallets* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegateeWallets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegateeWallets* New() const final {
    return CreateMaybeMessage<DelegateeWallets>(nullptr);
  }

  DelegateeWallets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegateeWallets>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DelegateeWallets& from);
  void MergeFrom(const DelegateeWallets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegateeWallets* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.DelegateeWallets";
  }
  protected:
  explicit DelegateeWallets(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletAdrFieldNumber = 1,
  };
  // repeated bytes wallet_adr = 1;
  int wallet_adr_size() const;
  private:
  int _internal_wallet_adr_size() const;
  public:
  void clear_wallet_adr();
  const std::string& wallet_adr(int index) const;
  std::string* mutable_wallet_adr(int index);
  void set_wallet_adr(int index, const std::string& value);
  void set_wallet_adr(int index, std::string&& value);
  void set_wallet_adr(int index, const char* value);
  void set_wallet_adr(int index, const void* value, size_t size);
  std::string* add_wallet_adr();
  void add_wallet_adr(const std::string& value);
  void add_wallet_adr(std::string&& value);
  void add_wallet_adr(const char* value);
  void add_wallet_adr(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wallet_adr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wallet_adr();
  private:
  const std::string& _internal_wallet_adr(int index) const;
  std::string* _internal_add_wallet_adr();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.DelegateeWallets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wallet_adr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class Delegatees_DelegatedWalletsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Delegatees_DelegatedWalletsEntry_DoNotUse, 
    std::string, ::zera_validator::DelegateeWallets,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Delegatees_DelegatedWalletsEntry_DoNotUse, 
    std::string, ::zera_validator::DelegateeWallets,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Delegatees_DelegatedWalletsEntry_DoNotUse();
  Delegatees_DelegatedWalletsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Delegatees_DelegatedWalletsEntry_DoNotUse& other);
  static const Delegatees_DelegatedWalletsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Delegatees_DelegatedWalletsEntry_DoNotUse*>(&_Delegatees_DelegatedWalletsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.Delegatees.DelegatedWalletsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[60];
  }

  public:
};

// -------------------------------------------------------------------

class Delegatees PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.Delegatees) */ {
 public:
  inline Delegatees() : Delegatees(nullptr) {};
  virtual ~Delegatees();

  Delegatees(const Delegatees& from);
  Delegatees(Delegatees&& from) noexcept
    : Delegatees() {
    *this = ::std::move(from);
  }

  inline Delegatees& operator=(const Delegatees& from) {
    CopyFrom(from);
    return *this;
  }
  inline Delegatees& operator=(Delegatees&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Delegatees& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delegatees* internal_default_instance() {
    return reinterpret_cast<const Delegatees*>(
               &_Delegatees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(Delegatees& a, Delegatees& b) {
    a.Swap(&b);
  }
  inline void Swap(Delegatees* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Delegatees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Delegatees* New() const final {
    return CreateMaybeMessage<Delegatees>(nullptr);
  }

  Delegatees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Delegatees>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Delegatees& from);
  void MergeFrom(const Delegatees& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delegatees* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.Delegatees";
  }
  protected:
  explicit Delegatees(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDelegatedWalletsFieldNumber = 1,
  };
  // map<string, .zera_validator.DelegateeWallets> delegated_wallets = 1;
  int delegated_wallets_size() const;
  private:
  int _internal_delegated_wallets_size() const;
  public:
  void clear_delegated_wallets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::DelegateeWallets >&
      _internal_delegated_wallets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::DelegateeWallets >*
      _internal_mutable_delegated_wallets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::DelegateeWallets >&
      delegated_wallets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::DelegateeWallets >*
      mutable_delegated_wallets();

  // @@protoc_insertion_point(class_scope:zera_validator.Delegatees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Delegatees_DelegatedWalletsEntry_DoNotUse,
      std::string, ::zera_validator::DelegateeWallets,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > delegated_wallets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class DelegateWallets PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.DelegateWallets) */ {
 public:
  inline DelegateWallets() : DelegateWallets(nullptr) {};
  virtual ~DelegateWallets();

  DelegateWallets(const DelegateWallets& from);
  DelegateWallets(DelegateWallets&& from) noexcept
    : DelegateWallets() {
    *this = ::std::move(from);
  }

  inline DelegateWallets& operator=(const DelegateWallets& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegateWallets& operator=(DelegateWallets&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DelegateWallets& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DelegateWallets* internal_default_instance() {
    return reinterpret_cast<const DelegateWallets*>(
               &_DelegateWallets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(DelegateWallets& a, DelegateWallets& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegateWallets* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegateWallets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegateWallets* New() const final {
    return CreateMaybeMessage<DelegateWallets>(nullptr);
  }

  DelegateWallets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegateWallets>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DelegateWallets& from);
  void MergeFrom(const DelegateWallets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegateWallets* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.DelegateWallets";
  }
  protected:
  explicit DelegateWallets(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletsFieldNumber = 1,
  };
  // repeated bytes wallets = 1;
  int wallets_size() const;
  private:
  int _internal_wallets_size() const;
  public:
  void clear_wallets();
  const std::string& wallets(int index) const;
  std::string* mutable_wallets(int index);
  void set_wallets(int index, const std::string& value);
  void set_wallets(int index, std::string&& value);
  void set_wallets(int index, const char* value);
  void set_wallets(int index, const void* value, size_t size);
  std::string* add_wallets();
  void add_wallets(const std::string& value);
  void add_wallets(std::string&& value);
  void add_wallets(const char* value);
  void add_wallets(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wallets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wallets();
  private:
  const std::string& _internal_wallets(int index) const;
  std::string* _internal_add_wallets();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.DelegateWallets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wallets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class QuashLedger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.QuashLedger) */ {
 public:
  inline QuashLedger() : QuashLedger(nullptr) {};
  virtual ~QuashLedger();

  QuashLedger(const QuashLedger& from);
  QuashLedger(QuashLedger&& from) noexcept
    : QuashLedger() {
    *this = ::std::move(from);
  }

  inline QuashLedger& operator=(const QuashLedger& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuashLedger& operator=(QuashLedger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QuashLedger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuashLedger* internal_default_instance() {
    return reinterpret_cast<const QuashLedger*>(
               &_QuashLedger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(QuashLedger& a, QuashLedger& b) {
    a.Swap(&b);
  }
  inline void Swap(QuashLedger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuashLedger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QuashLedger* New() const final {
    return CreateMaybeMessage<QuashLedger>(nullptr);
  }

  QuashLedger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QuashLedger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QuashLedger& from);
  void MergeFrom(const QuashLedger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuashLedger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.QuashLedger";
  }
  protected:
  explicit QuashLedger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnIdsFieldNumber = 1,
  };
  // repeated bytes txn_ids = 1;
  int txn_ids_size() const;
  private:
  int _internal_txn_ids_size() const;
  public:
  void clear_txn_ids();
  const std::string& txn_ids(int index) const;
  std::string* mutable_txn_ids(int index);
  void set_txn_ids(int index, const std::string& value);
  void set_txn_ids(int index, std::string&& value);
  void set_txn_ids(int index, const char* value);
  void set_txn_ids(int index, const void* value, size_t size);
  std::string* add_txn_ids();
  void add_txn_ids(const std::string& value);
  void add_txn_ids(std::string&& value);
  void add_txn_ids(const char* value);
  void add_txn_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txn_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txn_ids();
  private:
  const std::string& _internal_txn_ids(int index) const;
  std::string* _internal_add_txn_ids();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.QuashLedger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txn_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class QuashLookup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.QuashLookup) */ {
 public:
  inline QuashLookup() : QuashLookup(nullptr) {};
  virtual ~QuashLookup();

  QuashLookup(const QuashLookup& from);
  QuashLookup(QuashLookup&& from) noexcept
    : QuashLookup() {
    *this = ::std::move(from);
  }

  inline QuashLookup& operator=(const QuashLookup& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuashLookup& operator=(QuashLookup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QuashLookup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuashLookup* internal_default_instance() {
    return reinterpret_cast<const QuashLookup*>(
               &_QuashLookup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(QuashLookup& a, QuashLookup& b) {
    a.Swap(&b);
  }
  inline void Swap(QuashLookup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuashLookup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QuashLookup* New() const final {
    return CreateMaybeMessage<QuashLookup>(nullptr);
  }

  QuashLookup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QuashLookup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QuashLookup& from);
  void MergeFrom(const QuashLookup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuashLookup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.QuashLookup";
  }
  protected:
  explicit QuashLookup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuashKeysFieldNumber = 1,
    kKeysRequiredFieldNumber = 2,
  };
  // repeated .zera_txn.PublicKey quash_keys = 1;
  int quash_keys_size() const;
  private:
  int _internal_quash_keys_size() const;
  public:
  void clear_quash_keys();
  ::zera_txn::PublicKey* mutable_quash_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >*
      mutable_quash_keys();
  private:
  const ::zera_txn::PublicKey& _internal_quash_keys(int index) const;
  ::zera_txn::PublicKey* _internal_add_quash_keys();
  public:
  const ::zera_txn::PublicKey& quash_keys(int index) const;
  ::zera_txn::PublicKey* add_quash_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >&
      quash_keys() const;

  // uint32 keys_required = 2;
  void clear_keys_required();
  ::PROTOBUF_NAMESPACE_ID::uint32 keys_required() const;
  void set_keys_required(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_keys_required() const;
  void _internal_set_keys_required(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.QuashLookup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey > quash_keys_;
  ::PROTOBUF_NAMESPACE_ID::uint32 keys_required_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ComplianceData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ComplianceData) */ {
 public:
  inline ComplianceData() : ComplianceData(nullptr) {};
  virtual ~ComplianceData();

  ComplianceData(const ComplianceData& from);
  ComplianceData(ComplianceData&& from) noexcept
    : ComplianceData() {
    *this = ::std::move(from);
  }

  inline ComplianceData& operator=(const ComplianceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComplianceData& operator=(ComplianceData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ComplianceData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComplianceData* internal_default_instance() {
    return reinterpret_cast<const ComplianceData*>(
               &_ComplianceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(ComplianceData& a, ComplianceData& b) {
    a.Swap(&b);
  }
  inline void Swap(ComplianceData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComplianceData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComplianceData* New() const final {
    return CreateMaybeMessage<ComplianceData>(nullptr);
  }

  ComplianceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComplianceData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ComplianceData& from);
  void MergeFrom(const ComplianceData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComplianceData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ComplianceData";
  }
  protected:
  explicit ComplianceData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpiryFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // .google.protobuf.Timestamp expiry = 2;
  bool has_expiry() const;
  private:
  bool _internal_has_expiry() const;
  public:
  void clear_expiry();
  const PROTOBUF_NAMESPACE_ID::Timestamp& expiry() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_expiry();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expiry();
  void set_allocated_expiry(PROTOBUF_NAMESPACE_ID::Timestamp* expiry);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expiry() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expiry();
  public:
  void unsafe_arena_set_allocated_expiry(
      PROTOBUF_NAMESPACE_ID::Timestamp* expiry);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expiry();

  // uint32 level = 1;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::uint32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.ComplianceData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* expiry_;
  ::PROTOBUF_NAMESPACE_ID::uint32 level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ComplianceLevels PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ComplianceLevels) */ {
 public:
  inline ComplianceLevels() : ComplianceLevels(nullptr) {};
  virtual ~ComplianceLevels();

  ComplianceLevels(const ComplianceLevels& from);
  ComplianceLevels(ComplianceLevels&& from) noexcept
    : ComplianceLevels() {
    *this = ::std::move(from);
  }

  inline ComplianceLevels& operator=(const ComplianceLevels& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComplianceLevels& operator=(ComplianceLevels&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ComplianceLevels& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComplianceLevels* internal_default_instance() {
    return reinterpret_cast<const ComplianceLevels*>(
               &_ComplianceLevels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(ComplianceLevels& a, ComplianceLevels& b) {
    a.Swap(&b);
  }
  inline void Swap(ComplianceLevels* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComplianceLevels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComplianceLevels* New() const final {
    return CreateMaybeMessage<ComplianceLevels>(nullptr);
  }

  ComplianceLevels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComplianceLevels>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ComplianceLevels& from);
  void MergeFrom(const ComplianceLevels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComplianceLevels* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ComplianceLevels";
  }
  protected:
  explicit ComplianceLevels(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelsFieldNumber = 1,
  };
  // repeated .zera_validator.ComplianceData levels = 1;
  int levels_size() const;
  private:
  int _internal_levels_size() const;
  public:
  void clear_levels();
  ::zera_validator::ComplianceData* mutable_levels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ComplianceData >*
      mutable_levels();
  private:
  const ::zera_validator::ComplianceData& _internal_levels(int index) const;
  ::zera_validator::ComplianceData* _internal_add_levels();
  public:
  const ::zera_validator::ComplianceData& levels(int index) const;
  ::zera_validator::ComplianceData* add_levels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ComplianceData >&
      levels() const;

  // @@protoc_insertion_point(class_scope:zera_validator.ComplianceLevels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ComplianceData > levels_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class WalletLookup_ComplianceEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WalletLookup_ComplianceEntry_DoNotUse, 
    std::string, ::zera_validator::ComplianceLevels,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WalletLookup_ComplianceEntry_DoNotUse, 
    std::string, ::zera_validator::ComplianceLevels,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  WalletLookup_ComplianceEntry_DoNotUse();
  WalletLookup_ComplianceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WalletLookup_ComplianceEntry_DoNotUse& other);
  static const WalletLookup_ComplianceEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WalletLookup_ComplianceEntry_DoNotUse*>(&_WalletLookup_ComplianceEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.WalletLookup.ComplianceEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[67];
  }

  public:
};

// -------------------------------------------------------------------

class WalletLookup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.WalletLookup) */ {
 public:
  inline WalletLookup() : WalletLookup(nullptr) {};
  virtual ~WalletLookup();

  WalletLookup(const WalletLookup& from);
  WalletLookup(WalletLookup&& from) noexcept
    : WalletLookup() {
    *this = ::std::move(from);
  }

  inline WalletLookup& operator=(const WalletLookup& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalletLookup& operator=(WalletLookup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WalletLookup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WalletLookup* internal_default_instance() {
    return reinterpret_cast<const WalletLookup*>(
               &_WalletLookup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(WalletLookup& a, WalletLookup& b) {
    a.Swap(&b);
  }
  inline void Swap(WalletLookup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalletLookup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WalletLookup* New() const final {
    return CreateMaybeMessage<WalletLookup>(nullptr);
  }

  WalletLookup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WalletLookup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WalletLookup& from);
  void MergeFrom(const WalletLookup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalletLookup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.WalletLookup";
  }
  protected:
  explicit WalletLookup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kComplianceFieldNumber = 1,
  };
  // map<string, .zera_validator.ComplianceLevels> compliance = 1;
  int compliance_size() const;
  private:
  int _internal_compliance_size() const;
  public:
  void clear_compliance();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ComplianceLevels >&
      _internal_compliance() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ComplianceLevels >*
      _internal_mutable_compliance();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ComplianceLevels >&
      compliance() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ComplianceLevels >*
      mutable_compliance();

  // @@protoc_insertion_point(class_scope:zera_validator.WalletLookup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      WalletLookup_ComplianceEntry_DoNotUse,
      std::string, ::zera_validator::ComplianceLevels,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > compliance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ProposalProcess PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ProposalProcess) */ {
 public:
  inline ProposalProcess() : ProposalProcess(nullptr) {};
  virtual ~ProposalProcess();

  ProposalProcess(const ProposalProcess& from);
  ProposalProcess(ProposalProcess&& from) noexcept
    : ProposalProcess() {
    *this = ::std::move(from);
  }

  inline ProposalProcess& operator=(const ProposalProcess& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalProcess& operator=(ProposalProcess&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProposalProcess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProposalProcess* internal_default_instance() {
    return reinterpret_cast<const ProposalProcess*>(
               &_ProposalProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(ProposalProcess& a, ProposalProcess& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalProcess* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalProcess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposalProcess* New() const final {
    return CreateMaybeMessage<ProposalProcess>(nullptr);
  }

  ProposalProcess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposalProcess>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProposalProcess& from);
  void MergeFrom(const ProposalProcess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalProcess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ProposalProcess";
  }
  protected:
  explicit ProposalProcess(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndDateFieldNumber = 4,
    kStartDateFieldNumber = 5,
    kTypeFieldNumber = 1,
    kStageFieldNumber = 2,
    kTotalStagesFieldNumber = 3,
  };
  // .google.protobuf.Timestamp end_date = 4;
  bool has_end_date() const;
  private:
  bool _internal_has_end_date() const;
  public:
  void clear_end_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& end_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_end_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_date();
  void set_allocated_end_date(PROTOBUF_NAMESPACE_ID::Timestamp* end_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_date();
  public:
  void unsafe_arena_set_allocated_end_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* end_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_date();

  // .google.protobuf.Timestamp start_date = 5;
  bool has_start_date() const;
  private:
  bool _internal_has_start_date() const;
  public:
  void clear_start_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& start_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_start_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_date();
  void set_allocated_start_date(PROTOBUF_NAMESPACE_ID::Timestamp* start_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_date();
  public:
  void unsafe_arena_set_allocated_start_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* start_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_date();

  // .zera_txn.GOVERNANCE_TYPE type = 1;
  void clear_type();
  ::zera_txn::GOVERNANCE_TYPE type() const;
  void set_type(::zera_txn::GOVERNANCE_TYPE value);
  private:
  ::zera_txn::GOVERNANCE_TYPE _internal_type() const;
  void _internal_set_type(::zera_txn::GOVERNANCE_TYPE value);
  public:

  // uint32 stage = 2;
  void clear_stage();
  ::PROTOBUF_NAMESPACE_ID::uint32 stage() const;
  void set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stage() const;
  void _internal_set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 total_stages = 3;
  void clear_total_stages();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_stages() const;
  void set_total_stages(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_total_stages() const;
  void _internal_set_total_stages(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.ProposalProcess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* end_date_;
  PROTOBUF_NAMESPACE_ID::Timestamp* start_date_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stage_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_stages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class TXNTracker PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.TXNTracker) */ {
 public:
  inline TXNTracker() : TXNTracker(nullptr) {};
  virtual ~TXNTracker();

  TXNTracker(const TXNTracker& from);
  TXNTracker(TXNTracker&& from) noexcept
    : TXNTracker() {
    *this = ::std::move(from);
  }

  inline TXNTracker& operator=(const TXNTracker& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXNTracker& operator=(TXNTracker&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TXNTracker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TXNTracker* internal_default_instance() {
    return reinterpret_cast<const TXNTracker*>(
               &_TXNTracker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(TXNTracker& a, TXNTracker& b) {
    a.Swap(&b);
  }
  inline void Swap(TXNTracker* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXNTracker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TXNTracker* New() const final {
    return CreateMaybeMessage<TXNTracker>(nullptr);
  }

  TXNTracker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TXNTracker>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TXNTracker& from);
  void MergeFrom(const TXNTracker& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXNTracker* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.TXNTracker";
  }
  protected:
  explicit TXNTracker(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnIdsFieldNumber = 1,
  };
  // repeated bytes txn_ids = 1;
  int txn_ids_size() const;
  private:
  int _internal_txn_ids_size() const;
  public:
  void clear_txn_ids();
  const std::string& txn_ids(int index) const;
  std::string* mutable_txn_ids(int index);
  void set_txn_ids(int index, const std::string& value);
  void set_txn_ids(int index, std::string&& value);
  void set_txn_ids(int index, const char* value);
  void set_txn_ids(int index, const void* value, size_t size);
  std::string* add_txn_ids();
  void add_txn_ids(const std::string& value);
  void add_txn_ids(std::string&& value);
  void add_txn_ids(const char* value);
  void add_txn_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txn_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txn_ids();
  private:
  const std::string& _internal_txn_ids(int index) const;
  std::string* _internal_add_txn_ids();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.TXNTracker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txn_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class PreProcessedWallets PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.PreProcessedWallets) */ {
 public:
  inline PreProcessedWallets() : PreProcessedWallets(nullptr) {};
  virtual ~PreProcessedWallets();

  PreProcessedWallets(const PreProcessedWallets& from);
  PreProcessedWallets(PreProcessedWallets&& from) noexcept
    : PreProcessedWallets() {
    *this = ::std::move(from);
  }

  inline PreProcessedWallets& operator=(const PreProcessedWallets& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreProcessedWallets& operator=(PreProcessedWallets&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PreProcessedWallets& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreProcessedWallets* internal_default_instance() {
    return reinterpret_cast<const PreProcessedWallets*>(
               &_PreProcessedWallets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(PreProcessedWallets& a, PreProcessedWallets& b) {
    a.Swap(&b);
  }
  inline void Swap(PreProcessedWallets* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreProcessedWallets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PreProcessedWallets* New() const final {
    return CreateMaybeMessage<PreProcessedWallets>(nullptr);
  }

  PreProcessedWallets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PreProcessedWallets>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PreProcessedWallets& from);
  void MergeFrom(const PreProcessedWallets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreProcessedWallets* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.PreProcessedWallets";
  }
  protected:
  explicit PreProcessedWallets(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 1,
  };
  // string amount = 1;
  void clear_amount();
  const std::string& amount() const;
  void set_amount(const std::string& value);
  void set_amount(std::string&& value);
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  std::string* mutable_amount();
  std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_amount();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_amount(
      std::string* amount);
  private:
  const std::string& _internal_amount() const;
  void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.PreProcessedWallets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ZeraGovernanceAuth PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ZeraGovernanceAuth) */ {
 public:
  inline ZeraGovernanceAuth() : ZeraGovernanceAuth(nullptr) {};
  virtual ~ZeraGovernanceAuth();

  ZeraGovernanceAuth(const ZeraGovernanceAuth& from);
  ZeraGovernanceAuth(ZeraGovernanceAuth&& from) noexcept
    : ZeraGovernanceAuth() {
    *this = ::std::move(from);
  }

  inline ZeraGovernanceAuth& operator=(const ZeraGovernanceAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZeraGovernanceAuth& operator=(ZeraGovernanceAuth&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ZeraGovernanceAuth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZeraGovernanceAuth* internal_default_instance() {
    return reinterpret_cast<const ZeraGovernanceAuth*>(
               &_ZeraGovernanceAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ZeraGovernanceAuth& a, ZeraGovernanceAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(ZeraGovernanceAuth* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZeraGovernanceAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ZeraGovernanceAuth* New() const final {
    return CreateMaybeMessage<ZeraGovernanceAuth>(nullptr);
  }

  ZeraGovernanceAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ZeraGovernanceAuth>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ZeraGovernanceAuth& from);
  void MergeFrom(const ZeraGovernanceAuth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZeraGovernanceAuth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ZeraGovernanceAuth";
  }
  protected:
  explicit ZeraGovernanceAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // .zera_txn.TRANSACTION_TYPE type = 2;
  void clear_type();
  ::zera_txn::TRANSACTION_TYPE type() const;
  void set_type(::zera_txn::TRANSACTION_TYPE value);
  private:
  ::zera_txn::TRANSACTION_TYPE _internal_type() const;
  void _internal_set_type(::zera_txn::TRANSACTION_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.ZeraGovernanceAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zera_txn::PublicKey* public_key_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class ContractPrice PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.ContractPrice) */ {
 public:
  inline ContractPrice() : ContractPrice(nullptr) {};
  virtual ~ContractPrice();

  ContractPrice(const ContractPrice& from);
  ContractPrice(ContractPrice&& from) noexcept
    : ContractPrice() {
    *this = ::std::move(from);
  }

  inline ContractPrice& operator=(const ContractPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractPrice& operator=(ContractPrice&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractPrice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractPrice* internal_default_instance() {
    return reinterpret_cast<const ContractPrice*>(
               &_ContractPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ContractPrice& a, ContractPrice& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractPrice* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractPrice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractPrice* New() const final {
    return CreateMaybeMessage<ContractPrice>(nullptr);
  }

  ContractPrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractPrice>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractPrice& from);
  void MergeFrom(const ContractPrice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractPrice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.ContractPrice";
  }
  protected:
  explicit ContractPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kMultiplierFieldNumber = 3,
    kNumberOfSymbolsFieldNumber = 2,
  };
  // string symbol = 1;
  void clear_symbol();
  const std::string& symbol() const;
  void set_symbol(const std::string& value);
  void set_symbol(std::string&& value);
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  std::string* mutable_symbol();
  std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_symbol();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symbol(
      std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string multiplier = 3;
  void clear_multiplier();
  const std::string& multiplier() const;
  void set_multiplier(const std::string& value);
  void set_multiplier(std::string&& value);
  void set_multiplier(const char* value);
  void set_multiplier(const char* value, size_t size);
  std::string* mutable_multiplier();
  std::string* release_multiplier();
  void set_allocated_multiplier(std::string* multiplier);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_multiplier();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_multiplier(
      std::string* multiplier);
  private:
  const std::string& _internal_multiplier() const;
  void _internal_set_multiplier(const std::string& value);
  std::string* _internal_mutable_multiplier();
  public:

  // uint32 number_of_symbols = 2;
  void clear_number_of_symbols();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_symbols() const;
  void set_number_of_symbols(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_number_of_symbols() const;
  void _internal_set_number_of_symbols(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.ContractPrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multiplier_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_symbols_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class BalanceTracker_WalletBalancesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BalanceTracker_WalletBalancesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BalanceTracker_WalletBalancesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  BalanceTracker_WalletBalancesEntry_DoNotUse();
  BalanceTracker_WalletBalancesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BalanceTracker_WalletBalancesEntry_DoNotUse& other);
  static const BalanceTracker_WalletBalancesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BalanceTracker_WalletBalancesEntry_DoNotUse*>(&_BalanceTracker_WalletBalancesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.BalanceTracker.WalletBalancesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zera_validator.BalanceTracker.WalletBalancesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[74];
  }

  public:
};

// -------------------------------------------------------------------

class BalanceTracker PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.BalanceTracker) */ {
 public:
  inline BalanceTracker() : BalanceTracker(nullptr) {};
  virtual ~BalanceTracker();

  BalanceTracker(const BalanceTracker& from);
  BalanceTracker(BalanceTracker&& from) noexcept
    : BalanceTracker() {
    *this = ::std::move(from);
  }

  inline BalanceTracker& operator=(const BalanceTracker& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceTracker& operator=(BalanceTracker&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BalanceTracker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BalanceTracker* internal_default_instance() {
    return reinterpret_cast<const BalanceTracker*>(
               &_BalanceTracker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(BalanceTracker& a, BalanceTracker& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceTracker* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceTracker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BalanceTracker* New() const final {
    return CreateMaybeMessage<BalanceTracker>(nullptr);
  }

  BalanceTracker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BalanceTracker>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BalanceTracker& from);
  void MergeFrom(const BalanceTracker& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceTracker* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.BalanceTracker";
  }
  protected:
  explicit BalanceTracker(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kWalletBalancesFieldNumber = 1,
  };
  // map<string, string> wallet_balances = 1;
  int wallet_balances_size() const;
  private:
  int _internal_wallet_balances_size() const;
  public:
  void clear_wallet_balances();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_wallet_balances() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_wallet_balances();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      wallet_balances() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_wallet_balances();

  // @@protoc_insertion_point(class_scope:zera_validator.BalanceTracker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      BalanceTracker_WalletBalancesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > wallet_balances_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class TokenLookup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.TokenLookup) */ {
 public:
  inline TokenLookup() : TokenLookup(nullptr) {};
  virtual ~TokenLookup();

  TokenLookup(const TokenLookup& from);
  TokenLookup(TokenLookup&& from) noexcept
    : TokenLookup() {
    *this = ::std::move(from);
  }

  inline TokenLookup& operator=(const TokenLookup& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenLookup& operator=(TokenLookup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TokenLookup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TokenLookup* internal_default_instance() {
    return reinterpret_cast<const TokenLookup*>(
               &_TokenLookup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(TokenLookup& a, TokenLookup& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenLookup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenLookup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TokenLookup* New() const final {
    return CreateMaybeMessage<TokenLookup>(nullptr);
  }

  TokenLookup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TokenLookup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TokenLookup& from);
  void MergeFrom(const TokenLookup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenLookup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.TokenLookup";
  }
  protected:
  explicit TokenLookup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 1,
  };
  // repeated string tokens = 1;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  const std::string& tokens(int index) const;
  std::string* mutable_tokens(int index);
  void set_tokens(int index, const std::string& value);
  void set_tokens(int index, std::string&& value);
  void set_tokens(int index, const char* value);
  void set_tokens(int index, const char* value, size_t size);
  std::string* add_tokens();
  void add_tokens(const std::string& value);
  void add_tokens(std::string&& value);
  void add_tokens(const char* value);
  void add_tokens(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tokens() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tokens();
  private:
  const std::string& _internal_tokens(int index) const;
  std::string* _internal_add_tokens();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.TokenLookup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tokens_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class BalanceRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.BalanceRequest) */ {
 public:
  inline BalanceRequest() : BalanceRequest(nullptr) {};
  virtual ~BalanceRequest();

  BalanceRequest(const BalanceRequest& from);
  BalanceRequest(BalanceRequest&& from) noexcept
    : BalanceRequest() {
    *this = ::std::move(from);
  }

  inline BalanceRequest& operator=(const BalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceRequest& operator=(BalanceRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BalanceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BalanceRequest* internal_default_instance() {
    return reinterpret_cast<const BalanceRequest*>(
               &_BalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(BalanceRequest& a, BalanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BalanceRequest* New() const final {
    return CreateMaybeMessage<BalanceRequest>(nullptr);
  }

  BalanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BalanceRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BalanceRequest& from);
  void MergeFrom(const BalanceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.BalanceRequest";
  }
  protected:
  explicit BalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletAddressFieldNumber = 1,
    kContractIdFieldNumber = 2,
    kEncodedFieldNumber = 3,
  };
  // bytes wallet_address = 1;
  void clear_wallet_address();
  const std::string& wallet_address() const;
  void set_wallet_address(const std::string& value);
  void set_wallet_address(std::string&& value);
  void set_wallet_address(const char* value);
  void set_wallet_address(const void* value, size_t size);
  std::string* mutable_wallet_address();
  std::string* release_wallet_address();
  void set_allocated_wallet_address(std::string* wallet_address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_wallet_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_wallet_address(
      std::string* wallet_address);
  private:
  const std::string& _internal_wallet_address() const;
  void _internal_set_wallet_address(const std::string& value);
  std::string* _internal_mutable_wallet_address();
  public:

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  void set_contract_id(const std::string& value);
  void set_contract_id(std::string&& value);
  void set_contract_id(const char* value);
  void set_contract_id(const char* value, size_t size);
  std::string* mutable_contract_id();
  std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_contract_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_contract_id(
      std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bool encoded = 3;
  void clear_encoded();
  bool encoded() const;
  void set_encoded(bool value);
  private:
  bool _internal_encoded() const;
  void _internal_set_encoded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.BalanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  bool encoded_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class BalanceResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.BalanceResponse) */ {
 public:
  inline BalanceResponse() : BalanceResponse(nullptr) {};
  virtual ~BalanceResponse();

  BalanceResponse(const BalanceResponse& from);
  BalanceResponse(BalanceResponse&& from) noexcept
    : BalanceResponse() {
    *this = ::std::move(from);
  }

  inline BalanceResponse& operator=(const BalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceResponse& operator=(BalanceResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BalanceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BalanceResponse* internal_default_instance() {
    return reinterpret_cast<const BalanceResponse*>(
               &_BalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(BalanceResponse& a, BalanceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BalanceResponse* New() const final {
    return CreateMaybeMessage<BalanceResponse>(nullptr);
  }

  BalanceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BalanceResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BalanceResponse& from);
  void MergeFrom(const BalanceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.BalanceResponse";
  }
  protected:
  explicit BalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceFieldNumber = 1,
  };
  // string balance = 1;
  void clear_balance();
  const std::string& balance() const;
  void set_balance(const std::string& value);
  void set_balance(std::string&& value);
  void set_balance(const char* value);
  void set_balance(const char* value, size_t size);
  std::string* mutable_balance();
  std::string* release_balance();
  void set_allocated_balance(std::string* balance);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_balance();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_balance(
      std::string* balance);
  private:
  const std::string& _internal_balance() const;
  void _internal_set_balance(const std::string& value);
  std::string* _internal_mutable_balance();
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.BalanceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class TXN PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.TXN) */ {
 public:
  inline TXN() : TXN(nullptr) {};
  virtual ~TXN();

  TXN(const TXN& from);
  TXN(TXN&& from) noexcept
    : TXN() {
    *this = ::std::move(from);
  }

  inline TXN& operator=(const TXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXN& operator=(TXN&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TXN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TXN* internal_default_instance() {
    return reinterpret_cast<const TXN*>(
               &_TXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(TXN& a, TXN& b) {
    a.Swap(&b);
  }
  inline void Swap(TXN* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TXN* New() const final {
    return CreateMaybeMessage<TXN>(nullptr);
  }

  TXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TXN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TXN& from);
  void MergeFrom(const TXN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.TXN";
  }
  protected:
  explicit TXN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedTxnFieldNumber = 2,
    kTxnTypeFieldNumber = 1,
  };
  // bytes serialized_txn = 2;
  void clear_serialized_txn();
  const std::string& serialized_txn() const;
  void set_serialized_txn(const std::string& value);
  void set_serialized_txn(std::string&& value);
  void set_serialized_txn(const char* value);
  void set_serialized_txn(const void* value, size_t size);
  std::string* mutable_serialized_txn();
  std::string* release_serialized_txn();
  void set_allocated_serialized_txn(std::string* serialized_txn);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_serialized_txn();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_serialized_txn(
      std::string* serialized_txn);
  private:
  const std::string& _internal_serialized_txn() const;
  void _internal_set_serialized_txn(const std::string& value);
  std::string* _internal_mutable_serialized_txn();
  public:

  // .zera_txn.TRANSACTION_TYPE txn_type = 1;
  void clear_txn_type();
  ::zera_txn::TRANSACTION_TYPE txn_type() const;
  void set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  private:
  ::zera_txn::TRANSACTION_TYPE _internal_txn_type() const;
  void _internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_validator.TXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_txn_;
  int txn_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// -------------------------------------------------------------------

class TXNGossip PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_validator.TXNGossip) */ {
 public:
  inline TXNGossip() : TXNGossip(nullptr) {};
  virtual ~TXNGossip();

  TXNGossip(const TXNGossip& from);
  TXNGossip(TXNGossip&& from) noexcept
    : TXNGossip() {
    *this = ::std::move(from);
  }

  inline TXNGossip& operator=(const TXNGossip& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXNGossip& operator=(TXNGossip&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TXNGossip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TXNGossip* internal_default_instance() {
    return reinterpret_cast<const TXNGossip*>(
               &_TXNGossip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(TXNGossip& a, TXNGossip& b) {
    a.Swap(&b);
  }
  inline void Swap(TXNGossip* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXNGossip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TXNGossip* New() const final {
    return CreateMaybeMessage<TXNGossip>(nullptr);
  }

  TXNGossip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TXNGossip>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TXNGossip& from);
  void MergeFrom(const TXNGossip& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXNGossip* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_validator.TXNGossip";
  }
  protected:
  explicit TXNGossip(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_validator_2eproto);
    return ::descriptor_table_validator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnsFieldNumber = 1,
  };
  // repeated .zera_validator.TXN txns = 1;
  int txns_size() const;
  private:
  int _internal_txns_size() const;
  public:
  void clear_txns();
  ::zera_validator::TXN* mutable_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::TXN >*
      mutable_txns();
  private:
  const ::zera_validator::TXN& _internal_txns(int index) const;
  ::zera_validator::TXN* _internal_add_txns();
  public:
  const ::zera_validator::TXN& txns(int index) const;
  ::zera_validator::TXN* add_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::TXN >&
      txns() const;

  // @@protoc_insertion_point(class_scope:zera_validator.TXNGossip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::TXN > txns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_validator_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AllowanceState

// string allowed_currency_equivelent = 1;
inline bool AllowanceState::_internal_has_allowed_currency_equivelent() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllowanceState::has_allowed_currency_equivelent() const {
  return _internal_has_allowed_currency_equivelent();
}
inline void AllowanceState::clear_allowed_currency_equivelent() {
  allowed_currency_equivelent_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllowanceState::allowed_currency_equivelent() const {
  // @@protoc_insertion_point(field_get:zera_validator.AllowanceState.allowed_currency_equivelent)
  return _internal_allowed_currency_equivelent();
}
inline void AllowanceState::set_allowed_currency_equivelent(const std::string& value) {
  _internal_set_allowed_currency_equivelent(value);
  // @@protoc_insertion_point(field_set:zera_validator.AllowanceState.allowed_currency_equivelent)
}
inline std::string* AllowanceState::mutable_allowed_currency_equivelent() {
  // @@protoc_insertion_point(field_mutable:zera_validator.AllowanceState.allowed_currency_equivelent)
  return _internal_mutable_allowed_currency_equivelent();
}
inline const std::string& AllowanceState::_internal_allowed_currency_equivelent() const {
  return allowed_currency_equivelent_.Get();
}
inline void AllowanceState::_internal_set_allowed_currency_equivelent(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  allowed_currency_equivelent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AllowanceState::set_allowed_currency_equivelent(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  allowed_currency_equivelent_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.AllowanceState.allowed_currency_equivelent)
}
inline void AllowanceState::set_allowed_currency_equivelent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  allowed_currency_equivelent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.AllowanceState.allowed_currency_equivelent)
}
inline void AllowanceState::set_allowed_currency_equivelent(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  allowed_currency_equivelent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.AllowanceState.allowed_currency_equivelent)
}
inline std::string* AllowanceState::_internal_mutable_allowed_currency_equivelent() {
  _has_bits_[0] |= 0x00000001u;
  return allowed_currency_equivelent_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AllowanceState::release_allowed_currency_equivelent() {
  // @@protoc_insertion_point(field_release:zera_validator.AllowanceState.allowed_currency_equivelent)
  if (!_internal_has_allowed_currency_equivelent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return allowed_currency_equivelent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllowanceState::set_allocated_allowed_currency_equivelent(std::string* allowed_currency_equivelent) {
  if (allowed_currency_equivelent != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  allowed_currency_equivelent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), allowed_currency_equivelent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.AllowanceState.allowed_currency_equivelent)
}
inline std::string* AllowanceState::unsafe_arena_release_allowed_currency_equivelent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.AllowanceState.allowed_currency_equivelent)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return allowed_currency_equivelent_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AllowanceState::unsafe_arena_set_allocated_allowed_currency_equivelent(
    std::string* allowed_currency_equivelent) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (allowed_currency_equivelent != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  allowed_currency_equivelent_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      allowed_currency_equivelent, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.AllowanceState.allowed_currency_equivelent)
}

// string allowed_amount = 2;
inline bool AllowanceState::_internal_has_allowed_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AllowanceState::has_allowed_amount() const {
  return _internal_has_allowed_amount();
}
inline void AllowanceState::clear_allowed_amount() {
  allowed_amount_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AllowanceState::allowed_amount() const {
  // @@protoc_insertion_point(field_get:zera_validator.AllowanceState.allowed_amount)
  return _internal_allowed_amount();
}
inline void AllowanceState::set_allowed_amount(const std::string& value) {
  _internal_set_allowed_amount(value);
  // @@protoc_insertion_point(field_set:zera_validator.AllowanceState.allowed_amount)
}
inline std::string* AllowanceState::mutable_allowed_amount() {
  // @@protoc_insertion_point(field_mutable:zera_validator.AllowanceState.allowed_amount)
  return _internal_mutable_allowed_amount();
}
inline const std::string& AllowanceState::_internal_allowed_amount() const {
  return allowed_amount_.Get();
}
inline void AllowanceState::_internal_set_allowed_amount(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  allowed_amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AllowanceState::set_allowed_amount(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  allowed_amount_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.AllowanceState.allowed_amount)
}
inline void AllowanceState::set_allowed_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  allowed_amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.AllowanceState.allowed_amount)
}
inline void AllowanceState::set_allowed_amount(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  allowed_amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.AllowanceState.allowed_amount)
}
inline std::string* AllowanceState::_internal_mutable_allowed_amount() {
  _has_bits_[0] |= 0x00000002u;
  return allowed_amount_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AllowanceState::release_allowed_amount() {
  // @@protoc_insertion_point(field_release:zera_validator.AllowanceState.allowed_amount)
  if (!_internal_has_allowed_amount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return allowed_amount_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllowanceState::set_allocated_allowed_amount(std::string* allowed_amount) {
  if (allowed_amount != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  allowed_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), allowed_amount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.AllowanceState.allowed_amount)
}
inline std::string* AllowanceState::unsafe_arena_release_allowed_amount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.AllowanceState.allowed_amount)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return allowed_amount_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AllowanceState::unsafe_arena_set_allocated_allowed_amount(
    std::string* allowed_amount) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (allowed_amount != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  allowed_amount_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      allowed_amount, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.AllowanceState.allowed_amount)
}

// uint32 period_months = 3;
inline bool AllowanceState::_internal_has_period_months() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AllowanceState::has_period_months() const {
  return _internal_has_period_months();
}
inline void AllowanceState::clear_period_months() {
  period_months_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllowanceState::_internal_period_months() const {
  return period_months_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllowanceState::period_months() const {
  // @@protoc_insertion_point(field_get:zera_validator.AllowanceState.period_months)
  return _internal_period_months();
}
inline void AllowanceState::_internal_set_period_months(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  period_months_ = value;
}
inline void AllowanceState::set_period_months(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_period_months(value);
  // @@protoc_insertion_point(field_set:zera_validator.AllowanceState.period_months)
}

// uint32 period_seconds = 4;
inline bool AllowanceState::_internal_has_period_seconds() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AllowanceState::has_period_seconds() const {
  return _internal_has_period_seconds();
}
inline void AllowanceState::clear_period_seconds() {
  period_seconds_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllowanceState::_internal_period_seconds() const {
  return period_seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllowanceState::period_seconds() const {
  // @@protoc_insertion_point(field_get:zera_validator.AllowanceState.period_seconds)
  return _internal_period_seconds();
}
inline void AllowanceState::_internal_set_period_seconds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  period_seconds_ = value;
}
inline void AllowanceState::set_period_seconds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_period_seconds(value);
  // @@protoc_insertion_point(field_set:zera_validator.AllowanceState.period_seconds)
}

// .google.protobuf.Timestamp period_end = 5;
inline bool AllowanceState::_internal_has_period_end() const {
  return this != internal_default_instance() && period_end_ != nullptr;
}
inline bool AllowanceState::has_period_end() const {
  return _internal_has_period_end();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& AllowanceState::_internal_period_end() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = period_end_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& AllowanceState::period_end() const {
  // @@protoc_insertion_point(field_get:zera_validator.AllowanceState.period_end)
  return _internal_period_end();
}
inline void AllowanceState::unsafe_arena_set_allocated_period_end(
    PROTOBUF_NAMESPACE_ID::Timestamp* period_end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(period_end_);
  }
  period_end_ = period_end;
  if (period_end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.AllowanceState.period_end)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceState::release_period_end() {
  auto temp = unsafe_arena_release_period_end();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceState::unsafe_arena_release_period_end() {
  // @@protoc_insertion_point(field_release:zera_validator.AllowanceState.period_end)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = period_end_;
  period_end_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceState::_internal_mutable_period_end() {
  
  if (period_end_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    period_end_ = p;
  }
  return period_end_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceState::mutable_period_end() {
  // @@protoc_insertion_point(field_mutable:zera_validator.AllowanceState.period_end)
  return _internal_mutable_period_end();
}
inline void AllowanceState::set_allocated_period_end(PROTOBUF_NAMESPACE_ID::Timestamp* period_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(period_end_);
  }
  if (period_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(period_end)->GetArena();
    if (message_arena != submessage_arena) {
      period_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, period_end, submessage_arena);
    }
    
  } else {
    
  }
  period_end_ = period_end;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.AllowanceState.period_end)
}

// .google.protobuf.Timestamp start_time = 6;
inline bool AllowanceState::_internal_has_start_time() const {
  return this != internal_default_instance() && start_time_ != nullptr;
}
inline bool AllowanceState::has_start_time() const {
  return _internal_has_start_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& AllowanceState::_internal_start_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = start_time_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& AllowanceState::start_time() const {
  // @@protoc_insertion_point(field_get:zera_validator.AllowanceState.start_time)
  return _internal_start_time();
}
inline void AllowanceState::unsafe_arena_set_allocated_start_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.AllowanceState.start_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceState::release_start_time() {
  auto temp = unsafe_arena_release_start_time();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceState::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:zera_validator.AllowanceState.start_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_time_;
  start_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceState::_internal_mutable_start_time() {
  
  if (start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    start_time_ = p;
  }
  return start_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceState::mutable_start_time() {
  // @@protoc_insertion_point(field_mutable:zera_validator.AllowanceState.start_time)
  return _internal_mutable_start_time();
}
inline void AllowanceState::set_allocated_start_time(PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.AllowanceState.start_time)
}

// uint64 nonce = 7;
inline void AllowanceState::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AllowanceState::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AllowanceState::nonce() const {
  // @@protoc_insertion_point(field_get:zera_validator.AllowanceState.nonce)
  return _internal_nonce();
}
inline void AllowanceState::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nonce_ = value;
}
inline void AllowanceState::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:zera_validator.AllowanceState.nonce)
}

// bool authorize = 8;
inline void AllowanceState::clear_authorize() {
  authorize_ = false;
}
inline bool AllowanceState::_internal_authorize() const {
  return authorize_;
}
inline bool AllowanceState::authorize() const {
  // @@protoc_insertion_point(field_get:zera_validator.AllowanceState.authorize)
  return _internal_authorize();
}
inline void AllowanceState::_internal_set_authorize(bool value) {
  
  authorize_ = value;
}
inline void AllowanceState::set_authorize(bool value) {
  _internal_set_authorize(value);
  // @@protoc_insertion_point(field_set:zera_validator.AllowanceState.authorize)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StakeMultipliers

// map<string, string> contract_multipliers = 1;
inline int StakeMultipliers::_internal_contract_multipliers_size() const {
  return contract_multipliers_.size();
}
inline int StakeMultipliers::contract_multipliers_size() const {
  return _internal_contract_multipliers_size();
}
inline void StakeMultipliers::clear_contract_multipliers() {
  contract_multipliers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StakeMultipliers::_internal_contract_multipliers() const {
  return contract_multipliers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StakeMultipliers::contract_multipliers() const {
  // @@protoc_insertion_point(field_map:zera_validator.StakeMultipliers.contract_multipliers)
  return _internal_contract_multipliers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StakeMultipliers::_internal_mutable_contract_multipliers() {
  return contract_multipliers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StakeMultipliers::mutable_contract_multipliers() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.StakeMultipliers.contract_multipliers)
  return _internal_mutable_contract_multipliers();
}

// string default_multiplier = 2;
inline void StakeMultipliers::clear_default_multiplier() {
  default_multiplier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& StakeMultipliers::default_multiplier() const {
  // @@protoc_insertion_point(field_get:zera_validator.StakeMultipliers.default_multiplier)
  return _internal_default_multiplier();
}
inline void StakeMultipliers::set_default_multiplier(const std::string& value) {
  _internal_set_default_multiplier(value);
  // @@protoc_insertion_point(field_set:zera_validator.StakeMultipliers.default_multiplier)
}
inline std::string* StakeMultipliers::mutable_default_multiplier() {
  // @@protoc_insertion_point(field_mutable:zera_validator.StakeMultipliers.default_multiplier)
  return _internal_mutable_default_multiplier();
}
inline const std::string& StakeMultipliers::_internal_default_multiplier() const {
  return default_multiplier_.Get();
}
inline void StakeMultipliers::_internal_set_default_multiplier(const std::string& value) {
  
  default_multiplier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StakeMultipliers::set_default_multiplier(std::string&& value) {
  
  default_multiplier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.StakeMultipliers.default_multiplier)
}
inline void StakeMultipliers::set_default_multiplier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  default_multiplier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.StakeMultipliers.default_multiplier)
}
inline void StakeMultipliers::set_default_multiplier(const char* value,
    size_t size) {
  
  default_multiplier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.StakeMultipliers.default_multiplier)
}
inline std::string* StakeMultipliers::_internal_mutable_default_multiplier() {
  
  return default_multiplier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StakeMultipliers::release_default_multiplier() {
  // @@protoc_insertion_point(field_release:zera_validator.StakeMultipliers.default_multiplier)
  return default_multiplier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StakeMultipliers::set_allocated_default_multiplier(std::string* default_multiplier) {
  if (default_multiplier != nullptr) {
    
  } else {
    
  }
  default_multiplier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_multiplier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.StakeMultipliers.default_multiplier)
}
inline std::string* StakeMultipliers::unsafe_arena_release_default_multiplier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.StakeMultipliers.default_multiplier)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return default_multiplier_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StakeMultipliers::unsafe_arena_set_allocated_default_multiplier(
    std::string* default_multiplier) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (default_multiplier != nullptr) {
    
  } else {
    
  }
  default_multiplier_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      default_multiplier, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.StakeMultipliers.default_multiplier)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ValidatorArchive

// map<string, .zera_validator.ValidatorBalance> validators = 1;
inline int ValidatorArchive::_internal_validators_size() const {
  return validators_.size();
}
inline int ValidatorArchive::validators_size() const {
  return _internal_validators_size();
}
inline void ValidatorArchive::clear_validators() {
  validators_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ValidatorBalance >&
ValidatorArchive::_internal_validators() const {
  return validators_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ValidatorBalance >&
ValidatorArchive::validators() const {
  // @@protoc_insertion_point(field_map:zera_validator.ValidatorArchive.validators)
  return _internal_validators();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ValidatorBalance >*
ValidatorArchive::_internal_mutable_validators() {
  return validators_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ValidatorBalance >*
ValidatorArchive::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.ValidatorArchive.validators)
  return _internal_mutable_validators();
}

// string total_balance = 2;
inline void ValidatorArchive::clear_total_balance() {
  total_balance_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ValidatorArchive::total_balance() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorArchive.total_balance)
  return _internal_total_balance();
}
inline void ValidatorArchive::set_total_balance(const std::string& value) {
  _internal_set_total_balance(value);
  // @@protoc_insertion_point(field_set:zera_validator.ValidatorArchive.total_balance)
}
inline std::string* ValidatorArchive::mutable_total_balance() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorArchive.total_balance)
  return _internal_mutable_total_balance();
}
inline const std::string& ValidatorArchive::_internal_total_balance() const {
  return total_balance_.Get();
}
inline void ValidatorArchive::_internal_set_total_balance(const std::string& value) {
  
  total_balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidatorArchive::set_total_balance(std::string&& value) {
  
  total_balance_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ValidatorArchive.total_balance)
}
inline void ValidatorArchive::set_total_balance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  total_balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ValidatorArchive.total_balance)
}
inline void ValidatorArchive::set_total_balance(const char* value,
    size_t size) {
  
  total_balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ValidatorArchive.total_balance)
}
inline std::string* ValidatorArchive::_internal_mutable_total_balance() {
  
  return total_balance_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidatorArchive::release_total_balance() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorArchive.total_balance)
  return total_balance_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorArchive::set_allocated_total_balance(std::string* total_balance) {
  if (total_balance != nullptr) {
    
  } else {
    
  }
  total_balance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), total_balance,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorArchive.total_balance)
}
inline std::string* ValidatorArchive::unsafe_arena_release_total_balance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ValidatorArchive.total_balance)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return total_balance_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidatorArchive::unsafe_arena_set_allocated_total_balance(
    std::string* total_balance) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (total_balance != nullptr) {
    
  } else {
    
  }
  total_balance_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      total_balance, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorArchive.total_balance)
}

// -------------------------------------------------------------------

// ValidatorBalance

// .zera_txn.PublicKey public_key = 1;
inline bool ValidatorBalance::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool ValidatorBalance::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& ValidatorBalance::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& ValidatorBalance::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorBalance.public_key)
  return _internal_public_key();
}
inline void ValidatorBalance::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorBalance.public_key)
}
inline ::zera_txn::PublicKey* ValidatorBalance::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorBalance::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorBalance.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorBalance::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* ValidatorBalance::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorBalance.public_key)
  return _internal_mutable_public_key();
}
inline void ValidatorBalance::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorBalance.public_key)
}

// string total_balance = 2;
inline void ValidatorBalance::clear_total_balance() {
  total_balance_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ValidatorBalance::total_balance() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorBalance.total_balance)
  return _internal_total_balance();
}
inline void ValidatorBalance::set_total_balance(const std::string& value) {
  _internal_set_total_balance(value);
  // @@protoc_insertion_point(field_set:zera_validator.ValidatorBalance.total_balance)
}
inline std::string* ValidatorBalance::mutable_total_balance() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorBalance.total_balance)
  return _internal_mutable_total_balance();
}
inline const std::string& ValidatorBalance::_internal_total_balance() const {
  return total_balance_.Get();
}
inline void ValidatorBalance::_internal_set_total_balance(const std::string& value) {
  
  total_balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidatorBalance::set_total_balance(std::string&& value) {
  
  total_balance_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ValidatorBalance.total_balance)
}
inline void ValidatorBalance::set_total_balance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  total_balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ValidatorBalance.total_balance)
}
inline void ValidatorBalance::set_total_balance(const char* value,
    size_t size) {
  
  total_balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ValidatorBalance.total_balance)
}
inline std::string* ValidatorBalance::_internal_mutable_total_balance() {
  
  return total_balance_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidatorBalance::release_total_balance() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorBalance.total_balance)
  return total_balance_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorBalance::set_allocated_total_balance(std::string* total_balance) {
  if (total_balance != nullptr) {
    
  } else {
    
  }
  total_balance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), total_balance,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorBalance.total_balance)
}
inline std::string* ValidatorBalance::unsafe_arena_release_total_balance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ValidatorBalance.total_balance)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return total_balance_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidatorBalance::unsafe_arena_set_allocated_total_balance(
    std::string* total_balance) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (total_balance != nullptr) {
    
  } else {
    
  }
  total_balance_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      total_balance, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorBalance.total_balance)
}

// -------------------------------------------------------------------

// BlockAttestationResponse

// bool support = 1;
inline void BlockAttestationResponse::clear_support() {
  support_ = false;
}
inline bool BlockAttestationResponse::_internal_support() const {
  return support_;
}
inline bool BlockAttestationResponse::support() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestationResponse.support)
  return _internal_support();
}
inline void BlockAttestationResponse::_internal_set_support(bool value) {
  
  support_ = value;
}
inline void BlockAttestationResponse::set_support(bool value) {
  _internal_set_support(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestationResponse.support)
}

// bool no_preference = 2;
inline void BlockAttestationResponse::clear_no_preference() {
  no_preference_ = false;
}
inline bool BlockAttestationResponse::_internal_no_preference() const {
  return no_preference_;
}
inline bool BlockAttestationResponse::no_preference() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestationResponse.no_preference)
  return _internal_no_preference();
}
inline void BlockAttestationResponse::_internal_set_no_preference(bool value) {
  
  no_preference_ = value;
}
inline void BlockAttestationResponse::set_no_preference(bool value) {
  _internal_set_no_preference(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestationResponse.no_preference)
}

// .zera_validator.Block supported_block = 3;
inline bool BlockAttestationResponse::_internal_has_supported_block() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || supported_block_ != nullptr);
  return value;
}
inline bool BlockAttestationResponse::has_supported_block() const {
  return _internal_has_supported_block();
}
inline void BlockAttestationResponse::clear_supported_block() {
  if (GetArena() == nullptr && supported_block_ != nullptr) {
    delete supported_block_;
  }
  supported_block_ = nullptr;
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::zera_validator::Block& BlockAttestationResponse::_internal_supported_block() const {
  const ::zera_validator::Block* p = supported_block_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_validator::Block*>(
      &::zera_validator::_Block_default_instance_);
}
inline const ::zera_validator::Block& BlockAttestationResponse::supported_block() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestationResponse.supported_block)
  return _internal_supported_block();
}
inline void BlockAttestationResponse::unsafe_arena_set_allocated_supported_block(
    ::zera_validator::Block* supported_block) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(supported_block_);
  }
  supported_block_ = supported_block;
  if (supported_block) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockAttestationResponse.supported_block)
}
inline ::zera_validator::Block* BlockAttestationResponse::release_supported_block() {
  auto temp = unsafe_arena_release_supported_block();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_validator::Block* BlockAttestationResponse::unsafe_arena_release_supported_block() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockAttestationResponse.supported_block)
  _has_bits_[0] &= ~0x00000001u;
  ::zera_validator::Block* temp = supported_block_;
  supported_block_ = nullptr;
  return temp;
}
inline ::zera_validator::Block* BlockAttestationResponse::_internal_mutable_supported_block() {
  _has_bits_[0] |= 0x00000001u;
  if (supported_block_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_validator::Block>(GetArena());
    supported_block_ = p;
  }
  return supported_block_;
}
inline ::zera_validator::Block* BlockAttestationResponse::mutable_supported_block() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestationResponse.supported_block)
  return _internal_mutable_supported_block();
}
inline void BlockAttestationResponse::set_allocated_supported_block(::zera_validator::Block* supported_block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete supported_block_;
  }
  if (supported_block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(supported_block);
    if (message_arena != submessage_arena) {
      supported_block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supported_block, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  supported_block_ = supported_block;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockAttestationResponse.supported_block)
}

// repeated .zera_validator.ValidatorSupport validator_support = 4;
inline int BlockAttestationResponse::_internal_validator_support_size() const {
  return validator_support_.size();
}
inline int BlockAttestationResponse::validator_support_size() const {
  return _internal_validator_support_size();
}
inline void BlockAttestationResponse::clear_validator_support() {
  validator_support_.Clear();
}
inline ::zera_validator::ValidatorSupport* BlockAttestationResponse::mutable_validator_support(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestationResponse.validator_support)
  return validator_support_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >*
BlockAttestationResponse::mutable_validator_support() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.BlockAttestationResponse.validator_support)
  return &validator_support_;
}
inline const ::zera_validator::ValidatorSupport& BlockAttestationResponse::_internal_validator_support(int index) const {
  return validator_support_.Get(index);
}
inline const ::zera_validator::ValidatorSupport& BlockAttestationResponse::validator_support(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestationResponse.validator_support)
  return _internal_validator_support(index);
}
inline ::zera_validator::ValidatorSupport* BlockAttestationResponse::_internal_add_validator_support() {
  return validator_support_.Add();
}
inline ::zera_validator::ValidatorSupport* BlockAttestationResponse::add_validator_support() {
  // @@protoc_insertion_point(field_add:zera_validator.BlockAttestationResponse.validator_support)
  return _internal_add_validator_support();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >&
BlockAttestationResponse::validator_support() const {
  // @@protoc_insertion_point(field_list:zera_validator.BlockAttestationResponse.validator_support)
  return validator_support_;
}

// .zera_txn.PublicKey public_key = 5;
inline bool BlockAttestationResponse::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool BlockAttestationResponse::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& BlockAttestationResponse::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& BlockAttestationResponse::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestationResponse.public_key)
  return _internal_public_key();
}
inline void BlockAttestationResponse::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockAttestationResponse.public_key)
}
inline ::zera_txn::PublicKey* BlockAttestationResponse::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* BlockAttestationResponse::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockAttestationResponse.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* BlockAttestationResponse::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* BlockAttestationResponse::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestationResponse.public_key)
  return _internal_mutable_public_key();
}
inline void BlockAttestationResponse::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockAttestationResponse.public_key)
}

// bytes signature = 6;
inline void BlockAttestationResponse::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BlockAttestationResponse::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestationResponse.signature)
  return _internal_signature();
}
inline void BlockAttestationResponse::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestationResponse.signature)
}
inline std::string* BlockAttestationResponse::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestationResponse.signature)
  return _internal_mutable_signature();
}
inline const std::string& BlockAttestationResponse::_internal_signature() const {
  return signature_.Get();
}
inline void BlockAttestationResponse::_internal_set_signature(const std::string& value) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockAttestationResponse::set_signature(std::string&& value) {
  
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockAttestationResponse.signature)
}
inline void BlockAttestationResponse::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockAttestationResponse.signature)
}
inline void BlockAttestationResponse::set_signature(const void* value,
    size_t size) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockAttestationResponse.signature)
}
inline std::string* BlockAttestationResponse::_internal_mutable_signature() {
  
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockAttestationResponse::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockAttestationResponse.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockAttestationResponse::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockAttestationResponse.signature)
}
inline std::string* BlockAttestationResponse::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockAttestationResponse.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockAttestationResponse::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockAttestationResponse.signature)
}

// bool confirmed = 7;
inline void BlockAttestationResponse::clear_confirmed() {
  confirmed_ = false;
}
inline bool BlockAttestationResponse::_internal_confirmed() const {
  return confirmed_;
}
inline bool BlockAttestationResponse::confirmed() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestationResponse.confirmed)
  return _internal_confirmed();
}
inline void BlockAttestationResponse::_internal_set_confirmed(bool value) {
  
  confirmed_ = value;
}
inline void BlockAttestationResponse::set_confirmed(bool value) {
  _internal_set_confirmed(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestationResponse.confirmed)
}

// -------------------------------------------------------------------

// BlockAttestation

// bytes block_hash = 1;
inline void BlockAttestation::clear_block_hash() {
  block_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BlockAttestation::block_hash() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestation.block_hash)
  return _internal_block_hash();
}
inline void BlockAttestation::set_block_hash(const std::string& value) {
  _internal_set_block_hash(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestation.block_hash)
}
inline std::string* BlockAttestation::mutable_block_hash() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestation.block_hash)
  return _internal_mutable_block_hash();
}
inline const std::string& BlockAttestation::_internal_block_hash() const {
  return block_hash_.Get();
}
inline void BlockAttestation::_internal_set_block_hash(const std::string& value) {
  
  block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockAttestation::set_block_hash(std::string&& value) {
  
  block_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockAttestation.block_hash)
}
inline void BlockAttestation::set_block_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockAttestation.block_hash)
}
inline void BlockAttestation::set_block_hash(const void* value,
    size_t size) {
  
  block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockAttestation.block_hash)
}
inline std::string* BlockAttestation::_internal_mutable_block_hash() {
  
  return block_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockAttestation::release_block_hash() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockAttestation.block_hash)
  return block_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockAttestation::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockAttestation.block_hash)
}
inline std::string* BlockAttestation::unsafe_arena_release_block_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockAttestation.block_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return block_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockAttestation::unsafe_arena_set_allocated_block_hash(
    std::string* block_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (block_hash != nullptr) {
    
  } else {
    
  }
  block_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      block_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockAttestation.block_hash)
}

// uint32 block_height = 2;
inline void BlockAttestation::clear_block_height() {
  block_height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BlockAttestation::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BlockAttestation::block_height() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestation.block_height)
  return _internal_block_height();
}
inline void BlockAttestation::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  block_height_ = value;
}
inline void BlockAttestation::set_block_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestation.block_height)
}

// bytes previous_block_hash = 3;
inline void BlockAttestation::clear_previous_block_hash() {
  previous_block_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BlockAttestation::previous_block_hash() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestation.previous_block_hash)
  return _internal_previous_block_hash();
}
inline void BlockAttestation::set_previous_block_hash(const std::string& value) {
  _internal_set_previous_block_hash(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestation.previous_block_hash)
}
inline std::string* BlockAttestation::mutable_previous_block_hash() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestation.previous_block_hash)
  return _internal_mutable_previous_block_hash();
}
inline const std::string& BlockAttestation::_internal_previous_block_hash() const {
  return previous_block_hash_.Get();
}
inline void BlockAttestation::_internal_set_previous_block_hash(const std::string& value) {
  
  previous_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockAttestation::set_previous_block_hash(std::string&& value) {
  
  previous_block_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockAttestation.previous_block_hash)
}
inline void BlockAttestation::set_previous_block_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  previous_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockAttestation.previous_block_hash)
}
inline void BlockAttestation::set_previous_block_hash(const void* value,
    size_t size) {
  
  previous_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockAttestation.previous_block_hash)
}
inline std::string* BlockAttestation::_internal_mutable_previous_block_hash() {
  
  return previous_block_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockAttestation::release_previous_block_hash() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockAttestation.previous_block_hash)
  return previous_block_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockAttestation::set_allocated_previous_block_hash(std::string* previous_block_hash) {
  if (previous_block_hash != nullptr) {
    
  } else {
    
  }
  previous_block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous_block_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockAttestation.previous_block_hash)
}
inline std::string* BlockAttestation::unsafe_arena_release_previous_block_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockAttestation.previous_block_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return previous_block_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockAttestation::unsafe_arena_set_allocated_previous_block_hash(
    std::string* previous_block_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (previous_block_hash != nullptr) {
    
  } else {
    
  }
  previous_block_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      previous_block_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockAttestation.previous_block_hash)
}

// repeated .zera_validator.ValidatorSupport validator_support = 4;
inline int BlockAttestation::_internal_validator_support_size() const {
  return validator_support_.size();
}
inline int BlockAttestation::validator_support_size() const {
  return _internal_validator_support_size();
}
inline void BlockAttestation::clear_validator_support() {
  validator_support_.Clear();
}
inline ::zera_validator::ValidatorSupport* BlockAttestation::mutable_validator_support(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestation.validator_support)
  return validator_support_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >*
BlockAttestation::mutable_validator_support() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.BlockAttestation.validator_support)
  return &validator_support_;
}
inline const ::zera_validator::ValidatorSupport& BlockAttestation::_internal_validator_support(int index) const {
  return validator_support_.Get(index);
}
inline const ::zera_validator::ValidatorSupport& BlockAttestation::validator_support(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestation.validator_support)
  return _internal_validator_support(index);
}
inline ::zera_validator::ValidatorSupport* BlockAttestation::_internal_add_validator_support() {
  return validator_support_.Add();
}
inline ::zera_validator::ValidatorSupport* BlockAttestation::add_validator_support() {
  // @@protoc_insertion_point(field_add:zera_validator.BlockAttestation.validator_support)
  return _internal_add_validator_support();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >&
BlockAttestation::validator_support() const {
  // @@protoc_insertion_point(field_list:zera_validator.BlockAttestation.validator_support)
  return validator_support_;
}

// .zera_txn.PublicKey public_key = 5;
inline bool BlockAttestation::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool BlockAttestation::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& BlockAttestation::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& BlockAttestation::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestation.public_key)
  return _internal_public_key();
}
inline void BlockAttestation::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockAttestation.public_key)
}
inline ::zera_txn::PublicKey* BlockAttestation::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* BlockAttestation::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockAttestation.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* BlockAttestation::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* BlockAttestation::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestation.public_key)
  return _internal_mutable_public_key();
}
inline void BlockAttestation::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockAttestation.public_key)
}

// bytes signature = 6;
inline void BlockAttestation::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BlockAttestation::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestation.signature)
  return _internal_signature();
}
inline void BlockAttestation::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestation.signature)
}
inline std::string* BlockAttestation::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockAttestation.signature)
  return _internal_mutable_signature();
}
inline const std::string& BlockAttestation::_internal_signature() const {
  return signature_.Get();
}
inline void BlockAttestation::_internal_set_signature(const std::string& value) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockAttestation::set_signature(std::string&& value) {
  
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockAttestation.signature)
}
inline void BlockAttestation::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockAttestation.signature)
}
inline void BlockAttestation::set_signature(const void* value,
    size_t size) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockAttestation.signature)
}
inline std::string* BlockAttestation::_internal_mutable_signature() {
  
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockAttestation::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockAttestation.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockAttestation::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockAttestation.signature)
}
inline std::string* BlockAttestation::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockAttestation.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockAttestation::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockAttestation.signature)
}

// bool confirmed = 7;
inline void BlockAttestation::clear_confirmed() {
  confirmed_ = false;
}
inline bool BlockAttestation::_internal_confirmed() const {
  return confirmed_;
}
inline bool BlockAttestation::confirmed() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockAttestation.confirmed)
  return _internal_confirmed();
}
inline void BlockAttestation::_internal_set_confirmed(bool value) {
  
  confirmed_ = value;
}
inline void BlockAttestation::set_confirmed(bool value) {
  _internal_set_confirmed(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockAttestation.confirmed)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AttestationLedger

// map<string, .zera_validator.AttestationSupport> block_attestation_responses = 1;
inline int AttestationLedger::_internal_block_attestation_responses_size() const {
  return block_attestation_responses_.size();
}
inline int AttestationLedger::block_attestation_responses_size() const {
  return _internal_block_attestation_responses_size();
}
inline void AttestationLedger::clear_block_attestation_responses() {
  block_attestation_responses_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::AttestationSupport >&
AttestationLedger::_internal_block_attestation_responses() const {
  return block_attestation_responses_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::AttestationSupport >&
AttestationLedger::block_attestation_responses() const {
  // @@protoc_insertion_point(field_map:zera_validator.AttestationLedger.block_attestation_responses)
  return _internal_block_attestation_responses();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::AttestationSupport >*
AttestationLedger::_internal_mutable_block_attestation_responses() {
  return block_attestation_responses_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::AttestationSupport >*
AttestationLedger::mutable_block_attestation_responses() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.AttestationLedger.block_attestation_responses)
  return _internal_mutable_block_attestation_responses();
}

// map<string, string> validator_support = 2;
inline int AttestationLedger::_internal_validator_support_size() const {
  return validator_support_.size();
}
inline int AttestationLedger::validator_support_size() const {
  return _internal_validator_support_size();
}
inline void AttestationLedger::clear_validator_support() {
  validator_support_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AttestationLedger::_internal_validator_support() const {
  return validator_support_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AttestationLedger::validator_support() const {
  // @@protoc_insertion_point(field_map:zera_validator.AttestationLedger.validator_support)
  return _internal_validator_support();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AttestationLedger::_internal_mutable_validator_support() {
  return validator_support_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AttestationLedger::mutable_validator_support() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.AttestationLedger.validator_support)
  return _internal_mutable_validator_support();
}

// -------------------------------------------------------------------

// AttestationSupport

// repeated .zera_validator.ValidatorSupport validator_support = 1;
inline int AttestationSupport::_internal_validator_support_size() const {
  return validator_support_.size();
}
inline int AttestationSupport::validator_support_size() const {
  return _internal_validator_support_size();
}
inline void AttestationSupport::clear_validator_support() {
  validator_support_.Clear();
}
inline ::zera_validator::ValidatorSupport* AttestationSupport::mutable_validator_support(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.AttestationSupport.validator_support)
  return validator_support_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >*
AttestationSupport::mutable_validator_support() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.AttestationSupport.validator_support)
  return &validator_support_;
}
inline const ::zera_validator::ValidatorSupport& AttestationSupport::_internal_validator_support(int index) const {
  return validator_support_.Get(index);
}
inline const ::zera_validator::ValidatorSupport& AttestationSupport::validator_support(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.AttestationSupport.validator_support)
  return _internal_validator_support(index);
}
inline ::zera_validator::ValidatorSupport* AttestationSupport::_internal_add_validator_support() {
  return validator_support_.Add();
}
inline ::zera_validator::ValidatorSupport* AttestationSupport::add_validator_support() {
  // @@protoc_insertion_point(field_add:zera_validator.AttestationSupport.validator_support)
  return _internal_add_validator_support();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ValidatorSupport >&
AttestationSupport::validator_support() const {
  // @@protoc_insertion_point(field_list:zera_validator.AttestationSupport.validator_support)
  return validator_support_;
}

// .zera_validator.Block supported_block = 2;
inline bool AttestationSupport::_internal_has_supported_block() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || supported_block_ != nullptr);
  return value;
}
inline bool AttestationSupport::has_supported_block() const {
  return _internal_has_supported_block();
}
inline void AttestationSupport::clear_supported_block() {
  if (GetArena() == nullptr && supported_block_ != nullptr) {
    delete supported_block_;
  }
  supported_block_ = nullptr;
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::zera_validator::Block& AttestationSupport::_internal_supported_block() const {
  const ::zera_validator::Block* p = supported_block_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_validator::Block*>(
      &::zera_validator::_Block_default_instance_);
}
inline const ::zera_validator::Block& AttestationSupport::supported_block() const {
  // @@protoc_insertion_point(field_get:zera_validator.AttestationSupport.supported_block)
  return _internal_supported_block();
}
inline void AttestationSupport::unsafe_arena_set_allocated_supported_block(
    ::zera_validator::Block* supported_block) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(supported_block_);
  }
  supported_block_ = supported_block;
  if (supported_block) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.AttestationSupport.supported_block)
}
inline ::zera_validator::Block* AttestationSupport::release_supported_block() {
  auto temp = unsafe_arena_release_supported_block();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_validator::Block* AttestationSupport::unsafe_arena_release_supported_block() {
  // @@protoc_insertion_point(field_release:zera_validator.AttestationSupport.supported_block)
  _has_bits_[0] &= ~0x00000001u;
  ::zera_validator::Block* temp = supported_block_;
  supported_block_ = nullptr;
  return temp;
}
inline ::zera_validator::Block* AttestationSupport::_internal_mutable_supported_block() {
  _has_bits_[0] |= 0x00000001u;
  if (supported_block_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_validator::Block>(GetArena());
    supported_block_ = p;
  }
  return supported_block_;
}
inline ::zera_validator::Block* AttestationSupport::mutable_supported_block() {
  // @@protoc_insertion_point(field_mutable:zera_validator.AttestationSupport.supported_block)
  return _internal_mutable_supported_block();
}
inline void AttestationSupport::set_allocated_supported_block(::zera_validator::Block* supported_block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete supported_block_;
  }
  if (supported_block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(supported_block);
    if (message_arena != submessage_arena) {
      supported_block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supported_block, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  supported_block_ = supported_block;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.AttestationSupport.supported_block)
}

// -------------------------------------------------------------------

// ValidatorSupport

// .zera_txn.PublicKey public_key = 1;
inline bool ValidatorSupport::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool ValidatorSupport::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& ValidatorSupport::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& ValidatorSupport::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorSupport.public_key)
  return _internal_public_key();
}
inline void ValidatorSupport::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorSupport.public_key)
}
inline ::zera_txn::PublicKey* ValidatorSupport::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorSupport::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorSupport.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorSupport::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* ValidatorSupport::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorSupport.public_key)
  return _internal_mutable_public_key();
}
inline void ValidatorSupport::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorSupport.public_key)
}

// bytes signature = 2;
inline void ValidatorSupport::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ValidatorSupport::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorSupport.signature)
  return _internal_signature();
}
inline void ValidatorSupport::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.ValidatorSupport.signature)
}
inline std::string* ValidatorSupport::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorSupport.signature)
  return _internal_mutable_signature();
}
inline const std::string& ValidatorSupport::_internal_signature() const {
  return signature_.Get();
}
inline void ValidatorSupport::_internal_set_signature(const std::string& value) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidatorSupport::set_signature(std::string&& value) {
  
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ValidatorSupport.signature)
}
inline void ValidatorSupport::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ValidatorSupport.signature)
}
inline void ValidatorSupport::set_signature(const void* value,
    size_t size) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ValidatorSupport.signature)
}
inline std::string* ValidatorSupport::_internal_mutable_signature() {
  
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidatorSupport::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorSupport.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorSupport::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorSupport.signature)
}
inline std::string* ValidatorSupport::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ValidatorSupport.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidatorSupport::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorSupport.signature)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool ValidatorSupport::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool ValidatorSupport::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ValidatorSupport::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ValidatorSupport::timestamp() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorSupport.timestamp)
  return _internal_timestamp();
}
inline void ValidatorSupport::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorSupport.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ValidatorSupport::release_timestamp() {
  auto temp = unsafe_arena_release_timestamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ValidatorSupport::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorSupport.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ValidatorSupport::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ValidatorSupport::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorSupport.timestamp)
  return _internal_mutable_timestamp();
}
inline void ValidatorSupport::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorSupport.timestamp)
}

// -------------------------------------------------------------------

// NonceRequest

// bytes wallet_address = 1;
inline void NonceRequest::clear_wallet_address() {
  wallet_address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NonceRequest::wallet_address() const {
  // @@protoc_insertion_point(field_get:zera_validator.NonceRequest.wallet_address)
  return _internal_wallet_address();
}
inline void NonceRequest::set_wallet_address(const std::string& value) {
  _internal_set_wallet_address(value);
  // @@protoc_insertion_point(field_set:zera_validator.NonceRequest.wallet_address)
}
inline std::string* NonceRequest::mutable_wallet_address() {
  // @@protoc_insertion_point(field_mutable:zera_validator.NonceRequest.wallet_address)
  return _internal_mutable_wallet_address();
}
inline const std::string& NonceRequest::_internal_wallet_address() const {
  return wallet_address_.Get();
}
inline void NonceRequest::_internal_set_wallet_address(const std::string& value) {
  
  wallet_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NonceRequest::set_wallet_address(std::string&& value) {
  
  wallet_address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.NonceRequest.wallet_address)
}
inline void NonceRequest::set_wallet_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  wallet_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.NonceRequest.wallet_address)
}
inline void NonceRequest::set_wallet_address(const void* value,
    size_t size) {
  
  wallet_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.NonceRequest.wallet_address)
}
inline std::string* NonceRequest::_internal_mutable_wallet_address() {
  
  return wallet_address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NonceRequest::release_wallet_address() {
  // @@protoc_insertion_point(field_release:zera_validator.NonceRequest.wallet_address)
  return wallet_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NonceRequest::set_allocated_wallet_address(std::string* wallet_address) {
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  wallet_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), wallet_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.NonceRequest.wallet_address)
}
inline std::string* NonceRequest::unsafe_arena_release_wallet_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.NonceRequest.wallet_address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return wallet_address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NonceRequest::unsafe_arena_set_allocated_wallet_address(
    std::string* wallet_address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  wallet_address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      wallet_address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.NonceRequest.wallet_address)
}

// -------------------------------------------------------------------

// NonceResponse

// uint64 nonce = 1;
inline void NonceResponse::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NonceResponse::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NonceResponse::nonce() const {
  // @@protoc_insertion_point(field_get:zera_validator.NonceResponse.nonce)
  return _internal_nonce();
}
inline void NonceResponse::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nonce_ = value;
}
inline void NonceResponse::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:zera_validator.NonceResponse.nonce)
}

// -------------------------------------------------------------------

// DataChunk

// bytes chunk_data = 1;
inline void DataChunk::clear_chunk_data() {
  chunk_data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DataChunk::chunk_data() const {
  // @@protoc_insertion_point(field_get:zera_validator.DataChunk.chunk_data)
  return _internal_chunk_data();
}
inline void DataChunk::set_chunk_data(const std::string& value) {
  _internal_set_chunk_data(value);
  // @@protoc_insertion_point(field_set:zera_validator.DataChunk.chunk_data)
}
inline std::string* DataChunk::mutable_chunk_data() {
  // @@protoc_insertion_point(field_mutable:zera_validator.DataChunk.chunk_data)
  return _internal_mutable_chunk_data();
}
inline const std::string& DataChunk::_internal_chunk_data() const {
  return chunk_data_.Get();
}
inline void DataChunk::_internal_set_chunk_data(const std::string& value) {
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataChunk::set_chunk_data(std::string&& value) {
  
  chunk_data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.DataChunk.chunk_data)
}
inline void DataChunk::set_chunk_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.DataChunk.chunk_data)
}
inline void DataChunk::set_chunk_data(const void* value,
    size_t size) {
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.DataChunk.chunk_data)
}
inline std::string* DataChunk::_internal_mutable_chunk_data() {
  
  return chunk_data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataChunk::release_chunk_data() {
  // @@protoc_insertion_point(field_release:zera_validator.DataChunk.chunk_data)
  return chunk_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataChunk::set_allocated_chunk_data(std::string* chunk_data) {
  if (chunk_data != nullptr) {
    
  } else {
    
  }
  chunk_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.DataChunk.chunk_data)
}
inline std::string* DataChunk::unsafe_arena_release_chunk_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.DataChunk.chunk_data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return chunk_data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DataChunk::unsafe_arena_set_allocated_chunk_data(
    std::string* chunk_data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (chunk_data != nullptr) {
    
  } else {
    
  }
  chunk_data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      chunk_data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.DataChunk.chunk_data)
}

// int32 chunk_number = 2;
inline void DataChunk::clear_chunk_number() {
  chunk_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataChunk::_internal_chunk_number() const {
  return chunk_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataChunk::chunk_number() const {
  // @@protoc_insertion_point(field_get:zera_validator.DataChunk.chunk_number)
  return _internal_chunk_number();
}
inline void DataChunk::_internal_set_chunk_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  chunk_number_ = value;
}
inline void DataChunk::set_chunk_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_chunk_number(value);
  // @@protoc_insertion_point(field_set:zera_validator.DataChunk.chunk_number)
}

// int32 total_chunks = 3;
inline bool DataChunk::_internal_has_total_chunks() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataChunk::has_total_chunks() const {
  return _internal_has_total_chunks();
}
inline void DataChunk::clear_total_chunks() {
  total_chunks_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataChunk::_internal_total_chunks() const {
  return total_chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataChunk::total_chunks() const {
  // @@protoc_insertion_point(field_get:zera_validator.DataChunk.total_chunks)
  return _internal_total_chunks();
}
inline void DataChunk::_internal_set_total_chunks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  total_chunks_ = value;
}
inline void DataChunk::set_total_chunks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_total_chunks(value);
  // @@protoc_insertion_point(field_set:zera_validator.DataChunk.total_chunks)
}

// -------------------------------------------------------------------

// ValidatorSyncRequest

// .zera_txn.PublicKey public_key = 1;
inline bool ValidatorSyncRequest::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool ValidatorSyncRequest::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& ValidatorSyncRequest::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& ValidatorSyncRequest::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorSyncRequest.public_key)
  return _internal_public_key();
}
inline void ValidatorSyncRequest::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorSyncRequest.public_key)
}
inline ::zera_txn::PublicKey* ValidatorSyncRequest::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorSyncRequest::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorSyncRequest.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorSyncRequest::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* ValidatorSyncRequest::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorSyncRequest.public_key)
  return _internal_mutable_public_key();
}
inline void ValidatorSyncRequest::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorSyncRequest.public_key)
}

// bytes signature = 2;
inline void ValidatorSyncRequest::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ValidatorSyncRequest::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorSyncRequest.signature)
  return _internal_signature();
}
inline void ValidatorSyncRequest::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.ValidatorSyncRequest.signature)
}
inline std::string* ValidatorSyncRequest::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorSyncRequest.signature)
  return _internal_mutable_signature();
}
inline const std::string& ValidatorSyncRequest::_internal_signature() const {
  return signature_.Get();
}
inline void ValidatorSyncRequest::_internal_set_signature(const std::string& value) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidatorSyncRequest::set_signature(std::string&& value) {
  
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ValidatorSyncRequest.signature)
}
inline void ValidatorSyncRequest::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ValidatorSyncRequest.signature)
}
inline void ValidatorSyncRequest::set_signature(const void* value,
    size_t size) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ValidatorSyncRequest.signature)
}
inline std::string* ValidatorSyncRequest::_internal_mutable_signature() {
  
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidatorSyncRequest::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorSyncRequest.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorSyncRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorSyncRequest.signature)
}
inline std::string* ValidatorSyncRequest::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ValidatorSyncRequest.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidatorSyncRequest::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorSyncRequest.signature)
}

// -------------------------------------------------------------------

// ValidatorSync

// repeated .zera_txn.Validator validators = 1;
inline int ValidatorSync::_internal_validators_size() const {
  return validators_.size();
}
inline int ValidatorSync::validators_size() const {
  return _internal_validators_size();
}
inline ::zera_txn::Validator* ValidatorSync::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorSync.validators)
  return validators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Validator >*
ValidatorSync::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ValidatorSync.validators)
  return &validators_;
}
inline const ::zera_txn::Validator& ValidatorSync::_internal_validators(int index) const {
  return validators_.Get(index);
}
inline const ::zera_txn::Validator& ValidatorSync::validators(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorSync.validators)
  return _internal_validators(index);
}
inline ::zera_txn::Validator* ValidatorSync::_internal_add_validators() {
  return validators_.Add();
}
inline ::zera_txn::Validator* ValidatorSync::add_validators() {
  // @@protoc_insertion_point(field_add:zera_validator.ValidatorSync.validators)
  return _internal_add_validators();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Validator >&
ValidatorSync::validators() const {
  // @@protoc_insertion_point(field_list:zera_validator.ValidatorSync.validators)
  return validators_;
}

// bytes signature = 2;
inline bool ValidatorSync::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ValidatorSync::has_signature() const {
  return _internal_has_signature();
}
inline void ValidatorSync::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ValidatorSync::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorSync.signature)
  return _internal_signature();
}
inline void ValidatorSync::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.ValidatorSync.signature)
}
inline std::string* ValidatorSync::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorSync.signature)
  return _internal_mutable_signature();
}
inline const std::string& ValidatorSync::_internal_signature() const {
  return signature_.Get();
}
inline void ValidatorSync::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidatorSync::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ValidatorSync.signature)
}
inline void ValidatorSync::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ValidatorSync.signature)
}
inline void ValidatorSync::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ValidatorSync.signature)
}
inline std::string* ValidatorSync::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidatorSync::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorSync.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorSync::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorSync.signature)
}
inline std::string* ValidatorSync::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ValidatorSync.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidatorSync::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorSync.signature)
}

// .zera_txn.PublicKey public_key = 3;
inline bool ValidatorSync::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool ValidatorSync::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& ValidatorSync::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& ValidatorSync::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.ValidatorSync.public_key)
  return _internal_public_key();
}
inline void ValidatorSync::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ValidatorSync.public_key)
}
inline ::zera_txn::PublicKey* ValidatorSync::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorSync::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.ValidatorSync.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorSync::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* ValidatorSync::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ValidatorSync.public_key)
  return _internal_mutable_public_key();
}
inline void ValidatorSync::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ValidatorSync.public_key)
}

// -------------------------------------------------------------------

// BlockSync

// bytes last_key = 1;
inline void BlockSync::clear_last_key() {
  last_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BlockSync::last_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockSync.last_key)
  return _internal_last_key();
}
inline void BlockSync::set_last_key(const std::string& value) {
  _internal_set_last_key(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockSync.last_key)
}
inline std::string* BlockSync::mutable_last_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockSync.last_key)
  return _internal_mutable_last_key();
}
inline const std::string& BlockSync::_internal_last_key() const {
  return last_key_.Get();
}
inline void BlockSync::_internal_set_last_key(const std::string& value) {
  
  last_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockSync::set_last_key(std::string&& value) {
  
  last_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockSync.last_key)
}
inline void BlockSync::set_last_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  last_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockSync.last_key)
}
inline void BlockSync::set_last_key(const void* value,
    size_t size) {
  
  last_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockSync.last_key)
}
inline std::string* BlockSync::_internal_mutable_last_key() {
  
  return last_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockSync::release_last_key() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockSync.last_key)
  return last_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockSync::set_allocated_last_key(std::string* last_key) {
  if (last_key != nullptr) {
    
  } else {
    
  }
  last_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockSync.last_key)
}
inline std::string* BlockSync::unsafe_arena_release_last_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockSync.last_key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return last_key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockSync::unsafe_arena_set_allocated_last_key(
    std::string* last_key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (last_key != nullptr) {
    
  } else {
    
  }
  last_key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      last_key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockSync.last_key)
}

// uint64 amount = 2;
inline void BlockSync::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockSync::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockSync::amount() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockSync.amount)
  return _internal_amount();
}
inline void BlockSync::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  amount_ = value;
}
inline void BlockSync::set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockSync.amount)
}

// bytes signature = 3;
inline bool BlockSync::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlockSync::has_signature() const {
  return _internal_has_signature();
}
inline void BlockSync::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockSync::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockSync.signature)
  return _internal_signature();
}
inline void BlockSync::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockSync.signature)
}
inline std::string* BlockSync::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockSync.signature)
  return _internal_mutable_signature();
}
inline const std::string& BlockSync::_internal_signature() const {
  return signature_.Get();
}
inline void BlockSync::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockSync::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockSync.signature)
}
inline void BlockSync::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockSync.signature)
}
inline void BlockSync::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockSync.signature)
}
inline std::string* BlockSync::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockSync::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockSync.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockSync::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockSync.signature)
}
inline std::string* BlockSync::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockSync.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockSync::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockSync.signature)
}

// .zera_txn.PublicKey public_key = 4;
inline bool BlockSync::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool BlockSync::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& BlockSync::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& BlockSync::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockSync.public_key)
  return _internal_public_key();
}
inline void BlockSync::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockSync.public_key)
}
inline ::zera_txn::PublicKey* BlockSync::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* BlockSync::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockSync.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* BlockSync::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* BlockSync::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockSync.public_key)
  return _internal_mutable_public_key();
}
inline void BlockSync::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockSync.public_key)
}

// -------------------------------------------------------------------

// BlockHeader

// uint64 version = 1;
inline bool BlockHeader::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BlockHeader::has_version() const {
  return _internal_has_version();
}
inline void BlockHeader::clear_version() {
  version_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::version() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.version)
  return _internal_version();
}
inline void BlockHeader::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  version_ = value;
}
inline void BlockHeader::set_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockHeader.version)
}

// bytes previous_block_hash = 2;
inline bool BlockHeader::_internal_has_previous_block_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlockHeader::has_previous_block_hash() const {
  return _internal_has_previous_block_hash();
}
inline void BlockHeader::clear_previous_block_hash() {
  previous_block_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockHeader::previous_block_hash() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.previous_block_hash)
  return _internal_previous_block_hash();
}
inline void BlockHeader::set_previous_block_hash(const std::string& value) {
  _internal_set_previous_block_hash(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockHeader.previous_block_hash)
}
inline std::string* BlockHeader::mutable_previous_block_hash() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockHeader.previous_block_hash)
  return _internal_mutable_previous_block_hash();
}
inline const std::string& BlockHeader::_internal_previous_block_hash() const {
  return previous_block_hash_.Get();
}
inline void BlockHeader::_internal_set_previous_block_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  previous_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_previous_block_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  previous_block_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockHeader.previous_block_hash)
}
inline void BlockHeader::set_previous_block_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  previous_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockHeader.previous_block_hash)
}
inline void BlockHeader::set_previous_block_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  previous_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockHeader.previous_block_hash)
}
inline std::string* BlockHeader::_internal_mutable_previous_block_hash() {
  _has_bits_[0] |= 0x00000001u;
  return previous_block_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_previous_block_hash() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockHeader.previous_block_hash)
  if (!_internal_has_previous_block_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return previous_block_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_previous_block_hash(std::string* previous_block_hash) {
  if (previous_block_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  previous_block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous_block_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockHeader.previous_block_hash)
}
inline std::string* BlockHeader::unsafe_arena_release_previous_block_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockHeader.previous_block_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return previous_block_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockHeader::unsafe_arena_set_allocated_previous_block_hash(
    std::string* previous_block_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (previous_block_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  previous_block_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      previous_block_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockHeader.previous_block_hash)
}

// bytes hash = 3;
inline bool BlockHeader::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BlockHeader::has_hash() const {
  return _internal_has_hash();
}
inline void BlockHeader::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockHeader::hash() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.hash)
  return _internal_hash();
}
inline void BlockHeader::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockHeader.hash)
}
inline std::string* BlockHeader::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockHeader.hash)
  return _internal_mutable_hash();
}
inline const std::string& BlockHeader::_internal_hash() const {
  return hash_.Get();
}
inline void BlockHeader::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockHeader.hash)
}
inline void BlockHeader::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockHeader.hash)
}
inline void BlockHeader::set_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockHeader.hash)
}
inline std::string* BlockHeader::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000002u;
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_hash() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockHeader.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockHeader.hash)
}
inline std::string* BlockHeader::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockHeader.hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockHeader::unsafe_arena_set_allocated_hash(
    std::string* hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockHeader.hash)
}

// .google.protobuf.Timestamp timestamp = 4;
inline bool BlockHeader::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool BlockHeader::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& BlockHeader::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& BlockHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.timestamp)
  return _internal_timestamp();
}
inline void BlockHeader::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockHeader.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BlockHeader::release_timestamp() {
  auto temp = unsafe_arena_release_timestamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BlockHeader::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockHeader.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BlockHeader::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BlockHeader::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockHeader.timestamp)
  return _internal_mutable_timestamp();
}
inline void BlockHeader::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockHeader.timestamp)
}

// uint64 nonce = 5;
inline void BlockHeader::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::nonce() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.nonce)
  return _internal_nonce();
}
inline void BlockHeader::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nonce_ = value;
}
inline void BlockHeader::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockHeader.nonce)
}

// uint64 block_height = 6;
inline void BlockHeader::clear_block_height() {
  block_height_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::block_height() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.block_height)
  return _internal_block_height();
}
inline void BlockHeader::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_height_ = value;
}
inline void BlockHeader::set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockHeader.block_height)
}

// bytes fee_address = 7;
inline void BlockHeader::clear_fee_address() {
  fee_address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BlockHeader::fee_address() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.fee_address)
  return _internal_fee_address();
}
inline void BlockHeader::set_fee_address(const std::string& value) {
  _internal_set_fee_address(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockHeader.fee_address)
}
inline std::string* BlockHeader::mutable_fee_address() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockHeader.fee_address)
  return _internal_mutable_fee_address();
}
inline const std::string& BlockHeader::_internal_fee_address() const {
  return fee_address_.Get();
}
inline void BlockHeader::_internal_set_fee_address(const std::string& value) {
  
  fee_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_fee_address(std::string&& value) {
  
  fee_address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockHeader.fee_address)
}
inline void BlockHeader::set_fee_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fee_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockHeader.fee_address)
}
inline void BlockHeader::set_fee_address(const void* value,
    size_t size) {
  
  fee_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockHeader.fee_address)
}
inline std::string* BlockHeader::_internal_mutable_fee_address() {
  
  return fee_address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_fee_address() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockHeader.fee_address)
  return fee_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_fee_address(std::string* fee_address) {
  if (fee_address != nullptr) {
    
  } else {
    
  }
  fee_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fee_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockHeader.fee_address)
}
inline std::string* BlockHeader::unsafe_arena_release_fee_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockHeader.fee_address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return fee_address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockHeader::unsafe_arena_set_allocated_fee_address(
    std::string* fee_address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (fee_address != nullptr) {
    
  } else {
    
  }
  fee_address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      fee_address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockHeader.fee_address)
}

// bytes signature = 8;
inline bool BlockHeader::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BlockHeader::has_signature() const {
  return _internal_has_signature();
}
inline void BlockHeader::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BlockHeader::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.signature)
  return _internal_signature();
}
inline void BlockHeader::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockHeader.signature)
}
inline std::string* BlockHeader::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockHeader.signature)
  return _internal_mutable_signature();
}
inline const std::string& BlockHeader::_internal_signature() const {
  return signature_.Get();
}
inline void BlockHeader::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockHeader.signature)
}
inline void BlockHeader::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockHeader.signature)
}
inline void BlockHeader::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockHeader.signature)
}
inline std::string* BlockHeader::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockHeader.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockHeader.signature)
}
inline std::string* BlockHeader::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockHeader.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockHeader::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockHeader.signature)
}

// bytes merkle_root = 9;
inline bool BlockHeader::_internal_has_merkle_root() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BlockHeader::has_merkle_root() const {
  return _internal_has_merkle_root();
}
inline void BlockHeader::clear_merkle_root() {
  merkle_root_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BlockHeader::merkle_root() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.merkle_root)
  return _internal_merkle_root();
}
inline void BlockHeader::set_merkle_root(const std::string& value) {
  _internal_set_merkle_root(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockHeader.merkle_root)
}
inline std::string* BlockHeader::mutable_merkle_root() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockHeader.merkle_root)
  return _internal_mutable_merkle_root();
}
inline const std::string& BlockHeader::_internal_merkle_root() const {
  return merkle_root_.Get();
}
inline void BlockHeader::_internal_set_merkle_root(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  merkle_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_merkle_root(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  merkle_root_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockHeader.merkle_root)
}
inline void BlockHeader::set_merkle_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  merkle_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockHeader.merkle_root)
}
inline void BlockHeader::set_merkle_root(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  merkle_root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockHeader.merkle_root)
}
inline std::string* BlockHeader::_internal_mutable_merkle_root() {
  _has_bits_[0] |= 0x00000008u;
  return merkle_root_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_merkle_root() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockHeader.merkle_root)
  if (!_internal_has_merkle_root()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return merkle_root_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_merkle_root(std::string* merkle_root) {
  if (merkle_root != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  merkle_root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), merkle_root,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockHeader.merkle_root)
}
inline std::string* BlockHeader::unsafe_arena_release_merkle_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockHeader.merkle_root)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return merkle_root_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockHeader::unsafe_arena_set_allocated_merkle_root(
    std::string* merkle_root) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (merkle_root != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  merkle_root_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      merkle_root, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockHeader.merkle_root)
}

// .zera_txn.PublicKey public_key = 10;
inline bool BlockHeader::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool BlockHeader::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& BlockHeader::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& BlockHeader::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockHeader.public_key)
  return _internal_public_key();
}
inline void BlockHeader::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockHeader.public_key)
}
inline ::zera_txn::PublicKey* BlockHeader::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* BlockHeader::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockHeader.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* BlockHeader::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* BlockHeader::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockHeader.public_key)
  return _internal_mutable_public_key();
}
inline void BlockHeader::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockHeader.public_key)
}

// -------------------------------------------------------------------

// Block

// .zera_validator.BlockHeader block_header = 1;
inline bool Block::_internal_has_block_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || block_header_ != nullptr);
  return value;
}
inline bool Block::has_block_header() const {
  return _internal_has_block_header();
}
inline void Block::clear_block_header() {
  if (GetArena() == nullptr && block_header_ != nullptr) {
    delete block_header_;
  }
  block_header_ = nullptr;
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::zera_validator::BlockHeader& Block::_internal_block_header() const {
  const ::zera_validator::BlockHeader* p = block_header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_validator::BlockHeader*>(
      &::zera_validator::_BlockHeader_default_instance_);
}
inline const ::zera_validator::BlockHeader& Block::block_header() const {
  // @@protoc_insertion_point(field_get:zera_validator.Block.block_header)
  return _internal_block_header();
}
inline void Block::unsafe_arena_set_allocated_block_header(
    ::zera_validator::BlockHeader* block_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_header_);
  }
  block_header_ = block_header;
  if (block_header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Block.block_header)
}
inline ::zera_validator::BlockHeader* Block::release_block_header() {
  auto temp = unsafe_arena_release_block_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_validator::BlockHeader* Block::unsafe_arena_release_block_header() {
  // @@protoc_insertion_point(field_release:zera_validator.Block.block_header)
  _has_bits_[0] &= ~0x00000002u;
  ::zera_validator::BlockHeader* temp = block_header_;
  block_header_ = nullptr;
  return temp;
}
inline ::zera_validator::BlockHeader* Block::_internal_mutable_block_header() {
  _has_bits_[0] |= 0x00000002u;
  if (block_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_validator::BlockHeader>(GetArena());
    block_header_ = p;
  }
  return block_header_;
}
inline ::zera_validator::BlockHeader* Block::mutable_block_header() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Block.block_header)
  return _internal_mutable_block_header();
}
inline void Block::set_allocated_block_header(::zera_validator::BlockHeader* block_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete block_header_;
  }
  if (block_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(block_header);
    if (message_arena != submessage_arena) {
      block_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  block_header_ = block_header;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Block.block_header)
}

// .zera_txn.TXNS transactions = 2;
inline bool Block::_internal_has_transactions() const {
  return this != internal_default_instance() && transactions_ != nullptr;
}
inline bool Block::has_transactions() const {
  return _internal_has_transactions();
}
inline const ::zera_txn::TXNS& Block::_internal_transactions() const {
  const ::zera_txn::TXNS* p = transactions_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::TXNS*>(
      &::zera_txn::_TXNS_default_instance_);
}
inline const ::zera_txn::TXNS& Block::transactions() const {
  // @@protoc_insertion_point(field_get:zera_validator.Block.transactions)
  return _internal_transactions();
}
inline void Block::unsafe_arena_set_allocated_transactions(
    ::zera_txn::TXNS* transactions) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transactions_);
  }
  transactions_ = transactions;
  if (transactions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Block.transactions)
}
inline ::zera_txn::TXNS* Block::release_transactions() {
  auto temp = unsafe_arena_release_transactions();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::TXNS* Block::unsafe_arena_release_transactions() {
  // @@protoc_insertion_point(field_release:zera_validator.Block.transactions)
  
  ::zera_txn::TXNS* temp = transactions_;
  transactions_ = nullptr;
  return temp;
}
inline ::zera_txn::TXNS* Block::_internal_mutable_transactions() {
  
  if (transactions_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::TXNS>(GetArena());
    transactions_ = p;
  }
  return transactions_;
}
inline ::zera_txn::TXNS* Block::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Block.transactions)
  return _internal_mutable_transactions();
}
inline void Block::set_allocated_transactions(::zera_txn::TXNS* transactions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transactions_);
  }
  if (transactions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transactions)->GetArena();
    if (message_arena != submessage_arena) {
      transactions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transactions, submessage_arena);
    }
    
  } else {
    
  }
  transactions_ = transactions;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Block.transactions)
}

// bytes signature = 4;
inline bool Block::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Block::has_signature() const {
  return _internal_has_signature();
}
inline void Block::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Block::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.Block.signature)
  return _internal_signature();
}
inline void Block::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.Block.signature)
}
inline std::string* Block::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Block.signature)
  return _internal_mutable_signature();
}
inline const std::string& Block::_internal_signature() const {
  return signature_.Get();
}
inline void Block::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Block::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.Block.signature)
}
inline void Block::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.Block.signature)
}
inline void Block::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.Block.signature)
}
inline std::string* Block::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Block::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.Block.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Block::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Block.signature)
}
inline std::string* Block::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.Block.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Block::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Block.signature)
}

// .zera_txn.PublicKey public_key = 5;
inline bool Block::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool Block::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& Block::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& Block::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.Block.public_key)
  return _internal_public_key();
}
inline void Block::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Block.public_key)
}
inline ::zera_txn::PublicKey* Block::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* Block::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.Block.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* Block::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* Block::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Block.public_key)
  return _internal_mutable_public_key();
}
inline void Block::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Block.public_key)
}

// repeated .zera_validator.SlashedValidator slashed_validators = 6;
inline int Block::_internal_slashed_validators_size() const {
  return slashed_validators_.size();
}
inline int Block::slashed_validators_size() const {
  return _internal_slashed_validators_size();
}
inline void Block::clear_slashed_validators() {
  slashed_validators_.Clear();
}
inline ::zera_validator::SlashedValidator* Block::mutable_slashed_validators(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.Block.slashed_validators)
  return slashed_validators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedValidator >*
Block::mutable_slashed_validators() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.Block.slashed_validators)
  return &slashed_validators_;
}
inline const ::zera_validator::SlashedValidator& Block::_internal_slashed_validators(int index) const {
  return slashed_validators_.Get(index);
}
inline const ::zera_validator::SlashedValidator& Block::slashed_validators(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.Block.slashed_validators)
  return _internal_slashed_validators(index);
}
inline ::zera_validator::SlashedValidator* Block::_internal_add_slashed_validators() {
  return slashed_validators_.Add();
}
inline ::zera_validator::SlashedValidator* Block::add_slashed_validators() {
  // @@protoc_insertion_point(field_add:zera_validator.Block.slashed_validators)
  return _internal_add_slashed_validators();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedValidator >&
Block::slashed_validators() const {
  // @@protoc_insertion_point(field_list:zera_validator.Block.slashed_validators)
  return slashed_validators_;
}

// -------------------------------------------------------------------

// SlashedValidator

// .zera_txn.PublicKey public_key = 1;
inline bool SlashedValidator::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool SlashedValidator::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& SlashedValidator::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& SlashedValidator::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.SlashedValidator.public_key)
  return _internal_public_key();
}
inline void SlashedValidator::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.SlashedValidator.public_key)
}
inline ::zera_txn::PublicKey* SlashedValidator::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* SlashedValidator::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.SlashedValidator.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* SlashedValidator::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* SlashedValidator::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.SlashedValidator.public_key)
  return _internal_mutable_public_key();
}
inline void SlashedValidator::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.SlashedValidator.public_key)
}

// bytes slashed_block_hash = 2;
inline void SlashedValidator::clear_slashed_block_hash() {
  slashed_block_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SlashedValidator::slashed_block_hash() const {
  // @@protoc_insertion_point(field_get:zera_validator.SlashedValidator.slashed_block_hash)
  return _internal_slashed_block_hash();
}
inline void SlashedValidator::set_slashed_block_hash(const std::string& value) {
  _internal_set_slashed_block_hash(value);
  // @@protoc_insertion_point(field_set:zera_validator.SlashedValidator.slashed_block_hash)
}
inline std::string* SlashedValidator::mutable_slashed_block_hash() {
  // @@protoc_insertion_point(field_mutable:zera_validator.SlashedValidator.slashed_block_hash)
  return _internal_mutable_slashed_block_hash();
}
inline const std::string& SlashedValidator::_internal_slashed_block_hash() const {
  return slashed_block_hash_.Get();
}
inline void SlashedValidator::_internal_set_slashed_block_hash(const std::string& value) {
  
  slashed_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SlashedValidator::set_slashed_block_hash(std::string&& value) {
  
  slashed_block_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.SlashedValidator.slashed_block_hash)
}
inline void SlashedValidator::set_slashed_block_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  slashed_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.SlashedValidator.slashed_block_hash)
}
inline void SlashedValidator::set_slashed_block_hash(const void* value,
    size_t size) {
  
  slashed_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.SlashedValidator.slashed_block_hash)
}
inline std::string* SlashedValidator::_internal_mutable_slashed_block_hash() {
  
  return slashed_block_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SlashedValidator::release_slashed_block_hash() {
  // @@protoc_insertion_point(field_release:zera_validator.SlashedValidator.slashed_block_hash)
  return slashed_block_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SlashedValidator::set_allocated_slashed_block_hash(std::string* slashed_block_hash) {
  if (slashed_block_hash != nullptr) {
    
  } else {
    
  }
  slashed_block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), slashed_block_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.SlashedValidator.slashed_block_hash)
}
inline std::string* SlashedValidator::unsafe_arena_release_slashed_block_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.SlashedValidator.slashed_block_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return slashed_block_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SlashedValidator::unsafe_arena_set_allocated_slashed_block_hash(
    std::string* slashed_block_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (slashed_block_hash != nullptr) {
    
  } else {
    
  }
  slashed_block_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      slashed_block_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.SlashedValidator.slashed_block_hash)
}

// repeated .zera_validator.SlashedToken slashed_tokens = 3;
inline int SlashedValidator::_internal_slashed_tokens_size() const {
  return slashed_tokens_.size();
}
inline int SlashedValidator::slashed_tokens_size() const {
  return _internal_slashed_tokens_size();
}
inline void SlashedValidator::clear_slashed_tokens() {
  slashed_tokens_.Clear();
}
inline ::zera_validator::SlashedToken* SlashedValidator::mutable_slashed_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.SlashedValidator.slashed_tokens)
  return slashed_tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedToken >*
SlashedValidator::mutable_slashed_tokens() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.SlashedValidator.slashed_tokens)
  return &slashed_tokens_;
}
inline const ::zera_validator::SlashedToken& SlashedValidator::_internal_slashed_tokens(int index) const {
  return slashed_tokens_.Get(index);
}
inline const ::zera_validator::SlashedToken& SlashedValidator::slashed_tokens(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.SlashedValidator.slashed_tokens)
  return _internal_slashed_tokens(index);
}
inline ::zera_validator::SlashedToken* SlashedValidator::_internal_add_slashed_tokens() {
  return slashed_tokens_.Add();
}
inline ::zera_validator::SlashedToken* SlashedValidator::add_slashed_tokens() {
  // @@protoc_insertion_point(field_add:zera_validator.SlashedValidator.slashed_tokens)
  return _internal_add_slashed_tokens();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::SlashedToken >&
SlashedValidator::slashed_tokens() const {
  // @@protoc_insertion_point(field_list:zera_validator.SlashedValidator.slashed_tokens)
  return slashed_tokens_;
}

// -------------------------------------------------------------------

// SlashedRequest

// bytes slashed_block_hash = 1;
inline void SlashedRequest::clear_slashed_block_hash() {
  slashed_block_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SlashedRequest::slashed_block_hash() const {
  // @@protoc_insertion_point(field_get:zera_validator.SlashedRequest.slashed_block_hash)
  return _internal_slashed_block_hash();
}
inline void SlashedRequest::set_slashed_block_hash(const std::string& value) {
  _internal_set_slashed_block_hash(value);
  // @@protoc_insertion_point(field_set:zera_validator.SlashedRequest.slashed_block_hash)
}
inline std::string* SlashedRequest::mutable_slashed_block_hash() {
  // @@protoc_insertion_point(field_mutable:zera_validator.SlashedRequest.slashed_block_hash)
  return _internal_mutable_slashed_block_hash();
}
inline const std::string& SlashedRequest::_internal_slashed_block_hash() const {
  return slashed_block_hash_.Get();
}
inline void SlashedRequest::_internal_set_slashed_block_hash(const std::string& value) {
  
  slashed_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SlashedRequest::set_slashed_block_hash(std::string&& value) {
  
  slashed_block_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.SlashedRequest.slashed_block_hash)
}
inline void SlashedRequest::set_slashed_block_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  slashed_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.SlashedRequest.slashed_block_hash)
}
inline void SlashedRequest::set_slashed_block_hash(const void* value,
    size_t size) {
  
  slashed_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.SlashedRequest.slashed_block_hash)
}
inline std::string* SlashedRequest::_internal_mutable_slashed_block_hash() {
  
  return slashed_block_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SlashedRequest::release_slashed_block_hash() {
  // @@protoc_insertion_point(field_release:zera_validator.SlashedRequest.slashed_block_hash)
  return slashed_block_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SlashedRequest::set_allocated_slashed_block_hash(std::string* slashed_block_hash) {
  if (slashed_block_hash != nullptr) {
    
  } else {
    
  }
  slashed_block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), slashed_block_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.SlashedRequest.slashed_block_hash)
}
inline std::string* SlashedRequest::unsafe_arena_release_slashed_block_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.SlashedRequest.slashed_block_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return slashed_block_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SlashedRequest::unsafe_arena_set_allocated_slashed_block_hash(
    std::string* slashed_block_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (slashed_block_hash != nullptr) {
    
  } else {
    
  }
  slashed_block_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      slashed_block_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.SlashedRequest.slashed_block_hash)
}

// -------------------------------------------------------------------

// SlashedToken

// string contract_id = 1;
inline void SlashedToken::clear_contract_id() {
  contract_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SlashedToken::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.SlashedToken.contract_id)
  return _internal_contract_id();
}
inline void SlashedToken::set_contract_id(const std::string& value) {
  _internal_set_contract_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.SlashedToken.contract_id)
}
inline std::string* SlashedToken::mutable_contract_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.SlashedToken.contract_id)
  return _internal_mutable_contract_id();
}
inline const std::string& SlashedToken::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void SlashedToken::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SlashedToken::set_contract_id(std::string&& value) {
  
  contract_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.SlashedToken.contract_id)
}
inline void SlashedToken::set_contract_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.SlashedToken.contract_id)
}
inline void SlashedToken::set_contract_id(const char* value,
    size_t size) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.SlashedToken.contract_id)
}
inline std::string* SlashedToken::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SlashedToken::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_validator.SlashedToken.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SlashedToken::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.SlashedToken.contract_id)
}
inline std::string* SlashedToken::unsafe_arena_release_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.SlashedToken.contract_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return contract_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SlashedToken::unsafe_arena_set_allocated_contract_id(
    std::string* contract_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      contract_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.SlashedToken.contract_id)
}

// string amount = 2;
inline void SlashedToken::clear_amount() {
  amount_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SlashedToken::amount() const {
  // @@protoc_insertion_point(field_get:zera_validator.SlashedToken.amount)
  return _internal_amount();
}
inline void SlashedToken::set_amount(const std::string& value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:zera_validator.SlashedToken.amount)
}
inline std::string* SlashedToken::mutable_amount() {
  // @@protoc_insertion_point(field_mutable:zera_validator.SlashedToken.amount)
  return _internal_mutable_amount();
}
inline const std::string& SlashedToken::_internal_amount() const {
  return amount_.Get();
}
inline void SlashedToken::_internal_set_amount(const std::string& value) {
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SlashedToken::set_amount(std::string&& value) {
  
  amount_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.SlashedToken.amount)
}
inline void SlashedToken::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.SlashedToken.amount)
}
inline void SlashedToken::set_amount(const char* value,
    size_t size) {
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.SlashedToken.amount)
}
inline std::string* SlashedToken::_internal_mutable_amount() {
  
  return amount_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SlashedToken::release_amount() {
  // @@protoc_insertion_point(field_release:zera_validator.SlashedToken.amount)
  return amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SlashedToken::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.SlashedToken.amount)
}
inline std::string* SlashedToken::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.SlashedToken.amount)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return amount_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SlashedToken::unsafe_arena_set_allocated_amount(
    std::string* amount) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      amount, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.SlashedToken.amount)
}

// -------------------------------------------------------------------

// BlockBatch

// repeated .zera_validator.Block blocks = 1;
inline int BlockBatch::_internal_blocks_size() const {
  return blocks_.size();
}
inline int BlockBatch::blocks_size() const {
  return _internal_blocks_size();
}
inline void BlockBatch::clear_blocks() {
  blocks_.Clear();
}
inline ::zera_validator::Block* BlockBatch::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockBatch.blocks)
  return blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Block >*
BlockBatch::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.BlockBatch.blocks)
  return &blocks_;
}
inline const ::zera_validator::Block& BlockBatch::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const ::zera_validator::Block& BlockBatch::blocks(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockBatch.blocks)
  return _internal_blocks(index);
}
inline ::zera_validator::Block* BlockBatch::_internal_add_blocks() {
  return blocks_.Add();
}
inline ::zera_validator::Block* BlockBatch::add_blocks() {
  // @@protoc_insertion_point(field_add:zera_validator.BlockBatch.blocks)
  return _internal_add_blocks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Block >&
BlockBatch::blocks() const {
  // @@protoc_insertion_point(field_list:zera_validator.BlockBatch.blocks)
  return blocks_;
}

// bool last_block = 2;
inline void BlockBatch::clear_last_block() {
  last_block_ = false;
}
inline bool BlockBatch::_internal_last_block() const {
  return last_block_;
}
inline bool BlockBatch::last_block() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockBatch.last_block)
  return _internal_last_block();
}
inline void BlockBatch::_internal_set_last_block(bool value) {
  
  last_block_ = value;
}
inline void BlockBatch::set_last_block(bool value) {
  _internal_set_last_block(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockBatch.last_block)
}

// bytes signature = 3;
inline bool BlockBatch::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlockBatch::has_signature() const {
  return _internal_has_signature();
}
inline void BlockBatch::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockBatch::signature() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockBatch.signature)
  return _internal_signature();
}
inline void BlockBatch::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:zera_validator.BlockBatch.signature)
}
inline std::string* BlockBatch::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockBatch.signature)
  return _internal_mutable_signature();
}
inline const std::string& BlockBatch::_internal_signature() const {
  return signature_.Get();
}
inline void BlockBatch::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockBatch::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BlockBatch.signature)
}
inline void BlockBatch::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BlockBatch.signature)
}
inline void BlockBatch::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BlockBatch.signature)
}
inline std::string* BlockBatch::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockBatch::release_signature() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockBatch.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockBatch::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockBatch.signature)
}
inline std::string* BlockBatch::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BlockBatch.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BlockBatch::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockBatch.signature)
}

// .zera_txn.PublicKey public_key = 4;
inline bool BlockBatch::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool BlockBatch::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& BlockBatch::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& BlockBatch::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.BlockBatch.public_key)
  return _internal_public_key();
}
inline void BlockBatch::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BlockBatch.public_key)
}
inline ::zera_txn::PublicKey* BlockBatch::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* BlockBatch::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.BlockBatch.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* BlockBatch::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* BlockBatch::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BlockBatch.public_key)
  return _internal_mutable_public_key();
}
inline void BlockBatch::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BlockBatch.public_key)
}

// -------------------------------------------------------------------

// NFT

// bytes holder_address = 1;
inline void NFT::clear_holder_address() {
  holder_address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NFT::holder_address() const {
  // @@protoc_insertion_point(field_get:zera_validator.NFT.holder_address)
  return _internal_holder_address();
}
inline void NFT::set_holder_address(const std::string& value) {
  _internal_set_holder_address(value);
  // @@protoc_insertion_point(field_set:zera_validator.NFT.holder_address)
}
inline std::string* NFT::mutable_holder_address() {
  // @@protoc_insertion_point(field_mutable:zera_validator.NFT.holder_address)
  return _internal_mutable_holder_address();
}
inline const std::string& NFT::_internal_holder_address() const {
  return holder_address_.Get();
}
inline void NFT::_internal_set_holder_address(const std::string& value) {
  
  holder_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NFT::set_holder_address(std::string&& value) {
  
  holder_address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.NFT.holder_address)
}
inline void NFT::set_holder_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  holder_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.NFT.holder_address)
}
inline void NFT::set_holder_address(const void* value,
    size_t size) {
  
  holder_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.NFT.holder_address)
}
inline std::string* NFT::_internal_mutable_holder_address() {
  
  return holder_address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NFT::release_holder_address() {
  // @@protoc_insertion_point(field_release:zera_validator.NFT.holder_address)
  return holder_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NFT::set_allocated_holder_address(std::string* holder_address) {
  if (holder_address != nullptr) {
    
  } else {
    
  }
  holder_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), holder_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.NFT.holder_address)
}
inline std::string* NFT::unsafe_arena_release_holder_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.NFT.holder_address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return holder_address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NFT::unsafe_arena_set_allocated_holder_address(
    std::string* holder_address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (holder_address != nullptr) {
    
  } else {
    
  }
  holder_address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      holder_address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.NFT.holder_address)
}

// string contract_id = 2;
inline void NFT::clear_contract_id() {
  contract_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NFT::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.NFT.contract_id)
  return _internal_contract_id();
}
inline void NFT::set_contract_id(const std::string& value) {
  _internal_set_contract_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.NFT.contract_id)
}
inline std::string* NFT::mutable_contract_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.NFT.contract_id)
  return _internal_mutable_contract_id();
}
inline const std::string& NFT::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void NFT::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NFT::set_contract_id(std::string&& value) {
  
  contract_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.NFT.contract_id)
}
inline void NFT::set_contract_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.NFT.contract_id)
}
inline void NFT::set_contract_id(const char* value,
    size_t size) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.NFT.contract_id)
}
inline std::string* NFT::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NFT::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_validator.NFT.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NFT::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.NFT.contract_id)
}
inline std::string* NFT::unsafe_arena_release_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.NFT.contract_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return contract_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NFT::unsafe_arena_set_allocated_contract_id(
    std::string* contract_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      contract_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.NFT.contract_id)
}

// string item_id = 3;
inline void NFT::clear_item_id() {
  item_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NFT::item_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.NFT.item_id)
  return _internal_item_id();
}
inline void NFT::set_item_id(const std::string& value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.NFT.item_id)
}
inline std::string* NFT::mutable_item_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.NFT.item_id)
  return _internal_mutable_item_id();
}
inline const std::string& NFT::_internal_item_id() const {
  return item_id_.Get();
}
inline void NFT::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NFT::set_item_id(std::string&& value) {
  
  item_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.NFT.item_id)
}
inline void NFT::set_item_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  item_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.NFT.item_id)
}
inline void NFT::set_item_id(const char* value,
    size_t size) {
  
  item_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.NFT.item_id)
}
inline std::string* NFT::_internal_mutable_item_id() {
  
  return item_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NFT::release_item_id() {
  // @@protoc_insertion_point(field_release:zera_validator.NFT.item_id)
  return item_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NFT::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), item_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.NFT.item_id)
}
inline std::string* NFT::unsafe_arena_release_item_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.NFT.item_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return item_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NFT::unsafe_arena_set_allocated_item_id(
    std::string* item_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      item_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.NFT.item_id)
}

// string voting_weight = 4;
inline bool NFT::_internal_has_voting_weight() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NFT::has_voting_weight() const {
  return _internal_has_voting_weight();
}
inline void NFT::clear_voting_weight() {
  voting_weight_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NFT::voting_weight() const {
  // @@protoc_insertion_point(field_get:zera_validator.NFT.voting_weight)
  return _internal_voting_weight();
}
inline void NFT::set_voting_weight(const std::string& value) {
  _internal_set_voting_weight(value);
  // @@protoc_insertion_point(field_set:zera_validator.NFT.voting_weight)
}
inline std::string* NFT::mutable_voting_weight() {
  // @@protoc_insertion_point(field_mutable:zera_validator.NFT.voting_weight)
  return _internal_mutable_voting_weight();
}
inline const std::string& NFT::_internal_voting_weight() const {
  return voting_weight_.Get();
}
inline void NFT::_internal_set_voting_weight(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  voting_weight_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NFT::set_voting_weight(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  voting_weight_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.NFT.voting_weight)
}
inline void NFT::set_voting_weight(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  voting_weight_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.NFT.voting_weight)
}
inline void NFT::set_voting_weight(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  voting_weight_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.NFT.voting_weight)
}
inline std::string* NFT::_internal_mutable_voting_weight() {
  _has_bits_[0] |= 0x00000001u;
  return voting_weight_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NFT::release_voting_weight() {
  // @@protoc_insertion_point(field_release:zera_validator.NFT.voting_weight)
  if (!_internal_has_voting_weight()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return voting_weight_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NFT::set_allocated_voting_weight(std::string* voting_weight) {
  if (voting_weight != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  voting_weight_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), voting_weight,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.NFT.voting_weight)
}
inline std::string* NFT::unsafe_arena_release_voting_weight() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.NFT.voting_weight)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return voting_weight_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NFT::unsafe_arena_set_allocated_voting_weight(
    std::string* voting_weight) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (voting_weight != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  voting_weight_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      voting_weight, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.NFT.voting_weight)
}

// .zera_txn.ItemContractFees contract_fees = 5;
inline bool NFT::_internal_has_contract_fees() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || contract_fees_ != nullptr);
  return value;
}
inline bool NFT::has_contract_fees() const {
  return _internal_has_contract_fees();
}
inline const ::zera_txn::ItemContractFees& NFT::_internal_contract_fees() const {
  const ::zera_txn::ItemContractFees* p = contract_fees_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::ItemContractFees*>(
      &::zera_txn::_ItemContractFees_default_instance_);
}
inline const ::zera_txn::ItemContractFees& NFT::contract_fees() const {
  // @@protoc_insertion_point(field_get:zera_validator.NFT.contract_fees)
  return _internal_contract_fees();
}
inline void NFT::unsafe_arena_set_allocated_contract_fees(
    ::zera_txn::ItemContractFees* contract_fees) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contract_fees_);
  }
  contract_fees_ = contract_fees;
  if (contract_fees) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.NFT.contract_fees)
}
inline ::zera_txn::ItemContractFees* NFT::release_contract_fees() {
  auto temp = unsafe_arena_release_contract_fees();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::ItemContractFees* NFT::unsafe_arena_release_contract_fees() {
  // @@protoc_insertion_point(field_release:zera_validator.NFT.contract_fees)
  _has_bits_[0] &= ~0x00000002u;
  ::zera_txn::ItemContractFees* temp = contract_fees_;
  contract_fees_ = nullptr;
  return temp;
}
inline ::zera_txn::ItemContractFees* NFT::_internal_mutable_contract_fees() {
  _has_bits_[0] |= 0x00000002u;
  if (contract_fees_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::ItemContractFees>(GetArena());
    contract_fees_ = p;
  }
  return contract_fees_;
}
inline ::zera_txn::ItemContractFees* NFT::mutable_contract_fees() {
  // @@protoc_insertion_point(field_mutable:zera_validator.NFT.contract_fees)
  return _internal_mutable_contract_fees();
}
inline void NFT::set_allocated_contract_fees(::zera_txn::ItemContractFees* contract_fees) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(contract_fees_);
  }
  if (contract_fees) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contract_fees)->GetArena();
    if (message_arena != submessage_arena) {
      contract_fees = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_fees, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  contract_fees_ = contract_fees;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.NFT.contract_fees)
}

// -------------------------------------------------------------------

// Item

// string contract_id = 1;
inline void Item::clear_contract_id() {
  contract_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Item::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.Item.contract_id)
  return _internal_contract_id();
}
inline void Item::set_contract_id(const std::string& value) {
  _internal_set_contract_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.Item.contract_id)
}
inline std::string* Item::mutable_contract_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Item.contract_id)
  return _internal_mutable_contract_id();
}
inline const std::string& Item::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void Item::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Item::set_contract_id(std::string&& value) {
  
  contract_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.Item.contract_id)
}
inline void Item::set_contract_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.Item.contract_id)
}
inline void Item::set_contract_id(const char* value,
    size_t size) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.Item.contract_id)
}
inline std::string* Item::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Item::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_validator.Item.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Item::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Item.contract_id)
}
inline std::string* Item::unsafe_arena_release_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.Item.contract_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return contract_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Item::unsafe_arena_set_allocated_contract_id(
    std::string* contract_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      contract_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Item.contract_id)
}

// string item_id = 2;
inline void Item::clear_item_id() {
  item_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Item::item_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.Item.item_id)
  return _internal_item_id();
}
inline void Item::set_item_id(const std::string& value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.Item.item_id)
}
inline std::string* Item::mutable_item_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Item.item_id)
  return _internal_mutable_item_id();
}
inline const std::string& Item::_internal_item_id() const {
  return item_id_.Get();
}
inline void Item::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Item::set_item_id(std::string&& value) {
  
  item_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.Item.item_id)
}
inline void Item::set_item_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  item_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.Item.item_id)
}
inline void Item::set_item_id(const char* value,
    size_t size) {
  
  item_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.Item.item_id)
}
inline std::string* Item::_internal_mutable_item_id() {
  
  return item_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Item::release_item_id() {
  // @@protoc_insertion_point(field_release:zera_validator.Item.item_id)
  return item_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Item::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), item_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Item.item_id)
}
inline std::string* Item::unsafe_arena_release_item_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.Item.item_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return item_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Item::unsafe_arena_set_allocated_item_id(
    std::string* item_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      item_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Item.item_id)
}

// -------------------------------------------------------------------

// WalletItems

// repeated .zera_validator.Item items = 1;
inline int WalletItems::_internal_items_size() const {
  return items_.size();
}
inline int WalletItems::items_size() const {
  return _internal_items_size();
}
inline void WalletItems::clear_items() {
  items_.Clear();
}
inline ::zera_validator::Item* WalletItems::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.WalletItems.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Item >*
WalletItems::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.WalletItems.items)
  return &items_;
}
inline const ::zera_validator::Item& WalletItems::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::zera_validator::Item& WalletItems::items(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.WalletItems.items)
  return _internal_items(index);
}
inline ::zera_validator::Item* WalletItems::_internal_add_items() {
  return items_.Add();
}
inline ::zera_validator::Item* WalletItems::add_items() {
  // @@protoc_insertion_point(field_add:zera_validator.WalletItems.items)
  return _internal_add_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Item >&
WalletItems::items() const {
  // @@protoc_insertion_point(field_list:zera_validator.WalletItems.items)
  return items_;
}

// -------------------------------------------------------------------

// ProcessLedger

// repeated bytes cycle_contract_ids = 1;
inline int ProcessLedger::_internal_cycle_contract_ids_size() const {
  return cycle_contract_ids_.size();
}
inline int ProcessLedger::cycle_contract_ids_size() const {
  return _internal_cycle_contract_ids_size();
}
inline void ProcessLedger::clear_cycle_contract_ids() {
  cycle_contract_ids_.Clear();
}
inline std::string* ProcessLedger::add_cycle_contract_ids() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.ProcessLedger.cycle_contract_ids)
  return _internal_add_cycle_contract_ids();
}
inline const std::string& ProcessLedger::_internal_cycle_contract_ids(int index) const {
  return cycle_contract_ids_.Get(index);
}
inline const std::string& ProcessLedger::cycle_contract_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ProcessLedger.cycle_contract_ids)
  return _internal_cycle_contract_ids(index);
}
inline std::string* ProcessLedger::mutable_cycle_contract_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProcessLedger.cycle_contract_ids)
  return cycle_contract_ids_.Mutable(index);
}
inline void ProcessLedger::set_cycle_contract_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProcessLedger.cycle_contract_ids)
  cycle_contract_ids_.Mutable(index)->assign(value);
}
inline void ProcessLedger::set_cycle_contract_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProcessLedger.cycle_contract_ids)
  cycle_contract_ids_.Mutable(index)->assign(std::move(value));
}
inline void ProcessLedger::set_cycle_contract_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cycle_contract_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.ProcessLedger.cycle_contract_ids)
}
inline void ProcessLedger::set_cycle_contract_ids(int index, const void* value, size_t size) {
  cycle_contract_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProcessLedger.cycle_contract_ids)
}
inline std::string* ProcessLedger::_internal_add_cycle_contract_ids() {
  return cycle_contract_ids_.Add();
}
inline void ProcessLedger::add_cycle_contract_ids(const std::string& value) {
  cycle_contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.ProcessLedger.cycle_contract_ids)
}
inline void ProcessLedger::add_cycle_contract_ids(std::string&& value) {
  cycle_contract_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.ProcessLedger.cycle_contract_ids)
}
inline void ProcessLedger::add_cycle_contract_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cycle_contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.ProcessLedger.cycle_contract_ids)
}
inline void ProcessLedger::add_cycle_contract_ids(const void* value, size_t size) {
  cycle_contract_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.ProcessLedger.cycle_contract_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessLedger::cycle_contract_ids() const {
  // @@protoc_insertion_point(field_list:zera_validator.ProcessLedger.cycle_contract_ids)
  return cycle_contract_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessLedger::mutable_cycle_contract_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ProcessLedger.cycle_contract_ids)
  return &cycle_contract_ids_;
}

// repeated bytes proposal_ids = 2;
inline int ProcessLedger::_internal_proposal_ids_size() const {
  return proposal_ids_.size();
}
inline int ProcessLedger::proposal_ids_size() const {
  return _internal_proposal_ids_size();
}
inline void ProcessLedger::clear_proposal_ids() {
  proposal_ids_.Clear();
}
inline std::string* ProcessLedger::add_proposal_ids() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.ProcessLedger.proposal_ids)
  return _internal_add_proposal_ids();
}
inline const std::string& ProcessLedger::_internal_proposal_ids(int index) const {
  return proposal_ids_.Get(index);
}
inline const std::string& ProcessLedger::proposal_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ProcessLedger.proposal_ids)
  return _internal_proposal_ids(index);
}
inline std::string* ProcessLedger::mutable_proposal_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProcessLedger.proposal_ids)
  return proposal_ids_.Mutable(index);
}
inline void ProcessLedger::set_proposal_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProcessLedger.proposal_ids)
  proposal_ids_.Mutable(index)->assign(value);
}
inline void ProcessLedger::set_proposal_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProcessLedger.proposal_ids)
  proposal_ids_.Mutable(index)->assign(std::move(value));
}
inline void ProcessLedger::set_proposal_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proposal_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.ProcessLedger.proposal_ids)
}
inline void ProcessLedger::set_proposal_ids(int index, const void* value, size_t size) {
  proposal_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProcessLedger.proposal_ids)
}
inline std::string* ProcessLedger::_internal_add_proposal_ids() {
  return proposal_ids_.Add();
}
inline void ProcessLedger::add_proposal_ids(const std::string& value) {
  proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.ProcessLedger.proposal_ids)
}
inline void ProcessLedger::add_proposal_ids(std::string&& value) {
  proposal_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.ProcessLedger.proposal_ids)
}
inline void ProcessLedger::add_proposal_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.ProcessLedger.proposal_ids)
}
inline void ProcessLedger::add_proposal_ids(const void* value, size_t size) {
  proposal_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.ProcessLedger.proposal_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessLedger::proposal_ids() const {
  // @@protoc_insertion_point(field_list:zera_validator.ProcessLedger.proposal_ids)
  return proposal_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessLedger::mutable_proposal_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ProcessLedger.proposal_ids)
  return &proposal_ids_;
}

// -------------------------------------------------------------------

// ProposalLedger

// repeated bytes proposal_ids = 1;
inline int ProposalLedger::_internal_proposal_ids_size() const {
  return proposal_ids_.size();
}
inline int ProposalLedger::proposal_ids_size() const {
  return _internal_proposal_ids_size();
}
inline void ProposalLedger::clear_proposal_ids() {
  proposal_ids_.Clear();
}
inline std::string* ProposalLedger::add_proposal_ids() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.ProposalLedger.proposal_ids)
  return _internal_add_proposal_ids();
}
inline const std::string& ProposalLedger::_internal_proposal_ids(int index) const {
  return proposal_ids_.Get(index);
}
inline const std::string& ProposalLedger::proposal_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.proposal_ids)
  return _internal_proposal_ids(index);
}
inline std::string* ProposalLedger::mutable_proposal_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalLedger.proposal_ids)
  return proposal_ids_.Mutable(index);
}
inline void ProposalLedger::set_proposal_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalLedger.proposal_ids)
  proposal_ids_.Mutable(index)->assign(value);
}
inline void ProposalLedger::set_proposal_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalLedger.proposal_ids)
  proposal_ids_.Mutable(index)->assign(std::move(value));
}
inline void ProposalLedger::set_proposal_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proposal_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalLedger.proposal_ids)
}
inline void ProposalLedger::set_proposal_ids(int index, const void* value, size_t size) {
  proposal_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalLedger.proposal_ids)
}
inline std::string* ProposalLedger::_internal_add_proposal_ids() {
  return proposal_ids_.Add();
}
inline void ProposalLedger::add_proposal_ids(const std::string& value) {
  proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.ProposalLedger.proposal_ids)
}
inline void ProposalLedger::add_proposal_ids(std::string&& value) {
  proposal_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.ProposalLedger.proposal_ids)
}
inline void ProposalLedger::add_proposal_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.ProposalLedger.proposal_ids)
}
inline void ProposalLedger::add_proposal_ids(const void* value, size_t size) {
  proposal_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.ProposalLedger.proposal_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedger::proposal_ids() const {
  // @@protoc_insertion_point(field_list:zera_validator.ProposalLedger.proposal_ids)
  return proposal_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedger::mutable_proposal_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ProposalLedger.proposal_ids)
  return &proposal_ids_;
}

// repeated bytes pending_proposal_ids = 2;
inline int ProposalLedger::_internal_pending_proposal_ids_size() const {
  return pending_proposal_ids_.size();
}
inline int ProposalLedger::pending_proposal_ids_size() const {
  return _internal_pending_proposal_ids_size();
}
inline void ProposalLedger::clear_pending_proposal_ids() {
  pending_proposal_ids_.Clear();
}
inline std::string* ProposalLedger::add_pending_proposal_ids() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.ProposalLedger.pending_proposal_ids)
  return _internal_add_pending_proposal_ids();
}
inline const std::string& ProposalLedger::_internal_pending_proposal_ids(int index) const {
  return pending_proposal_ids_.Get(index);
}
inline const std::string& ProposalLedger::pending_proposal_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.pending_proposal_ids)
  return _internal_pending_proposal_ids(index);
}
inline std::string* ProposalLedger::mutable_pending_proposal_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalLedger.pending_proposal_ids)
  return pending_proposal_ids_.Mutable(index);
}
inline void ProposalLedger::set_pending_proposal_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalLedger.pending_proposal_ids)
  pending_proposal_ids_.Mutable(index)->assign(value);
}
inline void ProposalLedger::set_pending_proposal_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalLedger.pending_proposal_ids)
  pending_proposal_ids_.Mutable(index)->assign(std::move(value));
}
inline void ProposalLedger::set_pending_proposal_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pending_proposal_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalLedger.pending_proposal_ids)
}
inline void ProposalLedger::set_pending_proposal_ids(int index, const void* value, size_t size) {
  pending_proposal_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalLedger.pending_proposal_ids)
}
inline std::string* ProposalLedger::_internal_add_pending_proposal_ids() {
  return pending_proposal_ids_.Add();
}
inline void ProposalLedger::add_pending_proposal_ids(const std::string& value) {
  pending_proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.ProposalLedger.pending_proposal_ids)
}
inline void ProposalLedger::add_pending_proposal_ids(std::string&& value) {
  pending_proposal_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.ProposalLedger.pending_proposal_ids)
}
inline void ProposalLedger::add_pending_proposal_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pending_proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.ProposalLedger.pending_proposal_ids)
}
inline void ProposalLedger::add_pending_proposal_ids(const void* value, size_t size) {
  pending_proposal_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.ProposalLedger.pending_proposal_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedger::pending_proposal_ids() const {
  // @@protoc_insertion_point(field_list:zera_validator.ProposalLedger.pending_proposal_ids)
  return pending_proposal_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedger::mutable_pending_proposal_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ProposalLedger.pending_proposal_ids)
  return &pending_proposal_ids_;
}

// repeated bytes process_proposal_ids = 3;
inline int ProposalLedger::_internal_process_proposal_ids_size() const {
  return process_proposal_ids_.size();
}
inline int ProposalLedger::process_proposal_ids_size() const {
  return _internal_process_proposal_ids_size();
}
inline void ProposalLedger::clear_process_proposal_ids() {
  process_proposal_ids_.Clear();
}
inline std::string* ProposalLedger::add_process_proposal_ids() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.ProposalLedger.process_proposal_ids)
  return _internal_add_process_proposal_ids();
}
inline const std::string& ProposalLedger::_internal_process_proposal_ids(int index) const {
  return process_proposal_ids_.Get(index);
}
inline const std::string& ProposalLedger::process_proposal_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.process_proposal_ids)
  return _internal_process_proposal_ids(index);
}
inline std::string* ProposalLedger::mutable_process_proposal_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalLedger.process_proposal_ids)
  return process_proposal_ids_.Mutable(index);
}
inline void ProposalLedger::set_process_proposal_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalLedger.process_proposal_ids)
  process_proposal_ids_.Mutable(index)->assign(value);
}
inline void ProposalLedger::set_process_proposal_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalLedger.process_proposal_ids)
  process_proposal_ids_.Mutable(index)->assign(std::move(value));
}
inline void ProposalLedger::set_process_proposal_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  process_proposal_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalLedger.process_proposal_ids)
}
inline void ProposalLedger::set_process_proposal_ids(int index, const void* value, size_t size) {
  process_proposal_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalLedger.process_proposal_ids)
}
inline std::string* ProposalLedger::_internal_add_process_proposal_ids() {
  return process_proposal_ids_.Add();
}
inline void ProposalLedger::add_process_proposal_ids(const std::string& value) {
  process_proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.ProposalLedger.process_proposal_ids)
}
inline void ProposalLedger::add_process_proposal_ids(std::string&& value) {
  process_proposal_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.ProposalLedger.process_proposal_ids)
}
inline void ProposalLedger::add_process_proposal_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  process_proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.ProposalLedger.process_proposal_ids)
}
inline void ProposalLedger::add_process_proposal_ids(const void* value, size_t size) {
  process_proposal_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.ProposalLedger.process_proposal_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalLedger::process_proposal_ids() const {
  // @@protoc_insertion_point(field_list:zera_validator.ProposalLedger.process_proposal_ids)
  return process_proposal_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalLedger::mutable_process_proposal_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ProposalLedger.process_proposal_ids)
  return &process_proposal_ids_;
}

// uint32 stage = 4;
inline void ProposalLedger::clear_stage() {
  stage_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProposalLedger::_internal_stage() const {
  return stage_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProposalLedger::stage() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.stage)
  return _internal_stage();
}
inline void ProposalLedger::_internal_set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  stage_ = value;
}
inline void ProposalLedger::set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalLedger.stage)
}

// .google.protobuf.Timestamp cycle_end_date = 5;
inline bool ProposalLedger::_internal_has_cycle_end_date() const {
  return this != internal_default_instance() && cycle_end_date_ != nullptr;
}
inline bool ProposalLedger::has_cycle_end_date() const {
  return _internal_has_cycle_end_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalLedger::_internal_cycle_end_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = cycle_end_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalLedger::cycle_end_date() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.cycle_end_date)
  return _internal_cycle_end_date();
}
inline void ProposalLedger::unsafe_arena_set_allocated_cycle_end_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* cycle_end_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cycle_end_date_);
  }
  cycle_end_date_ = cycle_end_date;
  if (cycle_end_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalLedger.cycle_end_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::release_cycle_end_date() {
  auto temp = unsafe_arena_release_cycle_end_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::unsafe_arena_release_cycle_end_date() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalLedger.cycle_end_date)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = cycle_end_date_;
  cycle_end_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::_internal_mutable_cycle_end_date() {
  
  if (cycle_end_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    cycle_end_date_ = p;
  }
  return cycle_end_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::mutable_cycle_end_date() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalLedger.cycle_end_date)
  return _internal_mutable_cycle_end_date();
}
inline void ProposalLedger::set_allocated_cycle_end_date(PROTOBUF_NAMESPACE_ID::Timestamp* cycle_end_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cycle_end_date_);
  }
  if (cycle_end_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cycle_end_date)->GetArena();
    if (message_arena != submessage_arena) {
      cycle_end_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cycle_end_date, submessage_arena);
    }
    
  } else {
    
  }
  cycle_end_date_ = cycle_end_date;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalLedger.cycle_end_date)
}

// .google.protobuf.Timestamp cycle_start_date = 6;
inline bool ProposalLedger::_internal_has_cycle_start_date() const {
  return this != internal_default_instance() && cycle_start_date_ != nullptr;
}
inline bool ProposalLedger::has_cycle_start_date() const {
  return _internal_has_cycle_start_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalLedger::_internal_cycle_start_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = cycle_start_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalLedger::cycle_start_date() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.cycle_start_date)
  return _internal_cycle_start_date();
}
inline void ProposalLedger::unsafe_arena_set_allocated_cycle_start_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* cycle_start_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cycle_start_date_);
  }
  cycle_start_date_ = cycle_start_date;
  if (cycle_start_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalLedger.cycle_start_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::release_cycle_start_date() {
  auto temp = unsafe_arena_release_cycle_start_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::unsafe_arena_release_cycle_start_date() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalLedger.cycle_start_date)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = cycle_start_date_;
  cycle_start_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::_internal_mutable_cycle_start_date() {
  
  if (cycle_start_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    cycle_start_date_ = p;
  }
  return cycle_start_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::mutable_cycle_start_date() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalLedger.cycle_start_date)
  return _internal_mutable_cycle_start_date();
}
inline void ProposalLedger::set_allocated_cycle_start_date(PROTOBUF_NAMESPACE_ID::Timestamp* cycle_start_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cycle_start_date_);
  }
  if (cycle_start_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cycle_start_date)->GetArena();
    if (message_arena != submessage_arena) {
      cycle_start_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cycle_start_date, submessage_arena);
    }
    
  } else {
    
  }
  cycle_start_date_ = cycle_start_date;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalLedger.cycle_start_date)
}

// .google.protobuf.Timestamp stage_end_date = 7;
inline bool ProposalLedger::_internal_has_stage_end_date() const {
  return this != internal_default_instance() && stage_end_date_ != nullptr;
}
inline bool ProposalLedger::has_stage_end_date() const {
  return _internal_has_stage_end_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalLedger::_internal_stage_end_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = stage_end_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalLedger::stage_end_date() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.stage_end_date)
  return _internal_stage_end_date();
}
inline void ProposalLedger::unsafe_arena_set_allocated_stage_end_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* stage_end_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stage_end_date_);
  }
  stage_end_date_ = stage_end_date;
  if (stage_end_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalLedger.stage_end_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::release_stage_end_date() {
  auto temp = unsafe_arena_release_stage_end_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::unsafe_arena_release_stage_end_date() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalLedger.stage_end_date)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = stage_end_date_;
  stage_end_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::_internal_mutable_stage_end_date() {
  
  if (stage_end_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    stage_end_date_ = p;
  }
  return stage_end_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::mutable_stage_end_date() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalLedger.stage_end_date)
  return _internal_mutable_stage_end_date();
}
inline void ProposalLedger::set_allocated_stage_end_date(PROTOBUF_NAMESPACE_ID::Timestamp* stage_end_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stage_end_date_);
  }
  if (stage_end_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stage_end_date)->GetArena();
    if (message_arena != submessage_arena) {
      stage_end_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stage_end_date, submessage_arena);
    }
    
  } else {
    
  }
  stage_end_date_ = stage_end_date;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalLedger.stage_end_date)
}

// .google.protobuf.Timestamp stage_start_date = 8;
inline bool ProposalLedger::_internal_has_stage_start_date() const {
  return this != internal_default_instance() && stage_start_date_ != nullptr;
}
inline bool ProposalLedger::has_stage_start_date() const {
  return _internal_has_stage_start_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalLedger::_internal_stage_start_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = stage_start_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalLedger::stage_start_date() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.stage_start_date)
  return _internal_stage_start_date();
}
inline void ProposalLedger::unsafe_arena_set_allocated_stage_start_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* stage_start_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stage_start_date_);
  }
  stage_start_date_ = stage_start_date;
  if (stage_start_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalLedger.stage_start_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::release_stage_start_date() {
  auto temp = unsafe_arena_release_stage_start_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::unsafe_arena_release_stage_start_date() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalLedger.stage_start_date)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = stage_start_date_;
  stage_start_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::_internal_mutable_stage_start_date() {
  
  if (stage_start_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    stage_start_date_ = p;
  }
  return stage_start_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalLedger::mutable_stage_start_date() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalLedger.stage_start_date)
  return _internal_mutable_stage_start_date();
}
inline void ProposalLedger::set_allocated_stage_start_date(PROTOBUF_NAMESPACE_ID::Timestamp* stage_start_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stage_start_date_);
  }
  if (stage_start_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stage_start_date)->GetArena();
    if (message_arena != submessage_arena) {
      stage_start_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stage_start_date, submessage_arena);
    }
    
  } else {
    
  }
  stage_start_date_ = stage_start_date;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalLedger.stage_start_date)
}

// bool break = 9;
inline void ProposalLedger::clear_break_() {
  break__ = false;
}
inline bool ProposalLedger::_internal_break_() const {
  return break__;
}
inline bool ProposalLedger::break_() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalLedger.break)
  return _internal_break_();
}
inline void ProposalLedger::_internal_set_break_(bool value) {
  
  break__ = value;
}
inline void ProposalLedger::set_break_(bool value) {
  _internal_set_break_(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalLedger.break)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Vote

// map<string, string> vote = 1;
inline int Vote::_internal_vote_size() const {
  return vote_.size();
}
inline int Vote::vote_size() const {
  return _internal_vote_size();
}
inline void Vote::clear_vote() {
  vote_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Vote::_internal_vote() const {
  return vote_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Vote::vote() const {
  // @@protoc_insertion_point(field_map:zera_validator.Vote.vote)
  return _internal_vote();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Vote::_internal_mutable_vote() {
  return vote_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Vote::mutable_vote() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.Vote.vote)
  return _internal_mutable_vote();
}

// -------------------------------------------------------------------

// Voter

// bool support = 1;
inline bool Voter::_internal_has_support() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Voter::has_support() const {
  return _internal_has_support();
}
inline void Voter::clear_support() {
  support_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Voter::_internal_support() const {
  return support_;
}
inline bool Voter::support() const {
  // @@protoc_insertion_point(field_get:zera_validator.Voter.support)
  return _internal_support();
}
inline void Voter::_internal_set_support(bool value) {
  _has_bits_[0] |= 0x00000002u;
  support_ = value;
}
inline void Voter::set_support(bool value) {
  _internal_set_support(value);
  // @@protoc_insertion_point(field_set:zera_validator.Voter.support)
}

// uint32 option = 2;
inline bool Voter::_internal_has_option() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Voter::has_option() const {
  return _internal_has_option();
}
inline void Voter::clear_option() {
  option_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Voter::_internal_option() const {
  return option_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Voter::option() const {
  // @@protoc_insertion_point(field_get:zera_validator.Voter.option)
  return _internal_option();
}
inline void Voter::_internal_set_option(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  option_ = value;
}
inline void Voter::set_option(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_option(value);
  // @@protoc_insertion_point(field_set:zera_validator.Voter.option)
}

// bool delegated = 3;
inline void Voter::clear_delegated() {
  delegated_ = false;
}
inline bool Voter::_internal_delegated() const {
  return delegated_;
}
inline bool Voter::delegated() const {
  // @@protoc_insertion_point(field_get:zera_validator.Voter.delegated)
  return _internal_delegated();
}
inline void Voter::_internal_set_delegated(bool value) {
  
  delegated_ = value;
}
inline void Voter::set_delegated(bool value) {
  _internal_set_delegated(value);
  // @@protoc_insertion_point(field_set:zera_validator.Voter.delegated)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// VoteWallet

// map<string, .zera_validator.Voter> proposal_votes = 1;
inline int VoteWallet::_internal_proposal_votes_size() const {
  return proposal_votes_.size();
}
inline int VoteWallet::proposal_votes_size() const {
  return _internal_proposal_votes_size();
}
inline void VoteWallet::clear_proposal_votes() {
  proposal_votes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >&
VoteWallet::_internal_proposal_votes() const {
  return proposal_votes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >&
VoteWallet::proposal_votes() const {
  // @@protoc_insertion_point(field_map:zera_validator.VoteWallet.proposal_votes)
  return _internal_proposal_votes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >*
VoteWallet::_internal_mutable_proposal_votes() {
  return proposal_votes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >*
VoteWallet::mutable_proposal_votes() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.VoteWallet.proposal_votes)
  return _internal_mutable_proposal_votes();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Proposal

// string contract_id = 1;
inline void Proposal::clear_contract_id() {
  contract_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Proposal::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.contract_id)
  return _internal_contract_id();
}
inline void Proposal::set_contract_id(const std::string& value) {
  _internal_set_contract_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.Proposal.contract_id)
}
inline std::string* Proposal::mutable_contract_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Proposal.contract_id)
  return _internal_mutable_contract_id();
}
inline const std::string& Proposal::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void Proposal::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Proposal::set_contract_id(std::string&& value) {
  
  contract_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.Proposal.contract_id)
}
inline void Proposal::set_contract_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.Proposal.contract_id)
}
inline void Proposal::set_contract_id(const char* value,
    size_t size) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.Proposal.contract_id)
}
inline std::string* Proposal::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Proposal::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_validator.Proposal.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Proposal.contract_id)
}
inline std::string* Proposal::unsafe_arena_release_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.Proposal.contract_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return contract_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Proposal::unsafe_arena_set_allocated_contract_id(
    std::string* contract_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      contract_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Proposal.contract_id)
}

// map<string, string> yes = 4;
inline int Proposal::_internal_yes_size() const {
  return yes_.size();
}
inline int Proposal::yes_size() const {
  return _internal_yes_size();
}
inline void Proposal::clear_yes() {
  yes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Proposal::_internal_yes() const {
  return yes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Proposal::yes() const {
  // @@protoc_insertion_point(field_map:zera_validator.Proposal.yes)
  return _internal_yes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Proposal::_internal_mutable_yes() {
  return yes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Proposal::mutable_yes() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.Proposal.yes)
  return _internal_mutable_yes();
}

// map<string, string> no = 5;
inline int Proposal::_internal_no_size() const {
  return no_.size();
}
inline int Proposal::no_size() const {
  return _internal_no_size();
}
inline void Proposal::clear_no() {
  no_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Proposal::_internal_no() const {
  return no_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Proposal::no() const {
  // @@protoc_insertion_point(field_map:zera_validator.Proposal.no)
  return _internal_no();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Proposal::_internal_mutable_no() {
  return no_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Proposal::mutable_no() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.Proposal.no)
  return _internal_mutable_no();
}

// map<uint32, .zera_validator.Vote> options = 6;
inline int Proposal::_internal_options_size() const {
  return options_.size();
}
inline int Proposal::options_size() const {
  return _internal_options_size();
}
inline void Proposal::clear_options() {
  options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote >&
Proposal::_internal_options() const {
  return options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote >&
Proposal::options() const {
  // @@protoc_insertion_point(field_map:zera_validator.Proposal.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote >*
Proposal::_internal_mutable_options() {
  return options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::zera_validator::Vote >*
Proposal::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.Proposal.options)
  return _internal_mutable_options();
}

// uint32 stage = 7;
inline void Proposal::clear_stage() {
  stage_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Proposal::_internal_stage() const {
  return stage_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Proposal::stage() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.stage)
  return _internal_stage();
}
inline void Proposal::_internal_set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  stage_ = value;
}
inline void Proposal::set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:zera_validator.Proposal.stage)
}

// string fee = 8;
inline void Proposal::clear_fee() {
  fee_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Proposal::fee() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.fee)
  return _internal_fee();
}
inline void Proposal::set_fee(const std::string& value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:zera_validator.Proposal.fee)
}
inline std::string* Proposal::mutable_fee() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Proposal.fee)
  return _internal_mutable_fee();
}
inline const std::string& Proposal::_internal_fee() const {
  return fee_.Get();
}
inline void Proposal::_internal_set_fee(const std::string& value) {
  
  fee_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Proposal::set_fee(std::string&& value) {
  
  fee_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.Proposal.fee)
}
inline void Proposal::set_fee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fee_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.Proposal.fee)
}
inline void Proposal::set_fee(const char* value,
    size_t size) {
  
  fee_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.Proposal.fee)
}
inline std::string* Proposal::_internal_mutable_fee() {
  
  return fee_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Proposal::release_fee() {
  // @@protoc_insertion_point(field_release:zera_validator.Proposal.fee)
  return fee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_fee(std::string* fee) {
  if (fee != nullptr) {
    
  } else {
    
  }
  fee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Proposal.fee)
}
inline std::string* Proposal::unsafe_arena_release_fee() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.Proposal.fee)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return fee_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Proposal::unsafe_arena_set_allocated_fee(
    std::string* fee) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (fee != nullptr) {
    
  } else {
    
  }
  fee_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      fee, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Proposal.fee)
}

// string fee_id = 9;
inline void Proposal::clear_fee_id() {
  fee_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Proposal::fee_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.fee_id)
  return _internal_fee_id();
}
inline void Proposal::set_fee_id(const std::string& value) {
  _internal_set_fee_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.Proposal.fee_id)
}
inline std::string* Proposal::mutable_fee_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Proposal.fee_id)
  return _internal_mutable_fee_id();
}
inline const std::string& Proposal::_internal_fee_id() const {
  return fee_id_.Get();
}
inline void Proposal::_internal_set_fee_id(const std::string& value) {
  
  fee_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Proposal::set_fee_id(std::string&& value) {
  
  fee_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.Proposal.fee_id)
}
inline void Proposal::set_fee_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fee_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.Proposal.fee_id)
}
inline void Proposal::set_fee_id(const char* value,
    size_t size) {
  
  fee_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.Proposal.fee_id)
}
inline std::string* Proposal::_internal_mutable_fee_id() {
  
  return fee_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Proposal::release_fee_id() {
  // @@protoc_insertion_point(field_release:zera_validator.Proposal.fee_id)
  return fee_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_fee_id(std::string* fee_id) {
  if (fee_id != nullptr) {
    
  } else {
    
  }
  fee_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fee_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Proposal.fee_id)
}
inline std::string* Proposal::unsafe_arena_release_fee_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.Proposal.fee_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return fee_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Proposal::unsafe_arena_set_allocated_fee_id(
    std::string* fee_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (fee_id != nullptr) {
    
  } else {
    
  }
  fee_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      fee_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Proposal.fee_id)
}

// bytes wallet = 10;
inline void Proposal::clear_wallet() {
  wallet_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Proposal::wallet() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.wallet)
  return _internal_wallet();
}
inline void Proposal::set_wallet(const std::string& value) {
  _internal_set_wallet(value);
  // @@protoc_insertion_point(field_set:zera_validator.Proposal.wallet)
}
inline std::string* Proposal::mutable_wallet() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Proposal.wallet)
  return _internal_mutable_wallet();
}
inline const std::string& Proposal::_internal_wallet() const {
  return wallet_.Get();
}
inline void Proposal::_internal_set_wallet(const std::string& value) {
  
  wallet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Proposal::set_wallet(std::string&& value) {
  
  wallet_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.Proposal.wallet)
}
inline void Proposal::set_wallet(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  wallet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.Proposal.wallet)
}
inline void Proposal::set_wallet(const void* value,
    size_t size) {
  
  wallet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.Proposal.wallet)
}
inline std::string* Proposal::_internal_mutable_wallet() {
  
  return wallet_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Proposal::release_wallet() {
  // @@protoc_insertion_point(field_release:zera_validator.Proposal.wallet)
  return wallet_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_wallet(std::string* wallet) {
  if (wallet != nullptr) {
    
  } else {
    
  }
  wallet_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), wallet,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Proposal.wallet)
}
inline std::string* Proposal::unsafe_arena_release_wallet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.Proposal.wallet)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return wallet_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Proposal::unsafe_arena_set_allocated_wallet(
    std::string* wallet) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (wallet != nullptr) {
    
  } else {
    
  }
  wallet_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      wallet, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Proposal.wallet)
}

// map<string, .zera_validator.Voter> voters = 11;
inline int Proposal::_internal_voters_size() const {
  return voters_.size();
}
inline int Proposal::voters_size() const {
  return _internal_voters_size();
}
inline void Proposal::clear_voters() {
  voters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >&
Proposal::_internal_voters() const {
  return voters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >&
Proposal::voters() const {
  // @@protoc_insertion_point(field_map:zera_validator.Proposal.voters)
  return _internal_voters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >*
Proposal::_internal_mutable_voters() {
  return voters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Voter >*
Proposal::mutable_voters() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.Proposal.voters)
  return _internal_mutable_voters();
}

// .google.protobuf.Timestamp start_date = 12;
inline bool Proposal::_internal_has_start_date() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || start_date_ != nullptr);
  return value;
}
inline bool Proposal::has_start_date() const {
  return _internal_has_start_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Proposal::_internal_start_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = start_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Proposal::start_date() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.start_date)
  return _internal_start_date();
}
inline void Proposal::unsafe_arena_set_allocated_start_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* start_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_date_);
  }
  start_date_ = start_date;
  if (start_date) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Proposal.start_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Proposal::release_start_date() {
  auto temp = unsafe_arena_release_start_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Proposal::unsafe_arena_release_start_date() {
  // @@protoc_insertion_point(field_release:zera_validator.Proposal.start_date)
  _has_bits_[0] &= ~0x00000001u;
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_date_;
  start_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Proposal::_internal_mutable_start_date() {
  _has_bits_[0] |= 0x00000001u;
  if (start_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    start_date_ = p;
  }
  return start_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Proposal::mutable_start_date() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Proposal.start_date)
  return _internal_mutable_start_date();
}
inline void Proposal::set_allocated_start_date(PROTOBUF_NAMESPACE_ID::Timestamp* start_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_date_);
  }
  if (start_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_date)->GetArena();
    if (message_arena != submessage_arena) {
      start_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_date, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_date_ = start_date;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Proposal.start_date)
}

// .google.protobuf.Timestamp end_date = 13;
inline bool Proposal::_internal_has_end_date() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || end_date_ != nullptr);
  return value;
}
inline bool Proposal::has_end_date() const {
  return _internal_has_end_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Proposal::_internal_end_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = end_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Proposal::end_date() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.end_date)
  return _internal_end_date();
}
inline void Proposal::unsafe_arena_set_allocated_end_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* end_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date_);
  }
  end_date_ = end_date;
  if (end_date) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Proposal.end_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Proposal::release_end_date() {
  auto temp = unsafe_arena_release_end_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Proposal::unsafe_arena_release_end_date() {
  // @@protoc_insertion_point(field_release:zera_validator.Proposal.end_date)
  _has_bits_[0] &= ~0x00000002u;
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_date_;
  end_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Proposal::_internal_mutable_end_date() {
  _has_bits_[0] |= 0x00000002u;
  if (end_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    end_date_ = p;
  }
  return end_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Proposal::mutable_end_date() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Proposal.end_date)
  return _internal_mutable_end_date();
}
inline void Proposal::set_allocated_end_date(PROTOBUF_NAMESPACE_ID::Timestamp* end_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date_);
  }
  if (end_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date)->GetArena();
    if (message_arena != submessage_arena) {
      end_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_date, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_date_ = end_date;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Proposal.end_date)
}

// .zera_txn.PublicKey public_key = 14;
inline bool Proposal::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool Proposal::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& Proposal::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& Proposal::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.public_key)
  return _internal_public_key();
}
inline void Proposal::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Proposal.public_key)
}
inline ::zera_txn::PublicKey* Proposal::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* Proposal::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.Proposal.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* Proposal::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* Proposal::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Proposal.public_key)
  return _internal_mutable_public_key();
}
inline void Proposal::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Proposal.public_key)
}

// bool options_set = 15;
inline void Proposal::clear_options_set() {
  options_set_ = false;
}
inline bool Proposal::_internal_options_set() const {
  return options_set_;
}
inline bool Proposal::options_set() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.options_set)
  return _internal_options_set();
}
inline void Proposal::_internal_set_options_set(bool value) {
  
  options_set_ = value;
}
inline void Proposal::set_options_set(bool value) {
  _internal_set_options_set(value);
  // @@protoc_insertion_point(field_set:zera_validator.Proposal.options_set)
}

// uint32 number_of_options = 16;
inline void Proposal::clear_number_of_options() {
  number_of_options_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Proposal::_internal_number_of_options() const {
  return number_of_options_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Proposal::number_of_options() const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.number_of_options)
  return _internal_number_of_options();
}
inline void Proposal::_internal_set_number_of_options(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  number_of_options_ = value;
}
inline void Proposal::set_number_of_options(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_number_of_options(value);
  // @@protoc_insertion_point(field_set:zera_validator.Proposal.number_of_options)
}

// repeated .zera_txn.GovernanceTXN governance_txn = 17;
inline int Proposal::_internal_governance_txn_size() const {
  return governance_txn_.size();
}
inline int Proposal::governance_txn_size() const {
  return _internal_governance_txn_size();
}
inline ::zera_txn::GovernanceTXN* Proposal::mutable_governance_txn(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.Proposal.governance_txn)
  return governance_txn_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN >*
Proposal::mutable_governance_txn() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.Proposal.governance_txn)
  return &governance_txn_;
}
inline const ::zera_txn::GovernanceTXN& Proposal::_internal_governance_txn(int index) const {
  return governance_txn_.Get(index);
}
inline const ::zera_txn::GovernanceTXN& Proposal::governance_txn(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.Proposal.governance_txn)
  return _internal_governance_txn(index);
}
inline ::zera_txn::GovernanceTXN* Proposal::_internal_add_governance_txn() {
  return governance_txn_.Add();
}
inline ::zera_txn::GovernanceTXN* Proposal::add_governance_txn() {
  // @@protoc_insertion_point(field_add:zera_validator.Proposal.governance_txn)
  return _internal_add_governance_txn();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN >&
Proposal::governance_txn() const {
  // @@protoc_insertion_point(field_list:zera_validator.Proposal.governance_txn)
  return governance_txn_;
}

// -------------------------------------------------------------------

// ProposalWalletRecieve

// .zera_txn.BaseTXN base = 1;
inline bool ProposalWalletRecieve::_internal_has_base() const {
  return this != internal_default_instance() && base_ != nullptr;
}
inline bool ProposalWalletRecieve::has_base() const {
  return _internal_has_base();
}
inline const ::zera_txn::BaseTXN& ProposalWalletRecieve::_internal_base() const {
  const ::zera_txn::BaseTXN* p = base_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::BaseTXN*>(
      &::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ProposalWalletRecieve::base() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletRecieve.base)
  return _internal_base();
}
inline void ProposalWalletRecieve::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalWalletRecieve.base)
}
inline ::zera_txn::BaseTXN* ProposalWalletRecieve::release_base() {
  auto temp = unsafe_arena_release_base();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::BaseTXN* ProposalWalletRecieve::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalWalletRecieve.base)
  
  ::zera_txn::BaseTXN* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ProposalWalletRecieve::_internal_mutable_base() {
  
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArena());
    base_ = p;
  }
  return base_;
}
inline ::zera_txn::BaseTXN* ProposalWalletRecieve::mutable_base() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletRecieve.base)
  return _internal_mutable_base();
}
inline void ProposalWalletRecieve::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base)->GetArena();
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalWalletRecieve.base)
}

// bytes wallet_adr = 2;
inline void ProposalWalletRecieve::clear_wallet_adr() {
  wallet_adr_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProposalWalletRecieve::wallet_adr() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletRecieve.wallet_adr)
  return _internal_wallet_adr();
}
inline void ProposalWalletRecieve::set_wallet_adr(const std::string& value) {
  _internal_set_wallet_adr(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletRecieve.wallet_adr)
}
inline std::string* ProposalWalletRecieve::mutable_wallet_adr() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletRecieve.wallet_adr)
  return _internal_mutable_wallet_adr();
}
inline const std::string& ProposalWalletRecieve::_internal_wallet_adr() const {
  return wallet_adr_.Get();
}
inline void ProposalWalletRecieve::_internal_set_wallet_adr(const std::string& value) {
  
  wallet_adr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProposalWalletRecieve::set_wallet_adr(std::string&& value) {
  
  wallet_adr_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ProposalWalletRecieve.wallet_adr)
}
inline void ProposalWalletRecieve::set_wallet_adr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  wallet_adr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalWalletRecieve.wallet_adr)
}
inline void ProposalWalletRecieve::set_wallet_adr(const void* value,
    size_t size) {
  
  wallet_adr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalWalletRecieve.wallet_adr)
}
inline std::string* ProposalWalletRecieve::_internal_mutable_wallet_adr() {
  
  return wallet_adr_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProposalWalletRecieve::release_wallet_adr() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalWalletRecieve.wallet_adr)
  return wallet_adr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProposalWalletRecieve::set_allocated_wallet_adr(std::string* wallet_adr) {
  if (wallet_adr != nullptr) {
    
  } else {
    
  }
  wallet_adr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), wallet_adr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalWalletRecieve.wallet_adr)
}
inline std::string* ProposalWalletRecieve::unsafe_arena_release_wallet_adr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ProposalWalletRecieve.wallet_adr)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return wallet_adr_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProposalWalletRecieve::unsafe_arena_set_allocated_wallet_adr(
    std::string* wallet_adr) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (wallet_adr != nullptr) {
    
  } else {
    
  }
  wallet_adr_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      wallet_adr, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalWalletRecieve.wallet_adr)
}

// string contract_id = 3;
inline void ProposalWalletRecieve::clear_contract_id() {
  contract_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProposalWalletRecieve::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletRecieve.contract_id)
  return _internal_contract_id();
}
inline void ProposalWalletRecieve::set_contract_id(const std::string& value) {
  _internal_set_contract_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletRecieve.contract_id)
}
inline std::string* ProposalWalletRecieve::mutable_contract_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletRecieve.contract_id)
  return _internal_mutable_contract_id();
}
inline const std::string& ProposalWalletRecieve::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void ProposalWalletRecieve::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProposalWalletRecieve::set_contract_id(std::string&& value) {
  
  contract_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ProposalWalletRecieve.contract_id)
}
inline void ProposalWalletRecieve::set_contract_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalWalletRecieve.contract_id)
}
inline void ProposalWalletRecieve::set_contract_id(const char* value,
    size_t size) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalWalletRecieve.contract_id)
}
inline std::string* ProposalWalletRecieve::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProposalWalletRecieve::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalWalletRecieve.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProposalWalletRecieve::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalWalletRecieve.contract_id)
}
inline std::string* ProposalWalletRecieve::unsafe_arena_release_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ProposalWalletRecieve.contract_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return contract_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProposalWalletRecieve::unsafe_arena_set_allocated_contract_id(
    std::string* contract_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      contract_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalWalletRecieve.contract_id)
}

// string amount = 4;
inline void ProposalWalletRecieve::clear_amount() {
  amount_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProposalWalletRecieve::amount() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletRecieve.amount)
  return _internal_amount();
}
inline void ProposalWalletRecieve::set_amount(const std::string& value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletRecieve.amount)
}
inline std::string* ProposalWalletRecieve::mutable_amount() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletRecieve.amount)
  return _internal_mutable_amount();
}
inline const std::string& ProposalWalletRecieve::_internal_amount() const {
  return amount_.Get();
}
inline void ProposalWalletRecieve::_internal_set_amount(const std::string& value) {
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProposalWalletRecieve::set_amount(std::string&& value) {
  
  amount_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ProposalWalletRecieve.amount)
}
inline void ProposalWalletRecieve::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalWalletRecieve.amount)
}
inline void ProposalWalletRecieve::set_amount(const char* value,
    size_t size) {
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalWalletRecieve.amount)
}
inline std::string* ProposalWalletRecieve::_internal_mutable_amount() {
  
  return amount_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProposalWalletRecieve::release_amount() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalWalletRecieve.amount)
  return amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProposalWalletRecieve::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalWalletRecieve.amount)
}
inline std::string* ProposalWalletRecieve::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ProposalWalletRecieve.amount)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return amount_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProposalWalletRecieve::unsafe_arena_set_allocated_amount(
    std::string* amount) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      amount, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalWalletRecieve.amount)
}

// -------------------------------------------------------------------

// ProposalWalletSend

// .zera_txn.BaseTXN base = 1;
inline bool ProposalWalletSend::_internal_has_base() const {
  return this != internal_default_instance() && base_ != nullptr;
}
inline bool ProposalWalletSend::has_base() const {
  return _internal_has_base();
}
inline const ::zera_txn::BaseTXN& ProposalWalletSend::_internal_base() const {
  const ::zera_txn::BaseTXN* p = base_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::BaseTXN*>(
      &::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ProposalWalletSend::base() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletSend.base)
  return _internal_base();
}
inline void ProposalWalletSend::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalWalletSend.base)
}
inline ::zera_txn::BaseTXN* ProposalWalletSend::release_base() {
  auto temp = unsafe_arena_release_base();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::BaseTXN* ProposalWalletSend::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalWalletSend.base)
  
  ::zera_txn::BaseTXN* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ProposalWalletSend::_internal_mutable_base() {
  
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArena());
    base_ = p;
  }
  return base_;
}
inline ::zera_txn::BaseTXN* ProposalWalletSend::mutable_base() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletSend.base)
  return _internal_mutable_base();
}
inline void ProposalWalletSend::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base)->GetArena();
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalWalletSend.base)
}

// bytes wallet_adr = 2;
inline void ProposalWalletSend::clear_wallet_adr() {
  wallet_adr_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProposalWalletSend::wallet_adr() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletSend.wallet_adr)
  return _internal_wallet_adr();
}
inline void ProposalWalletSend::set_wallet_adr(const std::string& value) {
  _internal_set_wallet_adr(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletSend.wallet_adr)
}
inline std::string* ProposalWalletSend::mutable_wallet_adr() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletSend.wallet_adr)
  return _internal_mutable_wallet_adr();
}
inline const std::string& ProposalWalletSend::_internal_wallet_adr() const {
  return wallet_adr_.Get();
}
inline void ProposalWalletSend::_internal_set_wallet_adr(const std::string& value) {
  
  wallet_adr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProposalWalletSend::set_wallet_adr(std::string&& value) {
  
  wallet_adr_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ProposalWalletSend.wallet_adr)
}
inline void ProposalWalletSend::set_wallet_adr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  wallet_adr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalWalletSend.wallet_adr)
}
inline void ProposalWalletSend::set_wallet_adr(const void* value,
    size_t size) {
  
  wallet_adr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalWalletSend.wallet_adr)
}
inline std::string* ProposalWalletSend::_internal_mutable_wallet_adr() {
  
  return wallet_adr_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProposalWalletSend::release_wallet_adr() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalWalletSend.wallet_adr)
  return wallet_adr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProposalWalletSend::set_allocated_wallet_adr(std::string* wallet_adr) {
  if (wallet_adr != nullptr) {
    
  } else {
    
  }
  wallet_adr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), wallet_adr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalWalletSend.wallet_adr)
}
inline std::string* ProposalWalletSend::unsafe_arena_release_wallet_adr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ProposalWalletSend.wallet_adr)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return wallet_adr_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProposalWalletSend::unsafe_arena_set_allocated_wallet_adr(
    std::string* wallet_adr) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (wallet_adr != nullptr) {
    
  } else {
    
  }
  wallet_adr_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      wallet_adr, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalWalletSend.wallet_adr)
}

// string contract_id = 3;
inline void ProposalWalletSend::clear_contract_id() {
  contract_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProposalWalletSend::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletSend.contract_id)
  return _internal_contract_id();
}
inline void ProposalWalletSend::set_contract_id(const std::string& value) {
  _internal_set_contract_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletSend.contract_id)
}
inline std::string* ProposalWalletSend::mutable_contract_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletSend.contract_id)
  return _internal_mutable_contract_id();
}
inline const std::string& ProposalWalletSend::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void ProposalWalletSend::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProposalWalletSend::set_contract_id(std::string&& value) {
  
  contract_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ProposalWalletSend.contract_id)
}
inline void ProposalWalletSend::set_contract_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalWalletSend.contract_id)
}
inline void ProposalWalletSend::set_contract_id(const char* value,
    size_t size) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalWalletSend.contract_id)
}
inline std::string* ProposalWalletSend::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProposalWalletSend::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalWalletSend.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProposalWalletSend::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalWalletSend.contract_id)
}
inline std::string* ProposalWalletSend::unsafe_arena_release_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ProposalWalletSend.contract_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return contract_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProposalWalletSend::unsafe_arena_set_allocated_contract_id(
    std::string* contract_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      contract_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalWalletSend.contract_id)
}

// repeated bytes recipient_wallet = 4;
inline int ProposalWalletSend::_internal_recipient_wallet_size() const {
  return recipient_wallet_.size();
}
inline int ProposalWalletSend::recipient_wallet_size() const {
  return _internal_recipient_wallet_size();
}
inline void ProposalWalletSend::clear_recipient_wallet() {
  recipient_wallet_.Clear();
}
inline std::string* ProposalWalletSend::add_recipient_wallet() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.ProposalWalletSend.recipient_wallet)
  return _internal_add_recipient_wallet();
}
inline const std::string& ProposalWalletSend::_internal_recipient_wallet(int index) const {
  return recipient_wallet_.Get(index);
}
inline const std::string& ProposalWalletSend::recipient_wallet(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletSend.recipient_wallet)
  return _internal_recipient_wallet(index);
}
inline std::string* ProposalWalletSend::mutable_recipient_wallet(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletSend.recipient_wallet)
  return recipient_wallet_.Mutable(index);
}
inline void ProposalWalletSend::set_recipient_wallet(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletSend.recipient_wallet)
  recipient_wallet_.Mutable(index)->assign(value);
}
inline void ProposalWalletSend::set_recipient_wallet(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletSend.recipient_wallet)
  recipient_wallet_.Mutable(index)->assign(std::move(value));
}
inline void ProposalWalletSend::set_recipient_wallet(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  recipient_wallet_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalWalletSend.recipient_wallet)
}
inline void ProposalWalletSend::set_recipient_wallet(int index, const void* value, size_t size) {
  recipient_wallet_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalWalletSend.recipient_wallet)
}
inline std::string* ProposalWalletSend::_internal_add_recipient_wallet() {
  return recipient_wallet_.Add();
}
inline void ProposalWalletSend::add_recipient_wallet(const std::string& value) {
  recipient_wallet_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.ProposalWalletSend.recipient_wallet)
}
inline void ProposalWalletSend::add_recipient_wallet(std::string&& value) {
  recipient_wallet_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.ProposalWalletSend.recipient_wallet)
}
inline void ProposalWalletSend::add_recipient_wallet(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  recipient_wallet_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.ProposalWalletSend.recipient_wallet)
}
inline void ProposalWalletSend::add_recipient_wallet(const void* value, size_t size) {
  recipient_wallet_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.ProposalWalletSend.recipient_wallet)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalWalletSend::recipient_wallet() const {
  // @@protoc_insertion_point(field_list:zera_validator.ProposalWalletSend.recipient_wallet)
  return recipient_wallet_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalWalletSend::mutable_recipient_wallet() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ProposalWalletSend.recipient_wallet)
  return &recipient_wallet_;
}

// repeated string amounts = 5;
inline int ProposalWalletSend::_internal_amounts_size() const {
  return amounts_.size();
}
inline int ProposalWalletSend::amounts_size() const {
  return _internal_amounts_size();
}
inline void ProposalWalletSend::clear_amounts() {
  amounts_.Clear();
}
inline std::string* ProposalWalletSend::add_amounts() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.ProposalWalletSend.amounts)
  return _internal_add_amounts();
}
inline const std::string& ProposalWalletSend::_internal_amounts(int index) const {
  return amounts_.Get(index);
}
inline const std::string& ProposalWalletSend::amounts(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalWalletSend.amounts)
  return _internal_amounts(index);
}
inline std::string* ProposalWalletSend::mutable_amounts(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalWalletSend.amounts)
  return amounts_.Mutable(index);
}
inline void ProposalWalletSend::set_amounts(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletSend.amounts)
  amounts_.Mutable(index)->assign(value);
}
inline void ProposalWalletSend::set_amounts(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.ProposalWalletSend.amounts)
  amounts_.Mutable(index)->assign(std::move(value));
}
inline void ProposalWalletSend::set_amounts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  amounts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.ProposalWalletSend.amounts)
}
inline void ProposalWalletSend::set_amounts(int index, const char* value, size_t size) {
  amounts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ProposalWalletSend.amounts)
}
inline std::string* ProposalWalletSend::_internal_add_amounts() {
  return amounts_.Add();
}
inline void ProposalWalletSend::add_amounts(const std::string& value) {
  amounts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.ProposalWalletSend.amounts)
}
inline void ProposalWalletSend::add_amounts(std::string&& value) {
  amounts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.ProposalWalletSend.amounts)
}
inline void ProposalWalletSend::add_amounts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  amounts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.ProposalWalletSend.amounts)
}
inline void ProposalWalletSend::add_amounts(const char* value, size_t size) {
  amounts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.ProposalWalletSend.amounts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalWalletSend::amounts() const {
  // @@protoc_insertion_point(field_list:zera_validator.ProposalWalletSend.amounts)
  return amounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalWalletSend::mutable_amounts() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ProposalWalletSend.amounts)
  return &amounts_;
}

// -------------------------------------------------------------------

// CurrencyRate

// bool qualified = 1;
inline void CurrencyRate::clear_qualified() {
  qualified_ = false;
}
inline bool CurrencyRate::_internal_qualified() const {
  return qualified_;
}
inline bool CurrencyRate::qualified() const {
  // @@protoc_insertion_point(field_get:zera_validator.CurrencyRate.qualified)
  return _internal_qualified();
}
inline void CurrencyRate::_internal_set_qualified(bool value) {
  
  qualified_ = value;
}
inline void CurrencyRate::set_qualified(bool value) {
  _internal_set_qualified(value);
  // @@protoc_insertion_point(field_set:zera_validator.CurrencyRate.qualified)
}

// string rate = 2;
inline void CurrencyRate::clear_rate() {
  rate_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CurrencyRate::rate() const {
  // @@protoc_insertion_point(field_get:zera_validator.CurrencyRate.rate)
  return _internal_rate();
}
inline void CurrencyRate::set_rate(const std::string& value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:zera_validator.CurrencyRate.rate)
}
inline std::string* CurrencyRate::mutable_rate() {
  // @@protoc_insertion_point(field_mutable:zera_validator.CurrencyRate.rate)
  return _internal_mutable_rate();
}
inline const std::string& CurrencyRate::_internal_rate() const {
  return rate_.Get();
}
inline void CurrencyRate::_internal_set_rate(const std::string& value) {
  
  rate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CurrencyRate::set_rate(std::string&& value) {
  
  rate_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.CurrencyRate.rate)
}
inline void CurrencyRate::set_rate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.CurrencyRate.rate)
}
inline void CurrencyRate::set_rate(const char* value,
    size_t size) {
  
  rate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.CurrencyRate.rate)
}
inline std::string* CurrencyRate::_internal_mutable_rate() {
  
  return rate_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CurrencyRate::release_rate() {
  // @@protoc_insertion_point(field_release:zera_validator.CurrencyRate.rate)
  return rate_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrencyRate::set_allocated_rate(std::string* rate) {
  if (rate != nullptr) {
    
  } else {
    
  }
  rate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rate,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.CurrencyRate.rate)
}
inline std::string* CurrencyRate::unsafe_arena_release_rate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.CurrencyRate.rate)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return rate_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CurrencyRate::unsafe_arena_set_allocated_rate(
    std::string* rate) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (rate != nullptr) {
    
  } else {
    
  }
  rate_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      rate, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.CurrencyRate.rate)
}

// string max_stake = 3;
inline bool CurrencyRate::_internal_has_max_stake() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurrencyRate::has_max_stake() const {
  return _internal_has_max_stake();
}
inline void CurrencyRate::clear_max_stake() {
  max_stake_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CurrencyRate::max_stake() const {
  // @@protoc_insertion_point(field_get:zera_validator.CurrencyRate.max_stake)
  return _internal_max_stake();
}
inline void CurrencyRate::set_max_stake(const std::string& value) {
  _internal_set_max_stake(value);
  // @@protoc_insertion_point(field_set:zera_validator.CurrencyRate.max_stake)
}
inline std::string* CurrencyRate::mutable_max_stake() {
  // @@protoc_insertion_point(field_mutable:zera_validator.CurrencyRate.max_stake)
  return _internal_mutable_max_stake();
}
inline const std::string& CurrencyRate::_internal_max_stake() const {
  return max_stake_.Get();
}
inline void CurrencyRate::_internal_set_max_stake(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  max_stake_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CurrencyRate::set_max_stake(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  max_stake_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.CurrencyRate.max_stake)
}
inline void CurrencyRate::set_max_stake(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  max_stake_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.CurrencyRate.max_stake)
}
inline void CurrencyRate::set_max_stake(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  max_stake_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.CurrencyRate.max_stake)
}
inline std::string* CurrencyRate::_internal_mutable_max_stake() {
  _has_bits_[0] |= 0x00000001u;
  return max_stake_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CurrencyRate::release_max_stake() {
  // @@protoc_insertion_point(field_release:zera_validator.CurrencyRate.max_stake)
  if (!_internal_has_max_stake()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return max_stake_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrencyRate::set_allocated_max_stake(std::string* max_stake) {
  if (max_stake != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  max_stake_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), max_stake,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.CurrencyRate.max_stake)
}
inline std::string* CurrencyRate::unsafe_arena_release_max_stake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.CurrencyRate.max_stake)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return max_stake_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CurrencyRate::unsafe_arena_set_allocated_max_stake(
    std::string* max_stake) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (max_stake != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  max_stake_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      max_stake, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.CurrencyRate.max_stake)
}

// -------------------------------------------------------------------

// ExpenseTracker

// int32 day = 1;
inline void ExpenseTracker::clear_day() {
  day_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExpenseTracker::_internal_day() const {
  return day_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExpenseTracker::day() const {
  // @@protoc_insertion_point(field_get:zera_validator.ExpenseTracker.day)
  return _internal_day();
}
inline void ExpenseTracker::_internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  day_ = value;
}
inline void ExpenseTracker::set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:zera_validator.ExpenseTracker.day)
}

// int32 month = 2;
inline void ExpenseTracker::clear_month() {
  month_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExpenseTracker::_internal_month() const {
  return month_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExpenseTracker::month() const {
  // @@protoc_insertion_point(field_get:zera_validator.ExpenseTracker.month)
  return _internal_month();
}
inline void ExpenseTracker::_internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  month_ = value;
}
inline void ExpenseTracker::set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:zera_validator.ExpenseTracker.month)
}

// -------------------------------------------------------------------

// RestrictedSymbols

// repeated string symbols = 1;
inline int RestrictedSymbols::_internal_symbols_size() const {
  return symbols_.size();
}
inline int RestrictedSymbols::symbols_size() const {
  return _internal_symbols_size();
}
inline void RestrictedSymbols::clear_symbols() {
  symbols_.Clear();
}
inline std::string* RestrictedSymbols::add_symbols() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.RestrictedSymbols.symbols)
  return _internal_add_symbols();
}
inline const std::string& RestrictedSymbols::_internal_symbols(int index) const {
  return symbols_.Get(index);
}
inline const std::string& RestrictedSymbols::symbols(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.RestrictedSymbols.symbols)
  return _internal_symbols(index);
}
inline std::string* RestrictedSymbols::mutable_symbols(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.RestrictedSymbols.symbols)
  return symbols_.Mutable(index);
}
inline void RestrictedSymbols::set_symbols(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.RestrictedSymbols.symbols)
  symbols_.Mutable(index)->assign(value);
}
inline void RestrictedSymbols::set_symbols(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.RestrictedSymbols.symbols)
  symbols_.Mutable(index)->assign(std::move(value));
}
inline void RestrictedSymbols::set_symbols(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  symbols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.RestrictedSymbols.symbols)
}
inline void RestrictedSymbols::set_symbols(int index, const char* value, size_t size) {
  symbols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.RestrictedSymbols.symbols)
}
inline std::string* RestrictedSymbols::_internal_add_symbols() {
  return symbols_.Add();
}
inline void RestrictedSymbols::add_symbols(const std::string& value) {
  symbols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.RestrictedSymbols.symbols)
}
inline void RestrictedSymbols::add_symbols(std::string&& value) {
  symbols_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.RestrictedSymbols.symbols)
}
inline void RestrictedSymbols::add_symbols(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  symbols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.RestrictedSymbols.symbols)
}
inline void RestrictedSymbols::add_symbols(const char* value, size_t size) {
  symbols_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.RestrictedSymbols.symbols)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RestrictedSymbols::symbols() const {
  // @@protoc_insertion_point(field_list:zera_validator.RestrictedSymbols.symbols)
  return symbols_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RestrictedSymbols::mutable_symbols() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.RestrictedSymbols.symbols)
  return &symbols_;
}

// -------------------------------------------------------------------

// IndexerVotingRequest

// bytes proposal_id = 1;
inline void IndexerVotingRequest::clear_proposal_id() {
  proposal_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& IndexerVotingRequest::proposal_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerVotingRequest.proposal_id)
  return _internal_proposal_id();
}
inline void IndexerVotingRequest::set_proposal_id(const std::string& value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.IndexerVotingRequest.proposal_id)
}
inline std::string* IndexerVotingRequest::mutable_proposal_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.IndexerVotingRequest.proposal_id)
  return _internal_mutable_proposal_id();
}
inline const std::string& IndexerVotingRequest::_internal_proposal_id() const {
  return proposal_id_.Get();
}
inline void IndexerVotingRequest::_internal_set_proposal_id(const std::string& value) {
  
  proposal_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void IndexerVotingRequest::set_proposal_id(std::string&& value) {
  
  proposal_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.IndexerVotingRequest.proposal_id)
}
inline void IndexerVotingRequest::set_proposal_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proposal_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.IndexerVotingRequest.proposal_id)
}
inline void IndexerVotingRequest::set_proposal_id(const void* value,
    size_t size) {
  
  proposal_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.IndexerVotingRequest.proposal_id)
}
inline std::string* IndexerVotingRequest::_internal_mutable_proposal_id() {
  
  return proposal_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* IndexerVotingRequest::release_proposal_id() {
  // @@protoc_insertion_point(field_release:zera_validator.IndexerVotingRequest.proposal_id)
  return proposal_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IndexerVotingRequest::set_allocated_proposal_id(std::string* proposal_id) {
  if (proposal_id != nullptr) {
    
  } else {
    
  }
  proposal_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proposal_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.IndexerVotingRequest.proposal_id)
}
inline std::string* IndexerVotingRequest::unsafe_arena_release_proposal_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.IndexerVotingRequest.proposal_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return proposal_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void IndexerVotingRequest::unsafe_arena_set_allocated_proposal_id(
    std::string* proposal_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (proposal_id != nullptr) {
    
  } else {
    
  }
  proposal_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      proposal_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.IndexerVotingRequest.proposal_id)
}

// -------------------------------------------------------------------

// IndexerOption

// repeated .zera_validator.IndexerVote votes = 1;
inline int IndexerOption::_internal_votes_size() const {
  return votes_.size();
}
inline int IndexerOption::votes_size() const {
  return _internal_votes_size();
}
inline void IndexerOption::clear_votes() {
  votes_.Clear();
}
inline ::zera_validator::IndexerVote* IndexerOption::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.IndexerOption.votes)
  return votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >*
IndexerOption::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.IndexerOption.votes)
  return &votes_;
}
inline const ::zera_validator::IndexerVote& IndexerOption::_internal_votes(int index) const {
  return votes_.Get(index);
}
inline const ::zera_validator::IndexerVote& IndexerOption::votes(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerOption.votes)
  return _internal_votes(index);
}
inline ::zera_validator::IndexerVote* IndexerOption::_internal_add_votes() {
  return votes_.Add();
}
inline ::zera_validator::IndexerVote* IndexerOption::add_votes() {
  // @@protoc_insertion_point(field_add:zera_validator.IndexerOption.votes)
  return _internal_add_votes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >&
IndexerOption::votes() const {
  // @@protoc_insertion_point(field_list:zera_validator.IndexerOption.votes)
  return votes_;
}

// uint32 index = 2;
inline void IndexerOption::clear_index() {
  index_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IndexerOption::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IndexerOption::index() const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerOption.index)
  return _internal_index();
}
inline void IndexerOption::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  index_ = value;
}
inline void IndexerOption::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:zera_validator.IndexerOption.index)
}

// -------------------------------------------------------------------

// IndexerVote

// string contract_id = 1;
inline void IndexerVote::clear_contract_id() {
  contract_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& IndexerVote::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerVote.contract_id)
  return _internal_contract_id();
}
inline void IndexerVote::set_contract_id(const std::string& value) {
  _internal_set_contract_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.IndexerVote.contract_id)
}
inline std::string* IndexerVote::mutable_contract_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.IndexerVote.contract_id)
  return _internal_mutable_contract_id();
}
inline const std::string& IndexerVote::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void IndexerVote::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void IndexerVote::set_contract_id(std::string&& value) {
  
  contract_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.IndexerVote.contract_id)
}
inline void IndexerVote::set_contract_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.IndexerVote.contract_id)
}
inline void IndexerVote::set_contract_id(const char* value,
    size_t size) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.IndexerVote.contract_id)
}
inline std::string* IndexerVote::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* IndexerVote::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_validator.IndexerVote.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IndexerVote::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.IndexerVote.contract_id)
}
inline std::string* IndexerVote::unsafe_arena_release_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.IndexerVote.contract_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return contract_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void IndexerVote::unsafe_arena_set_allocated_contract_id(
    std::string* contract_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      contract_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.IndexerVote.contract_id)
}

// string amount = 2;
inline void IndexerVote::clear_amount() {
  amount_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& IndexerVote::amount() const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerVote.amount)
  return _internal_amount();
}
inline void IndexerVote::set_amount(const std::string& value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:zera_validator.IndexerVote.amount)
}
inline std::string* IndexerVote::mutable_amount() {
  // @@protoc_insertion_point(field_mutable:zera_validator.IndexerVote.amount)
  return _internal_mutable_amount();
}
inline const std::string& IndexerVote::_internal_amount() const {
  return amount_.Get();
}
inline void IndexerVote::_internal_set_amount(const std::string& value) {
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void IndexerVote::set_amount(std::string&& value) {
  
  amount_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.IndexerVote.amount)
}
inline void IndexerVote::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.IndexerVote.amount)
}
inline void IndexerVote::set_amount(const char* value,
    size_t size) {
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.IndexerVote.amount)
}
inline std::string* IndexerVote::_internal_mutable_amount() {
  
  return amount_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* IndexerVote::release_amount() {
  // @@protoc_insertion_point(field_release:zera_validator.IndexerVote.amount)
  return amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IndexerVote::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.IndexerVote.amount)
}
inline std::string* IndexerVote::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.IndexerVote.amount)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return amount_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void IndexerVote::unsafe_arena_set_allocated_amount(
    std::string* amount) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      amount, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.IndexerVote.amount)
}

// -------------------------------------------------------------------

// IndexerVotingResponse

// repeated .zera_validator.IndexerVote support = 1;
inline int IndexerVotingResponse::_internal_support_size() const {
  return support_.size();
}
inline int IndexerVotingResponse::support_size() const {
  return _internal_support_size();
}
inline void IndexerVotingResponse::clear_support() {
  support_.Clear();
}
inline ::zera_validator::IndexerVote* IndexerVotingResponse::mutable_support(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.IndexerVotingResponse.support)
  return support_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >*
IndexerVotingResponse::mutable_support() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.IndexerVotingResponse.support)
  return &support_;
}
inline const ::zera_validator::IndexerVote& IndexerVotingResponse::_internal_support(int index) const {
  return support_.Get(index);
}
inline const ::zera_validator::IndexerVote& IndexerVotingResponse::support(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerVotingResponse.support)
  return _internal_support(index);
}
inline ::zera_validator::IndexerVote* IndexerVotingResponse::_internal_add_support() {
  return support_.Add();
}
inline ::zera_validator::IndexerVote* IndexerVotingResponse::add_support() {
  // @@protoc_insertion_point(field_add:zera_validator.IndexerVotingResponse.support)
  return _internal_add_support();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >&
IndexerVotingResponse::support() const {
  // @@protoc_insertion_point(field_list:zera_validator.IndexerVotingResponse.support)
  return support_;
}

// repeated .zera_validator.IndexerVote against = 2;
inline int IndexerVotingResponse::_internal_against_size() const {
  return against_.size();
}
inline int IndexerVotingResponse::against_size() const {
  return _internal_against_size();
}
inline void IndexerVotingResponse::clear_against() {
  against_.Clear();
}
inline ::zera_validator::IndexerVote* IndexerVotingResponse::mutable_against(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.IndexerVotingResponse.against)
  return against_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >*
IndexerVotingResponse::mutable_against() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.IndexerVotingResponse.against)
  return &against_;
}
inline const ::zera_validator::IndexerVote& IndexerVotingResponse::_internal_against(int index) const {
  return against_.Get(index);
}
inline const ::zera_validator::IndexerVote& IndexerVotingResponse::against(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerVotingResponse.against)
  return _internal_against(index);
}
inline ::zera_validator::IndexerVote* IndexerVotingResponse::_internal_add_against() {
  return against_.Add();
}
inline ::zera_validator::IndexerVote* IndexerVotingResponse::add_against() {
  // @@protoc_insertion_point(field_add:zera_validator.IndexerVotingResponse.against)
  return _internal_add_against();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerVote >&
IndexerVotingResponse::against() const {
  // @@protoc_insertion_point(field_list:zera_validator.IndexerVotingResponse.against)
  return against_;
}

// repeated .zera_validator.IndexerOption options = 3;
inline int IndexerVotingResponse::_internal_options_size() const {
  return options_.size();
}
inline int IndexerVotingResponse::options_size() const {
  return _internal_options_size();
}
inline void IndexerVotingResponse::clear_options() {
  options_.Clear();
}
inline ::zera_validator::IndexerOption* IndexerVotingResponse::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.IndexerVotingResponse.options)
  return options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerOption >*
IndexerVotingResponse::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.IndexerVotingResponse.options)
  return &options_;
}
inline const ::zera_validator::IndexerOption& IndexerVotingResponse::_internal_options(int index) const {
  return options_.Get(index);
}
inline const ::zera_validator::IndexerOption& IndexerVotingResponse::options(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerVotingResponse.options)
  return _internal_options(index);
}
inline ::zera_validator::IndexerOption* IndexerVotingResponse::_internal_add_options() {
  return options_.Add();
}
inline ::zera_validator::IndexerOption* IndexerVotingResponse::add_options() {
  // @@protoc_insertion_point(field_add:zera_validator.IndexerVotingResponse.options)
  return _internal_add_options();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::IndexerOption >&
IndexerVotingResponse::options() const {
  // @@protoc_insertion_point(field_list:zera_validator.IndexerVotingResponse.options)
  return options_;
}

// uint32 stage = 4;
inline void IndexerVotingResponse::clear_stage() {
  stage_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IndexerVotingResponse::_internal_stage() const {
  return stage_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IndexerVotingResponse::stage() const {
  // @@protoc_insertion_point(field_get:zera_validator.IndexerVotingResponse.stage)
  return _internal_stage();
}
inline void IndexerVotingResponse::_internal_set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  stage_ = value;
}
inline void IndexerVotingResponse::set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:zera_validator.IndexerVotingResponse.stage)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DelegationFees

// map<string, string> authorized_fees = 3;
inline int DelegationFees::_internal_authorized_fees_size() const {
  return authorized_fees_.size();
}
inline int DelegationFees::authorized_fees_size() const {
  return _internal_authorized_fees_size();
}
inline void DelegationFees::clear_authorized_fees() {
  authorized_fees_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DelegationFees::_internal_authorized_fees() const {
  return authorized_fees_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DelegationFees::authorized_fees() const {
  // @@protoc_insertion_point(field_map:zera_validator.DelegationFees.authorized_fees)
  return _internal_authorized_fees();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DelegationFees::_internal_mutable_authorized_fees() {
  return authorized_fees_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DelegationFees::mutable_authorized_fees() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.DelegationFees.authorized_fees)
  return _internal_mutable_authorized_fees();
}

// -------------------------------------------------------------------

// AuthorizedFee

// uint32 priority = 1;
inline void AuthorizedFee::clear_priority() {
  priority_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AuthorizedFee::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AuthorizedFee::priority() const {
  // @@protoc_insertion_point(field_get:zera_validator.AuthorizedFee.priority)
  return _internal_priority();
}
inline void AuthorizedFee::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  priority_ = value;
}
inline void AuthorizedFee::set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:zera_validator.AuthorizedFee.priority)
}

// string authorized_amount = 2;
inline void AuthorizedFee::clear_authorized_amount() {
  authorized_amount_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AuthorizedFee::authorized_amount() const {
  // @@protoc_insertion_point(field_get:zera_validator.AuthorizedFee.authorized_amount)
  return _internal_authorized_amount();
}
inline void AuthorizedFee::set_authorized_amount(const std::string& value) {
  _internal_set_authorized_amount(value);
  // @@protoc_insertion_point(field_set:zera_validator.AuthorizedFee.authorized_amount)
}
inline std::string* AuthorizedFee::mutable_authorized_amount() {
  // @@protoc_insertion_point(field_mutable:zera_validator.AuthorizedFee.authorized_amount)
  return _internal_mutable_authorized_amount();
}
inline const std::string& AuthorizedFee::_internal_authorized_amount() const {
  return authorized_amount_.Get();
}
inline void AuthorizedFee::_internal_set_authorized_amount(const std::string& value) {
  
  authorized_amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AuthorizedFee::set_authorized_amount(std::string&& value) {
  
  authorized_amount_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.AuthorizedFee.authorized_amount)
}
inline void AuthorizedFee::set_authorized_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  authorized_amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.AuthorizedFee.authorized_amount)
}
inline void AuthorizedFee::set_authorized_amount(const char* value,
    size_t size) {
  
  authorized_amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.AuthorizedFee.authorized_amount)
}
inline std::string* AuthorizedFee::_internal_mutable_authorized_amount() {
  
  return authorized_amount_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AuthorizedFee::release_authorized_amount() {
  // @@protoc_insertion_point(field_release:zera_validator.AuthorizedFee.authorized_amount)
  return authorized_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AuthorizedFee::set_allocated_authorized_amount(std::string* authorized_amount) {
  if (authorized_amount != nullptr) {
    
  } else {
    
  }
  authorized_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), authorized_amount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.AuthorizedFee.authorized_amount)
}
inline std::string* AuthorizedFee::unsafe_arena_release_authorized_amount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.AuthorizedFee.authorized_amount)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return authorized_amount_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AuthorizedFee::unsafe_arena_set_allocated_authorized_amount(
    std::string* authorized_amount) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (authorized_amount != nullptr) {
    
  } else {
    
  }
  authorized_amount_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      authorized_amount, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.AuthorizedFee.authorized_amount)
}

// -------------------------------------------------------------------

// Delegator

// .zera_txn.PublicKey public_key = 1;
inline bool Delegator::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool Delegator::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& Delegator::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& Delegator::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.Delegator.public_key)
  return _internal_public_key();
}
inline void Delegator::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.Delegator.public_key)
}
inline ::zera_txn::PublicKey* Delegator::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* Delegator::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.Delegator.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* Delegator::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* Delegator::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.Delegator.public_key)
  return _internal_mutable_public_key();
}
inline void Delegator::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.Delegator.public_key)
}

// uint32 priority = 2;
inline void Delegator::clear_priority() {
  priority_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Delegator::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Delegator::priority() const {
  // @@protoc_insertion_point(field_get:zera_validator.Delegator.priority)
  return _internal_priority();
}
inline void Delegator::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  priority_ = value;
}
inline void Delegator::set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:zera_validator.Delegator.priority)
}

// -------------------------------------------------------------------

// DelegatedFees

// repeated string contract_ids = 1;
inline int DelegatedFees::_internal_contract_ids_size() const {
  return contract_ids_.size();
}
inline int DelegatedFees::contract_ids_size() const {
  return _internal_contract_ids_size();
}
inline void DelegatedFees::clear_contract_ids() {
  contract_ids_.Clear();
}
inline std::string* DelegatedFees::add_contract_ids() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.DelegatedFees.contract_ids)
  return _internal_add_contract_ids();
}
inline const std::string& DelegatedFees::_internal_contract_ids(int index) const {
  return contract_ids_.Get(index);
}
inline const std::string& DelegatedFees::contract_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.DelegatedFees.contract_ids)
  return _internal_contract_ids(index);
}
inline std::string* DelegatedFees::mutable_contract_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.DelegatedFees.contract_ids)
  return contract_ids_.Mutable(index);
}
inline void DelegatedFees::set_contract_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.DelegatedFees.contract_ids)
  contract_ids_.Mutable(index)->assign(value);
}
inline void DelegatedFees::set_contract_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.DelegatedFees.contract_ids)
  contract_ids_.Mutable(index)->assign(std::move(value));
}
inline void DelegatedFees::set_contract_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contract_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.DelegatedFees.contract_ids)
}
inline void DelegatedFees::set_contract_ids(int index, const char* value, size_t size) {
  contract_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.DelegatedFees.contract_ids)
}
inline std::string* DelegatedFees::_internal_add_contract_ids() {
  return contract_ids_.Add();
}
inline void DelegatedFees::add_contract_ids(const std::string& value) {
  contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.DelegatedFees.contract_ids)
}
inline void DelegatedFees::add_contract_ids(std::string&& value) {
  contract_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.DelegatedFees.contract_ids)
}
inline void DelegatedFees::add_contract_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.DelegatedFees.contract_ids)
}
inline void DelegatedFees::add_contract_ids(const char* value, size_t size) {
  contract_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.DelegatedFees.contract_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DelegatedFees::contract_ids() const {
  // @@protoc_insertion_point(field_list:zera_validator.DelegatedFees.contract_ids)
  return contract_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DelegatedFees::mutable_contract_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.DelegatedFees.contract_ids)
  return &contract_ids_;
}

// -------------------------------------------------------------------

// Delegators

// repeated .zera_validator.Delegator delegator = 1;
inline int Delegators::_internal_delegator_size() const {
  return delegator_.size();
}
inline int Delegators::delegator_size() const {
  return _internal_delegator_size();
}
inline void Delegators::clear_delegator() {
  delegator_.Clear();
}
inline ::zera_validator::Delegator* Delegators::mutable_delegator(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.Delegators.delegator)
  return delegator_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Delegator >*
Delegators::mutable_delegator() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.Delegators.delegator)
  return &delegator_;
}
inline const ::zera_validator::Delegator& Delegators::_internal_delegator(int index) const {
  return delegator_.Get(index);
}
inline const ::zera_validator::Delegator& Delegators::delegator(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.Delegators.delegator)
  return _internal_delegator(index);
}
inline ::zera_validator::Delegator* Delegators::_internal_add_delegator() {
  return delegator_.Add();
}
inline ::zera_validator::Delegator* Delegators::add_delegator() {
  // @@protoc_insertion_point(field_add:zera_validator.Delegators.delegator)
  return _internal_add_delegator();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::Delegator >&
Delegators::delegator() const {
  // @@protoc_insertion_point(field_list:zera_validator.Delegators.delegator)
  return delegator_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DelegatedRecipient

// map<string, .zera_validator.Delegators> delegations = 1;
inline int DelegatedRecipient::_internal_delegations_size() const {
  return delegations_.size();
}
inline int DelegatedRecipient::delegations_size() const {
  return _internal_delegations_size();
}
inline void DelegatedRecipient::clear_delegations() {
  delegations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Delegators >&
DelegatedRecipient::_internal_delegations() const {
  return delegations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Delegators >&
DelegatedRecipient::delegations() const {
  // @@protoc_insertion_point(field_map:zera_validator.DelegatedRecipient.delegations)
  return _internal_delegations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Delegators >*
DelegatedRecipient::_internal_mutable_delegations() {
  return delegations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::Delegators >*
DelegatedRecipient::mutable_delegations() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.DelegatedRecipient.delegations)
  return _internal_mutable_delegations();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Delegated

// map<string, uint32> proposals = 1;
inline int Delegated::_internal_proposals_size() const {
  return proposals_.size();
}
inline int Delegated::proposals_size() const {
  return _internal_proposals_size();
}
inline void Delegated::clear_proposals() {
  proposals_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::uint32 >&
Delegated::_internal_proposals() const {
  return proposals_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::uint32 >&
Delegated::proposals() const {
  // @@protoc_insertion_point(field_map:zera_validator.Delegated.proposals)
  return _internal_proposals();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::uint32 >*
Delegated::_internal_mutable_proposals() {
  return proposals_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::uint32 >*
Delegated::mutable_proposals() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.Delegated.proposals)
  return _internal_mutable_proposals();
}

// -------------------------------------------------------------------

// DelegateeWallets

// repeated bytes wallet_adr = 1;
inline int DelegateeWallets::_internal_wallet_adr_size() const {
  return wallet_adr_.size();
}
inline int DelegateeWallets::wallet_adr_size() const {
  return _internal_wallet_adr_size();
}
inline void DelegateeWallets::clear_wallet_adr() {
  wallet_adr_.Clear();
}
inline std::string* DelegateeWallets::add_wallet_adr() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.DelegateeWallets.wallet_adr)
  return _internal_add_wallet_adr();
}
inline const std::string& DelegateeWallets::_internal_wallet_adr(int index) const {
  return wallet_adr_.Get(index);
}
inline const std::string& DelegateeWallets::wallet_adr(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.DelegateeWallets.wallet_adr)
  return _internal_wallet_adr(index);
}
inline std::string* DelegateeWallets::mutable_wallet_adr(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.DelegateeWallets.wallet_adr)
  return wallet_adr_.Mutable(index);
}
inline void DelegateeWallets::set_wallet_adr(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.DelegateeWallets.wallet_adr)
  wallet_adr_.Mutable(index)->assign(value);
}
inline void DelegateeWallets::set_wallet_adr(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.DelegateeWallets.wallet_adr)
  wallet_adr_.Mutable(index)->assign(std::move(value));
}
inline void DelegateeWallets::set_wallet_adr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wallet_adr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.DelegateeWallets.wallet_adr)
}
inline void DelegateeWallets::set_wallet_adr(int index, const void* value, size_t size) {
  wallet_adr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.DelegateeWallets.wallet_adr)
}
inline std::string* DelegateeWallets::_internal_add_wallet_adr() {
  return wallet_adr_.Add();
}
inline void DelegateeWallets::add_wallet_adr(const std::string& value) {
  wallet_adr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.DelegateeWallets.wallet_adr)
}
inline void DelegateeWallets::add_wallet_adr(std::string&& value) {
  wallet_adr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.DelegateeWallets.wallet_adr)
}
inline void DelegateeWallets::add_wallet_adr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wallet_adr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.DelegateeWallets.wallet_adr)
}
inline void DelegateeWallets::add_wallet_adr(const void* value, size_t size) {
  wallet_adr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.DelegateeWallets.wallet_adr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DelegateeWallets::wallet_adr() const {
  // @@protoc_insertion_point(field_list:zera_validator.DelegateeWallets.wallet_adr)
  return wallet_adr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DelegateeWallets::mutable_wallet_adr() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.DelegateeWallets.wallet_adr)
  return &wallet_adr_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Delegatees

// map<string, .zera_validator.DelegateeWallets> delegated_wallets = 1;
inline int Delegatees::_internal_delegated_wallets_size() const {
  return delegated_wallets_.size();
}
inline int Delegatees::delegated_wallets_size() const {
  return _internal_delegated_wallets_size();
}
inline void Delegatees::clear_delegated_wallets() {
  delegated_wallets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::DelegateeWallets >&
Delegatees::_internal_delegated_wallets() const {
  return delegated_wallets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::DelegateeWallets >&
Delegatees::delegated_wallets() const {
  // @@protoc_insertion_point(field_map:zera_validator.Delegatees.delegated_wallets)
  return _internal_delegated_wallets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::DelegateeWallets >*
Delegatees::_internal_mutable_delegated_wallets() {
  return delegated_wallets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::DelegateeWallets >*
Delegatees::mutable_delegated_wallets() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.Delegatees.delegated_wallets)
  return _internal_mutable_delegated_wallets();
}

// -------------------------------------------------------------------

// DelegateWallets

// repeated bytes wallets = 1;
inline int DelegateWallets::_internal_wallets_size() const {
  return wallets_.size();
}
inline int DelegateWallets::wallets_size() const {
  return _internal_wallets_size();
}
inline void DelegateWallets::clear_wallets() {
  wallets_.Clear();
}
inline std::string* DelegateWallets::add_wallets() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.DelegateWallets.wallets)
  return _internal_add_wallets();
}
inline const std::string& DelegateWallets::_internal_wallets(int index) const {
  return wallets_.Get(index);
}
inline const std::string& DelegateWallets::wallets(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.DelegateWallets.wallets)
  return _internal_wallets(index);
}
inline std::string* DelegateWallets::mutable_wallets(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.DelegateWallets.wallets)
  return wallets_.Mutable(index);
}
inline void DelegateWallets::set_wallets(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.DelegateWallets.wallets)
  wallets_.Mutable(index)->assign(value);
}
inline void DelegateWallets::set_wallets(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.DelegateWallets.wallets)
  wallets_.Mutable(index)->assign(std::move(value));
}
inline void DelegateWallets::set_wallets(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wallets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.DelegateWallets.wallets)
}
inline void DelegateWallets::set_wallets(int index, const void* value, size_t size) {
  wallets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.DelegateWallets.wallets)
}
inline std::string* DelegateWallets::_internal_add_wallets() {
  return wallets_.Add();
}
inline void DelegateWallets::add_wallets(const std::string& value) {
  wallets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.DelegateWallets.wallets)
}
inline void DelegateWallets::add_wallets(std::string&& value) {
  wallets_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.DelegateWallets.wallets)
}
inline void DelegateWallets::add_wallets(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wallets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.DelegateWallets.wallets)
}
inline void DelegateWallets::add_wallets(const void* value, size_t size) {
  wallets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.DelegateWallets.wallets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DelegateWallets::wallets() const {
  // @@protoc_insertion_point(field_list:zera_validator.DelegateWallets.wallets)
  return wallets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DelegateWallets::mutable_wallets() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.DelegateWallets.wallets)
  return &wallets_;
}

// -------------------------------------------------------------------

// QuashLedger

// repeated bytes txn_ids = 1;
inline int QuashLedger::_internal_txn_ids_size() const {
  return txn_ids_.size();
}
inline int QuashLedger::txn_ids_size() const {
  return _internal_txn_ids_size();
}
inline void QuashLedger::clear_txn_ids() {
  txn_ids_.Clear();
}
inline std::string* QuashLedger::add_txn_ids() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.QuashLedger.txn_ids)
  return _internal_add_txn_ids();
}
inline const std::string& QuashLedger::_internal_txn_ids(int index) const {
  return txn_ids_.Get(index);
}
inline const std::string& QuashLedger::txn_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.QuashLedger.txn_ids)
  return _internal_txn_ids(index);
}
inline std::string* QuashLedger::mutable_txn_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.QuashLedger.txn_ids)
  return txn_ids_.Mutable(index);
}
inline void QuashLedger::set_txn_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.QuashLedger.txn_ids)
  txn_ids_.Mutable(index)->assign(value);
}
inline void QuashLedger::set_txn_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.QuashLedger.txn_ids)
  txn_ids_.Mutable(index)->assign(std::move(value));
}
inline void QuashLedger::set_txn_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txn_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.QuashLedger.txn_ids)
}
inline void QuashLedger::set_txn_ids(int index, const void* value, size_t size) {
  txn_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.QuashLedger.txn_ids)
}
inline std::string* QuashLedger::_internal_add_txn_ids() {
  return txn_ids_.Add();
}
inline void QuashLedger::add_txn_ids(const std::string& value) {
  txn_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.QuashLedger.txn_ids)
}
inline void QuashLedger::add_txn_ids(std::string&& value) {
  txn_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.QuashLedger.txn_ids)
}
inline void QuashLedger::add_txn_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txn_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.QuashLedger.txn_ids)
}
inline void QuashLedger::add_txn_ids(const void* value, size_t size) {
  txn_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.QuashLedger.txn_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QuashLedger::txn_ids() const {
  // @@protoc_insertion_point(field_list:zera_validator.QuashLedger.txn_ids)
  return txn_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QuashLedger::mutable_txn_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.QuashLedger.txn_ids)
  return &txn_ids_;
}

// -------------------------------------------------------------------

// QuashLookup

// repeated .zera_txn.PublicKey quash_keys = 1;
inline int QuashLookup::_internal_quash_keys_size() const {
  return quash_keys_.size();
}
inline int QuashLookup::quash_keys_size() const {
  return _internal_quash_keys_size();
}
inline ::zera_txn::PublicKey* QuashLookup::mutable_quash_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.QuashLookup.quash_keys)
  return quash_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >*
QuashLookup::mutable_quash_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.QuashLookup.quash_keys)
  return &quash_keys_;
}
inline const ::zera_txn::PublicKey& QuashLookup::_internal_quash_keys(int index) const {
  return quash_keys_.Get(index);
}
inline const ::zera_txn::PublicKey& QuashLookup::quash_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.QuashLookup.quash_keys)
  return _internal_quash_keys(index);
}
inline ::zera_txn::PublicKey* QuashLookup::_internal_add_quash_keys() {
  return quash_keys_.Add();
}
inline ::zera_txn::PublicKey* QuashLookup::add_quash_keys() {
  // @@protoc_insertion_point(field_add:zera_validator.QuashLookup.quash_keys)
  return _internal_add_quash_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >&
QuashLookup::quash_keys() const {
  // @@protoc_insertion_point(field_list:zera_validator.QuashLookup.quash_keys)
  return quash_keys_;
}

// uint32 keys_required = 2;
inline void QuashLookup::clear_keys_required() {
  keys_required_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QuashLookup::_internal_keys_required() const {
  return keys_required_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QuashLookup::keys_required() const {
  // @@protoc_insertion_point(field_get:zera_validator.QuashLookup.keys_required)
  return _internal_keys_required();
}
inline void QuashLookup::_internal_set_keys_required(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  keys_required_ = value;
}
inline void QuashLookup::set_keys_required(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_keys_required(value);
  // @@protoc_insertion_point(field_set:zera_validator.QuashLookup.keys_required)
}

// -------------------------------------------------------------------

// ComplianceData

// uint32 level = 1;
inline void ComplianceData::clear_level() {
  level_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ComplianceData::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ComplianceData::level() const {
  // @@protoc_insertion_point(field_get:zera_validator.ComplianceData.level)
  return _internal_level();
}
inline void ComplianceData::_internal_set_level(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  level_ = value;
}
inline void ComplianceData::set_level(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:zera_validator.ComplianceData.level)
}

// .google.protobuf.Timestamp expiry = 2;
inline bool ComplianceData::_internal_has_expiry() const {
  return this != internal_default_instance() && expiry_ != nullptr;
}
inline bool ComplianceData::has_expiry() const {
  return _internal_has_expiry();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ComplianceData::_internal_expiry() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = expiry_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ComplianceData::expiry() const {
  // @@protoc_insertion_point(field_get:zera_validator.ComplianceData.expiry)
  return _internal_expiry();
}
inline void ComplianceData::unsafe_arena_set_allocated_expiry(
    PROTOBUF_NAMESPACE_ID::Timestamp* expiry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry_);
  }
  expiry_ = expiry;
  if (expiry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ComplianceData.expiry)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ComplianceData::release_expiry() {
  auto temp = unsafe_arena_release_expiry();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ComplianceData::unsafe_arena_release_expiry() {
  // @@protoc_insertion_point(field_release:zera_validator.ComplianceData.expiry)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = expiry_;
  expiry_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ComplianceData::_internal_mutable_expiry() {
  
  if (expiry_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    expiry_ = p;
  }
  return expiry_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ComplianceData::mutable_expiry() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ComplianceData.expiry)
  return _internal_mutable_expiry();
}
inline void ComplianceData::set_allocated_expiry(PROTOBUF_NAMESPACE_ID::Timestamp* expiry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry_);
  }
  if (expiry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry)->GetArena();
    if (message_arena != submessage_arena) {
      expiry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiry, submessage_arena);
    }
    
  } else {
    
  }
  expiry_ = expiry;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ComplianceData.expiry)
}

// -------------------------------------------------------------------

// ComplianceLevels

// repeated .zera_validator.ComplianceData levels = 1;
inline int ComplianceLevels::_internal_levels_size() const {
  return levels_.size();
}
inline int ComplianceLevels::levels_size() const {
  return _internal_levels_size();
}
inline void ComplianceLevels::clear_levels() {
  levels_.Clear();
}
inline ::zera_validator::ComplianceData* ComplianceLevels::mutable_levels(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.ComplianceLevels.levels)
  return levels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ComplianceData >*
ComplianceLevels::mutable_levels() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.ComplianceLevels.levels)
  return &levels_;
}
inline const ::zera_validator::ComplianceData& ComplianceLevels::_internal_levels(int index) const {
  return levels_.Get(index);
}
inline const ::zera_validator::ComplianceData& ComplianceLevels::levels(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.ComplianceLevels.levels)
  return _internal_levels(index);
}
inline ::zera_validator::ComplianceData* ComplianceLevels::_internal_add_levels() {
  return levels_.Add();
}
inline ::zera_validator::ComplianceData* ComplianceLevels::add_levels() {
  // @@protoc_insertion_point(field_add:zera_validator.ComplianceLevels.levels)
  return _internal_add_levels();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::ComplianceData >&
ComplianceLevels::levels() const {
  // @@protoc_insertion_point(field_list:zera_validator.ComplianceLevels.levels)
  return levels_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WalletLookup

// map<string, .zera_validator.ComplianceLevels> compliance = 1;
inline int WalletLookup::_internal_compliance_size() const {
  return compliance_.size();
}
inline int WalletLookup::compliance_size() const {
  return _internal_compliance_size();
}
inline void WalletLookup::clear_compliance() {
  compliance_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ComplianceLevels >&
WalletLookup::_internal_compliance() const {
  return compliance_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ComplianceLevels >&
WalletLookup::compliance() const {
  // @@protoc_insertion_point(field_map:zera_validator.WalletLookup.compliance)
  return _internal_compliance();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ComplianceLevels >*
WalletLookup::_internal_mutable_compliance() {
  return compliance_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_validator::ComplianceLevels >*
WalletLookup::mutable_compliance() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.WalletLookup.compliance)
  return _internal_mutable_compliance();
}

// -------------------------------------------------------------------

// ProposalProcess

// .zera_txn.GOVERNANCE_TYPE type = 1;
inline void ProposalProcess::clear_type() {
  type_ = 0;
}
inline ::zera_txn::GOVERNANCE_TYPE ProposalProcess::_internal_type() const {
  return static_cast< ::zera_txn::GOVERNANCE_TYPE >(type_);
}
inline ::zera_txn::GOVERNANCE_TYPE ProposalProcess::type() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalProcess.type)
  return _internal_type();
}
inline void ProposalProcess::_internal_set_type(::zera_txn::GOVERNANCE_TYPE value) {
  
  type_ = value;
}
inline void ProposalProcess::set_type(::zera_txn::GOVERNANCE_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalProcess.type)
}

// uint32 stage = 2;
inline void ProposalProcess::clear_stage() {
  stage_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProposalProcess::_internal_stage() const {
  return stage_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProposalProcess::stage() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalProcess.stage)
  return _internal_stage();
}
inline void ProposalProcess::_internal_set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  stage_ = value;
}
inline void ProposalProcess::set_stage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalProcess.stage)
}

// uint32 total_stages = 3;
inline void ProposalProcess::clear_total_stages() {
  total_stages_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProposalProcess::_internal_total_stages() const {
  return total_stages_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProposalProcess::total_stages() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalProcess.total_stages)
  return _internal_total_stages();
}
inline void ProposalProcess::_internal_set_total_stages(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  total_stages_ = value;
}
inline void ProposalProcess::set_total_stages(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_total_stages(value);
  // @@protoc_insertion_point(field_set:zera_validator.ProposalProcess.total_stages)
}

// .google.protobuf.Timestamp end_date = 4;
inline bool ProposalProcess::_internal_has_end_date() const {
  return this != internal_default_instance() && end_date_ != nullptr;
}
inline bool ProposalProcess::has_end_date() const {
  return _internal_has_end_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalProcess::_internal_end_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = end_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalProcess::end_date() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalProcess.end_date)
  return _internal_end_date();
}
inline void ProposalProcess::unsafe_arena_set_allocated_end_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* end_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date_);
  }
  end_date_ = end_date;
  if (end_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalProcess.end_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalProcess::release_end_date() {
  auto temp = unsafe_arena_release_end_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalProcess::unsafe_arena_release_end_date() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalProcess.end_date)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_date_;
  end_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalProcess::_internal_mutable_end_date() {
  
  if (end_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    end_date_ = p;
  }
  return end_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalProcess::mutable_end_date() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalProcess.end_date)
  return _internal_mutable_end_date();
}
inline void ProposalProcess::set_allocated_end_date(PROTOBUF_NAMESPACE_ID::Timestamp* end_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date_);
  }
  if (end_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date)->GetArena();
    if (message_arena != submessage_arena) {
      end_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_date, submessage_arena);
    }
    
  } else {
    
  }
  end_date_ = end_date;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalProcess.end_date)
}

// .google.protobuf.Timestamp start_date = 5;
inline bool ProposalProcess::_internal_has_start_date() const {
  return this != internal_default_instance() && start_date_ != nullptr;
}
inline bool ProposalProcess::has_start_date() const {
  return _internal_has_start_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalProcess::_internal_start_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = start_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ProposalProcess::start_date() const {
  // @@protoc_insertion_point(field_get:zera_validator.ProposalProcess.start_date)
  return _internal_start_date();
}
inline void ProposalProcess::unsafe_arena_set_allocated_start_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* start_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_date_);
  }
  start_date_ = start_date;
  if (start_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ProposalProcess.start_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalProcess::release_start_date() {
  auto temp = unsafe_arena_release_start_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalProcess::unsafe_arena_release_start_date() {
  // @@protoc_insertion_point(field_release:zera_validator.ProposalProcess.start_date)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_date_;
  start_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalProcess::_internal_mutable_start_date() {
  
  if (start_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    start_date_ = p;
  }
  return start_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ProposalProcess::mutable_start_date() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ProposalProcess.start_date)
  return _internal_mutable_start_date();
}
inline void ProposalProcess::set_allocated_start_date(PROTOBUF_NAMESPACE_ID::Timestamp* start_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_date_);
  }
  if (start_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_date)->GetArena();
    if (message_arena != submessage_arena) {
      start_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_date, submessage_arena);
    }
    
  } else {
    
  }
  start_date_ = start_date;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ProposalProcess.start_date)
}

// -------------------------------------------------------------------

// TXNTracker

// repeated bytes txn_ids = 1;
inline int TXNTracker::_internal_txn_ids_size() const {
  return txn_ids_.size();
}
inline int TXNTracker::txn_ids_size() const {
  return _internal_txn_ids_size();
}
inline void TXNTracker::clear_txn_ids() {
  txn_ids_.Clear();
}
inline std::string* TXNTracker::add_txn_ids() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.TXNTracker.txn_ids)
  return _internal_add_txn_ids();
}
inline const std::string& TXNTracker::_internal_txn_ids(int index) const {
  return txn_ids_.Get(index);
}
inline const std::string& TXNTracker::txn_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.TXNTracker.txn_ids)
  return _internal_txn_ids(index);
}
inline std::string* TXNTracker::mutable_txn_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.TXNTracker.txn_ids)
  return txn_ids_.Mutable(index);
}
inline void TXNTracker::set_txn_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.TXNTracker.txn_ids)
  txn_ids_.Mutable(index)->assign(value);
}
inline void TXNTracker::set_txn_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.TXNTracker.txn_ids)
  txn_ids_.Mutable(index)->assign(std::move(value));
}
inline void TXNTracker::set_txn_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txn_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.TXNTracker.txn_ids)
}
inline void TXNTracker::set_txn_ids(int index, const void* value, size_t size) {
  txn_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.TXNTracker.txn_ids)
}
inline std::string* TXNTracker::_internal_add_txn_ids() {
  return txn_ids_.Add();
}
inline void TXNTracker::add_txn_ids(const std::string& value) {
  txn_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.TXNTracker.txn_ids)
}
inline void TXNTracker::add_txn_ids(std::string&& value) {
  txn_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.TXNTracker.txn_ids)
}
inline void TXNTracker::add_txn_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txn_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.TXNTracker.txn_ids)
}
inline void TXNTracker::add_txn_ids(const void* value, size_t size) {
  txn_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.TXNTracker.txn_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TXNTracker::txn_ids() const {
  // @@protoc_insertion_point(field_list:zera_validator.TXNTracker.txn_ids)
  return txn_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TXNTracker::mutable_txn_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.TXNTracker.txn_ids)
  return &txn_ids_;
}

// -------------------------------------------------------------------

// PreProcessedWallets

// string amount = 1;
inline void PreProcessedWallets::clear_amount() {
  amount_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PreProcessedWallets::amount() const {
  // @@protoc_insertion_point(field_get:zera_validator.PreProcessedWallets.amount)
  return _internal_amount();
}
inline void PreProcessedWallets::set_amount(const std::string& value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:zera_validator.PreProcessedWallets.amount)
}
inline std::string* PreProcessedWallets::mutable_amount() {
  // @@protoc_insertion_point(field_mutable:zera_validator.PreProcessedWallets.amount)
  return _internal_mutable_amount();
}
inline const std::string& PreProcessedWallets::_internal_amount() const {
  return amount_.Get();
}
inline void PreProcessedWallets::_internal_set_amount(const std::string& value) {
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PreProcessedWallets::set_amount(std::string&& value) {
  
  amount_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.PreProcessedWallets.amount)
}
inline void PreProcessedWallets::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.PreProcessedWallets.amount)
}
inline void PreProcessedWallets::set_amount(const char* value,
    size_t size) {
  
  amount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.PreProcessedWallets.amount)
}
inline std::string* PreProcessedWallets::_internal_mutable_amount() {
  
  return amount_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PreProcessedWallets::release_amount() {
  // @@protoc_insertion_point(field_release:zera_validator.PreProcessedWallets.amount)
  return amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PreProcessedWallets::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.PreProcessedWallets.amount)
}
inline std::string* PreProcessedWallets::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.PreProcessedWallets.amount)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return amount_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PreProcessedWallets::unsafe_arena_set_allocated_amount(
    std::string* amount) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      amount, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.PreProcessedWallets.amount)
}

// -------------------------------------------------------------------

// ZeraGovernanceAuth

// .zera_txn.PublicKey public_key = 1;
inline bool ZeraGovernanceAuth::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool ZeraGovernanceAuth::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::zera_txn::PublicKey& ZeraGovernanceAuth::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = public_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zera_txn::PublicKey*>(
      &::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& ZeraGovernanceAuth::public_key() const {
  // @@protoc_insertion_point(field_get:zera_validator.ZeraGovernanceAuth.public_key)
  return _internal_public_key();
}
inline void ZeraGovernanceAuth::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ZeraGovernanceAuth.public_key)
}
inline ::zera_txn::PublicKey* ZeraGovernanceAuth::release_public_key() {
  auto temp = unsafe_arena_release_public_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zera_txn::PublicKey* ZeraGovernanceAuth::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_validator.ZeraGovernanceAuth.public_key)
  
  ::zera_txn::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* ZeraGovernanceAuth::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::zera_txn::PublicKey* ZeraGovernanceAuth::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ZeraGovernanceAuth.public_key)
  return _internal_mutable_public_key();
}
inline void ZeraGovernanceAuth::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key)->GetArena();
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ZeraGovernanceAuth.public_key)
}

// .zera_txn.TRANSACTION_TYPE type = 2;
inline void ZeraGovernanceAuth::clear_type() {
  type_ = 0;
}
inline ::zera_txn::TRANSACTION_TYPE ZeraGovernanceAuth::_internal_type() const {
  return static_cast< ::zera_txn::TRANSACTION_TYPE >(type_);
}
inline ::zera_txn::TRANSACTION_TYPE ZeraGovernanceAuth::type() const {
  // @@protoc_insertion_point(field_get:zera_validator.ZeraGovernanceAuth.type)
  return _internal_type();
}
inline void ZeraGovernanceAuth::_internal_set_type(::zera_txn::TRANSACTION_TYPE value) {
  
  type_ = value;
}
inline void ZeraGovernanceAuth::set_type(::zera_txn::TRANSACTION_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zera_validator.ZeraGovernanceAuth.type)
}

// -------------------------------------------------------------------

// ContractPrice

// string symbol = 1;
inline void ContractPrice::clear_symbol() {
  symbol_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ContractPrice::symbol() const {
  // @@protoc_insertion_point(field_get:zera_validator.ContractPrice.symbol)
  return _internal_symbol();
}
inline void ContractPrice::set_symbol(const std::string& value) {
  _internal_set_symbol(value);
  // @@protoc_insertion_point(field_set:zera_validator.ContractPrice.symbol)
}
inline std::string* ContractPrice::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ContractPrice.symbol)
  return _internal_mutable_symbol();
}
inline const std::string& ContractPrice::_internal_symbol() const {
  return symbol_.Get();
}
inline void ContractPrice::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContractPrice::set_symbol(std::string&& value) {
  
  symbol_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ContractPrice.symbol)
}
inline void ContractPrice::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ContractPrice.symbol)
}
inline void ContractPrice::set_symbol(const char* value,
    size_t size) {
  
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ContractPrice.symbol)
}
inline std::string* ContractPrice::_internal_mutable_symbol() {
  
  return symbol_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContractPrice::release_symbol() {
  // @@protoc_insertion_point(field_release:zera_validator.ContractPrice.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContractPrice::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ContractPrice.symbol)
}
inline std::string* ContractPrice::unsafe_arena_release_symbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ContractPrice.symbol)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return symbol_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ContractPrice::unsafe_arena_set_allocated_symbol(
    std::string* symbol) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      symbol, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ContractPrice.symbol)
}

// uint32 number_of_symbols = 2;
inline void ContractPrice::clear_number_of_symbols() {
  number_of_symbols_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContractPrice::_internal_number_of_symbols() const {
  return number_of_symbols_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContractPrice::number_of_symbols() const {
  // @@protoc_insertion_point(field_get:zera_validator.ContractPrice.number_of_symbols)
  return _internal_number_of_symbols();
}
inline void ContractPrice::_internal_set_number_of_symbols(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  number_of_symbols_ = value;
}
inline void ContractPrice::set_number_of_symbols(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_number_of_symbols(value);
  // @@protoc_insertion_point(field_set:zera_validator.ContractPrice.number_of_symbols)
}

// string multiplier = 3;
inline void ContractPrice::clear_multiplier() {
  multiplier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ContractPrice::multiplier() const {
  // @@protoc_insertion_point(field_get:zera_validator.ContractPrice.multiplier)
  return _internal_multiplier();
}
inline void ContractPrice::set_multiplier(const std::string& value) {
  _internal_set_multiplier(value);
  // @@protoc_insertion_point(field_set:zera_validator.ContractPrice.multiplier)
}
inline std::string* ContractPrice::mutable_multiplier() {
  // @@protoc_insertion_point(field_mutable:zera_validator.ContractPrice.multiplier)
  return _internal_mutable_multiplier();
}
inline const std::string& ContractPrice::_internal_multiplier() const {
  return multiplier_.Get();
}
inline void ContractPrice::_internal_set_multiplier(const std::string& value) {
  
  multiplier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContractPrice::set_multiplier(std::string&& value) {
  
  multiplier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.ContractPrice.multiplier)
}
inline void ContractPrice::set_multiplier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  multiplier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.ContractPrice.multiplier)
}
inline void ContractPrice::set_multiplier(const char* value,
    size_t size) {
  
  multiplier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.ContractPrice.multiplier)
}
inline std::string* ContractPrice::_internal_mutable_multiplier() {
  
  return multiplier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContractPrice::release_multiplier() {
  // @@protoc_insertion_point(field_release:zera_validator.ContractPrice.multiplier)
  return multiplier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContractPrice::set_allocated_multiplier(std::string* multiplier) {
  if (multiplier != nullptr) {
    
  } else {
    
  }
  multiplier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), multiplier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.ContractPrice.multiplier)
}
inline std::string* ContractPrice::unsafe_arena_release_multiplier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.ContractPrice.multiplier)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return multiplier_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ContractPrice::unsafe_arena_set_allocated_multiplier(
    std::string* multiplier) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (multiplier != nullptr) {
    
  } else {
    
  }
  multiplier_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      multiplier, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.ContractPrice.multiplier)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BalanceTracker

// map<string, string> wallet_balances = 1;
inline int BalanceTracker::_internal_wallet_balances_size() const {
  return wallet_balances_.size();
}
inline int BalanceTracker::wallet_balances_size() const {
  return _internal_wallet_balances_size();
}
inline void BalanceTracker::clear_wallet_balances() {
  wallet_balances_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BalanceTracker::_internal_wallet_balances() const {
  return wallet_balances_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BalanceTracker::wallet_balances() const {
  // @@protoc_insertion_point(field_map:zera_validator.BalanceTracker.wallet_balances)
  return _internal_wallet_balances();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BalanceTracker::_internal_mutable_wallet_balances() {
  return wallet_balances_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BalanceTracker::mutable_wallet_balances() {
  // @@protoc_insertion_point(field_mutable_map:zera_validator.BalanceTracker.wallet_balances)
  return _internal_mutable_wallet_balances();
}

// -------------------------------------------------------------------

// TokenLookup

// repeated string tokens = 1;
inline int TokenLookup::_internal_tokens_size() const {
  return tokens_.size();
}
inline int TokenLookup::tokens_size() const {
  return _internal_tokens_size();
}
inline void TokenLookup::clear_tokens() {
  tokens_.Clear();
}
inline std::string* TokenLookup::add_tokens() {
  // @@protoc_insertion_point(field_add_mutable:zera_validator.TokenLookup.tokens)
  return _internal_add_tokens();
}
inline const std::string& TokenLookup::_internal_tokens(int index) const {
  return tokens_.Get(index);
}
inline const std::string& TokenLookup::tokens(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.TokenLookup.tokens)
  return _internal_tokens(index);
}
inline std::string* TokenLookup::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.TokenLookup.tokens)
  return tokens_.Mutable(index);
}
inline void TokenLookup::set_tokens(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zera_validator.TokenLookup.tokens)
  tokens_.Mutable(index)->assign(value);
}
inline void TokenLookup::set_tokens(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zera_validator.TokenLookup.tokens)
  tokens_.Mutable(index)->assign(std::move(value));
}
inline void TokenLookup::set_tokens(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_validator.TokenLookup.tokens)
}
inline void TokenLookup::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_validator.TokenLookup.tokens)
}
inline std::string* TokenLookup::_internal_add_tokens() {
  return tokens_.Add();
}
inline void TokenLookup::add_tokens(const std::string& value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_validator.TokenLookup.tokens)
}
inline void TokenLookup::add_tokens(std::string&& value) {
  tokens_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_validator.TokenLookup.tokens)
}
inline void TokenLookup::add_tokens(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_validator.TokenLookup.tokens)
}
inline void TokenLookup::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_validator.TokenLookup.tokens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TokenLookup::tokens() const {
  // @@protoc_insertion_point(field_list:zera_validator.TokenLookup.tokens)
  return tokens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TokenLookup::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.TokenLookup.tokens)
  return &tokens_;
}

// -------------------------------------------------------------------

// BalanceRequest

// bytes wallet_address = 1;
inline void BalanceRequest::clear_wallet_address() {
  wallet_address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BalanceRequest::wallet_address() const {
  // @@protoc_insertion_point(field_get:zera_validator.BalanceRequest.wallet_address)
  return _internal_wallet_address();
}
inline void BalanceRequest::set_wallet_address(const std::string& value) {
  _internal_set_wallet_address(value);
  // @@protoc_insertion_point(field_set:zera_validator.BalanceRequest.wallet_address)
}
inline std::string* BalanceRequest::mutable_wallet_address() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BalanceRequest.wallet_address)
  return _internal_mutable_wallet_address();
}
inline const std::string& BalanceRequest::_internal_wallet_address() const {
  return wallet_address_.Get();
}
inline void BalanceRequest::_internal_set_wallet_address(const std::string& value) {
  
  wallet_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BalanceRequest::set_wallet_address(std::string&& value) {
  
  wallet_address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BalanceRequest.wallet_address)
}
inline void BalanceRequest::set_wallet_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  wallet_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BalanceRequest.wallet_address)
}
inline void BalanceRequest::set_wallet_address(const void* value,
    size_t size) {
  
  wallet_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BalanceRequest.wallet_address)
}
inline std::string* BalanceRequest::_internal_mutable_wallet_address() {
  
  return wallet_address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BalanceRequest::release_wallet_address() {
  // @@protoc_insertion_point(field_release:zera_validator.BalanceRequest.wallet_address)
  return wallet_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BalanceRequest::set_allocated_wallet_address(std::string* wallet_address) {
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  wallet_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), wallet_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BalanceRequest.wallet_address)
}
inline std::string* BalanceRequest::unsafe_arena_release_wallet_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BalanceRequest.wallet_address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return wallet_address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BalanceRequest::unsafe_arena_set_allocated_wallet_address(
    std::string* wallet_address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  wallet_address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      wallet_address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BalanceRequest.wallet_address)
}

// string contract_id = 2;
inline void BalanceRequest::clear_contract_id() {
  contract_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BalanceRequest::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_validator.BalanceRequest.contract_id)
  return _internal_contract_id();
}
inline void BalanceRequest::set_contract_id(const std::string& value) {
  _internal_set_contract_id(value);
  // @@protoc_insertion_point(field_set:zera_validator.BalanceRequest.contract_id)
}
inline std::string* BalanceRequest::mutable_contract_id() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BalanceRequest.contract_id)
  return _internal_mutable_contract_id();
}
inline const std::string& BalanceRequest::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void BalanceRequest::_internal_set_contract_id(const std::string& value) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BalanceRequest::set_contract_id(std::string&& value) {
  
  contract_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BalanceRequest.contract_id)
}
inline void BalanceRequest::set_contract_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BalanceRequest.contract_id)
}
inline void BalanceRequest::set_contract_id(const char* value,
    size_t size) {
  
  contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BalanceRequest.contract_id)
}
inline std::string* BalanceRequest::_internal_mutable_contract_id() {
  
  return contract_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BalanceRequest::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_validator.BalanceRequest.contract_id)
  return contract_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BalanceRequest::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BalanceRequest.contract_id)
}
inline std::string* BalanceRequest::unsafe_arena_release_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BalanceRequest.contract_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return contract_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BalanceRequest::unsafe_arena_set_allocated_contract_id(
    std::string* contract_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (contract_id != nullptr) {
    
  } else {
    
  }
  contract_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      contract_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BalanceRequest.contract_id)
}

// bool encoded = 3;
inline void BalanceRequest::clear_encoded() {
  encoded_ = false;
}
inline bool BalanceRequest::_internal_encoded() const {
  return encoded_;
}
inline bool BalanceRequest::encoded() const {
  // @@protoc_insertion_point(field_get:zera_validator.BalanceRequest.encoded)
  return _internal_encoded();
}
inline void BalanceRequest::_internal_set_encoded(bool value) {
  
  encoded_ = value;
}
inline void BalanceRequest::set_encoded(bool value) {
  _internal_set_encoded(value);
  // @@protoc_insertion_point(field_set:zera_validator.BalanceRequest.encoded)
}

// -------------------------------------------------------------------

// BalanceResponse

// string balance = 1;
inline void BalanceResponse::clear_balance() {
  balance_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BalanceResponse::balance() const {
  // @@protoc_insertion_point(field_get:zera_validator.BalanceResponse.balance)
  return _internal_balance();
}
inline void BalanceResponse::set_balance(const std::string& value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:zera_validator.BalanceResponse.balance)
}
inline std::string* BalanceResponse::mutable_balance() {
  // @@protoc_insertion_point(field_mutable:zera_validator.BalanceResponse.balance)
  return _internal_mutable_balance();
}
inline const std::string& BalanceResponse::_internal_balance() const {
  return balance_.Get();
}
inline void BalanceResponse::_internal_set_balance(const std::string& value) {
  
  balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BalanceResponse::set_balance(std::string&& value) {
  
  balance_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.BalanceResponse.balance)
}
inline void BalanceResponse::set_balance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.BalanceResponse.balance)
}
inline void BalanceResponse::set_balance(const char* value,
    size_t size) {
  
  balance_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.BalanceResponse.balance)
}
inline std::string* BalanceResponse::_internal_mutable_balance() {
  
  return balance_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BalanceResponse::release_balance() {
  // @@protoc_insertion_point(field_release:zera_validator.BalanceResponse.balance)
  return balance_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BalanceResponse::set_allocated_balance(std::string* balance) {
  if (balance != nullptr) {
    
  } else {
    
  }
  balance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), balance,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.BalanceResponse.balance)
}
inline std::string* BalanceResponse::unsafe_arena_release_balance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.BalanceResponse.balance)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return balance_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BalanceResponse::unsafe_arena_set_allocated_balance(
    std::string* balance) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (balance != nullptr) {
    
  } else {
    
  }
  balance_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      balance, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.BalanceResponse.balance)
}

// -------------------------------------------------------------------

// TXN

// .zera_txn.TRANSACTION_TYPE txn_type = 1;
inline void TXN::clear_txn_type() {
  txn_type_ = 0;
}
inline ::zera_txn::TRANSACTION_TYPE TXN::_internal_txn_type() const {
  return static_cast< ::zera_txn::TRANSACTION_TYPE >(txn_type_);
}
inline ::zera_txn::TRANSACTION_TYPE TXN::txn_type() const {
  // @@protoc_insertion_point(field_get:zera_validator.TXN.txn_type)
  return _internal_txn_type();
}
inline void TXN::_internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  
  txn_type_ = value;
}
inline void TXN::set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  _internal_set_txn_type(value);
  // @@protoc_insertion_point(field_set:zera_validator.TXN.txn_type)
}

// bytes serialized_txn = 2;
inline void TXN::clear_serialized_txn() {
  serialized_txn_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TXN::serialized_txn() const {
  // @@protoc_insertion_point(field_get:zera_validator.TXN.serialized_txn)
  return _internal_serialized_txn();
}
inline void TXN::set_serialized_txn(const std::string& value) {
  _internal_set_serialized_txn(value);
  // @@protoc_insertion_point(field_set:zera_validator.TXN.serialized_txn)
}
inline std::string* TXN::mutable_serialized_txn() {
  // @@protoc_insertion_point(field_mutable:zera_validator.TXN.serialized_txn)
  return _internal_mutable_serialized_txn();
}
inline const std::string& TXN::_internal_serialized_txn() const {
  return serialized_txn_.Get();
}
inline void TXN::_internal_set_serialized_txn(const std::string& value) {
  
  serialized_txn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TXN::set_serialized_txn(std::string&& value) {
  
  serialized_txn_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zera_validator.TXN.serialized_txn)
}
inline void TXN::set_serialized_txn(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  serialized_txn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zera_validator.TXN.serialized_txn)
}
inline void TXN::set_serialized_txn(const void* value,
    size_t size) {
  
  serialized_txn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zera_validator.TXN.serialized_txn)
}
inline std::string* TXN::_internal_mutable_serialized_txn() {
  
  return serialized_txn_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TXN::release_serialized_txn() {
  // @@protoc_insertion_point(field_release:zera_validator.TXN.serialized_txn)
  return serialized_txn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TXN::set_allocated_serialized_txn(std::string* serialized_txn) {
  if (serialized_txn != nullptr) {
    
  } else {
    
  }
  serialized_txn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_txn,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zera_validator.TXN.serialized_txn)
}
inline std::string* TXN::unsafe_arena_release_serialized_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_validator.TXN.serialized_txn)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return serialized_txn_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TXN::unsafe_arena_set_allocated_serialized_txn(
    std::string* serialized_txn) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (serialized_txn != nullptr) {
    
  } else {
    
  }
  serialized_txn_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      serialized_txn, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_validator.TXN.serialized_txn)
}

// -------------------------------------------------------------------

// TXNGossip

// repeated .zera_validator.TXN txns = 1;
inline int TXNGossip::_internal_txns_size() const {
  return txns_.size();
}
inline int TXNGossip::txns_size() const {
  return _internal_txns_size();
}
inline void TXNGossip::clear_txns() {
  txns_.Clear();
}
inline ::zera_validator::TXN* TXNGossip::mutable_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_validator.TXNGossip.txns)
  return txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::TXN >*
TXNGossip::mutable_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_validator.TXNGossip.txns)
  return &txns_;
}
inline const ::zera_validator::TXN& TXNGossip::_internal_txns(int index) const {
  return txns_.Get(index);
}
inline const ::zera_validator::TXN& TXNGossip::txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_validator.TXNGossip.txns)
  return _internal_txns(index);
}
inline ::zera_validator::TXN* TXNGossip::_internal_add_txns() {
  return txns_.Add();
}
inline ::zera_validator::TXN* TXNGossip::add_txns() {
  // @@protoc_insertion_point(field_add:zera_validator.TXNGossip.txns)
  return _internal_add_txns();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_validator::TXN >&
TXNGossip::txns() const {
  // @@protoc_insertion_point(field_list:zera_validator.TXNGossip.txns)
  return txns_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zera_validator

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_validator_2eproto
