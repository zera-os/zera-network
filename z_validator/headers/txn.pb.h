// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: txn.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_txn_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_txn_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_txn_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_txn_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_txn_2eproto;
namespace zera_txn {
class AllowanceTXN;
struct AllowanceTXNDefaultTypeInternal;
extern AllowanceTXNDefaultTypeInternal _AllowanceTXN_default_instance_;
class AuthorizedCurrencyEquiv;
struct AuthorizedCurrencyEquivDefaultTypeInternal;
extern AuthorizedCurrencyEquivDefaultTypeInternal _AuthorizedCurrencyEquiv_default_instance_;
class BaseTXN;
struct BaseTXNDefaultTypeInternal;
extern BaseTXNDefaultTypeInternal _BaseTXN_default_instance_;
class BurnSBTTXN;
struct BurnSBTTXNDefaultTypeInternal;
extern BurnSBTTXNDefaultTypeInternal _BurnSBTTXN_default_instance_;
class ByteMultiplier;
struct ByteMultiplierDefaultTypeInternal;
extern ByteMultiplierDefaultTypeInternal _ByteMultiplier_default_instance_;
class CoinDenomination;
struct CoinDenominationDefaultTypeInternal;
extern CoinDenominationDefaultTypeInternal _CoinDenomination_default_instance_;
class CoinTXN;
struct CoinTXNDefaultTypeInternal;
extern CoinTXNDefaultTypeInternal _CoinTXN_default_instance_;
class Compliance;
struct ComplianceDefaultTypeInternal;
extern ComplianceDefaultTypeInternal _Compliance_default_instance_;
class ComplianceAssign;
struct ComplianceAssignDefaultTypeInternal;
extern ComplianceAssignDefaultTypeInternal _ComplianceAssign_default_instance_;
class ComplianceTXN;
struct ComplianceTXNDefaultTypeInternal;
extern ComplianceTXNDefaultTypeInternal _ComplianceTXN_default_instance_;
class ContractFees;
struct ContractFeesDefaultTypeInternal;
extern ContractFeesDefaultTypeInternal _ContractFees_default_instance_;
class ContractUpdateTXN;
struct ContractUpdateTXNDefaultTypeInternal;
extern ContractUpdateTXNDefaultTypeInternal _ContractUpdateTXN_default_instance_;
class CurrencyEquiv;
struct CurrencyEquivDefaultTypeInternal;
extern CurrencyEquivDefaultTypeInternal _CurrencyEquiv_default_instance_;
class DelegateContract;
struct DelegateContractDefaultTypeInternal;
extern DelegateContractDefaultTypeInternal _DelegateContract_default_instance_;
class DelegateFees;
struct DelegateFeesDefaultTypeInternal;
extern DelegateFeesDefaultTypeInternal _DelegateFees_default_instance_;
class DelegateVote;
struct DelegateVoteDefaultTypeInternal;
extern DelegateVoteDefaultTypeInternal _DelegateVote_default_instance_;
class DelegatedData;
struct DelegatedDataDefaultTypeInternal;
extern DelegatedDataDefaultTypeInternal _DelegatedData_default_instance_;
class DelegatedTXN;
struct DelegatedTXNDefaultTypeInternal;
extern DelegatedTXNDefaultTypeInternal _DelegatedTXN_default_instance_;
class ExpenseRatio;
struct ExpenseRatioDefaultTypeInternal;
extern ExpenseRatioDefaultTypeInternal _ExpenseRatio_default_instance_;
class ExpenseRatioResult;
struct ExpenseRatioResultDefaultTypeInternal;
extern ExpenseRatioResultDefaultTypeInternal _ExpenseRatioResult_default_instance_;
class ExpenseRatioTXN;
struct ExpenseRatioTXNDefaultTypeInternal;
extern ExpenseRatioTXNDefaultTypeInternal _ExpenseRatioTXN_default_instance_;
class FastQuorumTXN;
struct FastQuorumTXNDefaultTypeInternal;
extern FastQuorumTXNDefaultTypeInternal _FastQuorumTXN_default_instance_;
class FoundationTXN;
struct FoundationTXNDefaultTypeInternal;
extern FoundationTXNDefaultTypeInternal _FoundationTXN_default_instance_;
class Governance;
struct GovernanceDefaultTypeInternal;
extern GovernanceDefaultTypeInternal _Governance_default_instance_;
class GovernanceAuth;
struct GovernanceAuthDefaultTypeInternal;
extern GovernanceAuthDefaultTypeInternal _GovernanceAuth_default_instance_;
class GovernanceProposal;
struct GovernanceProposalDefaultTypeInternal;
extern GovernanceProposalDefaultTypeInternal _GovernanceProposal_default_instance_;
class GovernanceTXN;
struct GovernanceTXNDefaultTypeInternal;
extern GovernanceTXNDefaultTypeInternal _GovernanceTXN_default_instance_;
class GovernanceVote;
struct GovernanceVoteDefaultTypeInternal;
extern GovernanceVoteDefaultTypeInternal _GovernanceVote_default_instance_;
class InputTransfers;
struct InputTransfersDefaultTypeInternal;
extern InputTransfersDefaultTypeInternal _InputTransfers_default_instance_;
class InstrumentContract;
struct InstrumentContractDefaultTypeInternal;
extern InstrumentContractDefaultTypeInternal _InstrumentContract_default_instance_;
class ItemContractFees;
struct ItemContractFeesDefaultTypeInternal;
extern ItemContractFeesDefaultTypeInternal _ItemContractFees_default_instance_;
class ItemizedMintTXN;
struct ItemizedMintTXNDefaultTypeInternal;
extern ItemizedMintTXNDefaultTypeInternal _ItemizedMintTXN_default_instance_;
class KeyValuePair;
struct KeyValuePairDefaultTypeInternal;
extern KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
class MaxSupplyRelease;
struct MaxSupplyReleaseDefaultTypeInternal;
extern MaxSupplyReleaseDefaultTypeInternal _MaxSupplyRelease_default_instance_;
class MintTXN;
struct MintTXNDefaultTypeInternal;
extern MintTXNDefaultTypeInternal _MintTXN_default_instance_;
class MultiKey;
struct MultiKeyDefaultTypeInternal;
extern MultiKeyDefaultTypeInternal _MultiKey_default_instance_;
class MultiPatterns;
struct MultiPatternsDefaultTypeInternal;
extern MultiPatternsDefaultTypeInternal _MultiPatterns_default_instance_;
class NFTTXN;
struct NFTTXNDefaultTypeInternal;
extern NFTTXNDefaultTypeInternal _NFTTXN_default_instance_;
class OutputTransfers;
struct OutputTransfersDefaultTypeInternal;
extern OutputTransfersDefaultTypeInternal _OutputTransfers_default_instance_;
class Parameters;
struct ParametersDefaultTypeInternal;
extern ParametersDefaultTypeInternal _Parameters_default_instance_;
class PreMintWallet;
struct PreMintWalletDefaultTypeInternal;
extern PreMintWalletDefaultTypeInternal _PreMintWallet_default_instance_;
class ProposalContract;
struct ProposalContractDefaultTypeInternal;
extern ProposalContractDefaultTypeInternal _ProposalContract_default_instance_;
class ProposalResult;
struct ProposalResultDefaultTypeInternal;
extern ProposalResultDefaultTypeInternal _ProposalResult_default_instance_;
class PublicKey;
struct PublicKeyDefaultTypeInternal;
extern PublicKeyDefaultTypeInternal _PublicKey_default_instance_;
class QuashResult;
struct QuashResultDefaultTypeInternal;
extern QuashResultDefaultTypeInternal _QuashResult_default_instance_;
class QuashTXN;
struct QuashTXNDefaultTypeInternal;
extern QuashTXNDefaultTypeInternal _QuashTXN_default_instance_;
class RequiredVersion;
struct RequiredVersionDefaultTypeInternal;
extern RequiredVersionDefaultTypeInternal _RequiredVersion_default_instance_;
class RestrictedKey;
struct RestrictedKeyDefaultTypeInternal;
extern RestrictedKeyDefaultTypeInternal _RestrictedKey_default_instance_;
class RevokeTXN;
struct RevokeTXNDefaultTypeInternal;
extern RevokeTXNDefaultTypeInternal _RevokeTXN_default_instance_;
class SelfCurrencyEquiv;
struct SelfCurrencyEquivDefaultTypeInternal;
extern SelfCurrencyEquivDefaultTypeInternal _SelfCurrencyEquiv_default_instance_;
class SmartContractExecuteTXN;
struct SmartContractExecuteTXNDefaultTypeInternal;
extern SmartContractExecuteTXNDefaultTypeInternal _SmartContractExecuteTXN_default_instance_;
class SmartContractInstantiateTXN;
struct SmartContractInstantiateTXNDefaultTypeInternal;
extern SmartContractInstantiateTXNDefaultTypeInternal _SmartContractInstantiateTXN_default_instance_;
class SmartContractParameter;
struct SmartContractParameterDefaultTypeInternal;
extern SmartContractParameterDefaultTypeInternal _SmartContractParameter_default_instance_;
class SmartContractTXN;
struct SmartContractTXNDefaultTypeInternal;
extern SmartContractTXNDefaultTypeInternal _SmartContractTXN_default_instance_;
class Stage;
struct StageDefaultTypeInternal;
extern StageDefaultTypeInternal _Stage_default_instance_;
class TXNS;
struct TXNSDefaultTypeInternal;
extern TXNSDefaultTypeInternal _TXNS_default_instance_;
class TXNStatusFees;
struct TXNStatusFeesDefaultTypeInternal;
extern TXNStatusFeesDefaultTypeInternal _TXNStatusFees_default_instance_;
class TXNWrapper;
struct TXNWrapperDefaultTypeInternal;
extern TXNWrapperDefaultTypeInternal _TXNWrapper_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class TokenCompliance;
struct TokenComplianceDefaultTypeInternal;
extern TokenComplianceDefaultTypeInternal _TokenCompliance_default_instance_;
class TokenFees;
struct TokenFeesDefaultTypeInternal;
extern TokenFeesDefaultTypeInternal _TokenFees_default_instance_;
class Transfer;
struct TransferDefaultTypeInternal;
extern TransferDefaultTypeInternal _Transfer_default_instance_;
class TransferAuthentication;
struct TransferAuthenticationDefaultTypeInternal;
extern TransferAuthenticationDefaultTypeInternal _TransferAuthentication_default_instance_;
class Validator;
struct ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
class ValidatorHeartbeat;
struct ValidatorHeartbeatDefaultTypeInternal;
extern ValidatorHeartbeatDefaultTypeInternal _ValidatorHeartbeat_default_instance_;
class ValidatorRegistration;
struct ValidatorRegistrationDefaultTypeInternal;
extern ValidatorRegistrationDefaultTypeInternal _ValidatorRegistration_default_instance_;
class VotePair;
struct VotePairDefaultTypeInternal;
extern VotePairDefaultTypeInternal _VotePair_default_instance_;
class Votes;
struct VotesDefaultTypeInternal;
extern VotesDefaultTypeInternal _Votes_default_instance_;
class Wallets;
struct WalletsDefaultTypeInternal;
extern WalletsDefaultTypeInternal _Wallets_default_instance_;
}  // namespace zera_txn
PROTOBUF_NAMESPACE_OPEN
template<> ::zera_txn::AllowanceTXN* Arena::CreateMaybeMessage<::zera_txn::AllowanceTXN>(Arena*);
template<> ::zera_txn::AuthorizedCurrencyEquiv* Arena::CreateMaybeMessage<::zera_txn::AuthorizedCurrencyEquiv>(Arena*);
template<> ::zera_txn::BaseTXN* Arena::CreateMaybeMessage<::zera_txn::BaseTXN>(Arena*);
template<> ::zera_txn::BurnSBTTXN* Arena::CreateMaybeMessage<::zera_txn::BurnSBTTXN>(Arena*);
template<> ::zera_txn::ByteMultiplier* Arena::CreateMaybeMessage<::zera_txn::ByteMultiplier>(Arena*);
template<> ::zera_txn::CoinDenomination* Arena::CreateMaybeMessage<::zera_txn::CoinDenomination>(Arena*);
template<> ::zera_txn::CoinTXN* Arena::CreateMaybeMessage<::zera_txn::CoinTXN>(Arena*);
template<> ::zera_txn::Compliance* Arena::CreateMaybeMessage<::zera_txn::Compliance>(Arena*);
template<> ::zera_txn::ComplianceAssign* Arena::CreateMaybeMessage<::zera_txn::ComplianceAssign>(Arena*);
template<> ::zera_txn::ComplianceTXN* Arena::CreateMaybeMessage<::zera_txn::ComplianceTXN>(Arena*);
template<> ::zera_txn::ContractFees* Arena::CreateMaybeMessage<::zera_txn::ContractFees>(Arena*);
template<> ::zera_txn::ContractUpdateTXN* Arena::CreateMaybeMessage<::zera_txn::ContractUpdateTXN>(Arena*);
template<> ::zera_txn::CurrencyEquiv* Arena::CreateMaybeMessage<::zera_txn::CurrencyEquiv>(Arena*);
template<> ::zera_txn::DelegateContract* Arena::CreateMaybeMessage<::zera_txn::DelegateContract>(Arena*);
template<> ::zera_txn::DelegateFees* Arena::CreateMaybeMessage<::zera_txn::DelegateFees>(Arena*);
template<> ::zera_txn::DelegateVote* Arena::CreateMaybeMessage<::zera_txn::DelegateVote>(Arena*);
template<> ::zera_txn::DelegatedData* Arena::CreateMaybeMessage<::zera_txn::DelegatedData>(Arena*);
template<> ::zera_txn::DelegatedTXN* Arena::CreateMaybeMessage<::zera_txn::DelegatedTXN>(Arena*);
template<> ::zera_txn::ExpenseRatio* Arena::CreateMaybeMessage<::zera_txn::ExpenseRatio>(Arena*);
template<> ::zera_txn::ExpenseRatioResult* Arena::CreateMaybeMessage<::zera_txn::ExpenseRatioResult>(Arena*);
template<> ::zera_txn::ExpenseRatioTXN* Arena::CreateMaybeMessage<::zera_txn::ExpenseRatioTXN>(Arena*);
template<> ::zera_txn::FastQuorumTXN* Arena::CreateMaybeMessage<::zera_txn::FastQuorumTXN>(Arena*);
template<> ::zera_txn::FoundationTXN* Arena::CreateMaybeMessage<::zera_txn::FoundationTXN>(Arena*);
template<> ::zera_txn::Governance* Arena::CreateMaybeMessage<::zera_txn::Governance>(Arena*);
template<> ::zera_txn::GovernanceAuth* Arena::CreateMaybeMessage<::zera_txn::GovernanceAuth>(Arena*);
template<> ::zera_txn::GovernanceProposal* Arena::CreateMaybeMessage<::zera_txn::GovernanceProposal>(Arena*);
template<> ::zera_txn::GovernanceTXN* Arena::CreateMaybeMessage<::zera_txn::GovernanceTXN>(Arena*);
template<> ::zera_txn::GovernanceVote* Arena::CreateMaybeMessage<::zera_txn::GovernanceVote>(Arena*);
template<> ::zera_txn::InputTransfers* Arena::CreateMaybeMessage<::zera_txn::InputTransfers>(Arena*);
template<> ::zera_txn::InstrumentContract* Arena::CreateMaybeMessage<::zera_txn::InstrumentContract>(Arena*);
template<> ::zera_txn::ItemContractFees* Arena::CreateMaybeMessage<::zera_txn::ItemContractFees>(Arena*);
template<> ::zera_txn::ItemizedMintTXN* Arena::CreateMaybeMessage<::zera_txn::ItemizedMintTXN>(Arena*);
template<> ::zera_txn::KeyValuePair* Arena::CreateMaybeMessage<::zera_txn::KeyValuePair>(Arena*);
template<> ::zera_txn::MaxSupplyRelease* Arena::CreateMaybeMessage<::zera_txn::MaxSupplyRelease>(Arena*);
template<> ::zera_txn::MintTXN* Arena::CreateMaybeMessage<::zera_txn::MintTXN>(Arena*);
template<> ::zera_txn::MultiKey* Arena::CreateMaybeMessage<::zera_txn::MultiKey>(Arena*);
template<> ::zera_txn::MultiPatterns* Arena::CreateMaybeMessage<::zera_txn::MultiPatterns>(Arena*);
template<> ::zera_txn::NFTTXN* Arena::CreateMaybeMessage<::zera_txn::NFTTXN>(Arena*);
template<> ::zera_txn::OutputTransfers* Arena::CreateMaybeMessage<::zera_txn::OutputTransfers>(Arena*);
template<> ::zera_txn::Parameters* Arena::CreateMaybeMessage<::zera_txn::Parameters>(Arena*);
template<> ::zera_txn::PreMintWallet* Arena::CreateMaybeMessage<::zera_txn::PreMintWallet>(Arena*);
template<> ::zera_txn::ProposalContract* Arena::CreateMaybeMessage<::zera_txn::ProposalContract>(Arena*);
template<> ::zera_txn::ProposalResult* Arena::CreateMaybeMessage<::zera_txn::ProposalResult>(Arena*);
template<> ::zera_txn::PublicKey* Arena::CreateMaybeMessage<::zera_txn::PublicKey>(Arena*);
template<> ::zera_txn::QuashResult* Arena::CreateMaybeMessage<::zera_txn::QuashResult>(Arena*);
template<> ::zera_txn::QuashTXN* Arena::CreateMaybeMessage<::zera_txn::QuashTXN>(Arena*);
template<> ::zera_txn::RequiredVersion* Arena::CreateMaybeMessage<::zera_txn::RequiredVersion>(Arena*);
template<> ::zera_txn::RestrictedKey* Arena::CreateMaybeMessage<::zera_txn::RestrictedKey>(Arena*);
template<> ::zera_txn::RevokeTXN* Arena::CreateMaybeMessage<::zera_txn::RevokeTXN>(Arena*);
template<> ::zera_txn::SelfCurrencyEquiv* Arena::CreateMaybeMessage<::zera_txn::SelfCurrencyEquiv>(Arena*);
template<> ::zera_txn::SmartContractExecuteTXN* Arena::CreateMaybeMessage<::zera_txn::SmartContractExecuteTXN>(Arena*);
template<> ::zera_txn::SmartContractInstantiateTXN* Arena::CreateMaybeMessage<::zera_txn::SmartContractInstantiateTXN>(Arena*);
template<> ::zera_txn::SmartContractParameter* Arena::CreateMaybeMessage<::zera_txn::SmartContractParameter>(Arena*);
template<> ::zera_txn::SmartContractTXN* Arena::CreateMaybeMessage<::zera_txn::SmartContractTXN>(Arena*);
template<> ::zera_txn::Stage* Arena::CreateMaybeMessage<::zera_txn::Stage>(Arena*);
template<> ::zera_txn::TXNS* Arena::CreateMaybeMessage<::zera_txn::TXNS>(Arena*);
template<> ::zera_txn::TXNStatusFees* Arena::CreateMaybeMessage<::zera_txn::TXNStatusFees>(Arena*);
template<> ::zera_txn::TXNWrapper* Arena::CreateMaybeMessage<::zera_txn::TXNWrapper>(Arena*);
template<> ::zera_txn::Token* Arena::CreateMaybeMessage<::zera_txn::Token>(Arena*);
template<> ::zera_txn::TokenCompliance* Arena::CreateMaybeMessage<::zera_txn::TokenCompliance>(Arena*);
template<> ::zera_txn::TokenFees* Arena::CreateMaybeMessage<::zera_txn::TokenFees>(Arena*);
template<> ::zera_txn::Transfer* Arena::CreateMaybeMessage<::zera_txn::Transfer>(Arena*);
template<> ::zera_txn::TransferAuthentication* Arena::CreateMaybeMessage<::zera_txn::TransferAuthentication>(Arena*);
template<> ::zera_txn::Validator* Arena::CreateMaybeMessage<::zera_txn::Validator>(Arena*);
template<> ::zera_txn::ValidatorHeartbeat* Arena::CreateMaybeMessage<::zera_txn::ValidatorHeartbeat>(Arena*);
template<> ::zera_txn::ValidatorRegistration* Arena::CreateMaybeMessage<::zera_txn::ValidatorRegistration>(Arena*);
template<> ::zera_txn::VotePair* Arena::CreateMaybeMessage<::zera_txn::VotePair>(Arena*);
template<> ::zera_txn::Votes* Arena::CreateMaybeMessage<::zera_txn::Votes>(Arena*);
template<> ::zera_txn::Wallets* Arena::CreateMaybeMessage<::zera_txn::Wallets>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zera_txn {

enum TXN_STATUS : int {
  OK = 0,
  INVALID_PARAMETERS = 1,
  INSUFFICIENT_AMOUNT = 2,
  INSUFFICIENT_CONTRACT_FEES = 3,
  AUTHORIZED_INSUFFICIENT_FEES = 4,
  AUTHORIZED_INSUFFICIENT_CONTRACT_FEES = 5,
  INVALID_CONTRACT = 6,
  INVALID_AUTH_KEY = 7,
  INVALID_WALLET_ADDRESS = 8,
  INVALID_MULTI_TRANSACTION = 9,
  INVALID_CONTRACT_PARAMETERS = 10,
  INVALID_CONTRACT_FEE_ID = 11,
  INVALID_UINT256 = 12,
  EXCEEDED_MAX_SUPPLY = 13,
  INVALID_NFT = 14,
  NFT_OWNERSHIP = 15,
  VALIDATOR_ADDRESS = 16,
  CONTRACT_HAS_NO_GOVERNANCE = 17,
  INVALID_BASE_FEE_ID = 18,
  EXPENSE_RATIO_DUPLICATE = 19,
  RESTRICTED_SYMBOL = 20,
  INVALID_PROPOSAL_ID = 21,
  PROPOSAL_NOT_IN_VOTING_PERIOD = 22,
  TIME_DELAY_INITIALIZED = 23,
  INVALID_TXN_HASH = 24,
  INVALID_TXN_TYPE = 25,
  TIME_DELAY_EXPIRED = 26,
  DUPLICATE_AUTH_KEY = 27,
  KEY_WEIGHT_TOO_LOW = 28,
  INVALID_ITEM = 29,
  INVALID_PROPOSAL = 30,
  PROPOSAL_DOES_NOT_BELONG_TO_SENDER = 31,
  INVALID_ADDRESS = 32,
  NO_CHANGE_TO_COMPLIANCE = 33,
  COMPLIANCE_CHECK_FAILED = 34,
  INVALID_SAFE_SEND = 35,
  INVALID_TXN_DATA = 36,
  DUPLICATE_SMART_CONTRACT_NONCE = 37,
  INVALID_SMART_CONTRACT = 38,
  FAULTY_TXN = 39,
  OUT_OF_GAS = 40,
  INVALID_ALLOWANCE = 41,
  TXN_STATUS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TXN_STATUS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TXN_STATUS_IsValid(int value);
constexpr TXN_STATUS TXN_STATUS_MIN = OK;
constexpr TXN_STATUS TXN_STATUS_MAX = INVALID_ALLOWANCE;
constexpr int TXN_STATUS_ARRAYSIZE = TXN_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TXN_STATUS_descriptor();
template<typename T>
inline const std::string& TXN_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TXN_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TXN_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TXN_STATUS_descriptor(), enum_t_value);
}
inline bool TXN_STATUS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TXN_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TXN_STATUS>(
    TXN_STATUS_descriptor(), name, value);
}
enum TRANSACTION_TYPE : int {
  COIN_TYPE = 0,
  FOUNDATION_TYPE = 2,
  MINT_TYPE = 1,
  ITEM_MINT_TYPE = 3,
  CONTRACT_TXN_TYPE = 4,
  VOTE_TYPE = 5,
  PROPOSAL_TYPE = 6,
  SMART_CONTRACT_TYPE = 7,
  SMART_CONTRACT_EXECUTE_TYPE = 8,
  SELF_CURRENCY_EQUIV_TYPE = 9,
  AUTHORIZED_CURRENCY_EQUIV_TYPE = 10,
  EXPENSE_RATIO_TYPE = 11,
  NFT_TYPE = 12,
  UPDATE_CONTRACT_TYPE = 13,
  VALIDATOR_REGISTRATION_TYPE = 14,
  VALIDATOR_HEARTBEAT_TYPE = 15,
  PROPOSAL_RESULT_TYPE = 16,
  DELEGATED_VOTING_TYPE = 17,
  REVOKE_TYPE = 18,
  QUASH_TYPE = 19,
  FAST_QUORUM_TYPE = 20,
  COMPLIANCE_TYPE = 21,
  SBT_BURN_TYPE = 22,
  REQUIRED_VERSION = 23,
  SMART_CONTRACT_INSTANTIATE_TYPE = 24,
  UKNOWN_TYPE = 25,
  ALLOWANCE_TYPE = 26,
  TRANSACTION_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TRANSACTION_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TRANSACTION_TYPE_IsValid(int value);
constexpr TRANSACTION_TYPE TRANSACTION_TYPE_MIN = COIN_TYPE;
constexpr TRANSACTION_TYPE TRANSACTION_TYPE_MAX = ALLOWANCE_TYPE;
constexpr int TRANSACTION_TYPE_ARRAYSIZE = TRANSACTION_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TRANSACTION_TYPE_descriptor();
template<typename T>
inline const std::string& TRANSACTION_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TRANSACTION_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TRANSACTION_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TRANSACTION_TYPE_descriptor(), enum_t_value);
}
inline bool TRANSACTION_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TRANSACTION_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TRANSACTION_TYPE>(
    TRANSACTION_TYPE_descriptor(), name, value);
}
enum LANGUAGE : int {
  COMPILED = 0,
  PYTHON = 1,
  JAVASCRIPT = 2,
  LANGUAGE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LANGUAGE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LANGUAGE_IsValid(int value);
constexpr LANGUAGE LANGUAGE_MIN = COMPILED;
constexpr LANGUAGE LANGUAGE_MAX = JAVASCRIPT;
constexpr int LANGUAGE_ARRAYSIZE = LANGUAGE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LANGUAGE_descriptor();
template<typename T>
inline const std::string& LANGUAGE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LANGUAGE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LANGUAGE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LANGUAGE_descriptor(), enum_t_value);
}
inline bool LANGUAGE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LANGUAGE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LANGUAGE>(
    LANGUAGE_descriptor(), name, value);
}
enum PROPOSAL_PERIOD : int {
  DAYS = 0,
  MONTHS = 1,
  PROPOSAL_PERIOD_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PROPOSAL_PERIOD_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PROPOSAL_PERIOD_IsValid(int value);
constexpr PROPOSAL_PERIOD PROPOSAL_PERIOD_MIN = DAYS;
constexpr PROPOSAL_PERIOD PROPOSAL_PERIOD_MAX = MONTHS;
constexpr int PROPOSAL_PERIOD_ARRAYSIZE = PROPOSAL_PERIOD_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PROPOSAL_PERIOD_descriptor();
template<typename T>
inline const std::string& PROPOSAL_PERIOD_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PROPOSAL_PERIOD>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PROPOSAL_PERIOD_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PROPOSAL_PERIOD_descriptor(), enum_t_value);
}
inline bool PROPOSAL_PERIOD_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PROPOSAL_PERIOD* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PROPOSAL_PERIOD>(
    PROPOSAL_PERIOD_descriptor(), name, value);
}
enum VARIABLE_TYPE : int {
  INT = 0,
  SHORT = 1,
  LONG = 2,
  LONG_LONG = 3,
  BOOL = 4,
  STRING = 5,
  VARIABLE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VARIABLE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VARIABLE_TYPE_IsValid(int value);
constexpr VARIABLE_TYPE VARIABLE_TYPE_MIN = INT;
constexpr VARIABLE_TYPE VARIABLE_TYPE_MAX = STRING;
constexpr int VARIABLE_TYPE_ARRAYSIZE = VARIABLE_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VARIABLE_TYPE_descriptor();
template<typename T>
inline const std::string& VARIABLE_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VARIABLE_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VARIABLE_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VARIABLE_TYPE_descriptor(), enum_t_value);
}
inline bool VARIABLE_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VARIABLE_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VARIABLE_TYPE>(
    VARIABLE_TYPE_descriptor(), name, value);
}
enum CONTRACT_FEE_TYPE : int {
  FIXED = 0,
  CUR_EQUIVALENT = 1,
  PERCENTAGE = 2,
  NONE = 3,
  CONTRACT_FEE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CONTRACT_FEE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CONTRACT_FEE_TYPE_IsValid(int value);
constexpr CONTRACT_FEE_TYPE CONTRACT_FEE_TYPE_MIN = FIXED;
constexpr CONTRACT_FEE_TYPE CONTRACT_FEE_TYPE_MAX = NONE;
constexpr int CONTRACT_FEE_TYPE_ARRAYSIZE = CONTRACT_FEE_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CONTRACT_FEE_TYPE_descriptor();
template<typename T>
inline const std::string& CONTRACT_FEE_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CONTRACT_FEE_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CONTRACT_FEE_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CONTRACT_FEE_TYPE_descriptor(), enum_t_value);
}
inline bool CONTRACT_FEE_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CONTRACT_FEE_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CONTRACT_FEE_TYPE>(
    CONTRACT_FEE_TYPE_descriptor(), name, value);
}
enum GOVERNANCE_TYPE : int {
  STAGED = 0,
  CYCLE = 1,
  STAGGERED = 2,
  ADAPTIVE = 3,
  REMOVE = 4,
  GOVERNANCE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GOVERNANCE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GOVERNANCE_TYPE_IsValid(int value);
constexpr GOVERNANCE_TYPE GOVERNANCE_TYPE_MIN = STAGED;
constexpr GOVERNANCE_TYPE GOVERNANCE_TYPE_MAX = REMOVE;
constexpr int GOVERNANCE_TYPE_ARRAYSIZE = GOVERNANCE_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GOVERNANCE_TYPE_descriptor();
template<typename T>
inline const std::string& GOVERNANCE_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GOVERNANCE_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GOVERNANCE_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GOVERNANCE_TYPE_descriptor(), enum_t_value);
}
inline bool GOVERNANCE_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GOVERNANCE_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GOVERNANCE_TYPE>(
    GOVERNANCE_TYPE_descriptor(), name, value);
}
enum CONTRACT_TYPE : int {
  TOKEN = 0,
  NFT = 1,
  SBT = 2,
  CONTRACT_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CONTRACT_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CONTRACT_TYPE_IsValid(int value);
constexpr CONTRACT_TYPE CONTRACT_TYPE_MIN = TOKEN;
constexpr CONTRACT_TYPE CONTRACT_TYPE_MAX = SBT;
constexpr int CONTRACT_TYPE_ARRAYSIZE = CONTRACT_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CONTRACT_TYPE_descriptor();
template<typename T>
inline const std::string& CONTRACT_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CONTRACT_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CONTRACT_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CONTRACT_TYPE_descriptor(), enum_t_value);
}
inline bool CONTRACT_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CONTRACT_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CONTRACT_TYPE>(
    CONTRACT_TYPE_descriptor(), name, value);
}
// ===================================================================

class DelegateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.DelegateContract) */ {
 public:
  inline DelegateContract() : DelegateContract(nullptr) {}
  ~DelegateContract() override;
  explicit PROTOBUF_CONSTEXPR DelegateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegateContract(const DelegateContract& from);
  DelegateContract(DelegateContract&& from) noexcept
    : DelegateContract() {
    *this = ::std::move(from);
  }

  inline DelegateContract& operator=(const DelegateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegateContract& operator=(DelegateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegateContract* internal_default_instance() {
    return reinterpret_cast<const DelegateContract*>(
               &_DelegateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DelegateContract& a, DelegateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegateContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegateContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegateContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelegateContract& from) {
    DelegateContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.DelegateContract";
  }
  protected:
  explicit DelegateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 2,
    kPriorityFieldNumber = 1,
  };
  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // int32 priority = 1;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.DelegateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    int32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class DelegatedTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.DelegatedTXN) */ {
 public:
  inline DelegatedTXN() : DelegatedTXN(nullptr) {}
  ~DelegatedTXN() override;
  explicit PROTOBUF_CONSTEXPR DelegatedTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegatedTXN(const DelegatedTXN& from);
  DelegatedTXN(DelegatedTXN&& from) noexcept
    : DelegatedTXN() {
    *this = ::std::move(from);
  }

  inline DelegatedTXN& operator=(const DelegatedTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatedTXN& operator=(DelegatedTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegatedTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegatedTXN* internal_default_instance() {
    return reinterpret_cast<const DelegatedTXN*>(
               &_DelegatedTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DelegatedTXN& a, DelegatedTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatedTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatedTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegatedTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegatedTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegatedTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelegatedTXN& from) {
    DelegatedTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatedTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.DelegatedTXN";
  }
  protected:
  explicit DelegatedTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegateVotesFieldNumber = 2,
    kDelegateFeesFieldNumber = 3,
    kBaseFieldNumber = 1,
  };
  // repeated .zera_txn.DelegateVote delegate_votes = 2;
  int delegate_votes_size() const;
  private:
  int _internal_delegate_votes_size() const;
  public:
  void clear_delegate_votes();
  ::zera_txn::DelegateVote* mutable_delegate_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateVote >*
      mutable_delegate_votes();
  private:
  const ::zera_txn::DelegateVote& _internal_delegate_votes(int index) const;
  ::zera_txn::DelegateVote* _internal_add_delegate_votes();
  public:
  const ::zera_txn::DelegateVote& delegate_votes(int index) const;
  ::zera_txn::DelegateVote* add_delegate_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateVote >&
      delegate_votes() const;

  // repeated .zera_txn.DelegateFees delegate_fees = 3;
  int delegate_fees_size() const;
  private:
  int _internal_delegate_fees_size() const;
  public:
  void clear_delegate_fees();
  ::zera_txn::DelegateFees* mutable_delegate_fees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateFees >*
      mutable_delegate_fees();
  private:
  const ::zera_txn::DelegateFees& _internal_delegate_fees(int index) const;
  ::zera_txn::DelegateFees* _internal_add_delegate_fees();
  public:
  const ::zera_txn::DelegateFees& delegate_fees(int index) const;
  ::zera_txn::DelegateFees* add_delegate_fees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateFees >&
      delegate_fees() const;

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.DelegatedTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateVote > delegate_votes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateFees > delegate_fees_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class DelegateVote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.DelegateVote) */ {
 public:
  inline DelegateVote() : DelegateVote(nullptr) {}
  ~DelegateVote() override;
  explicit PROTOBUF_CONSTEXPR DelegateVote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegateVote(const DelegateVote& from);
  DelegateVote(DelegateVote&& from) noexcept
    : DelegateVote() {
    *this = ::std::move(from);
  }

  inline DelegateVote& operator=(const DelegateVote& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegateVote& operator=(DelegateVote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegateVote& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegateVote* internal_default_instance() {
    return reinterpret_cast<const DelegateVote*>(
               &_DelegateVote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DelegateVote& a, DelegateVote& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegateVote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegateVote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegateVote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegateVote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegateVote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelegateVote& from) {
    DelegateVote::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegateVote* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.DelegateVote";
  }
  protected:
  explicit DelegateVote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 2,
    kAddressFieldNumber = 1,
  };
  // repeated .zera_txn.DelegateContract contracts = 2;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::zera_txn::DelegateContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateContract >*
      mutable_contracts();
  private:
  const ::zera_txn::DelegateContract& _internal_contracts(int index) const;
  ::zera_txn::DelegateContract* _internal_add_contracts();
  public:
  const ::zera_txn::DelegateContract& contracts(int index) const;
  ::zera_txn::DelegateContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateContract >&
      contracts() const;

  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.DelegateVote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateContract > contracts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class DelegateFees final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.DelegateFees) */ {
 public:
  inline DelegateFees() : DelegateFees(nullptr) {}
  ~DelegateFees() override;
  explicit PROTOBUF_CONSTEXPR DelegateFees(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegateFees(const DelegateFees& from);
  DelegateFees(DelegateFees&& from) noexcept
    : DelegateFees() {
    *this = ::std::move(from);
  }

  inline DelegateFees& operator=(const DelegateFees& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegateFees& operator=(DelegateFees&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegateFees& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegateFees* internal_default_instance() {
    return reinterpret_cast<const DelegateFees*>(
               &_DelegateFees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DelegateFees& a, DelegateFees& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegateFees* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegateFees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegateFees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegateFees>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegateFees& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelegateFees& from) {
    DelegateFees::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegateFees* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.DelegateFees";
  }
  protected:
  explicit DelegateFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kAuthAmountFieldNumber = 2,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string auth_amount = 2;
  void clear_auth_amount();
  const std::string& auth_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_amount();
  PROTOBUF_NODISCARD std::string* release_auth_amount();
  void set_allocated_auth_amount(std::string* auth_amount);
  private:
  const std::string& _internal_auth_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_amount(const std::string& value);
  std::string* _internal_mutable_auth_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.DelegateFees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Compliance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Compliance) */ {
 public:
  inline Compliance() : Compliance(nullptr) {}
  ~Compliance() override;
  explicit PROTOBUF_CONSTEXPR Compliance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Compliance(const Compliance& from);
  Compliance(Compliance&& from) noexcept
    : Compliance() {
    *this = ::std::move(from);
  }

  inline Compliance& operator=(const Compliance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Compliance& operator=(Compliance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Compliance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Compliance* internal_default_instance() {
    return reinterpret_cast<const Compliance*>(
               &_Compliance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Compliance& a, Compliance& b) {
    a.Swap(&b);
  }
  inline void Swap(Compliance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Compliance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Compliance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Compliance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Compliance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Compliance& from) {
    Compliance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Compliance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Compliance";
  }
  protected:
  explicit Compliance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kComplianceLevelFieldNumber = 2,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // uint32 compliance_level = 2;
  void clear_compliance_level();
  uint32_t compliance_level() const;
  void set_compliance_level(uint32_t value);
  private:
  uint32_t _internal_compliance_level() const;
  void _internal_set_compliance_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.Compliance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    uint32_t compliance_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class TokenCompliance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.TokenCompliance) */ {
 public:
  inline TokenCompliance() : TokenCompliance(nullptr) {}
  ~TokenCompliance() override;
  explicit PROTOBUF_CONSTEXPR TokenCompliance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenCompliance(const TokenCompliance& from);
  TokenCompliance(TokenCompliance&& from) noexcept
    : TokenCompliance() {
    *this = ::std::move(from);
  }

  inline TokenCompliance& operator=(const TokenCompliance& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenCompliance& operator=(TokenCompliance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenCompliance& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenCompliance* internal_default_instance() {
    return reinterpret_cast<const TokenCompliance*>(
               &_TokenCompliance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TokenCompliance& a, TokenCompliance& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenCompliance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenCompliance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenCompliance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenCompliance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenCompliance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenCompliance& from) {
    TokenCompliance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenCompliance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.TokenCompliance";
  }
  protected:
  explicit TokenCompliance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComplianceFieldNumber = 1,
  };
  // repeated .zera_txn.Compliance compliance = 1;
  int compliance_size() const;
  private:
  int _internal_compliance_size() const;
  public:
  void clear_compliance();
  ::zera_txn::Compliance* mutable_compliance(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Compliance >*
      mutable_compliance();
  private:
  const ::zera_txn::Compliance& _internal_compliance(int index) const;
  ::zera_txn::Compliance* _internal_add_compliance();
  public:
  const ::zera_txn::Compliance& compliance(int index) const;
  ::zera_txn::Compliance* add_compliance();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Compliance >&
      compliance() const;

  // @@protoc_insertion_point(class_scope:zera_txn.TokenCompliance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Compliance > compliance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ExpenseRatio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ExpenseRatio) */ {
 public:
  inline ExpenseRatio() : ExpenseRatio(nullptr) {}
  ~ExpenseRatio() override;
  explicit PROTOBUF_CONSTEXPR ExpenseRatio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpenseRatio(const ExpenseRatio& from);
  ExpenseRatio(ExpenseRatio&& from) noexcept
    : ExpenseRatio() {
    *this = ::std::move(from);
  }

  inline ExpenseRatio& operator=(const ExpenseRatio& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpenseRatio& operator=(ExpenseRatio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpenseRatio& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpenseRatio* internal_default_instance() {
    return reinterpret_cast<const ExpenseRatio*>(
               &_ExpenseRatio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ExpenseRatio& a, ExpenseRatio& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpenseRatio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpenseRatio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpenseRatio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpenseRatio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpenseRatio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpenseRatio& from) {
    ExpenseRatio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpenseRatio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ExpenseRatio";
  }
  protected:
  explicit ExpenseRatio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDayFieldNumber = 1,
    kMonthFieldNumber = 2,
    kPercentFieldNumber = 3,
  };
  // uint32 day = 1;
  void clear_day();
  uint32_t day() const;
  void set_day(uint32_t value);
  private:
  uint32_t _internal_day() const;
  void _internal_set_day(uint32_t value);
  public:

  // uint32 month = 2;
  void clear_month();
  uint32_t month() const;
  void set_month(uint32_t value);
  private:
  uint32_t _internal_month() const;
  void _internal_set_month(uint32_t value);
  public:

  // uint32 percent = 3;
  void clear_percent();
  uint32_t percent() const;
  void set_percent(uint32_t value);
  private:
  uint32_t _internal_percent() const;
  void _internal_set_percent(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ExpenseRatio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t day_;
    uint32_t month_;
    uint32_t percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class KeyValuePair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.KeyValuePair) */ {
 public:
  inline KeyValuePair() : KeyValuePair(nullptr) {}
  ~KeyValuePair() override;
  explicit PROTOBUF_CONSTEXPR KeyValuePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValuePair(const KeyValuePair& from);
  KeyValuePair(KeyValuePair&& from) noexcept
    : KeyValuePair() {
    *this = ::std::move(from);
  }

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValuePair& operator=(KeyValuePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValuePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const KeyValuePair*>(
               &_KeyValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(KeyValuePair& a, KeyValuePair& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValuePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValuePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValuePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValuePair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyValuePair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyValuePair& from) {
    KeyValuePair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValuePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.KeyValuePair";
  }
  protected:
  explicit KeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.KeyValuePair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ByteMultiplier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ByteMultiplier) */ {
 public:
  inline ByteMultiplier() : ByteMultiplier(nullptr) {}
  ~ByteMultiplier() override;
  explicit PROTOBUF_CONSTEXPR ByteMultiplier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ByteMultiplier(const ByteMultiplier& from);
  ByteMultiplier(ByteMultiplier&& from) noexcept
    : ByteMultiplier() {
    *this = ::std::move(from);
  }

  inline ByteMultiplier& operator=(const ByteMultiplier& from) {
    CopyFrom(from);
    return *this;
  }
  inline ByteMultiplier& operator=(ByteMultiplier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ByteMultiplier& default_instance() {
    return *internal_default_instance();
  }
  static inline const ByteMultiplier* internal_default_instance() {
    return reinterpret_cast<const ByteMultiplier*>(
               &_ByteMultiplier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ByteMultiplier& a, ByteMultiplier& b) {
    a.Swap(&b);
  }
  inline void Swap(ByteMultiplier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ByteMultiplier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ByteMultiplier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ByteMultiplier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ByteMultiplier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ByteMultiplier& from) {
    ByteMultiplier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ByteMultiplier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ByteMultiplier";
  }
  protected:
  explicit ByteMultiplier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultiplierFieldNumber = 2,
    kTxnTypeFieldNumber = 1,
  };
  // string multiplier = 2;
  void clear_multiplier();
  const std::string& multiplier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_multiplier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_multiplier();
  PROTOBUF_NODISCARD std::string* release_multiplier();
  void set_allocated_multiplier(std::string* multiplier);
  private:
  const std::string& _internal_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_multiplier(const std::string& value);
  std::string* _internal_mutable_multiplier();
  public:

  // .zera_txn.TRANSACTION_TYPE txn_type = 1;
  void clear_txn_type();
  ::zera_txn::TRANSACTION_TYPE txn_type() const;
  void set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  private:
  ::zera_txn::TRANSACTION_TYPE _internal_txn_type() const;
  void _internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ByteMultiplier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multiplier_;
    int txn_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class FoundationTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.FoundationTXN) */ {
 public:
  inline FoundationTXN() : FoundationTXN(nullptr) {}
  ~FoundationTXN() override;
  explicit PROTOBUF_CONSTEXPR FoundationTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FoundationTXN(const FoundationTXN& from);
  FoundationTXN(FoundationTXN&& from) noexcept
    : FoundationTXN() {
    *this = ::std::move(from);
  }

  inline FoundationTXN& operator=(const FoundationTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline FoundationTXN& operator=(FoundationTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FoundationTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const FoundationTXN* internal_default_instance() {
    return reinterpret_cast<const FoundationTXN*>(
               &_FoundationTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FoundationTXN& a, FoundationTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(FoundationTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FoundationTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FoundationTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FoundationTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FoundationTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FoundationTXN& from) {
    FoundationTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FoundationTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.FoundationTXN";
  }
  protected:
  explicit FoundationTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRestrictedSymbolsFieldNumber = 2,
    kByteMultiplierFieldNumber = 3,
    kFeeISO4217FieldNumber = 4,
    kBaseFieldNumber = 1,
  };
  // repeated string restricted_symbols = 2;
  int restricted_symbols_size() const;
  private:
  int _internal_restricted_symbols_size() const;
  public:
  void clear_restricted_symbols();
  const std::string& restricted_symbols(int index) const;
  std::string* mutable_restricted_symbols(int index);
  void set_restricted_symbols(int index, const std::string& value);
  void set_restricted_symbols(int index, std::string&& value);
  void set_restricted_symbols(int index, const char* value);
  void set_restricted_symbols(int index, const char* value, size_t size);
  std::string* add_restricted_symbols();
  void add_restricted_symbols(const std::string& value);
  void add_restricted_symbols(std::string&& value);
  void add_restricted_symbols(const char* value);
  void add_restricted_symbols(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& restricted_symbols() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_restricted_symbols();
  private:
  const std::string& _internal_restricted_symbols(int index) const;
  std::string* _internal_add_restricted_symbols();
  public:

  // repeated .zera_txn.ByteMultiplier byte_multiplier = 3;
  int byte_multiplier_size() const;
  private:
  int _internal_byte_multiplier_size() const;
  public:
  void clear_byte_multiplier();
  ::zera_txn::ByteMultiplier* mutable_byte_multiplier(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ByteMultiplier >*
      mutable_byte_multiplier();
  private:
  const ::zera_txn::ByteMultiplier& _internal_byte_multiplier(int index) const;
  ::zera_txn::ByteMultiplier* _internal_add_byte_multiplier();
  public:
  const ::zera_txn::ByteMultiplier& byte_multiplier(int index) const;
  ::zera_txn::ByteMultiplier* add_byte_multiplier();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ByteMultiplier >&
      byte_multiplier() const;

  // optional string fee_ISO4217 = 4;
  bool has_fee_iso4217() const;
  private:
  bool _internal_has_fee_iso4217() const;
  public:
  void clear_fee_iso4217();
  const std::string& fee_iso4217() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fee_iso4217(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fee_iso4217();
  PROTOBUF_NODISCARD std::string* release_fee_iso4217();
  void set_allocated_fee_iso4217(std::string* fee_iso4217);
  private:
  const std::string& _internal_fee_iso4217() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_iso4217(const std::string& value);
  std::string* _internal_mutable_fee_iso4217();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.FoundationTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> restricted_symbols_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ByteMultiplier > byte_multiplier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_iso4217_;
    ::zera_txn::BaseTXN* base_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class RevokeTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.RevokeTXN) */ {
 public:
  inline RevokeTXN() : RevokeTXN(nullptr) {}
  ~RevokeTXN() override;
  explicit PROTOBUF_CONSTEXPR RevokeTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevokeTXN(const RevokeTXN& from);
  RevokeTXN(RevokeTXN&& from) noexcept
    : RevokeTXN() {
    *this = ::std::move(from);
  }

  inline RevokeTXN& operator=(const RevokeTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokeTXN& operator=(RevokeTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevokeTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevokeTXN* internal_default_instance() {
    return reinterpret_cast<const RevokeTXN*>(
               &_RevokeTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RevokeTXN& a, RevokeTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokeTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevokeTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevokeTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevokeTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevokeTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RevokeTXN& from) {
    RevokeTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevokeTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.RevokeTXN";
  }
  protected:
  explicit RevokeTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 2,
    kRecipientAddressFieldNumber = 3,
    kItemIdFieldNumber = 4,
    kBaseFieldNumber = 1,
  };
  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes recipient_address = 3;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // string item_id = 4;
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.RevokeTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class FastQuorumTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.FastQuorumTXN) */ {
 public:
  inline FastQuorumTXN() : FastQuorumTXN(nullptr) {}
  ~FastQuorumTXN() override;
  explicit PROTOBUF_CONSTEXPR FastQuorumTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FastQuorumTXN(const FastQuorumTXN& from);
  FastQuorumTXN(FastQuorumTXN&& from) noexcept
    : FastQuorumTXN() {
    *this = ::std::move(from);
  }

  inline FastQuorumTXN& operator=(const FastQuorumTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline FastQuorumTXN& operator=(FastQuorumTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FastQuorumTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const FastQuorumTXN* internal_default_instance() {
    return reinterpret_cast<const FastQuorumTXN*>(
               &_FastQuorumTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FastQuorumTXN& a, FastQuorumTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(FastQuorumTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FastQuorumTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FastQuorumTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FastQuorumTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FastQuorumTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FastQuorumTXN& from) {
    FastQuorumTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FastQuorumTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.FastQuorumTXN";
  }
  protected:
  explicit FastQuorumTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalIdFieldNumber = 2,
    kBaseFieldNumber = 1,
  };
  // bytes proposal_id = 2;
  void clear_proposal_id();
  const std::string& proposal_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proposal_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proposal_id();
  PROTOBUF_NODISCARD std::string* release_proposal_id();
  void set_allocated_proposal_id(std::string* proposal_id);
  private:
  const std::string& _internal_proposal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposal_id(const std::string& value);
  std::string* _internal_mutable_proposal_id();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.FastQuorumTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposal_id_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Governance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Governance) */ {
 public:
  inline Governance() : Governance(nullptr) {}
  ~Governance() override;
  explicit PROTOBUF_CONSTEXPR Governance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Governance(const Governance& from);
  Governance(Governance&& from) noexcept
    : Governance() {
    *this = ::std::move(from);
  }

  inline Governance& operator=(const Governance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Governance& operator=(Governance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Governance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Governance* internal_default_instance() {
    return reinterpret_cast<const Governance*>(
               &_Governance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Governance& a, Governance& b) {
    a.Swap(&b);
  }
  inline void Swap(Governance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Governance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Governance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Governance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Governance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Governance& from) {
    Governance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Governance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Governance";
  }
  protected:
  explicit Governance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVotingInstrumentFieldNumber = 4,
    kAllowedProposalInstrumentFieldNumber = 9,
    kStageLengthFieldNumber = 11,
    kStartTimestampFieldNumber = 12,
    kTypeFieldNumber = 1,
    kRegularQuorumFieldNumber = 2,
    kFastQuorumFieldNumber = 3,
    kThresholdFieldNumber = 5,
    kChickenDinnerFieldNumber = 6,
    kAllowMultiFieldNumber = 7,
    kVotingPeriodFieldNumber = 8,
    kProposalPeriodFieldNumber = 10,
    kMaxApprovedFieldNumber = 13,
  };
  // repeated string voting_instrument = 4;
  int voting_instrument_size() const;
  private:
  int _internal_voting_instrument_size() const;
  public:
  void clear_voting_instrument();
  const std::string& voting_instrument(int index) const;
  std::string* mutable_voting_instrument(int index);
  void set_voting_instrument(int index, const std::string& value);
  void set_voting_instrument(int index, std::string&& value);
  void set_voting_instrument(int index, const char* value);
  void set_voting_instrument(int index, const char* value, size_t size);
  std::string* add_voting_instrument();
  void add_voting_instrument(const std::string& value);
  void add_voting_instrument(std::string&& value);
  void add_voting_instrument(const char* value);
  void add_voting_instrument(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& voting_instrument() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_voting_instrument();
  private:
  const std::string& _internal_voting_instrument(int index) const;
  std::string* _internal_add_voting_instrument();
  public:

  // repeated string allowed_proposal_instrument = 9;
  int allowed_proposal_instrument_size() const;
  private:
  int _internal_allowed_proposal_instrument_size() const;
  public:
  void clear_allowed_proposal_instrument();
  const std::string& allowed_proposal_instrument(int index) const;
  std::string* mutable_allowed_proposal_instrument(int index);
  void set_allowed_proposal_instrument(int index, const std::string& value);
  void set_allowed_proposal_instrument(int index, std::string&& value);
  void set_allowed_proposal_instrument(int index, const char* value);
  void set_allowed_proposal_instrument(int index, const char* value, size_t size);
  std::string* add_allowed_proposal_instrument();
  void add_allowed_proposal_instrument(const std::string& value);
  void add_allowed_proposal_instrument(std::string&& value);
  void add_allowed_proposal_instrument(const char* value);
  void add_allowed_proposal_instrument(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowed_proposal_instrument() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowed_proposal_instrument();
  private:
  const std::string& _internal_allowed_proposal_instrument(int index) const;
  std::string* _internal_add_allowed_proposal_instrument();
  public:

  // repeated .zera_txn.Stage stage_length = 11;
  int stage_length_size() const;
  private:
  int _internal_stage_length_size() const;
  public:
  void clear_stage_length();
  ::zera_txn::Stage* mutable_stage_length(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Stage >*
      mutable_stage_length();
  private:
  const ::zera_txn::Stage& _internal_stage_length(int index) const;
  ::zera_txn::Stage* _internal_add_stage_length();
  public:
  const ::zera_txn::Stage& stage_length(int index) const;
  ::zera_txn::Stage* add_stage_length();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Stage >&
      stage_length() const;

  // optional .google.protobuf.Timestamp start_timestamp = 12;
  bool has_start_timestamp() const;
  private:
  bool _internal_has_start_timestamp() const;
  public:
  void clear_start_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_timestamp();
  void set_allocated_start_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_timestamp();
  public:
  void unsafe_arena_set_allocated_start_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_timestamp();

  // .zera_txn.GOVERNANCE_TYPE type = 1;
  void clear_type();
  ::zera_txn::GOVERNANCE_TYPE type() const;
  void set_type(::zera_txn::GOVERNANCE_TYPE value);
  private:
  ::zera_txn::GOVERNANCE_TYPE _internal_type() const;
  void _internal_set_type(::zera_txn::GOVERNANCE_TYPE value);
  public:

  // uint32 regular_quorum = 2;
  void clear_regular_quorum();
  uint32_t regular_quorum() const;
  void set_regular_quorum(uint32_t value);
  private:
  uint32_t _internal_regular_quorum() const;
  void _internal_set_regular_quorum(uint32_t value);
  public:

  // optional uint32 fast_quorum = 3;
  bool has_fast_quorum() const;
  private:
  bool _internal_has_fast_quorum() const;
  public:
  void clear_fast_quorum();
  uint32_t fast_quorum() const;
  void set_fast_quorum(uint32_t value);
  private:
  uint32_t _internal_fast_quorum() const;
  void _internal_set_fast_quorum(uint32_t value);
  public:

  // uint32 threshold = 5;
  void clear_threshold();
  uint32_t threshold() const;
  void set_threshold(uint32_t value);
  private:
  uint32_t _internal_threshold() const;
  void _internal_set_threshold(uint32_t value);
  public:

  // optional bool chicken_dinner = 6;
  bool has_chicken_dinner() const;
  private:
  bool _internal_has_chicken_dinner() const;
  public:
  void clear_chicken_dinner();
  bool chicken_dinner() const;
  void set_chicken_dinner(bool value);
  private:
  bool _internal_chicken_dinner() const;
  void _internal_set_chicken_dinner(bool value);
  public:

  // bool allow_multi = 7;
  void clear_allow_multi();
  bool allow_multi() const;
  void set_allow_multi(bool value);
  private:
  bool _internal_allow_multi() const;
  void _internal_set_allow_multi(bool value);
  public:

  // optional uint32 voting_period = 8;
  bool has_voting_period() const;
  private:
  bool _internal_has_voting_period() const;
  public:
  void clear_voting_period();
  uint32_t voting_period() const;
  void set_voting_period(uint32_t value);
  private:
  uint32_t _internal_voting_period() const;
  void _internal_set_voting_period(uint32_t value);
  public:

  // optional .zera_txn.PROPOSAL_PERIOD proposal_period = 10;
  bool has_proposal_period() const;
  private:
  bool _internal_has_proposal_period() const;
  public:
  void clear_proposal_period();
  ::zera_txn::PROPOSAL_PERIOD proposal_period() const;
  void set_proposal_period(::zera_txn::PROPOSAL_PERIOD value);
  private:
  ::zera_txn::PROPOSAL_PERIOD _internal_proposal_period() const;
  void _internal_set_proposal_period(::zera_txn::PROPOSAL_PERIOD value);
  public:

  // optional uint32 max_approved = 13;
  bool has_max_approved() const;
  private:
  bool _internal_has_max_approved() const;
  public:
  void clear_max_approved();
  uint32_t max_approved() const;
  void set_max_approved(uint32_t value);
  private:
  uint32_t _internal_max_approved() const;
  void _internal_set_max_approved(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.Governance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> voting_instrument_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowed_proposal_instrument_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Stage > stage_length_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp_;
    int type_;
    uint32_t regular_quorum_;
    uint32_t fast_quorum_;
    uint32_t threshold_;
    bool chicken_dinner_;
    bool allow_multi_;
    uint32_t voting_period_;
    int proposal_period_;
    uint32_t max_approved_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Stage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Stage) */ {
 public:
  inline Stage() : Stage(nullptr) {}
  ~Stage() override;
  explicit PROTOBUF_CONSTEXPR Stage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stage(const Stage& from);
  Stage(Stage&& from) noexcept
    : Stage() {
    *this = ::std::move(from);
  }

  inline Stage& operator=(const Stage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stage& operator=(Stage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stage* internal_default_instance() {
    return reinterpret_cast<const Stage*>(
               &_Stage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Stage& a, Stage& b) {
    a.Swap(&b);
  }
  inline void Swap(Stage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stage& from) {
    Stage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Stage";
  }
  protected:
  explicit Stage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kPeriodFieldNumber = 2,
    kBreakFieldNumber = 3,
    kMaxApprovedFieldNumber = 4,
  };
  // uint32 length = 1;
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // .zera_txn.PROPOSAL_PERIOD period = 2;
  void clear_period();
  ::zera_txn::PROPOSAL_PERIOD period() const;
  void set_period(::zera_txn::PROPOSAL_PERIOD value);
  private:
  ::zera_txn::PROPOSAL_PERIOD _internal_period() const;
  void _internal_set_period(::zera_txn::PROPOSAL_PERIOD value);
  public:

  // bool break = 3;
  void clear_break_();
  bool break_() const;
  void set_break_(bool value);
  private:
  bool _internal_break_() const;
  void _internal_set_break_(bool value);
  public:

  // uint32 max_approved = 4;
  void clear_max_approved();
  uint32_t max_approved() const;
  void set_max_approved(uint32_t value);
  private:
  uint32_t _internal_max_approved() const;
  void _internal_set_max_approved(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.Stage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t length_;
    int period_;
    bool break__;
    uint32_t max_approved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class CoinDenomination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.CoinDenomination) */ {
 public:
  inline CoinDenomination() : CoinDenomination(nullptr) {}
  ~CoinDenomination() override;
  explicit PROTOBUF_CONSTEXPR CoinDenomination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoinDenomination(const CoinDenomination& from);
  CoinDenomination(CoinDenomination&& from) noexcept
    : CoinDenomination() {
    *this = ::std::move(from);
  }

  inline CoinDenomination& operator=(const CoinDenomination& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoinDenomination& operator=(CoinDenomination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoinDenomination& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoinDenomination* internal_default_instance() {
    return reinterpret_cast<const CoinDenomination*>(
               &_CoinDenomination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CoinDenomination& a, CoinDenomination& b) {
    a.Swap(&b);
  }
  inline void Swap(CoinDenomination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoinDenomination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoinDenomination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoinDenomination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoinDenomination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CoinDenomination& from) {
    CoinDenomination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoinDenomination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.CoinDenomination";
  }
  protected:
  explicit CoinDenomination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenominationNameFieldNumber = 5,
    kAmountFieldNumber = 6,
  };
  // string denomination_name = 5;
  void clear_denomination_name();
  const std::string& denomination_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_denomination_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_denomination_name();
  PROTOBUF_NODISCARD std::string* release_denomination_name();
  void set_allocated_denomination_name(std::string* denomination_name);
  private:
  const std::string& _internal_denomination_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denomination_name(const std::string& value);
  std::string* _internal_mutable_denomination_name();
  public:

  // string amount = 6;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.CoinDenomination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denomination_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ContractFees final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ContractFees) */ {
 public:
  inline ContractFees() : ContractFees(nullptr) {}
  ~ContractFees() override;
  explicit PROTOBUF_CONSTEXPR ContractFees(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractFees(const ContractFees& from);
  ContractFees(ContractFees&& from) noexcept
    : ContractFees() {
    *this = ::std::move(from);
  }

  inline ContractFees& operator=(const ContractFees& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractFees& operator=(ContractFees&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractFees& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractFees* internal_default_instance() {
    return reinterpret_cast<const ContractFees*>(
               &_ContractFees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ContractFees& a, ContractFees& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractFees* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractFees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractFees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractFees>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractFees& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractFees& from) {
    ContractFees::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractFees* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ContractFees";
  }
  protected:
  explicit ContractFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedFeeInstrumentFieldNumber = 5,
    kFeeFieldNumber = 1,
    kFeeAddressFieldNumber = 2,
    kBurnFieldNumber = 3,
    kValidatorFieldNumber = 4,
    kContractFeeTypeFieldNumber = 6,
  };
  // repeated string allowed_fee_instrument = 5;
  int allowed_fee_instrument_size() const;
  private:
  int _internal_allowed_fee_instrument_size() const;
  public:
  void clear_allowed_fee_instrument();
  const std::string& allowed_fee_instrument(int index) const;
  std::string* mutable_allowed_fee_instrument(int index);
  void set_allowed_fee_instrument(int index, const std::string& value);
  void set_allowed_fee_instrument(int index, std::string&& value);
  void set_allowed_fee_instrument(int index, const char* value);
  void set_allowed_fee_instrument(int index, const char* value, size_t size);
  std::string* add_allowed_fee_instrument();
  void add_allowed_fee_instrument(const std::string& value);
  void add_allowed_fee_instrument(std::string&& value);
  void add_allowed_fee_instrument(const char* value);
  void add_allowed_fee_instrument(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowed_fee_instrument() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowed_fee_instrument();
  private:
  const std::string& _internal_allowed_fee_instrument(int index) const;
  std::string* _internal_add_allowed_fee_instrument();
  public:

  // string fee = 1;
  void clear_fee();
  const std::string& fee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* fee);
  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(const std::string& value);
  std::string* _internal_mutable_fee();
  public:

  // optional bytes fee_address = 2;
  bool has_fee_address() const;
  private:
  bool _internal_has_fee_address() const;
  public:
  void clear_fee_address();
  const std::string& fee_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fee_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fee_address();
  PROTOBUF_NODISCARD std::string* release_fee_address();
  void set_allocated_fee_address(std::string* fee_address);
  private:
  const std::string& _internal_fee_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_address(const std::string& value);
  std::string* _internal_mutable_fee_address();
  public:

  // string burn = 3;
  void clear_burn();
  const std::string& burn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_burn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_burn();
  PROTOBUF_NODISCARD std::string* release_burn();
  void set_allocated_burn(std::string* burn);
  private:
  const std::string& _internal_burn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_burn(const std::string& value);
  std::string* _internal_mutable_burn();
  public:

  // string validator = 4;
  void clear_validator();
  const std::string& validator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_validator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_validator();
  PROTOBUF_NODISCARD std::string* release_validator();
  void set_allocated_validator(std::string* validator);
  private:
  const std::string& _internal_validator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator(const std::string& value);
  std::string* _internal_mutable_validator();
  public:

  // .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 6;
  void clear_contract_fee_type();
  ::zera_txn::CONTRACT_FEE_TYPE contract_fee_type() const;
  void set_contract_fee_type(::zera_txn::CONTRACT_FEE_TYPE value);
  private:
  ::zera_txn::CONTRACT_FEE_TYPE _internal_contract_fee_type() const;
  void _internal_set_contract_fee_type(::zera_txn::CONTRACT_FEE_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ContractFees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowed_fee_instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr burn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_;
    int contract_fee_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ItemContractFees final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ItemContractFees) */ {
 public:
  inline ItemContractFees() : ItemContractFees(nullptr) {}
  ~ItemContractFees() override;
  explicit PROTOBUF_CONSTEXPR ItemContractFees(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemContractFees(const ItemContractFees& from);
  ItemContractFees(ItemContractFees&& from) noexcept
    : ItemContractFees() {
    *this = ::std::move(from);
  }

  inline ItemContractFees& operator=(const ItemContractFees& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemContractFees& operator=(ItemContractFees&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemContractFees& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemContractFees* internal_default_instance() {
    return reinterpret_cast<const ItemContractFees*>(
               &_ItemContractFees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ItemContractFees& a, ItemContractFees& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemContractFees* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemContractFees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemContractFees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemContractFees>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemContractFees& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemContractFees& from) {
    ItemContractFees::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemContractFees* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ItemContractFees";
  }
  protected:
  explicit ItemContractFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedFeeInstrumentFieldNumber = 5,
    kFeeFieldNumber = 1,
    kFeeAddressFieldNumber = 2,
    kBurnFieldNumber = 3,
    kValidatorFieldNumber = 4,
  };
  // repeated string allowed_fee_instrument = 5;
  int allowed_fee_instrument_size() const;
  private:
  int _internal_allowed_fee_instrument_size() const;
  public:
  void clear_allowed_fee_instrument();
  const std::string& allowed_fee_instrument(int index) const;
  std::string* mutable_allowed_fee_instrument(int index);
  void set_allowed_fee_instrument(int index, const std::string& value);
  void set_allowed_fee_instrument(int index, std::string&& value);
  void set_allowed_fee_instrument(int index, const char* value);
  void set_allowed_fee_instrument(int index, const char* value, size_t size);
  std::string* add_allowed_fee_instrument();
  void add_allowed_fee_instrument(const std::string& value);
  void add_allowed_fee_instrument(std::string&& value);
  void add_allowed_fee_instrument(const char* value);
  void add_allowed_fee_instrument(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowed_fee_instrument() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowed_fee_instrument();
  private:
  const std::string& _internal_allowed_fee_instrument(int index) const;
  std::string* _internal_add_allowed_fee_instrument();
  public:

  // string fee = 1;
  void clear_fee();
  const std::string& fee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* fee);
  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(const std::string& value);
  std::string* _internal_mutable_fee();
  public:

  // optional bytes fee_address = 2;
  bool has_fee_address() const;
  private:
  bool _internal_has_fee_address() const;
  public:
  void clear_fee_address();
  const std::string& fee_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fee_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fee_address();
  PROTOBUF_NODISCARD std::string* release_fee_address();
  void set_allocated_fee_address(std::string* fee_address);
  private:
  const std::string& _internal_fee_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_address(const std::string& value);
  std::string* _internal_mutable_fee_address();
  public:

  // string burn = 3;
  void clear_burn();
  const std::string& burn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_burn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_burn();
  PROTOBUF_NODISCARD std::string* release_burn();
  void set_allocated_burn(std::string* burn);
  private:
  const std::string& _internal_burn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_burn(const std::string& value);
  std::string* _internal_mutable_burn();
  public:

  // string validator = 4;
  void clear_validator();
  const std::string& validator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_validator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_validator();
  PROTOBUF_NODISCARD std::string* release_validator();
  void set_allocated_validator(std::string* validator);
  private:
  const std::string& _internal_validator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator(const std::string& value);
  std::string* _internal_mutable_validator();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ItemContractFees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowed_fee_instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr burn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class RestrictedKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.RestrictedKey) */ {
 public:
  inline RestrictedKey() : RestrictedKey(nullptr) {}
  ~RestrictedKey() override;
  explicit PROTOBUF_CONSTEXPR RestrictedKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestrictedKey(const RestrictedKey& from);
  RestrictedKey(RestrictedKey&& from) noexcept
    : RestrictedKey() {
    *this = ::std::move(from);
  }

  inline RestrictedKey& operator=(const RestrictedKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestrictedKey& operator=(RestrictedKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestrictedKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const RestrictedKey* internal_default_instance() {
    return reinterpret_cast<const RestrictedKey*>(
               &_RestrictedKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RestrictedKey& a, RestrictedKey& b) {
    a.Swap(&b);
  }
  inline void Swap(RestrictedKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestrictedKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestrictedKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestrictedKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestrictedKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestrictedKey& from) {
    RestrictedKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestrictedKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.RestrictedKey";
  }
  protected:
  explicit RestrictedKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kTimeDelayFieldNumber = 2,
    kGlobalFieldNumber = 3,
    kUpdateContractFieldNumber = 4,
    kTransferFieldNumber = 5,
    kQuashFieldNumber = 6,
    kMintFieldNumber = 7,
    kVoteFieldNumber = 8,
    kProposeFieldNumber = 9,
    kComplianceFieldNumber = 10,
    kExpenseRatioFieldNumber = 11,
    kCurEquivFieldNumber = 12,
    kRevokeFieldNumber = 13,
    kKeyWeightFieldNumber = 14,
  };
  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  PROTOBUF_NODISCARD ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // int64 time_delay = 2;
  void clear_time_delay();
  int64_t time_delay() const;
  void set_time_delay(int64_t value);
  private:
  int64_t _internal_time_delay() const;
  void _internal_set_time_delay(int64_t value);
  public:

  // bool global = 3;
  void clear_global();
  bool global() const;
  void set_global(bool value);
  private:
  bool _internal_global() const;
  void _internal_set_global(bool value);
  public:

  // bool update_contract = 4;
  void clear_update_contract();
  bool update_contract() const;
  void set_update_contract(bool value);
  private:
  bool _internal_update_contract() const;
  void _internal_set_update_contract(bool value);
  public:

  // bool transfer = 5;
  void clear_transfer();
  bool transfer() const;
  void set_transfer(bool value);
  private:
  bool _internal_transfer() const;
  void _internal_set_transfer(bool value);
  public:

  // bool quash = 6;
  void clear_quash();
  bool quash() const;
  void set_quash(bool value);
  private:
  bool _internal_quash() const;
  void _internal_set_quash(bool value);
  public:

  // bool mint = 7;
  void clear_mint();
  bool mint() const;
  void set_mint(bool value);
  private:
  bool _internal_mint() const;
  void _internal_set_mint(bool value);
  public:

  // bool vote = 8;
  void clear_vote();
  bool vote() const;
  void set_vote(bool value);
  private:
  bool _internal_vote() const;
  void _internal_set_vote(bool value);
  public:

  // bool propose = 9;
  void clear_propose();
  bool propose() const;
  void set_propose(bool value);
  private:
  bool _internal_propose() const;
  void _internal_set_propose(bool value);
  public:

  // bool compliance = 10;
  void clear_compliance();
  bool compliance() const;
  void set_compliance(bool value);
  private:
  bool _internal_compliance() const;
  void _internal_set_compliance(bool value);
  public:

  // bool expense_ratio = 11;
  void clear_expense_ratio();
  bool expense_ratio() const;
  void set_expense_ratio(bool value);
  private:
  bool _internal_expense_ratio() const;
  void _internal_set_expense_ratio(bool value);
  public:

  // bool cur_equiv = 12;
  void clear_cur_equiv();
  bool cur_equiv() const;
  void set_cur_equiv(bool value);
  private:
  bool _internal_cur_equiv() const;
  void _internal_set_cur_equiv(bool value);
  public:

  // bool revoke = 13;
  void clear_revoke();
  bool revoke() const;
  void set_revoke(bool value);
  private:
  bool _internal_revoke() const;
  void _internal_set_revoke(bool value);
  public:

  // uint32 key_weight = 14;
  void clear_key_weight();
  uint32_t key_weight() const;
  void set_key_weight(uint32_t value);
  private:
  uint32_t _internal_key_weight() const;
  void _internal_set_key_weight(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.RestrictedKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::zera_txn::PublicKey* public_key_;
    int64_t time_delay_;
    bool global_;
    bool update_contract_;
    bool transfer_;
    bool quash_;
    bool mint_;
    bool vote_;
    bool propose_;
    bool compliance_;
    bool expense_ratio_;
    bool cur_equiv_;
    bool revoke_;
    uint32_t key_weight_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ExpenseRatioTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ExpenseRatioTXN) */ {
 public:
  inline ExpenseRatioTXN() : ExpenseRatioTXN(nullptr) {}
  ~ExpenseRatioTXN() override;
  explicit PROTOBUF_CONSTEXPR ExpenseRatioTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpenseRatioTXN(const ExpenseRatioTXN& from);
  ExpenseRatioTXN(ExpenseRatioTXN&& from) noexcept
    : ExpenseRatioTXN() {
    *this = ::std::move(from);
  }

  inline ExpenseRatioTXN& operator=(const ExpenseRatioTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpenseRatioTXN& operator=(ExpenseRatioTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpenseRatioTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpenseRatioTXN* internal_default_instance() {
    return reinterpret_cast<const ExpenseRatioTXN*>(
               &_ExpenseRatioTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ExpenseRatioTXN& a, ExpenseRatioTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpenseRatioTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpenseRatioTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpenseRatioTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpenseRatioTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpenseRatioTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpenseRatioTXN& from) {
    ExpenseRatioTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpenseRatioTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ExpenseRatioTXN";
  }
  protected:
  explicit ExpenseRatioTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 3,
    kContractIdFieldNumber = 2,
    kOutputAddressFieldNumber = 4,
    kBaseFieldNumber = 1,
  };
  // repeated bytes addresses = 3;
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const void* value, size_t size);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();
  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  public:

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes output_address = 4;
  void clear_output_address();
  const std::string& output_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_address();
  PROTOBUF_NODISCARD std::string* release_output_address();
  void set_allocated_output_address(std::string* output_address);
  private:
  const std::string& _internal_output_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_address(const std::string& value);
  std::string* _internal_mutable_output_address();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.ExpenseRatioTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_address_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class PreMintWallet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.PreMintWallet) */ {
 public:
  inline PreMintWallet() : PreMintWallet(nullptr) {}
  ~PreMintWallet() override;
  explicit PROTOBUF_CONSTEXPR PreMintWallet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PreMintWallet(const PreMintWallet& from);
  PreMintWallet(PreMintWallet&& from) noexcept
    : PreMintWallet() {
    *this = ::std::move(from);
  }

  inline PreMintWallet& operator=(const PreMintWallet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreMintWallet& operator=(PreMintWallet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreMintWallet& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreMintWallet* internal_default_instance() {
    return reinterpret_cast<const PreMintWallet*>(
               &_PreMintWallet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PreMintWallet& a, PreMintWallet& b) {
    a.Swap(&b);
  }
  inline void Swap(PreMintWallet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreMintWallet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreMintWallet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PreMintWallet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PreMintWallet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PreMintWallet& from) {
    PreMintWallet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreMintWallet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.PreMintWallet";
  }
  protected:
  explicit PreMintWallet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.PreMintWallet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Transfer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Transfer) */ {
 public:
  inline Transfer() : Transfer(nullptr) {}
  ~Transfer() override;
  explicit PROTOBUF_CONSTEXPR Transfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transfer(const Transfer& from);
  Transfer(Transfer&& from) noexcept
    : Transfer() {
    *this = ::std::move(from);
  }

  inline Transfer& operator=(const Transfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transfer& operator=(Transfer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transfer* internal_default_instance() {
    return reinterpret_cast<const Transfer*>(
               &_Transfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Transfer& a, Transfer& b) {
    a.Swap(&b);
  }
  inline void Swap(Transfer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transfer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transfer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transfer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Transfer& from) {
    Transfer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transfer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Transfer";
  }
  protected:
  explicit Transfer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
    kContractIdFieldNumber = 3,
    kContractFeeAmountFieldNumber = 4,
    kContractFeeIdFieldNumber = 5,
    kBaseFeeAmountFieldNumber = 6,
    kBaseFeeIdFieldNumber = 7,
    kMemoFieldNumber = 8,
  };
  // bytes recipient_address = 1;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // string contract_id = 3;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // optional string contract_fee_amount = 4;
  bool has_contract_fee_amount() const;
  private:
  bool _internal_has_contract_fee_amount() const;
  public:
  void clear_contract_fee_amount();
  const std::string& contract_fee_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_fee_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_fee_amount();
  PROTOBUF_NODISCARD std::string* release_contract_fee_amount();
  void set_allocated_contract_fee_amount(std::string* contract_fee_amount);
  private:
  const std::string& _internal_contract_fee_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_fee_amount(const std::string& value);
  std::string* _internal_mutable_contract_fee_amount();
  public:

  // optional string contract_fee_id = 5;
  bool has_contract_fee_id() const;
  private:
  bool _internal_has_contract_fee_id() const;
  public:
  void clear_contract_fee_id();
  const std::string& contract_fee_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_fee_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_fee_id();
  PROTOBUF_NODISCARD std::string* release_contract_fee_id();
  void set_allocated_contract_fee_id(std::string* contract_fee_id);
  private:
  const std::string& _internal_contract_fee_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_fee_id(const std::string& value);
  std::string* _internal_mutable_contract_fee_id();
  public:

  // string base_fee_amount = 6;
  void clear_base_fee_amount();
  const std::string& base_fee_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_fee_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_fee_amount();
  PROTOBUF_NODISCARD std::string* release_base_fee_amount();
  void set_allocated_base_fee_amount(std::string* base_fee_amount);
  private:
  const std::string& _internal_base_fee_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_fee_amount(const std::string& value);
  std::string* _internal_mutable_base_fee_amount();
  public:

  // string base_fee_id = 7;
  void clear_base_fee_id();
  const std::string& base_fee_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_fee_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_fee_id();
  PROTOBUF_NODISCARD std::string* release_base_fee_id();
  void set_allocated_base_fee_id(std::string* base_fee_id);
  private:
  const std::string& _internal_base_fee_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_fee_id(const std::string& value);
  std::string* _internal_mutable_base_fee_id();
  public:

  // optional string memo = 8;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.Transfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_fee_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_fee_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_fee_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_fee_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class BurnSBTTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.BurnSBTTXN) */ {
 public:
  inline BurnSBTTXN() : BurnSBTTXN(nullptr) {}
  ~BurnSBTTXN() override;
  explicit PROTOBUF_CONSTEXPR BurnSBTTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BurnSBTTXN(const BurnSBTTXN& from);
  BurnSBTTXN(BurnSBTTXN&& from) noexcept
    : BurnSBTTXN() {
    *this = ::std::move(from);
  }

  inline BurnSBTTXN& operator=(const BurnSBTTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline BurnSBTTXN& operator=(BurnSBTTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BurnSBTTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const BurnSBTTXN* internal_default_instance() {
    return reinterpret_cast<const BurnSBTTXN*>(
               &_BurnSBTTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BurnSBTTXN& a, BurnSBTTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(BurnSBTTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BurnSBTTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BurnSBTTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BurnSBTTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BurnSBTTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BurnSBTTXN& from) {
    BurnSBTTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BurnSBTTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.BurnSBTTXN";
  }
  protected:
  explicit BurnSBTTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 2,
    kItemIdFieldNumber = 3,
    kBaseFieldNumber = 1,
  };
  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string item_id = 3;
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.BurnSBTTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class BaseTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.BaseTXN) */ {
 public:
  inline BaseTXN() : BaseTXN(nullptr) {}
  ~BaseTXN() override;
  explicit PROTOBUF_CONSTEXPR BaseTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseTXN(const BaseTXN& from);
  BaseTXN(BaseTXN&& from) noexcept
    : BaseTXN() {
    *this = ::std::move(from);
  }

  inline BaseTXN& operator=(const BaseTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseTXN& operator=(BaseTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseTXN* internal_default_instance() {
    return reinterpret_cast<const BaseTXN*>(
               &_BaseTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BaseTXN& a, BaseTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseTXN& from) {
    BaseTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.BaseTXN";
  }
  protected:
  explicit BaseTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeeAmountFieldNumber = 4,
    kFeeIdFieldNumber = 5,
    kSignatureFieldNumber = 6,
    kHashFieldNumber = 7,
    kMemoFieldNumber = 8,
    kInterfaceFeeFieldNumber = 11,
    kInterfaceFeeIdFieldNumber = 12,
    kInterfaceAddressFieldNumber = 13,
    kPublicKeyFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kNonceFieldNumber = 10,
    kSafeSendFieldNumber = 9,
  };
  // string fee_amount = 4;
  void clear_fee_amount();
  const std::string& fee_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fee_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fee_amount();
  PROTOBUF_NODISCARD std::string* release_fee_amount();
  void set_allocated_fee_amount(std::string* fee_amount);
  private:
  const std::string& _internal_fee_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_amount(const std::string& value);
  std::string* _internal_mutable_fee_amount();
  public:

  // string fee_id = 5;
  void clear_fee_id();
  const std::string& fee_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fee_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fee_id();
  PROTOBUF_NODISCARD std::string* release_fee_id();
  void set_allocated_fee_id(std::string* fee_id);
  private:
  const std::string& _internal_fee_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_id(const std::string& value);
  std::string* _internal_mutable_fee_id();
  public:

  // optional bytes signature = 6;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional bytes hash = 7;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional string memo = 8;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // optional string interface_fee = 11;
  bool has_interface_fee() const;
  private:
  bool _internal_has_interface_fee() const;
  public:
  void clear_interface_fee();
  const std::string& interface_fee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface_fee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface_fee();
  PROTOBUF_NODISCARD std::string* release_interface_fee();
  void set_allocated_interface_fee(std::string* interface_fee);
  private:
  const std::string& _internal_interface_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_fee(const std::string& value);
  std::string* _internal_mutable_interface_fee();
  public:

  // optional string interface_fee_id = 12;
  bool has_interface_fee_id() const;
  private:
  bool _internal_has_interface_fee_id() const;
  public:
  void clear_interface_fee_id();
  const std::string& interface_fee_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface_fee_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface_fee_id();
  PROTOBUF_NODISCARD std::string* release_interface_fee_id();
  void set_allocated_interface_fee_id(std::string* interface_fee_id);
  private:
  const std::string& _internal_interface_fee_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_fee_id(const std::string& value);
  std::string* _internal_mutable_interface_fee_id();
  public:

  // optional string interface_address = 13;
  bool has_interface_address() const;
  private:
  bool _internal_has_interface_address() const;
  public:
  void clear_interface_address();
  const std::string& interface_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface_address();
  PROTOBUF_NODISCARD std::string* release_interface_address();
  void set_allocated_interface_address(std::string* interface_address);
  private:
  const std::string& _internal_interface_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_address(const std::string& value);
  std::string* _internal_mutable_interface_address();
  public:

  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  PROTOBUF_NODISCARD ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint64 nonce = 10;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // optional bool safe_send = 9;
  bool has_safe_send() const;
  private:
  bool _internal_has_safe_send() const;
  public:
  void clear_safe_send();
  bool safe_send() const;
  void set_safe_send(bool value);
  private:
  bool _internal_safe_send() const;
  void _internal_set_safe_send(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.BaseTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_fee_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_address_;
    ::zera_txn::PublicKey* public_key_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    uint64_t nonce_;
    bool safe_send_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class PublicKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.PublicKey) */ {
 public:
  inline PublicKey() : PublicKey(nullptr) {}
  ~PublicKey() override;
  explicit PROTOBUF_CONSTEXPR PublicKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicKey(const PublicKey& from);
  PublicKey(PublicKey&& from) noexcept
    : PublicKey() {
    *this = ::std::move(from);
  }

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicKey& operator=(PublicKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicKey* internal_default_instance() {
    return reinterpret_cast<const PublicKey*>(
               &_PublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PublicKey& a, PublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublicKey& from) {
    PublicKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.PublicKey";
  }
  protected:
  explicit PublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSingleFieldNumber = 1,
    kSmartContractAuthFieldNumber = 3,
    kGovernanceAuthFieldNumber = 4,
    kMultiFieldNumber = 2,
  };
  // bytes single = 1;
  void clear_single();
  const std::string& single() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_single(ArgT0&& arg0, ArgT... args);
  std::string* mutable_single();
  PROTOBUF_NODISCARD std::string* release_single();
  void set_allocated_single(std::string* single);
  private:
  const std::string& _internal_single() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_single(const std::string& value);
  std::string* _internal_mutable_single();
  public:

  // optional bytes smart_contract_auth = 3;
  bool has_smart_contract_auth() const;
  private:
  bool _internal_has_smart_contract_auth() const;
  public:
  void clear_smart_contract_auth();
  const std::string& smart_contract_auth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smart_contract_auth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smart_contract_auth();
  PROTOBUF_NODISCARD std::string* release_smart_contract_auth();
  void set_allocated_smart_contract_auth(std::string* smart_contract_auth);
  private:
  const std::string& _internal_smart_contract_auth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smart_contract_auth(const std::string& value);
  std::string* _internal_mutable_smart_contract_auth();
  public:

  // optional bytes governance_auth = 4;
  bool has_governance_auth() const;
  private:
  bool _internal_has_governance_auth() const;
  public:
  void clear_governance_auth();
  const std::string& governance_auth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_governance_auth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_governance_auth();
  PROTOBUF_NODISCARD std::string* release_governance_auth();
  void set_allocated_governance_auth(std::string* governance_auth);
  private:
  const std::string& _internal_governance_auth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_governance_auth(const std::string& value);
  std::string* _internal_mutable_governance_auth();
  public:

  // .zera_txn.MultiKey multi = 2;
  bool has_multi() const;
  private:
  bool _internal_has_multi() const;
  public:
  void clear_multi();
  const ::zera_txn::MultiKey& multi() const;
  PROTOBUF_NODISCARD ::zera_txn::MultiKey* release_multi();
  ::zera_txn::MultiKey* mutable_multi();
  void set_allocated_multi(::zera_txn::MultiKey* multi);
  private:
  const ::zera_txn::MultiKey& _internal_multi() const;
  ::zera_txn::MultiKey* _internal_mutable_multi();
  public:
  void unsafe_arena_set_allocated_multi(
      ::zera_txn::MultiKey* multi);
  ::zera_txn::MultiKey* unsafe_arena_release_multi();

  // @@protoc_insertion_point(class_scope:zera_txn.PublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr single_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smart_contract_auth_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr governance_auth_;
    ::zera_txn::MultiKey* multi_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class GovernanceAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.GovernanceAuth) */ {
 public:
  inline GovernanceAuth() : GovernanceAuth(nullptr) {}
  ~GovernanceAuth() override;
  explicit PROTOBUF_CONSTEXPR GovernanceAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GovernanceAuth(const GovernanceAuth& from);
  GovernanceAuth(GovernanceAuth&& from) noexcept
    : GovernanceAuth() {
    *this = ::std::move(from);
  }

  inline GovernanceAuth& operator=(const GovernanceAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline GovernanceAuth& operator=(GovernanceAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GovernanceAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const GovernanceAuth* internal_default_instance() {
    return reinterpret_cast<const GovernanceAuth*>(
               &_GovernanceAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GovernanceAuth& a, GovernanceAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(GovernanceAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GovernanceAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GovernanceAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GovernanceAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GovernanceAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GovernanceAuth& from) {
    GovernanceAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GovernanceAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.GovernanceAuth";
  }
  protected:
  explicit GovernanceAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 1,
    kProposalIdFieldNumber = 2,
  };
  // bytes auth = 1;
  void clear_auth();
  const std::string& auth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth();
  PROTOBUF_NODISCARD std::string* release_auth();
  void set_allocated_auth(std::string* auth);
  private:
  const std::string& _internal_auth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth(const std::string& value);
  std::string* _internal_mutable_auth();
  public:

  // bytes proposal_id = 2;
  void clear_proposal_id();
  const std::string& proposal_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proposal_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proposal_id();
  PROTOBUF_NODISCARD std::string* release_proposal_id();
  void set_allocated_proposal_id(std::string* proposal_id);
  private:
  const std::string& _internal_proposal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposal_id(const std::string& value);
  std::string* _internal_mutable_proposal_id();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.GovernanceAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposal_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class MultiKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.MultiKey) */ {
 public:
  inline MultiKey() : MultiKey(nullptr) {}
  ~MultiKey() override;
  explicit PROTOBUF_CONSTEXPR MultiKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiKey(const MultiKey& from);
  MultiKey(MultiKey&& from) noexcept
    : MultiKey() {
    *this = ::std::move(from);
  }

  inline MultiKey& operator=(const MultiKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiKey& operator=(MultiKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiKey* internal_default_instance() {
    return reinterpret_cast<const MultiKey*>(
               &_MultiKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MultiKey& a, MultiKey& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MultiKey& from) {
    MultiKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.MultiKey";
  }
  protected:
  explicit MultiKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeysFieldNumber = 1,
    kSignaturesFieldNumber = 2,
    kMultiPatternsFieldNumber = 3,
    kHashTokensFieldNumber = 4,
  };
  // repeated bytes public_keys = 1;
  int public_keys_size() const;
  private:
  int _internal_public_keys_size() const;
  public:
  void clear_public_keys();
  const std::string& public_keys(int index) const;
  std::string* mutable_public_keys(int index);
  void set_public_keys(int index, const std::string& value);
  void set_public_keys(int index, std::string&& value);
  void set_public_keys(int index, const char* value);
  void set_public_keys(int index, const void* value, size_t size);
  std::string* add_public_keys();
  void add_public_keys(const std::string& value);
  void add_public_keys(std::string&& value);
  void add_public_keys(const char* value);
  void add_public_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& public_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_public_keys();
  private:
  const std::string& _internal_public_keys(int index) const;
  std::string* _internal_add_public_keys();
  public:

  // repeated bytes signatures = 2;
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;
  public:
  void clear_signatures();
  const std::string& signatures(int index) const;
  std::string* mutable_signatures(int index);
  void set_signatures(int index, const std::string& value);
  void set_signatures(int index, std::string&& value);
  void set_signatures(int index, const char* value);
  void set_signatures(int index, const void* value, size_t size);
  std::string* add_signatures();
  void add_signatures(const std::string& value);
  void add_signatures(std::string&& value);
  void add_signatures(const char* value);
  void add_signatures(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signatures();
  private:
  const std::string& _internal_signatures(int index) const;
  std::string* _internal_add_signatures();
  public:

  // repeated .zera_txn.MultiPatterns multi_patterns = 3;
  int multi_patterns_size() const;
  private:
  int _internal_multi_patterns_size() const;
  public:
  void clear_multi_patterns();
  ::zera_txn::MultiPatterns* mutable_multi_patterns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MultiPatterns >*
      mutable_multi_patterns();
  private:
  const ::zera_txn::MultiPatterns& _internal_multi_patterns(int index) const;
  ::zera_txn::MultiPatterns* _internal_add_multi_patterns();
  public:
  const ::zera_txn::MultiPatterns& multi_patterns(int index) const;
  ::zera_txn::MultiPatterns* add_multi_patterns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MultiPatterns >&
      multi_patterns() const;

  // repeated string hash_tokens = 4;
  int hash_tokens_size() const;
  private:
  int _internal_hash_tokens_size() const;
  public:
  void clear_hash_tokens();
  const std::string& hash_tokens(int index) const;
  std::string* mutable_hash_tokens(int index);
  void set_hash_tokens(int index, const std::string& value);
  void set_hash_tokens(int index, std::string&& value);
  void set_hash_tokens(int index, const char* value);
  void set_hash_tokens(int index, const char* value, size_t size);
  std::string* add_hash_tokens();
  void add_hash_tokens(const std::string& value);
  void add_hash_tokens(std::string&& value);
  void add_hash_tokens(const char* value);
  void add_hash_tokens(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hash_tokens() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hash_tokens();
  private:
  const std::string& _internal_hash_tokens(int index) const;
  std::string* _internal_add_hash_tokens();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.MultiKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> public_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signatures_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MultiPatterns > multi_patterns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hash_tokens_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class MultiPatterns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.MultiPatterns) */ {
 public:
  inline MultiPatterns() : MultiPatterns(nullptr) {}
  ~MultiPatterns() override;
  explicit PROTOBUF_CONSTEXPR MultiPatterns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiPatterns(const MultiPatterns& from);
  MultiPatterns(MultiPatterns&& from) noexcept
    : MultiPatterns() {
    *this = ::std::move(from);
  }

  inline MultiPatterns& operator=(const MultiPatterns& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiPatterns& operator=(MultiPatterns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiPatterns& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiPatterns* internal_default_instance() {
    return reinterpret_cast<const MultiPatterns*>(
               &_MultiPatterns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MultiPatterns& a, MultiPatterns& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiPatterns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiPatterns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiPatterns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiPatterns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiPatterns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MultiPatterns& from) {
    MultiPatterns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiPatterns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.MultiPatterns";
  }
  protected:
  explicit MultiPatterns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 1,
    kRequiredFieldNumber = 2,
  };
  // repeated uint32 class = 1;
  int class__size() const;
  private:
  int _internal_class__size() const;
  public:
  void clear_class_();
  private:
  uint32_t _internal_class_(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_class_() const;
  void _internal_add_class_(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_class_();
  public:
  uint32_t class_(int index) const;
  void set_class_(int index, uint32_t value);
  void add_class_(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      class_() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_class_();

  // repeated uint32 required = 2;
  int required_size() const;
  private:
  int _internal_required_size() const;
  public:
  void clear_required();
  private:
  uint32_t _internal_required(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_required() const;
  void _internal_add_required(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_required();
  public:
  uint32_t required(int index) const;
  void set_required(int index, uint32_t value);
  void add_required(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      required() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_required();

  // @@protoc_insertion_point(class_scope:zera_txn.MultiPatterns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > class__;
    mutable std::atomic<int> _class__cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > required_;
    mutable std::atomic<int> _required_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class SelfCurrencyEquiv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.SelfCurrencyEquiv) */ {
 public:
  inline SelfCurrencyEquiv() : SelfCurrencyEquiv(nullptr) {}
  ~SelfCurrencyEquiv() override;
  explicit PROTOBUF_CONSTEXPR SelfCurrencyEquiv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelfCurrencyEquiv(const SelfCurrencyEquiv& from);
  SelfCurrencyEquiv(SelfCurrencyEquiv&& from) noexcept
    : SelfCurrencyEquiv() {
    *this = ::std::move(from);
  }

  inline SelfCurrencyEquiv& operator=(const SelfCurrencyEquiv& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelfCurrencyEquiv& operator=(SelfCurrencyEquiv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelfCurrencyEquiv& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelfCurrencyEquiv* internal_default_instance() {
    return reinterpret_cast<const SelfCurrencyEquiv*>(
               &_SelfCurrencyEquiv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SelfCurrencyEquiv& a, SelfCurrencyEquiv& b) {
    a.Swap(&b);
  }
  inline void Swap(SelfCurrencyEquiv* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelfCurrencyEquiv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelfCurrencyEquiv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelfCurrencyEquiv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelfCurrencyEquiv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelfCurrencyEquiv& from) {
    SelfCurrencyEquiv::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelfCurrencyEquiv* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.SelfCurrencyEquiv";
  }
  protected:
  explicit SelfCurrencyEquiv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurEquivFieldNumber = 2,
    kBaseFieldNumber = 1,
  };
  // repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
  int cur_equiv_size() const;
  private:
  int _internal_cur_equiv_size() const;
  public:
  void clear_cur_equiv();
  ::zera_txn::CurrencyEquiv* mutable_cur_equiv(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv >*
      mutable_cur_equiv();
  private:
  const ::zera_txn::CurrencyEquiv& _internal_cur_equiv(int index) const;
  ::zera_txn::CurrencyEquiv* _internal_add_cur_equiv();
  public:
  const ::zera_txn::CurrencyEquiv& cur_equiv(int index) const;
  ::zera_txn::CurrencyEquiv* add_cur_equiv();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv >&
      cur_equiv() const;

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.SelfCurrencyEquiv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv > cur_equiv_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class AuthorizedCurrencyEquiv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.AuthorizedCurrencyEquiv) */ {
 public:
  inline AuthorizedCurrencyEquiv() : AuthorizedCurrencyEquiv(nullptr) {}
  ~AuthorizedCurrencyEquiv() override;
  explicit PROTOBUF_CONSTEXPR AuthorizedCurrencyEquiv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizedCurrencyEquiv(const AuthorizedCurrencyEquiv& from);
  AuthorizedCurrencyEquiv(AuthorizedCurrencyEquiv&& from) noexcept
    : AuthorizedCurrencyEquiv() {
    *this = ::std::move(from);
  }

  inline AuthorizedCurrencyEquiv& operator=(const AuthorizedCurrencyEquiv& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizedCurrencyEquiv& operator=(AuthorizedCurrencyEquiv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizedCurrencyEquiv& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizedCurrencyEquiv* internal_default_instance() {
    return reinterpret_cast<const AuthorizedCurrencyEquiv*>(
               &_AuthorizedCurrencyEquiv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AuthorizedCurrencyEquiv& a, AuthorizedCurrencyEquiv& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizedCurrencyEquiv* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizedCurrencyEquiv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizedCurrencyEquiv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizedCurrencyEquiv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizedCurrencyEquiv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthorizedCurrencyEquiv& from) {
    AuthorizedCurrencyEquiv::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizedCurrencyEquiv* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.AuthorizedCurrencyEquiv";
  }
  protected:
  explicit AuthorizedCurrencyEquiv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurEquivFieldNumber = 2,
    kBaseFieldNumber = 1,
  };
  // repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
  int cur_equiv_size() const;
  private:
  int _internal_cur_equiv_size() const;
  public:
  void clear_cur_equiv();
  ::zera_txn::CurrencyEquiv* mutable_cur_equiv(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv >*
      mutable_cur_equiv();
  private:
  const ::zera_txn::CurrencyEquiv& _internal_cur_equiv(int index) const;
  ::zera_txn::CurrencyEquiv* _internal_add_cur_equiv();
  public:
  const ::zera_txn::CurrencyEquiv& cur_equiv(int index) const;
  ::zera_txn::CurrencyEquiv* add_cur_equiv();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv >&
      cur_equiv() const;

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.AuthorizedCurrencyEquiv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv > cur_equiv_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class CurrencyEquiv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.CurrencyEquiv) */ {
 public:
  inline CurrencyEquiv() : CurrencyEquiv(nullptr) {}
  ~CurrencyEquiv() override;
  explicit PROTOBUF_CONSTEXPR CurrencyEquiv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrencyEquiv(const CurrencyEquiv& from);
  CurrencyEquiv(CurrencyEquiv&& from) noexcept
    : CurrencyEquiv() {
    *this = ::std::move(from);
  }

  inline CurrencyEquiv& operator=(const CurrencyEquiv& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyEquiv& operator=(CurrencyEquiv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyEquiv& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyEquiv* internal_default_instance() {
    return reinterpret_cast<const CurrencyEquiv*>(
               &_CurrencyEquiv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CurrencyEquiv& a, CurrencyEquiv& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyEquiv* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyEquiv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyEquiv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyEquiv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrencyEquiv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CurrencyEquiv& from) {
    CurrencyEquiv::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyEquiv* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.CurrencyEquiv";
  }
  protected:
  explicit CurrencyEquiv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kRateFieldNumber = 2,
    kMaxStakeFieldNumber = 4,
    kAuthorizedFieldNumber = 3,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string rate = 2;
  void clear_rate();
  const std::string& rate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rate();
  PROTOBUF_NODISCARD std::string* release_rate();
  void set_allocated_rate(std::string* rate);
  private:
  const std::string& _internal_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate(const std::string& value);
  std::string* _internal_mutable_rate();
  public:

  // optional string max_stake = 4;
  bool has_max_stake() const;
  private:
  bool _internal_has_max_stake() const;
  public:
  void clear_max_stake();
  const std::string& max_stake() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_max_stake(ArgT0&& arg0, ArgT... args);
  std::string* mutable_max_stake();
  PROTOBUF_NODISCARD std::string* release_max_stake();
  void set_allocated_max_stake(std::string* max_stake);
  private:
  const std::string& _internal_max_stake() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_stake(const std::string& value);
  std::string* _internal_mutable_max_stake();
  public:

  // optional bool authorized = 3;
  bool has_authorized() const;
  private:
  bool _internal_has_authorized() const;
  public:
  void clear_authorized();
  bool authorized() const;
  void set_authorized(bool value);
  private:
  bool _internal_authorized() const;
  void _internal_set_authorized(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.CurrencyEquiv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_stake_;
    bool authorized_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ExpenseRatioResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ExpenseRatioResult) */ {
 public:
  inline ExpenseRatioResult() : ExpenseRatioResult(nullptr) {}
  ~ExpenseRatioResult() override;
  explicit PROTOBUF_CONSTEXPR ExpenseRatioResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpenseRatioResult(const ExpenseRatioResult& from);
  ExpenseRatioResult(ExpenseRatioResult&& from) noexcept
    : ExpenseRatioResult() {
    *this = ::std::move(from);
  }

  inline ExpenseRatioResult& operator=(const ExpenseRatioResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpenseRatioResult& operator=(ExpenseRatioResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpenseRatioResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpenseRatioResult* internal_default_instance() {
    return reinterpret_cast<const ExpenseRatioResult*>(
               &_ExpenseRatioResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ExpenseRatioResult& a, ExpenseRatioResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpenseRatioResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpenseRatioResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpenseRatioResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpenseRatioResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpenseRatioResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpenseRatioResult& from) {
    ExpenseRatioResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpenseRatioResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ExpenseRatioResult";
  }
  protected:
  explicit ExpenseRatioResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletsFieldNumber = 2,
    kContractIdFieldNumber = 1,
    kHashFieldNumber = 3,
    kRecipientAddressFieldNumber = 4,
  };
  // repeated .zera_txn.Wallets wallets = 2;
  int wallets_size() const;
  private:
  int _internal_wallets_size() const;
  public:
  void clear_wallets();
  ::zera_txn::Wallets* mutable_wallets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Wallets >*
      mutable_wallets();
  private:
  const ::zera_txn::Wallets& _internal_wallets(int index) const;
  ::zera_txn::Wallets* _internal_add_wallets();
  public:
  const ::zera_txn::Wallets& wallets(int index) const;
  ::zera_txn::Wallets* add_wallets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Wallets >&
      wallets() const;

  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes hash = 3;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // bytes recipient_address = 4;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ExpenseRatioResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Wallets > wallets_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ComplianceAssign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ComplianceAssign) */ {
 public:
  inline ComplianceAssign() : ComplianceAssign(nullptr) {}
  ~ComplianceAssign() override;
  explicit PROTOBUF_CONSTEXPR ComplianceAssign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComplianceAssign(const ComplianceAssign& from);
  ComplianceAssign(ComplianceAssign&& from) noexcept
    : ComplianceAssign() {
    *this = ::std::move(from);
  }

  inline ComplianceAssign& operator=(const ComplianceAssign& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComplianceAssign& operator=(ComplianceAssign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComplianceAssign& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComplianceAssign* internal_default_instance() {
    return reinterpret_cast<const ComplianceAssign*>(
               &_ComplianceAssign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ComplianceAssign& a, ComplianceAssign& b) {
    a.Swap(&b);
  }
  inline void Swap(ComplianceAssign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComplianceAssign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComplianceAssign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComplianceAssign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComplianceAssign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ComplianceAssign& from) {
    ComplianceAssign::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComplianceAssign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ComplianceAssign";
  }
  protected:
  explicit ComplianceAssign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientAddressFieldNumber = 1,
    kExpiryFieldNumber = 4,
    kComplianceLevelFieldNumber = 2,
    kAssignRevokeFieldNumber = 3,
  };
  // bytes recipient_address = 1;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // .google.protobuf.Timestamp expiry = 4;
  bool has_expiry() const;
  private:
  bool _internal_has_expiry() const;
  public:
  void clear_expiry();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expiry() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expiry();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expiry();
  void set_allocated_expiry(::PROTOBUF_NAMESPACE_ID::Timestamp* expiry);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expiry() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expiry();
  public:
  void unsafe_arena_set_allocated_expiry(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expiry();

  // uint32 compliance_level = 2;
  void clear_compliance_level();
  uint32_t compliance_level() const;
  void set_compliance_level(uint32_t value);
  private:
  uint32_t _internal_compliance_level() const;
  void _internal_set_compliance_level(uint32_t value);
  public:

  // bool assign_revoke = 3;
  void clear_assign_revoke();
  bool assign_revoke() const;
  void set_assign_revoke(bool value);
  private:
  bool _internal_assign_revoke() const;
  void _internal_set_assign_revoke(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ComplianceAssign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry_;
    uint32_t compliance_level_;
    bool assign_revoke_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ComplianceTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ComplianceTXN) */ {
 public:
  inline ComplianceTXN() : ComplianceTXN(nullptr) {}
  ~ComplianceTXN() override;
  explicit PROTOBUF_CONSTEXPR ComplianceTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComplianceTXN(const ComplianceTXN& from);
  ComplianceTXN(ComplianceTXN&& from) noexcept
    : ComplianceTXN() {
    *this = ::std::move(from);
  }

  inline ComplianceTXN& operator=(const ComplianceTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComplianceTXN& operator=(ComplianceTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComplianceTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComplianceTXN* internal_default_instance() {
    return reinterpret_cast<const ComplianceTXN*>(
               &_ComplianceTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ComplianceTXN& a, ComplianceTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(ComplianceTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComplianceTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComplianceTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComplianceTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComplianceTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ComplianceTXN& from) {
    ComplianceTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComplianceTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ComplianceTXN";
  }
  protected:
  explicit ComplianceTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComplianceFieldNumber = 3,
    kContractIdFieldNumber = 2,
    kBaseFieldNumber = 1,
  };
  // repeated .zera_txn.ComplianceAssign compliance = 3;
  int compliance_size() const;
  private:
  int _internal_compliance_size() const;
  public:
  void clear_compliance();
  ::zera_txn::ComplianceAssign* mutable_compliance(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceAssign >*
      mutable_compliance();
  private:
  const ::zera_txn::ComplianceAssign& _internal_compliance(int index) const;
  ::zera_txn::ComplianceAssign* _internal_add_compliance();
  public:
  const ::zera_txn::ComplianceAssign& compliance(int index) const;
  ::zera_txn::ComplianceAssign* add_compliance();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceAssign >&
      compliance() const;

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.ComplianceTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceAssign > compliance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Wallets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Wallets) */ {
 public:
  inline Wallets() : Wallets(nullptr) {}
  ~Wallets() override;
  explicit PROTOBUF_CONSTEXPR Wallets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wallets(const Wallets& from);
  Wallets(Wallets&& from) noexcept
    : Wallets() {
    *this = ::std::move(from);
  }

  inline Wallets& operator=(const Wallets& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wallets& operator=(Wallets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wallets& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wallets* internal_default_instance() {
    return reinterpret_cast<const Wallets*>(
               &_Wallets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Wallets& a, Wallets& b) {
    a.Swap(&b);
  }
  inline void Swap(Wallets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wallets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wallets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wallets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wallets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Wallets& from) {
    Wallets::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wallets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Wallets";
  }
  protected:
  explicit Wallets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.Wallets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class QuashTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.QuashTXN) */ {
 public:
  inline QuashTXN() : QuashTXN(nullptr) {}
  ~QuashTXN() override;
  explicit PROTOBUF_CONSTEXPR QuashTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuashTXN(const QuashTXN& from);
  QuashTXN(QuashTXN&& from) noexcept
    : QuashTXN() {
    *this = ::std::move(from);
  }

  inline QuashTXN& operator=(const QuashTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuashTXN& operator=(QuashTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuashTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuashTXN* internal_default_instance() {
    return reinterpret_cast<const QuashTXN*>(
               &_QuashTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(QuashTXN& a, QuashTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(QuashTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuashTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuashTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuashTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuashTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuashTXN& from) {
    QuashTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuashTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.QuashTXN";
  }
  protected:
  explicit QuashTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 2,
    kTxnHashFieldNumber = 3,
    kBaseFieldNumber = 1,
  };
  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes txn_hash = 3;
  void clear_txn_hash();
  const std::string& txn_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txn_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txn_hash();
  PROTOBUF_NODISCARD std::string* release_txn_hash();
  void set_allocated_txn_hash(std::string* txn_hash);
  private:
  const std::string& _internal_txn_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txn_hash(const std::string& value);
  std::string* _internal_mutable_txn_hash();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.QuashTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txn_hash_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class QuashResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.QuashResult) */ {
 public:
  inline QuashResult() : QuashResult(nullptr) {}
  ~QuashResult() override;
  explicit PROTOBUF_CONSTEXPR QuashResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuashResult(const QuashResult& from);
  QuashResult(QuashResult&& from) noexcept
    : QuashResult() {
    *this = ::std::move(from);
  }

  inline QuashResult& operator=(const QuashResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuashResult& operator=(QuashResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuashResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuashResult* internal_default_instance() {
    return reinterpret_cast<const QuashResult*>(
               &_QuashResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(QuashResult& a, QuashResult& b) {
    a.Swap(&b);
  }
  inline void Swap(QuashResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuashResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuashResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuashResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuashResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuashResult& from) {
    QuashResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuashResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.QuashResult";
  }
  protected:
  explicit QuashResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeysFieldNumber = 2,
    kTxnHashFieldNumber = 1,
  };
  // repeated .zera_txn.PublicKey public_keys = 2;
  int public_keys_size() const;
  private:
  int _internal_public_keys_size() const;
  public:
  void clear_public_keys();
  ::zera_txn::PublicKey* mutable_public_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >*
      mutable_public_keys();
  private:
  const ::zera_txn::PublicKey& _internal_public_keys(int index) const;
  ::zera_txn::PublicKey* _internal_add_public_keys();
  public:
  const ::zera_txn::PublicKey& public_keys(int index) const;
  ::zera_txn::PublicKey* add_public_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >&
      public_keys() const;

  // bytes txn_hash = 1;
  void clear_txn_hash();
  const std::string& txn_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txn_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txn_hash();
  PROTOBUF_NODISCARD std::string* release_txn_hash();
  void set_allocated_txn_hash(std::string* txn_hash);
  private:
  const std::string& _internal_txn_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txn_hash(const std::string& value);
  std::string* _internal_mutable_txn_hash();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.QuashResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey > public_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txn_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class CoinTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.CoinTXN) */ {
 public:
  inline CoinTXN() : CoinTXN(nullptr) {}
  ~CoinTXN() override;
  explicit PROTOBUF_CONSTEXPR CoinTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoinTXN(const CoinTXN& from);
  CoinTXN(CoinTXN&& from) noexcept
    : CoinTXN() {
    *this = ::std::move(from);
  }

  inline CoinTXN& operator=(const CoinTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoinTXN& operator=(CoinTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoinTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoinTXN* internal_default_instance() {
    return reinterpret_cast<const CoinTXN*>(
               &_CoinTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CoinTXN& a, CoinTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(CoinTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoinTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoinTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoinTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoinTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CoinTXN& from) {
    CoinTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoinTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.CoinTXN";
  }
  protected:
  explicit CoinTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputTransfersFieldNumber = 4,
    kOutputTransfersFieldNumber = 5,
    kContractIdFieldNumber = 2,
    kContractFeeIdFieldNumber = 6,
    kContractFeeAmountFieldNumber = 7,
    kBaseFieldNumber = 1,
    kAuthFieldNumber = 3,
  };
  // repeated .zera_txn.InputTransfers input_transfers = 4;
  int input_transfers_size() const;
  private:
  int _internal_input_transfers_size() const;
  public:
  void clear_input_transfers();
  ::zera_txn::InputTransfers* mutable_input_transfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InputTransfers >*
      mutable_input_transfers();
  private:
  const ::zera_txn::InputTransfers& _internal_input_transfers(int index) const;
  ::zera_txn::InputTransfers* _internal_add_input_transfers();
  public:
  const ::zera_txn::InputTransfers& input_transfers(int index) const;
  ::zera_txn::InputTransfers* add_input_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InputTransfers >&
      input_transfers() const;

  // repeated .zera_txn.OutputTransfers output_transfers = 5;
  int output_transfers_size() const;
  private:
  int _internal_output_transfers_size() const;
  public:
  void clear_output_transfers();
  ::zera_txn::OutputTransfers* mutable_output_transfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::OutputTransfers >*
      mutable_output_transfers();
  private:
  const ::zera_txn::OutputTransfers& _internal_output_transfers(int index) const;
  ::zera_txn::OutputTransfers* _internal_add_output_transfers();
  public:
  const ::zera_txn::OutputTransfers& output_transfers(int index) const;
  ::zera_txn::OutputTransfers* add_output_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::OutputTransfers >&
      output_transfers() const;

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // optional string contract_fee_id = 6;
  bool has_contract_fee_id() const;
  private:
  bool _internal_has_contract_fee_id() const;
  public:
  void clear_contract_fee_id();
  const std::string& contract_fee_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_fee_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_fee_id();
  PROTOBUF_NODISCARD std::string* release_contract_fee_id();
  void set_allocated_contract_fee_id(std::string* contract_fee_id);
  private:
  const std::string& _internal_contract_fee_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_fee_id(const std::string& value);
  std::string* _internal_mutable_contract_fee_id();
  public:

  // optional string contract_fee_amount = 7;
  bool has_contract_fee_amount() const;
  private:
  bool _internal_has_contract_fee_amount() const;
  public:
  void clear_contract_fee_amount();
  const std::string& contract_fee_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_fee_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_fee_amount();
  PROTOBUF_NODISCARD std::string* release_contract_fee_amount();
  void set_allocated_contract_fee_amount(std::string* contract_fee_amount);
  private:
  const std::string& _internal_contract_fee_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_fee_amount(const std::string& value);
  std::string* _internal_mutable_contract_fee_amount();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // .zera_txn.TransferAuthentication auth = 3;
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::zera_txn::TransferAuthentication& auth() const;
  PROTOBUF_NODISCARD ::zera_txn::TransferAuthentication* release_auth();
  ::zera_txn::TransferAuthentication* mutable_auth();
  void set_allocated_auth(::zera_txn::TransferAuthentication* auth);
  private:
  const ::zera_txn::TransferAuthentication& _internal_auth() const;
  ::zera_txn::TransferAuthentication* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::zera_txn::TransferAuthentication* auth);
  ::zera_txn::TransferAuthentication* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:zera_txn.CoinTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InputTransfers > input_transfers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::OutputTransfers > output_transfers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_fee_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_fee_amount_;
    ::zera_txn::BaseTXN* base_;
    ::zera_txn::TransferAuthentication* auth_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class TransferAuthentication final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.TransferAuthentication) */ {
 public:
  inline TransferAuthentication() : TransferAuthentication(nullptr) {}
  ~TransferAuthentication() override;
  explicit PROTOBUF_CONSTEXPR TransferAuthentication(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferAuthentication(const TransferAuthentication& from);
  TransferAuthentication(TransferAuthentication&& from) noexcept
    : TransferAuthentication() {
    *this = ::std::move(from);
  }

  inline TransferAuthentication& operator=(const TransferAuthentication& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferAuthentication& operator=(TransferAuthentication&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferAuthentication& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferAuthentication* internal_default_instance() {
    return reinterpret_cast<const TransferAuthentication*>(
               &_TransferAuthentication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(TransferAuthentication& a, TransferAuthentication& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferAuthentication* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferAuthentication* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferAuthentication* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferAuthentication>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferAuthentication& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferAuthentication& from) {
    TransferAuthentication::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferAuthentication* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.TransferAuthentication";
  }
  protected:
  explicit TransferAuthentication(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kSignatureFieldNumber = 2,
    kNonceFieldNumber = 3,
    kAllowanceAddressFieldNumber = 4,
    kAllowanceNonceFieldNumber = 5,
  };
  // repeated .zera_txn.PublicKey public_key = 1;
  int public_key_size() const;
  private:
  int _internal_public_key_size() const;
  public:
  void clear_public_key();
  ::zera_txn::PublicKey* mutable_public_key(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >*
      mutable_public_key();
  private:
  const ::zera_txn::PublicKey& _internal_public_key(int index) const;
  ::zera_txn::PublicKey* _internal_add_public_key();
  public:
  const ::zera_txn::PublicKey& public_key(int index) const;
  ::zera_txn::PublicKey* add_public_key();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >&
      public_key() const;

  // repeated bytes signature = 2;
  int signature_size() const;
  private:
  int _internal_signature_size() const;
  public:
  void clear_signature();
  const std::string& signature(int index) const;
  std::string* mutable_signature(int index);
  void set_signature(int index, const std::string& value);
  void set_signature(int index, std::string&& value);
  void set_signature(int index, const char* value);
  void set_signature(int index, const void* value, size_t size);
  std::string* add_signature();
  void add_signature(const std::string& value);
  void add_signature(std::string&& value);
  void add_signature(const char* value);
  void add_signature(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signature();
  private:
  const std::string& _internal_signature(int index) const;
  std::string* _internal_add_signature();
  public:

  // repeated uint64 nonce = 3;
  int nonce_size() const;
  private:
  int _internal_nonce_size() const;
  public:
  void clear_nonce();
  private:
  uint64_t _internal_nonce(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_nonce() const;
  void _internal_add_nonce(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_nonce();
  public:
  uint64_t nonce(int index) const;
  void set_nonce(int index, uint64_t value);
  void add_nonce(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      nonce() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_nonce();

  // repeated bytes allowance_address = 4;
  int allowance_address_size() const;
  private:
  int _internal_allowance_address_size() const;
  public:
  void clear_allowance_address();
  const std::string& allowance_address(int index) const;
  std::string* mutable_allowance_address(int index);
  void set_allowance_address(int index, const std::string& value);
  void set_allowance_address(int index, std::string&& value);
  void set_allowance_address(int index, const char* value);
  void set_allowance_address(int index, const void* value, size_t size);
  std::string* add_allowance_address();
  void add_allowance_address(const std::string& value);
  void add_allowance_address(std::string&& value);
  void add_allowance_address(const char* value);
  void add_allowance_address(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowance_address() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowance_address();
  private:
  const std::string& _internal_allowance_address(int index) const;
  std::string* _internal_add_allowance_address();
  public:

  // repeated uint64 allowance_nonce = 5;
  int allowance_nonce_size() const;
  private:
  int _internal_allowance_nonce_size() const;
  public:
  void clear_allowance_nonce();
  private:
  uint64_t _internal_allowance_nonce(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_allowance_nonce() const;
  void _internal_add_allowance_nonce(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_allowance_nonce();
  public:
  uint64_t allowance_nonce(int index) const;
  void set_allowance_nonce(int index, uint64_t value);
  void add_allowance_nonce(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      allowance_nonce() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_allowance_nonce();

  // @@protoc_insertion_point(class_scope:zera_txn.TransferAuthentication)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey > public_key_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signature_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > nonce_;
    mutable std::atomic<int> _nonce_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowance_address_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > allowance_nonce_;
    mutable std::atomic<int> _allowance_nonce_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class InputTransfers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.InputTransfers) */ {
 public:
  inline InputTransfers() : InputTransfers(nullptr) {}
  ~InputTransfers() override;
  explicit PROTOBUF_CONSTEXPR InputTransfers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputTransfers(const InputTransfers& from);
  InputTransfers(InputTransfers&& from) noexcept
    : InputTransfers() {
    *this = ::std::move(from);
  }

  inline InputTransfers& operator=(const InputTransfers& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputTransfers& operator=(InputTransfers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputTransfers& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputTransfers* internal_default_instance() {
    return reinterpret_cast<const InputTransfers*>(
               &_InputTransfers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(InputTransfers& a, InputTransfers& b) {
    a.Swap(&b);
  }
  inline void Swap(InputTransfers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputTransfers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputTransfers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputTransfers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputTransfers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputTransfers& from) {
    InputTransfers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputTransfers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.InputTransfers";
  }
  protected:
  explicit InputTransfers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 2,
    kIndexFieldNumber = 1,
    kFeePercentFieldNumber = 3,
    kContractFeePercentFieldNumber = 4,
  };
  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // uint64 index = 1;
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // uint32 fee_percent = 3;
  void clear_fee_percent();
  uint32_t fee_percent() const;
  void set_fee_percent(uint32_t value);
  private:
  uint32_t _internal_fee_percent() const;
  void _internal_set_fee_percent(uint32_t value);
  public:

  // optional uint32 contract_fee_percent = 4;
  bool has_contract_fee_percent() const;
  private:
  bool _internal_has_contract_fee_percent() const;
  public:
  void clear_contract_fee_percent();
  uint32_t contract_fee_percent() const;
  void set_contract_fee_percent(uint32_t value);
  private:
  uint32_t _internal_contract_fee_percent() const;
  void _internal_set_contract_fee_percent(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.InputTransfers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    uint64_t index_;
    uint32_t fee_percent_;
    uint32_t contract_fee_percent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class OutputTransfers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.OutputTransfers) */ {
 public:
  inline OutputTransfers() : OutputTransfers(nullptr) {}
  ~OutputTransfers() override;
  explicit PROTOBUF_CONSTEXPR OutputTransfers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputTransfers(const OutputTransfers& from);
  OutputTransfers(OutputTransfers&& from) noexcept
    : OutputTransfers() {
    *this = ::std::move(from);
  }

  inline OutputTransfers& operator=(const OutputTransfers& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputTransfers& operator=(OutputTransfers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputTransfers& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputTransfers* internal_default_instance() {
    return reinterpret_cast<const OutputTransfers*>(
               &_OutputTransfers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(OutputTransfers& a, OutputTransfers& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputTransfers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputTransfers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputTransfers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputTransfers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutputTransfers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OutputTransfers& from) {
    OutputTransfers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputTransfers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.OutputTransfers";
  }
  protected:
  explicit OutputTransfers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
    kMemoFieldNumber = 3,
  };
  // bytes wallet_address = 1;
  void clear_wallet_address();
  const std::string& wallet_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wallet_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wallet_address();
  PROTOBUF_NODISCARD std::string* release_wallet_address();
  void set_allocated_wallet_address(std::string* wallet_address);
  private:
  const std::string& _internal_wallet_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet_address(const std::string& value);
  std::string* _internal_mutable_wallet_address();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // optional string memo = 3;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.OutputTransfers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class MintTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.MintTXN) */ {
 public:
  inline MintTXN() : MintTXN(nullptr) {}
  ~MintTXN() override;
  explicit PROTOBUF_CONSTEXPR MintTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MintTXN(const MintTXN& from);
  MintTXN(MintTXN&& from) noexcept
    : MintTXN() {
    *this = ::std::move(from);
  }

  inline MintTXN& operator=(const MintTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline MintTXN& operator=(MintTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MintTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const MintTXN* internal_default_instance() {
    return reinterpret_cast<const MintTXN*>(
               &_MintTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MintTXN& a, MintTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(MintTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MintTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MintTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MintTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MintTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MintTXN& from) {
    MintTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MintTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.MintTXN";
  }
  protected:
  explicit MintTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 2,
    kAmountFieldNumber = 3,
    kRecipientAddressFieldNumber = 4,
    kBaseFieldNumber = 1,
  };
  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string amount = 3;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // bytes recipient_address = 4;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.MintTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class NFTTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.NFTTXN) */ {
 public:
  inline NFTTXN() : NFTTXN(nullptr) {}
  ~NFTTXN() override;
  explicit PROTOBUF_CONSTEXPR NFTTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NFTTXN(const NFTTXN& from);
  NFTTXN(NFTTXN&& from) noexcept
    : NFTTXN() {
    *this = ::std::move(from);
  }

  inline NFTTXN& operator=(const NFTTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline NFTTXN& operator=(NFTTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NFTTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const NFTTXN* internal_default_instance() {
    return reinterpret_cast<const NFTTXN*>(
               &_NFTTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(NFTTXN& a, NFTTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(NFTTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NFTTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NFTTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NFTTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NFTTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NFTTXN& from) {
    NFTTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NFTTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.NFTTXN";
  }
  protected:
  explicit NFTTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 2,
    kItemIdFieldNumber = 3,
    kRecipientAddressFieldNumber = 4,
    kContractFeeAmountFieldNumber = 5,
    kContractFeeIdFieldNumber = 6,
    kBaseFieldNumber = 1,
  };
  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string item_id = 3;
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // bytes recipient_address = 4;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // optional string contract_fee_amount = 5;
  bool has_contract_fee_amount() const;
  private:
  bool _internal_has_contract_fee_amount() const;
  public:
  void clear_contract_fee_amount();
  const std::string& contract_fee_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_fee_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_fee_amount();
  PROTOBUF_NODISCARD std::string* release_contract_fee_amount();
  void set_allocated_contract_fee_amount(std::string* contract_fee_amount);
  private:
  const std::string& _internal_contract_fee_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_fee_amount(const std::string& value);
  std::string* _internal_mutable_contract_fee_amount();
  public:

  // optional string contract_fee_id = 6;
  bool has_contract_fee_id() const;
  private:
  bool _internal_has_contract_fee_id() const;
  public:
  void clear_contract_fee_id();
  const std::string& contract_fee_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_fee_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_fee_id();
  PROTOBUF_NODISCARD std::string* release_contract_fee_id();
  void set_allocated_contract_fee_id(std::string* contract_fee_id);
  private:
  const std::string& _internal_contract_fee_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_fee_id(const std::string& value);
  std::string* _internal_mutable_contract_fee_id();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.NFTTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_fee_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_fee_id_;
    ::zera_txn::BaseTXN* base_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ItemizedMintTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ItemizedMintTXN) */ {
 public:
  inline ItemizedMintTXN() : ItemizedMintTXN(nullptr) {}
  ~ItemizedMintTXN() override;
  explicit PROTOBUF_CONSTEXPR ItemizedMintTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemizedMintTXN(const ItemizedMintTXN& from);
  ItemizedMintTXN(ItemizedMintTXN&& from) noexcept
    : ItemizedMintTXN() {
    *this = ::std::move(from);
  }

  inline ItemizedMintTXN& operator=(const ItemizedMintTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemizedMintTXN& operator=(ItemizedMintTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemizedMintTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemizedMintTXN* internal_default_instance() {
    return reinterpret_cast<const ItemizedMintTXN*>(
               &_ItemizedMintTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ItemizedMintTXN& a, ItemizedMintTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemizedMintTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemizedMintTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemizedMintTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemizedMintTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemizedMintTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemizedMintTXN& from) {
    ItemizedMintTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemizedMintTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ItemizedMintTXN";
  }
  protected:
  explicit ItemizedMintTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 6,
    kContractIdFieldNumber = 2,
    kItemIdFieldNumber = 3,
    kRecipientAddressFieldNumber = 4,
    kVotingWeightFieldNumber = 5,
    kBaseFieldNumber = 1,
    kContractFeesFieldNumber = 8,
    kExpiryFieldNumber = 7,
    kValidFromFieldNumber = 9,
  };
  // repeated .zera_txn.KeyValuePair parameters = 6;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::zera_txn::KeyValuePair* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >*
      mutable_parameters();
  private:
  const ::zera_txn::KeyValuePair& _internal_parameters(int index) const;
  ::zera_txn::KeyValuePair* _internal_add_parameters();
  public:
  const ::zera_txn::KeyValuePair& parameters(int index) const;
  ::zera_txn::KeyValuePair* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >&
      parameters() const;

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string item_id = 3;
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // bytes recipient_address = 4;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // optional string voting_weight = 5;
  bool has_voting_weight() const;
  private:
  bool _internal_has_voting_weight() const;
  public:
  void clear_voting_weight();
  const std::string& voting_weight() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voting_weight(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voting_weight();
  PROTOBUF_NODISCARD std::string* release_voting_weight();
  void set_allocated_voting_weight(std::string* voting_weight);
  private:
  const std::string& _internal_voting_weight() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voting_weight(const std::string& value);
  std::string* _internal_mutable_voting_weight();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // optional .zera_txn.ItemContractFees contract_fees = 8;
  bool has_contract_fees() const;
  private:
  bool _internal_has_contract_fees() const;
  public:
  void clear_contract_fees();
  const ::zera_txn::ItemContractFees& contract_fees() const;
  PROTOBUF_NODISCARD ::zera_txn::ItemContractFees* release_contract_fees();
  ::zera_txn::ItemContractFees* mutable_contract_fees();
  void set_allocated_contract_fees(::zera_txn::ItemContractFees* contract_fees);
  private:
  const ::zera_txn::ItemContractFees& _internal_contract_fees() const;
  ::zera_txn::ItemContractFees* _internal_mutable_contract_fees();
  public:
  void unsafe_arena_set_allocated_contract_fees(
      ::zera_txn::ItemContractFees* contract_fees);
  ::zera_txn::ItemContractFees* unsafe_arena_release_contract_fees();

  // optional uint64 expiry = 7;
  bool has_expiry() const;
  private:
  bool _internal_has_expiry() const;
  public:
  void clear_expiry();
  uint64_t expiry() const;
  void set_expiry(uint64_t value);
  private:
  uint64_t _internal_expiry() const;
  void _internal_set_expiry(uint64_t value);
  public:

  // optional uint64 valid_from = 9;
  bool has_valid_from() const;
  private:
  bool _internal_has_valid_from() const;
  public:
  void clear_valid_from();
  uint64_t valid_from() const;
  void set_valid_from(uint64_t value);
  private:
  uint64_t _internal_valid_from() const;
  void _internal_set_valid_from(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ItemizedMintTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair > parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voting_weight_;
    ::zera_txn::BaseTXN* base_;
    ::zera_txn::ItemContractFees* contract_fees_;
    uint64_t expiry_;
    uint64_t valid_from_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ContractUpdateTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ContractUpdateTXN) */ {
 public:
  inline ContractUpdateTXN() : ContractUpdateTXN(nullptr) {}
  ~ContractUpdateTXN() override;
  explicit PROTOBUF_CONSTEXPR ContractUpdateTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractUpdateTXN(const ContractUpdateTXN& from);
  ContractUpdateTXN(ContractUpdateTXN&& from) noexcept
    : ContractUpdateTXN() {
    *this = ::std::move(from);
  }

  inline ContractUpdateTXN& operator=(const ContractUpdateTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractUpdateTXN& operator=(ContractUpdateTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractUpdateTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractUpdateTXN* internal_default_instance() {
    return reinterpret_cast<const ContractUpdateTXN*>(
               &_ContractUpdateTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ContractUpdateTXN& a, ContractUpdateTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractUpdateTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractUpdateTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractUpdateTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractUpdateTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractUpdateTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractUpdateTXN& from) {
    ContractUpdateTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractUpdateTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ContractUpdateTXN";
  }
  protected:
  explicit ContractUpdateTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRestrictedKeysFieldNumber = 6,
    kCustomParametersFieldNumber = 8,
    kExpenseRatioFieldNumber = 9,
    kTokenComplianceFieldNumber = 10,
    kContractIdFieldNumber = 2,
    kNameFieldNumber = 4,
    kBaseFieldNumber = 1,
    kGovernanceFieldNumber = 5,
    kContractFeesFieldNumber = 7,
    kContractVersionFieldNumber = 3,
    kKycStatusFieldNumber = 11,
    kImmutableKycStatusFieldNumber = 12,
    kQuashThresholdFieldNumber = 13,
  };
  // repeated .zera_txn.RestrictedKey restricted_keys = 6;
  int restricted_keys_size() const;
  private:
  int _internal_restricted_keys_size() const;
  public:
  void clear_restricted_keys();
  ::zera_txn::RestrictedKey* mutable_restricted_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey >*
      mutable_restricted_keys();
  private:
  const ::zera_txn::RestrictedKey& _internal_restricted_keys(int index) const;
  ::zera_txn::RestrictedKey* _internal_add_restricted_keys();
  public:
  const ::zera_txn::RestrictedKey& restricted_keys(int index) const;
  ::zera_txn::RestrictedKey* add_restricted_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey >&
      restricted_keys() const;

  // repeated .zera_txn.KeyValuePair custom_parameters = 8;
  int custom_parameters_size() const;
  private:
  int _internal_custom_parameters_size() const;
  public:
  void clear_custom_parameters();
  ::zera_txn::KeyValuePair* mutable_custom_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >*
      mutable_custom_parameters();
  private:
  const ::zera_txn::KeyValuePair& _internal_custom_parameters(int index) const;
  ::zera_txn::KeyValuePair* _internal_add_custom_parameters();
  public:
  const ::zera_txn::KeyValuePair& custom_parameters(int index) const;
  ::zera_txn::KeyValuePair* add_custom_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >&
      custom_parameters() const;

  // repeated .zera_txn.ExpenseRatio expense_ratio = 9;
  int expense_ratio_size() const;
  private:
  int _internal_expense_ratio_size() const;
  public:
  void clear_expense_ratio();
  ::zera_txn::ExpenseRatio* mutable_expense_ratio(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio >*
      mutable_expense_ratio();
  private:
  const ::zera_txn::ExpenseRatio& _internal_expense_ratio(int index) const;
  ::zera_txn::ExpenseRatio* _internal_add_expense_ratio();
  public:
  const ::zera_txn::ExpenseRatio& expense_ratio(int index) const;
  ::zera_txn::ExpenseRatio* add_expense_ratio();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio >&
      expense_ratio() const;

  // repeated .zera_txn.TokenCompliance token_compliance = 10;
  int token_compliance_size() const;
  private:
  int _internal_token_compliance_size() const;
  public:
  void clear_token_compliance();
  ::zera_txn::TokenCompliance* mutable_token_compliance(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance >*
      mutable_token_compliance();
  private:
  const ::zera_txn::TokenCompliance& _internal_token_compliance(int index) const;
  ::zera_txn::TokenCompliance* _internal_add_token_compliance();
  public:
  const ::zera_txn::TokenCompliance& token_compliance(int index) const;
  ::zera_txn::TokenCompliance* add_token_compliance();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance >&
      token_compliance() const;

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // optional .zera_txn.Governance governance = 5;
  bool has_governance() const;
  private:
  bool _internal_has_governance() const;
  public:
  void clear_governance();
  const ::zera_txn::Governance& governance() const;
  PROTOBUF_NODISCARD ::zera_txn::Governance* release_governance();
  ::zera_txn::Governance* mutable_governance();
  void set_allocated_governance(::zera_txn::Governance* governance);
  private:
  const ::zera_txn::Governance& _internal_governance() const;
  ::zera_txn::Governance* _internal_mutable_governance();
  public:
  void unsafe_arena_set_allocated_governance(
      ::zera_txn::Governance* governance);
  ::zera_txn::Governance* unsafe_arena_release_governance();

  // optional .zera_txn.ContractFees contract_fees = 7;
  bool has_contract_fees() const;
  private:
  bool _internal_has_contract_fees() const;
  public:
  void clear_contract_fees();
  const ::zera_txn::ContractFees& contract_fees() const;
  PROTOBUF_NODISCARD ::zera_txn::ContractFees* release_contract_fees();
  ::zera_txn::ContractFees* mutable_contract_fees();
  void set_allocated_contract_fees(::zera_txn::ContractFees* contract_fees);
  private:
  const ::zera_txn::ContractFees& _internal_contract_fees() const;
  ::zera_txn::ContractFees* _internal_mutable_contract_fees();
  public:
  void unsafe_arena_set_allocated_contract_fees(
      ::zera_txn::ContractFees* contract_fees);
  ::zera_txn::ContractFees* unsafe_arena_release_contract_fees();

  // uint64 contract_version = 3;
  void clear_contract_version();
  uint64_t contract_version() const;
  void set_contract_version(uint64_t value);
  private:
  uint64_t _internal_contract_version() const;
  void _internal_set_contract_version(uint64_t value);
  public:

  // optional bool kyc_status = 11;
  bool has_kyc_status() const;
  private:
  bool _internal_has_kyc_status() const;
  public:
  void clear_kyc_status();
  bool kyc_status() const;
  void set_kyc_status(bool value);
  private:
  bool _internal_kyc_status() const;
  void _internal_set_kyc_status(bool value);
  public:

  // optional bool immutable_kyc_status = 12;
  bool has_immutable_kyc_status() const;
  private:
  bool _internal_has_immutable_kyc_status() const;
  public:
  void clear_immutable_kyc_status();
  bool immutable_kyc_status() const;
  void set_immutable_kyc_status(bool value);
  private:
  bool _internal_immutable_kyc_status() const;
  void _internal_set_immutable_kyc_status(bool value);
  public:

  // optional uint32 quash_threshold = 13;
  bool has_quash_threshold() const;
  private:
  bool _internal_has_quash_threshold() const;
  public:
  void clear_quash_threshold();
  uint32_t quash_threshold() const;
  void set_quash_threshold(uint32_t value);
  private:
  uint32_t _internal_quash_threshold() const;
  void _internal_set_quash_threshold(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ContractUpdateTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey > restricted_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair > custom_parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio > expense_ratio_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance > token_compliance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::zera_txn::BaseTXN* base_;
    ::zera_txn::Governance* governance_;
    ::zera_txn::ContractFees* contract_fees_;
    uint64_t contract_version_;
    bool kyc_status_;
    bool immutable_kyc_status_;
    uint32_t quash_threshold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class InstrumentContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.InstrumentContract) */ {
 public:
  inline InstrumentContract() : InstrumentContract(nullptr) {}
  ~InstrumentContract() override;
  explicit PROTOBUF_CONSTEXPR InstrumentContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstrumentContract(const InstrumentContract& from);
  InstrumentContract(InstrumentContract&& from) noexcept
    : InstrumentContract() {
    *this = ::std::move(from);
  }

  inline InstrumentContract& operator=(const InstrumentContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentContract& operator=(InstrumentContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentContract* internal_default_instance() {
    return reinterpret_cast<const InstrumentContract*>(
               &_InstrumentContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(InstrumentContract& a, InstrumentContract& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstrumentContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstrumentContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstrumentContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstrumentContract& from) {
    InstrumentContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.InstrumentContract";
  }
  protected:
  explicit InstrumentContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRestrictedKeysFieldNumber = 6,
    kPremintWalletsFieldNumber = 9,
    kCustomParametersFieldNumber = 11,
    kExpenseRatioFieldNumber = 13,
    kTokenComplianceFieldNumber = 18,
    kMaxSupplyReleaseFieldNumber = 22,
    kSymbolFieldNumber = 3,
    kNameFieldNumber = 4,
    kMaxSupplyFieldNumber = 7,
    kContractIdFieldNumber = 12,
    kCurEquivStartFieldNumber = 21,
    kBaseFieldNumber = 1,
    kGovernanceFieldNumber = 5,
    kContractFeesFieldNumber = 8,
    kCoinDenominationFieldNumber = 10,
    kContractVersionFieldNumber = 2,
    kTypeFieldNumber = 14,
    kQuashThresholdFieldNumber = 17,
    kUpdateContractFeesFieldNumber = 15,
    kUpdateExpenseRatioFieldNumber = 16,
    kKycStatusFieldNumber = 19,
    kImmutableKycStatusFieldNumber = 20,
  };
  // repeated .zera_txn.RestrictedKey restricted_keys = 6;
  int restricted_keys_size() const;
  private:
  int _internal_restricted_keys_size() const;
  public:
  void clear_restricted_keys();
  ::zera_txn::RestrictedKey* mutable_restricted_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey >*
      mutable_restricted_keys();
  private:
  const ::zera_txn::RestrictedKey& _internal_restricted_keys(int index) const;
  ::zera_txn::RestrictedKey* _internal_add_restricted_keys();
  public:
  const ::zera_txn::RestrictedKey& restricted_keys(int index) const;
  ::zera_txn::RestrictedKey* add_restricted_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey >&
      restricted_keys() const;

  // repeated .zera_txn.PreMintWallet premint_wallets = 9;
  int premint_wallets_size() const;
  private:
  int _internal_premint_wallets_size() const;
  public:
  void clear_premint_wallets();
  ::zera_txn::PreMintWallet* mutable_premint_wallets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PreMintWallet >*
      mutable_premint_wallets();
  private:
  const ::zera_txn::PreMintWallet& _internal_premint_wallets(int index) const;
  ::zera_txn::PreMintWallet* _internal_add_premint_wallets();
  public:
  const ::zera_txn::PreMintWallet& premint_wallets(int index) const;
  ::zera_txn::PreMintWallet* add_premint_wallets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PreMintWallet >&
      premint_wallets() const;

  // repeated .zera_txn.KeyValuePair custom_parameters = 11;
  int custom_parameters_size() const;
  private:
  int _internal_custom_parameters_size() const;
  public:
  void clear_custom_parameters();
  ::zera_txn::KeyValuePair* mutable_custom_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >*
      mutable_custom_parameters();
  private:
  const ::zera_txn::KeyValuePair& _internal_custom_parameters(int index) const;
  ::zera_txn::KeyValuePair* _internal_add_custom_parameters();
  public:
  const ::zera_txn::KeyValuePair& custom_parameters(int index) const;
  ::zera_txn::KeyValuePair* add_custom_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >&
      custom_parameters() const;

  // repeated .zera_txn.ExpenseRatio expense_ratio = 13;
  int expense_ratio_size() const;
  private:
  int _internal_expense_ratio_size() const;
  public:
  void clear_expense_ratio();
  ::zera_txn::ExpenseRatio* mutable_expense_ratio(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio >*
      mutable_expense_ratio();
  private:
  const ::zera_txn::ExpenseRatio& _internal_expense_ratio(int index) const;
  ::zera_txn::ExpenseRatio* _internal_add_expense_ratio();
  public:
  const ::zera_txn::ExpenseRatio& expense_ratio(int index) const;
  ::zera_txn::ExpenseRatio* add_expense_ratio();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio >&
      expense_ratio() const;

  // repeated .zera_txn.TokenCompliance token_compliance = 18;
  int token_compliance_size() const;
  private:
  int _internal_token_compliance_size() const;
  public:
  void clear_token_compliance();
  ::zera_txn::TokenCompliance* mutable_token_compliance(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance >*
      mutable_token_compliance();
  private:
  const ::zera_txn::TokenCompliance& _internal_token_compliance(int index) const;
  ::zera_txn::TokenCompliance* _internal_add_token_compliance();
  public:
  const ::zera_txn::TokenCompliance& token_compliance(int index) const;
  ::zera_txn::TokenCompliance* add_token_compliance();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance >&
      token_compliance() const;

  // repeated .zera_txn.MaxSupplyRelease max_supply_release = 22;
  int max_supply_release_size() const;
  private:
  int _internal_max_supply_release_size() const;
  public:
  void clear_max_supply_release();
  ::zera_txn::MaxSupplyRelease* mutable_max_supply_release(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MaxSupplyRelease >*
      mutable_max_supply_release();
  private:
  const ::zera_txn::MaxSupplyRelease& _internal_max_supply_release(int index) const;
  ::zera_txn::MaxSupplyRelease* _internal_add_max_supply_release();
  public:
  const ::zera_txn::MaxSupplyRelease& max_supply_release(int index) const;
  ::zera_txn::MaxSupplyRelease* add_max_supply_release();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MaxSupplyRelease >&
      max_supply_release() const;

  // string symbol = 3;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string max_supply = 7;
  bool has_max_supply() const;
  private:
  bool _internal_has_max_supply() const;
  public:
  void clear_max_supply();
  const std::string& max_supply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_max_supply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_max_supply();
  PROTOBUF_NODISCARD std::string* release_max_supply();
  void set_allocated_max_supply(std::string* max_supply);
  private:
  const std::string& _internal_max_supply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_supply(const std::string& value);
  std::string* _internal_mutable_max_supply();
  public:

  // string contract_id = 12;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // optional string cur_equiv_start = 21;
  bool has_cur_equiv_start() const;
  private:
  bool _internal_has_cur_equiv_start() const;
  public:
  void clear_cur_equiv_start();
  const std::string& cur_equiv_start() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cur_equiv_start(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cur_equiv_start();
  PROTOBUF_NODISCARD std::string* release_cur_equiv_start();
  void set_allocated_cur_equiv_start(std::string* cur_equiv_start);
  private:
  const std::string& _internal_cur_equiv_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cur_equiv_start(const std::string& value);
  std::string* _internal_mutable_cur_equiv_start();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // optional .zera_txn.Governance governance = 5;
  bool has_governance() const;
  private:
  bool _internal_has_governance() const;
  public:
  void clear_governance();
  const ::zera_txn::Governance& governance() const;
  PROTOBUF_NODISCARD ::zera_txn::Governance* release_governance();
  ::zera_txn::Governance* mutable_governance();
  void set_allocated_governance(::zera_txn::Governance* governance);
  private:
  const ::zera_txn::Governance& _internal_governance() const;
  ::zera_txn::Governance* _internal_mutable_governance();
  public:
  void unsafe_arena_set_allocated_governance(
      ::zera_txn::Governance* governance);
  ::zera_txn::Governance* unsafe_arena_release_governance();

  // optional .zera_txn.ContractFees contract_fees = 8;
  bool has_contract_fees() const;
  private:
  bool _internal_has_contract_fees() const;
  public:
  void clear_contract_fees();
  const ::zera_txn::ContractFees& contract_fees() const;
  PROTOBUF_NODISCARD ::zera_txn::ContractFees* release_contract_fees();
  ::zera_txn::ContractFees* mutable_contract_fees();
  void set_allocated_contract_fees(::zera_txn::ContractFees* contract_fees);
  private:
  const ::zera_txn::ContractFees& _internal_contract_fees() const;
  ::zera_txn::ContractFees* _internal_mutable_contract_fees();
  public:
  void unsafe_arena_set_allocated_contract_fees(
      ::zera_txn::ContractFees* contract_fees);
  ::zera_txn::ContractFees* unsafe_arena_release_contract_fees();

  // optional .zera_txn.CoinDenomination coin_denomination = 10;
  bool has_coin_denomination() const;
  private:
  bool _internal_has_coin_denomination() const;
  public:
  void clear_coin_denomination();
  const ::zera_txn::CoinDenomination& coin_denomination() const;
  PROTOBUF_NODISCARD ::zera_txn::CoinDenomination* release_coin_denomination();
  ::zera_txn::CoinDenomination* mutable_coin_denomination();
  void set_allocated_coin_denomination(::zera_txn::CoinDenomination* coin_denomination);
  private:
  const ::zera_txn::CoinDenomination& _internal_coin_denomination() const;
  ::zera_txn::CoinDenomination* _internal_mutable_coin_denomination();
  public:
  void unsafe_arena_set_allocated_coin_denomination(
      ::zera_txn::CoinDenomination* coin_denomination);
  ::zera_txn::CoinDenomination* unsafe_arena_release_coin_denomination();

  // uint64 contract_version = 2;
  void clear_contract_version();
  uint64_t contract_version() const;
  void set_contract_version(uint64_t value);
  private:
  uint64_t _internal_contract_version() const;
  void _internal_set_contract_version(uint64_t value);
  public:

  // .zera_txn.CONTRACT_TYPE type = 14;
  void clear_type();
  ::zera_txn::CONTRACT_TYPE type() const;
  void set_type(::zera_txn::CONTRACT_TYPE value);
  private:
  ::zera_txn::CONTRACT_TYPE _internal_type() const;
  void _internal_set_type(::zera_txn::CONTRACT_TYPE value);
  public:

  // optional uint32 quash_threshold = 17;
  bool has_quash_threshold() const;
  private:
  bool _internal_has_quash_threshold() const;
  public:
  void clear_quash_threshold();
  uint32_t quash_threshold() const;
  void set_quash_threshold(uint32_t value);
  private:
  uint32_t _internal_quash_threshold() const;
  void _internal_set_quash_threshold(uint32_t value);
  public:

  // bool update_contract_fees = 15;
  void clear_update_contract_fees();
  bool update_contract_fees() const;
  void set_update_contract_fees(bool value);
  private:
  bool _internal_update_contract_fees() const;
  void _internal_set_update_contract_fees(bool value);
  public:

  // bool update_expense_ratio = 16;
  void clear_update_expense_ratio();
  bool update_expense_ratio() const;
  void set_update_expense_ratio(bool value);
  private:
  bool _internal_update_expense_ratio() const;
  void _internal_set_update_expense_ratio(bool value);
  public:

  // bool kyc_status = 19;
  void clear_kyc_status();
  bool kyc_status() const;
  void set_kyc_status(bool value);
  private:
  bool _internal_kyc_status() const;
  void _internal_set_kyc_status(bool value);
  public:

  // bool immutable_kyc_status = 20;
  void clear_immutable_kyc_status();
  bool immutable_kyc_status() const;
  void set_immutable_kyc_status(bool value);
  private:
  bool _internal_immutable_kyc_status() const;
  void _internal_set_immutable_kyc_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.InstrumentContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey > restricted_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PreMintWallet > premint_wallets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair > custom_parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio > expense_ratio_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance > token_compliance_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MaxSupplyRelease > max_supply_release_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_supply_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cur_equiv_start_;
    ::zera_txn::BaseTXN* base_;
    ::zera_txn::Governance* governance_;
    ::zera_txn::ContractFees* contract_fees_;
    ::zera_txn::CoinDenomination* coin_denomination_;
    uint64_t contract_version_;
    int type_;
    uint32_t quash_threshold_;
    bool update_contract_fees_;
    bool update_expense_ratio_;
    bool kyc_status_;
    bool immutable_kyc_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class MaxSupplyRelease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.MaxSupplyRelease) */ {
 public:
  inline MaxSupplyRelease() : MaxSupplyRelease(nullptr) {}
  ~MaxSupplyRelease() override;
  explicit PROTOBUF_CONSTEXPR MaxSupplyRelease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaxSupplyRelease(const MaxSupplyRelease& from);
  MaxSupplyRelease(MaxSupplyRelease&& from) noexcept
    : MaxSupplyRelease() {
    *this = ::std::move(from);
  }

  inline MaxSupplyRelease& operator=(const MaxSupplyRelease& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxSupplyRelease& operator=(MaxSupplyRelease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaxSupplyRelease& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaxSupplyRelease* internal_default_instance() {
    return reinterpret_cast<const MaxSupplyRelease*>(
               &_MaxSupplyRelease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MaxSupplyRelease& a, MaxSupplyRelease& b) {
    a.Swap(&b);
  }
  inline void Swap(MaxSupplyRelease* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxSupplyRelease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaxSupplyRelease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaxSupplyRelease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MaxSupplyRelease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MaxSupplyRelease& from) {
    MaxSupplyRelease::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaxSupplyRelease* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.MaxSupplyRelease";
  }
  protected:
  explicit MaxSupplyRelease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 2,
    kReleaseDateFieldNumber = 1,
  };
  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // .google.protobuf.Timestamp release_date = 1;
  bool has_release_date() const;
  private:
  bool _internal_has_release_date() const;
  public:
  void clear_release_date();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& release_date() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_release_date();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_release_date();
  void set_allocated_release_date(::PROTOBUF_NAMESPACE_ID::Timestamp* release_date);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_release_date() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_release_date();
  public:
  void unsafe_arena_set_allocated_release_date(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_release_date();

  // @@protoc_insertion_point(class_scope:zera_txn.MaxSupplyRelease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class GovernanceVote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.GovernanceVote) */ {
 public:
  inline GovernanceVote() : GovernanceVote(nullptr) {}
  ~GovernanceVote() override;
  explicit PROTOBUF_CONSTEXPR GovernanceVote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GovernanceVote(const GovernanceVote& from);
  GovernanceVote(GovernanceVote&& from) noexcept
    : GovernanceVote() {
    *this = ::std::move(from);
  }

  inline GovernanceVote& operator=(const GovernanceVote& from) {
    CopyFrom(from);
    return *this;
  }
  inline GovernanceVote& operator=(GovernanceVote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GovernanceVote& default_instance() {
    return *internal_default_instance();
  }
  static inline const GovernanceVote* internal_default_instance() {
    return reinterpret_cast<const GovernanceVote*>(
               &_GovernanceVote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(GovernanceVote& a, GovernanceVote& b) {
    a.Swap(&b);
  }
  inline void Swap(GovernanceVote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GovernanceVote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GovernanceVote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GovernanceVote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GovernanceVote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GovernanceVote& from) {
    GovernanceVote::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GovernanceVote* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.GovernanceVote";
  }
  protected:
  explicit GovernanceVote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 2,
    kProposalIdFieldNumber = 3,
    kBaseFieldNumber = 1,
    kSupportFieldNumber = 4,
    kSupportOptionFieldNumber = 5,
  };
  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes proposal_id = 3;
  void clear_proposal_id();
  const std::string& proposal_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proposal_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proposal_id();
  PROTOBUF_NODISCARD std::string* release_proposal_id();
  void set_allocated_proposal_id(std::string* proposal_id);
  private:
  const std::string& _internal_proposal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposal_id(const std::string& value);
  std::string* _internal_mutable_proposal_id();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // optional bool support = 4;
  bool has_support() const;
  private:
  bool _internal_has_support() const;
  public:
  void clear_support();
  bool support() const;
  void set_support(bool value);
  private:
  bool _internal_support() const;
  void _internal_set_support(bool value);
  public:

  // optional uint32 support_option = 5;
  bool has_support_option() const;
  private:
  bool _internal_has_support_option() const;
  public:
  void clear_support_option();
  uint32_t support_option() const;
  void set_support_option(uint32_t value);
  private:
  uint32_t _internal_support_option() const;
  void _internal_set_support_option(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.GovernanceVote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposal_id_;
    ::zera_txn::BaseTXN* base_;
    bool support_;
    uint32_t support_option_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class GovernanceProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.GovernanceProposal) */ {
 public:
  inline GovernanceProposal() : GovernanceProposal(nullptr) {}
  ~GovernanceProposal() override;
  explicit PROTOBUF_CONSTEXPR GovernanceProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GovernanceProposal(const GovernanceProposal& from);
  GovernanceProposal(GovernanceProposal&& from) noexcept
    : GovernanceProposal() {
    *this = ::std::move(from);
  }

  inline GovernanceProposal& operator=(const GovernanceProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline GovernanceProposal& operator=(GovernanceProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GovernanceProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const GovernanceProposal* internal_default_instance() {
    return reinterpret_cast<const GovernanceProposal*>(
               &_GovernanceProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(GovernanceProposal& a, GovernanceProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(GovernanceProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GovernanceProposal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GovernanceProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GovernanceProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GovernanceProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GovernanceProposal& from) {
    GovernanceProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GovernanceProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.GovernanceProposal";
  }
  protected:
  explicit GovernanceProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 6,
    kGovernanceTxnFieldNumber = 9,
    kContractIdFieldNumber = 2,
    kTitleFieldNumber = 3,
    kSynopsisFieldNumber = 4,
    kBodyFieldNumber = 5,
    kBaseFieldNumber = 1,
    kStartTimestampFieldNumber = 7,
    kEndTimestampFieldNumber = 8,
  };
  // repeated string options = 6;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  const std::string& options(int index) const;
  std::string* mutable_options(int index);
  void set_options(int index, const std::string& value);
  void set_options(int index, std::string&& value);
  void set_options(int index, const char* value);
  void set_options(int index, const char* value, size_t size);
  std::string* add_options();
  void add_options(const std::string& value);
  void add_options(std::string&& value);
  void add_options(const char* value);
  void add_options(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_options();
  private:
  const std::string& _internal_options(int index) const;
  std::string* _internal_add_options();
  public:

  // repeated .zera_txn.GovernanceTXN governance_txn = 9;
  int governance_txn_size() const;
  private:
  int _internal_governance_txn_size() const;
  public:
  void clear_governance_txn();
  ::zera_txn::GovernanceTXN* mutable_governance_txn(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN >*
      mutable_governance_txn();
  private:
  const ::zera_txn::GovernanceTXN& _internal_governance_txn(int index) const;
  ::zera_txn::GovernanceTXN* _internal_add_governance_txn();
  public:
  const ::zera_txn::GovernanceTXN& governance_txn(int index) const;
  ::zera_txn::GovernanceTXN* add_governance_txn();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN >&
      governance_txn() const;

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string synopsis = 4;
  void clear_synopsis();
  const std::string& synopsis() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_synopsis(ArgT0&& arg0, ArgT... args);
  std::string* mutable_synopsis();
  PROTOBUF_NODISCARD std::string* release_synopsis();
  void set_allocated_synopsis(std::string* synopsis);
  private:
  const std::string& _internal_synopsis() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_synopsis(const std::string& value);
  std::string* _internal_mutable_synopsis();
  public:

  // string body = 5;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // optional .google.protobuf.Timestamp start_timestamp = 7;
  bool has_start_timestamp() const;
  private:
  bool _internal_has_start_timestamp() const;
  public:
  void clear_start_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_timestamp();
  void set_allocated_start_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_timestamp();
  public:
  void unsafe_arena_set_allocated_start_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_timestamp();

  // optional .google.protobuf.Timestamp end_timestamp = 8;
  bool has_end_timestamp() const;
  private:
  bool _internal_has_end_timestamp() const;
  public:
  void clear_end_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_timestamp();
  void set_allocated_end_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* end_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_timestamp();
  public:
  void unsafe_arena_set_allocated_end_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_timestamp();

  // @@protoc_insertion_point(class_scope:zera_txn.GovernanceProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> options_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN > governance_txn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr synopsis_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    ::zera_txn::BaseTXN* base_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class GovernanceTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.GovernanceTXN) */ {
 public:
  inline GovernanceTXN() : GovernanceTXN(nullptr) {}
  ~GovernanceTXN() override;
  explicit PROTOBUF_CONSTEXPR GovernanceTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GovernanceTXN(const GovernanceTXN& from);
  GovernanceTXN(GovernanceTXN&& from) noexcept
    : GovernanceTXN() {
    *this = ::std::move(from);
  }

  inline GovernanceTXN& operator=(const GovernanceTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline GovernanceTXN& operator=(GovernanceTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GovernanceTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const GovernanceTXN* internal_default_instance() {
    return reinterpret_cast<const GovernanceTXN*>(
               &_GovernanceTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GovernanceTXN& a, GovernanceTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(GovernanceTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GovernanceTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GovernanceTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GovernanceTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GovernanceTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GovernanceTXN& from) {
    GovernanceTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GovernanceTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.GovernanceTXN";
  }
  protected:
  explicit GovernanceTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedTxnFieldNumber = 2,
    kTxnHashFieldNumber = 3,
    kTxnTypeFieldNumber = 1,
  };
  // bytes serialized_txn = 2;
  void clear_serialized_txn();
  const std::string& serialized_txn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_txn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_txn();
  PROTOBUF_NODISCARD std::string* release_serialized_txn();
  void set_allocated_serialized_txn(std::string* serialized_txn);
  private:
  const std::string& _internal_serialized_txn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_txn(const std::string& value);
  std::string* _internal_mutable_serialized_txn();
  public:

  // bytes txn_hash = 3;
  void clear_txn_hash();
  const std::string& txn_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txn_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txn_hash();
  PROTOBUF_NODISCARD std::string* release_txn_hash();
  void set_allocated_txn_hash(std::string* txn_hash);
  private:
  const std::string& _internal_txn_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txn_hash(const std::string& value);
  std::string* _internal_mutable_txn_hash();
  public:

  // .zera_txn.TRANSACTION_TYPE txn_type = 1;
  void clear_txn_type();
  ::zera_txn::TRANSACTION_TYPE txn_type() const;
  void set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  private:
  ::zera_txn::TRANSACTION_TYPE _internal_txn_type() const;
  void _internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.GovernanceTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_txn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txn_hash_;
    int txn_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class SmartContractTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.SmartContractTXN) */ {
 public:
  inline SmartContractTXN() : SmartContractTXN(nullptr) {}
  ~SmartContractTXN() override;
  explicit PROTOBUF_CONSTEXPR SmartContractTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContractTXN(const SmartContractTXN& from);
  SmartContractTXN(SmartContractTXN&& from) noexcept
    : SmartContractTXN() {
    *this = ::std::move(from);
  }

  inline SmartContractTXN& operator=(const SmartContractTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContractTXN& operator=(SmartContractTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContractTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContractTXN* internal_default_instance() {
    return reinterpret_cast<const SmartContractTXN*>(
               &_SmartContractTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(SmartContractTXN& a, SmartContractTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContractTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContractTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContractTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContractTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartContractTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmartContractTXN& from) {
    SmartContractTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContractTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.SmartContractTXN";
  }
  protected:
  explicit SmartContractTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionsFieldNumber = 5,
    kBinaryCodeFieldNumber = 2,
    kSmartContractNameFieldNumber = 4,
    kSourceCodeFieldNumber = 7,
    kBaseFieldNumber = 1,
    kLanguageFieldNumber = 3,
  };
  // repeated string functions = 5;
  int functions_size() const;
  private:
  int _internal_functions_size() const;
  public:
  void clear_functions();
  const std::string& functions(int index) const;
  std::string* mutable_functions(int index);
  void set_functions(int index, const std::string& value);
  void set_functions(int index, std::string&& value);
  void set_functions(int index, const char* value);
  void set_functions(int index, const char* value, size_t size);
  std::string* add_functions();
  void add_functions(const std::string& value);
  void add_functions(std::string&& value);
  void add_functions(const char* value);
  void add_functions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_functions();
  private:
  const std::string& _internal_functions(int index) const;
  std::string* _internal_add_functions();
  public:

  // bytes binary_code = 2;
  void clear_binary_code();
  const std::string& binary_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_code();
  PROTOBUF_NODISCARD std::string* release_binary_code();
  void set_allocated_binary_code(std::string* binary_code);
  private:
  const std::string& _internal_binary_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_code(const std::string& value);
  std::string* _internal_mutable_binary_code();
  public:

  // string smart_contract_name = 4;
  void clear_smart_contract_name();
  const std::string& smart_contract_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smart_contract_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smart_contract_name();
  PROTOBUF_NODISCARD std::string* release_smart_contract_name();
  void set_allocated_smart_contract_name(std::string* smart_contract_name);
  private:
  const std::string& _internal_smart_contract_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smart_contract_name(const std::string& value);
  std::string* _internal_mutable_smart_contract_name();
  public:

  // bytes source_code = 7;
  void clear_source_code();
  const std::string& source_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_code();
  PROTOBUF_NODISCARD std::string* release_source_code();
  void set_allocated_source_code(std::string* source_code);
  private:
  const std::string& _internal_source_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_code(const std::string& value);
  std::string* _internal_mutable_source_code();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // .zera_txn.LANGUAGE language = 3;
  void clear_language();
  ::zera_txn::LANGUAGE language() const;
  void set_language(::zera_txn::LANGUAGE value);
  private:
  ::zera_txn::LANGUAGE _internal_language() const;
  void _internal_set_language(::zera_txn::LANGUAGE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.SmartContractTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> functions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smart_contract_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_code_;
    ::zera_txn::BaseTXN* base_;
    int language_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Parameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Parameters) */ {
 public:
  inline Parameters() : Parameters(nullptr) {}
  ~Parameters() override;
  explicit PROTOBUF_CONSTEXPR Parameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Parameters(const Parameters& from);
  Parameters(Parameters&& from) noexcept
    : Parameters() {
    *this = ::std::move(from);
  }

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline Parameters& operator=(Parameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Parameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const Parameters* internal_default_instance() {
    return reinterpret_cast<const Parameters*>(
               &_Parameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Parameters& a, Parameters& b) {
    a.Swap(&b);
  }
  inline void Swap(Parameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Parameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Parameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Parameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Parameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Parameters& from) {
    Parameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Parameters";
  }
  protected:
  explicit Parameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.Parameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class SmartContractExecuteTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.SmartContractExecuteTXN) */ {
 public:
  inline SmartContractExecuteTXN() : SmartContractExecuteTXN(nullptr) {}
  ~SmartContractExecuteTXN() override;
  explicit PROTOBUF_CONSTEXPR SmartContractExecuteTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContractExecuteTXN(const SmartContractExecuteTXN& from);
  SmartContractExecuteTXN(SmartContractExecuteTXN&& from) noexcept
    : SmartContractExecuteTXN() {
    *this = ::std::move(from);
  }

  inline SmartContractExecuteTXN& operator=(const SmartContractExecuteTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContractExecuteTXN& operator=(SmartContractExecuteTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContractExecuteTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContractExecuteTXN* internal_default_instance() {
    return reinterpret_cast<const SmartContractExecuteTXN*>(
               &_SmartContractExecuteTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(SmartContractExecuteTXN& a, SmartContractExecuteTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContractExecuteTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContractExecuteTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContractExecuteTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContractExecuteTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartContractExecuteTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmartContractExecuteTXN& from) {
    SmartContractExecuteTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContractExecuteTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.SmartContractExecuteTXN";
  }
  protected:
  explicit SmartContractExecuteTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 5,
    kSmartContractNameFieldNumber = 2,
    kFunctionFieldNumber = 4,
    kBaseFieldNumber = 1,
    kInstanceFieldNumber = 3,
  };
  // repeated .zera_txn.Parameters parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::zera_txn::Parameters* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters >*
      mutable_parameters();
  private:
  const ::zera_txn::Parameters& _internal_parameters(int index) const;
  ::zera_txn::Parameters* _internal_add_parameters();
  public:
  const ::zera_txn::Parameters& parameters(int index) const;
  ::zera_txn::Parameters* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters >&
      parameters() const;

  // string smart_contract_name = 2;
  void clear_smart_contract_name();
  const std::string& smart_contract_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smart_contract_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smart_contract_name();
  PROTOBUF_NODISCARD std::string* release_smart_contract_name();
  void set_allocated_smart_contract_name(std::string* smart_contract_name);
  private:
  const std::string& _internal_smart_contract_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smart_contract_name(const std::string& value);
  std::string* _internal_mutable_smart_contract_name();
  public:

  // string function = 4;
  void clear_function();
  const std::string& function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function();
  PROTOBUF_NODISCARD std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // uint32 instance = 3;
  void clear_instance();
  uint32_t instance() const;
  void set_instance(uint32_t value);
  private:
  uint32_t _internal_instance() const;
  void _internal_set_instance(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.SmartContractExecuteTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters > parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smart_contract_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
    ::zera_txn::BaseTXN* base_;
    uint32_t instance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class SmartContractInstantiateTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.SmartContractInstantiateTXN) */ {
 public:
  inline SmartContractInstantiateTXN() : SmartContractInstantiateTXN(nullptr) {}
  ~SmartContractInstantiateTXN() override;
  explicit PROTOBUF_CONSTEXPR SmartContractInstantiateTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContractInstantiateTXN(const SmartContractInstantiateTXN& from);
  SmartContractInstantiateTXN(SmartContractInstantiateTXN&& from) noexcept
    : SmartContractInstantiateTXN() {
    *this = ::std::move(from);
  }

  inline SmartContractInstantiateTXN& operator=(const SmartContractInstantiateTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContractInstantiateTXN& operator=(SmartContractInstantiateTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContractInstantiateTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContractInstantiateTXN* internal_default_instance() {
    return reinterpret_cast<const SmartContractInstantiateTXN*>(
               &_SmartContractInstantiateTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(SmartContractInstantiateTXN& a, SmartContractInstantiateTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContractInstantiateTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContractInstantiateTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContractInstantiateTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContractInstantiateTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartContractInstantiateTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmartContractInstantiateTXN& from) {
    SmartContractInstantiateTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContractInstantiateTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.SmartContractInstantiateTXN";
  }
  protected:
  explicit SmartContractInstantiateTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kSmartContractNameFieldNumber = 2,
    kBaseFieldNumber = 1,
    kInstanceFieldNumber = 3,
  };
  // repeated .zera_txn.Parameters parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::zera_txn::Parameters* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters >*
      mutable_parameters();
  private:
  const ::zera_txn::Parameters& _internal_parameters(int index) const;
  ::zera_txn::Parameters* _internal_add_parameters();
  public:
  const ::zera_txn::Parameters& parameters(int index) const;
  ::zera_txn::Parameters* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters >&
      parameters() const;

  // string smart_contract_name = 2;
  void clear_smart_contract_name();
  const std::string& smart_contract_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smart_contract_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smart_contract_name();
  PROTOBUF_NODISCARD std::string* release_smart_contract_name();
  void set_allocated_smart_contract_name(std::string* smart_contract_name);
  private:
  const std::string& _internal_smart_contract_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smart_contract_name(const std::string& value);
  std::string* _internal_mutable_smart_contract_name();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // uint32 instance = 3;
  void clear_instance();
  uint32_t instance() const;
  void set_instance(uint32_t value);
  private:
  uint32_t _internal_instance() const;
  void _internal_set_instance(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.SmartContractInstantiateTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters > parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smart_contract_name_;
    ::zera_txn::BaseTXN* base_;
    uint32_t instance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Validator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Validator) */ {
 public:
  inline Validator() : Validator(nullptr) {}
  ~Validator() override;
  explicit PROTOBUF_CONSTEXPR Validator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Validator(const Validator& from);
  Validator(Validator&& from) noexcept
    : Validator() {
    *this = ::std::move(from);
  }

  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Validator& operator=(Validator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Validator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
               &_Validator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(Validator& a, Validator& b) {
    a.Swap(&b);
  }
  inline void Swap(Validator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Validator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Validator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Validator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Validator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Validator& from) {
    Validator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Validator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Validator";
  }
  protected:
  explicit Validator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStakedContractIdsFieldNumber = 5,
    kHostFieldNumber = 2,
    kClientPortFieldNumber = 3,
    kValidatorPortFieldNumber = 4,
    kPublicKeyFieldNumber = 1,
    kTimestampFieldNumber = 7,
    kBenchmarkFieldNumber = 6,
    kLiteFieldNumber = 8,
    kOnlineFieldNumber = 9,
    kVersionFieldNumber = 10,
    kLastHeartbeatFieldNumber = 11,
  };
  // repeated string staked_contract_ids = 5;
  int staked_contract_ids_size() const;
  private:
  int _internal_staked_contract_ids_size() const;
  public:
  void clear_staked_contract_ids();
  const std::string& staked_contract_ids(int index) const;
  std::string* mutable_staked_contract_ids(int index);
  void set_staked_contract_ids(int index, const std::string& value);
  void set_staked_contract_ids(int index, std::string&& value);
  void set_staked_contract_ids(int index, const char* value);
  void set_staked_contract_ids(int index, const char* value, size_t size);
  std::string* add_staked_contract_ids();
  void add_staked_contract_ids(const std::string& value);
  void add_staked_contract_ids(std::string&& value);
  void add_staked_contract_ids(const char* value);
  void add_staked_contract_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& staked_contract_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_staked_contract_ids();
  private:
  const std::string& _internal_staked_contract_ids(int index) const;
  std::string* _internal_add_staked_contract_ids();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string client_port = 3;
  void clear_client_port();
  const std::string& client_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_port();
  PROTOBUF_NODISCARD std::string* release_client_port();
  void set_allocated_client_port(std::string* client_port);
  private:
  const std::string& _internal_client_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_port(const std::string& value);
  std::string* _internal_mutable_client_port();
  public:

  // string validator_port = 4;
  void clear_validator_port();
  const std::string& validator_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_validator_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_validator_port();
  PROTOBUF_NODISCARD std::string* release_validator_port();
  void set_allocated_validator_port(std::string* validator_port);
  private:
  const std::string& _internal_validator_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_port(const std::string& value);
  std::string* _internal_mutable_validator_port();
  public:

  // .zera_txn.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::zera_txn::PublicKey& public_key() const;
  PROTOBUF_NODISCARD ::zera_txn::PublicKey* release_public_key();
  ::zera_txn::PublicKey* mutable_public_key();
  void set_allocated_public_key(::zera_txn::PublicKey* public_key);
  private:
  const ::zera_txn::PublicKey& _internal_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::zera_txn::PublicKey* public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_public_key();

  // .google.protobuf.Timestamp timestamp = 7;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint64 benchmark = 6;
  void clear_benchmark();
  uint64_t benchmark() const;
  void set_benchmark(uint64_t value);
  private:
  uint64_t _internal_benchmark() const;
  void _internal_set_benchmark(uint64_t value);
  public:

  // bool lite = 8;
  void clear_lite();
  bool lite() const;
  void set_lite(bool value);
  private:
  bool _internal_lite() const;
  void _internal_set_lite(bool value);
  public:

  // bool online = 9;
  void clear_online();
  bool online() const;
  void set_online(bool value);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);
  public:

  // uint32 version = 10;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // uint64 last_heartbeat = 11;
  void clear_last_heartbeat();
  uint64_t last_heartbeat() const;
  void set_last_heartbeat(uint64_t value);
  private:
  uint64_t _internal_last_heartbeat() const;
  void _internal_set_last_heartbeat(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.Validator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> staked_contract_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_port_;
    ::zera_txn::PublicKey* public_key_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    uint64_t benchmark_;
    bool lite_;
    bool online_;
    uint32_t version_;
    uint64_t last_heartbeat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ValidatorRegistration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ValidatorRegistration) */ {
 public:
  inline ValidatorRegistration() : ValidatorRegistration(nullptr) {}
  ~ValidatorRegistration() override;
  explicit PROTOBUF_CONSTEXPR ValidatorRegistration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorRegistration(const ValidatorRegistration& from);
  ValidatorRegistration(ValidatorRegistration&& from) noexcept
    : ValidatorRegistration() {
    *this = ::std::move(from);
  }

  inline ValidatorRegistration& operator=(const ValidatorRegistration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorRegistration& operator=(ValidatorRegistration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorRegistration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorRegistration* internal_default_instance() {
    return reinterpret_cast<const ValidatorRegistration*>(
               &_ValidatorRegistration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ValidatorRegistration& a, ValidatorRegistration& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorRegistration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorRegistration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorRegistration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorRegistration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorRegistration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorRegistration& from) {
    ValidatorRegistration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorRegistration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ValidatorRegistration";
  }
  protected:
  explicit ValidatorRegistration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeneratedSignatureFieldNumber = 5,
    kBaseFieldNumber = 1,
    kValidatorFieldNumber = 2,
    kGeneratedPublicKeyFieldNumber = 4,
    kRegisterFieldNumber = 3,
  };
  // bytes generated_signature = 5;
  void clear_generated_signature();
  const std::string& generated_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_generated_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_generated_signature();
  PROTOBUF_NODISCARD std::string* release_generated_signature();
  void set_allocated_generated_signature(std::string* generated_signature);
  private:
  const std::string& _internal_generated_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_generated_signature(const std::string& value);
  std::string* _internal_mutable_generated_signature();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // .zera_txn.Validator validator = 2;
  bool has_validator() const;
  private:
  bool _internal_has_validator() const;
  public:
  void clear_validator();
  const ::zera_txn::Validator& validator() const;
  PROTOBUF_NODISCARD ::zera_txn::Validator* release_validator();
  ::zera_txn::Validator* mutable_validator();
  void set_allocated_validator(::zera_txn::Validator* validator);
  private:
  const ::zera_txn::Validator& _internal_validator() const;
  ::zera_txn::Validator* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::zera_txn::Validator* validator);
  ::zera_txn::Validator* unsafe_arena_release_validator();

  // .zera_txn.PublicKey generated_public_key = 4;
  bool has_generated_public_key() const;
  private:
  bool _internal_has_generated_public_key() const;
  public:
  void clear_generated_public_key();
  const ::zera_txn::PublicKey& generated_public_key() const;
  PROTOBUF_NODISCARD ::zera_txn::PublicKey* release_generated_public_key();
  ::zera_txn::PublicKey* mutable_generated_public_key();
  void set_allocated_generated_public_key(::zera_txn::PublicKey* generated_public_key);
  private:
  const ::zera_txn::PublicKey& _internal_generated_public_key() const;
  ::zera_txn::PublicKey* _internal_mutable_generated_public_key();
  public:
  void unsafe_arena_set_allocated_generated_public_key(
      ::zera_txn::PublicKey* generated_public_key);
  ::zera_txn::PublicKey* unsafe_arena_release_generated_public_key();

  // bool register = 3;
  void clear_register_();
  bool register_() const;
  void set_register_(bool value);
  private:
  bool _internal_register_() const;
  void _internal_set_register_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ValidatorRegistration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr generated_signature_;
    ::zera_txn::BaseTXN* base_;
    ::zera_txn::Validator* validator_;
    ::zera_txn::PublicKey* generated_public_key_;
    bool register__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ValidatorHeartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ValidatorHeartbeat) */ {
 public:
  inline ValidatorHeartbeat() : ValidatorHeartbeat(nullptr) {}
  ~ValidatorHeartbeat() override;
  explicit PROTOBUF_CONSTEXPR ValidatorHeartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorHeartbeat(const ValidatorHeartbeat& from);
  ValidatorHeartbeat(ValidatorHeartbeat&& from) noexcept
    : ValidatorHeartbeat() {
    *this = ::std::move(from);
  }

  inline ValidatorHeartbeat& operator=(const ValidatorHeartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorHeartbeat& operator=(ValidatorHeartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorHeartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorHeartbeat* internal_default_instance() {
    return reinterpret_cast<const ValidatorHeartbeat*>(
               &_ValidatorHeartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ValidatorHeartbeat& a, ValidatorHeartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorHeartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorHeartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorHeartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorHeartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorHeartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorHeartbeat& from) {
    ValidatorHeartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorHeartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ValidatorHeartbeat";
  }
  protected:
  explicit ValidatorHeartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kOnlineFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // bool online = 2;
  void clear_online();
  bool online() const;
  void set_online(bool value);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);
  public:

  // uint32 version = 3;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ValidatorHeartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::zera_txn::BaseTXN* base_;
    bool online_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class SmartContractParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.SmartContractParameter) */ {
 public:
  inline SmartContractParameter() : SmartContractParameter(nullptr) {}
  ~SmartContractParameter() override;
  explicit PROTOBUF_CONSTEXPR SmartContractParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContractParameter(const SmartContractParameter& from);
  SmartContractParameter(SmartContractParameter&& from) noexcept
    : SmartContractParameter() {
    *this = ::std::move(from);
  }

  inline SmartContractParameter& operator=(const SmartContractParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContractParameter& operator=(SmartContractParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContractParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContractParameter* internal_default_instance() {
    return reinterpret_cast<const SmartContractParameter*>(
               &_SmartContractParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(SmartContractParameter& a, SmartContractParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContractParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContractParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContractParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContractParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartContractParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmartContractParameter& from) {
    SmartContractParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContractParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.SmartContractParameter";
  }
  protected:
  explicit SmartContractParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kIndexFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // .zera_txn.VARIABLE_TYPE type = 2;
  void clear_type();
  ::zera_txn::VARIABLE_TYPE type() const;
  void set_type(::zera_txn::VARIABLE_TYPE value);
  private:
  ::zera_txn::VARIABLE_TYPE _internal_type() const;
  void _internal_set_type(::zera_txn::VARIABLE_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.SmartContractParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    uint32_t index_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Votes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Votes) */ {
 public:
  inline Votes() : Votes(nullptr) {}
  ~Votes() override;
  explicit PROTOBUF_CONSTEXPR Votes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Votes(const Votes& from);
  Votes(Votes&& from) noexcept
    : Votes() {
    *this = ::std::move(from);
  }

  inline Votes& operator=(const Votes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Votes& operator=(Votes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Votes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Votes* internal_default_instance() {
    return reinterpret_cast<const Votes*>(
               &_Votes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(Votes& a, Votes& b) {
    a.Swap(&b);
  }
  inline void Swap(Votes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Votes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Votes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Votes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Votes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Votes& from) {
    Votes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Votes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Votes";
  }
  protected:
  explicit Votes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVotesFieldNumber = 1,
  };
  // repeated .zera_txn.VotePair votes = 1;
  int votes_size() const;
  private:
  int _internal_votes_size() const;
  public:
  void clear_votes();
  ::zera_txn::VotePair* mutable_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::VotePair >*
      mutable_votes();
  private:
  const ::zera_txn::VotePair& _internal_votes(int index) const;
  ::zera_txn::VotePair* _internal_add_votes();
  public:
  const ::zera_txn::VotePair& votes(int index) const;
  ::zera_txn::VotePair* add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::VotePair >&
      votes() const;

  // @@protoc_insertion_point(class_scope:zera_txn.Votes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::VotePair > votes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class VotePair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.VotePair) */ {
 public:
  inline VotePair() : VotePair(nullptr) {}
  ~VotePair() override;
  explicit PROTOBUF_CONSTEXPR VotePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VotePair(const VotePair& from);
  VotePair(VotePair&& from) noexcept
    : VotePair() {
    *this = ::std::move(from);
  }

  inline VotePair& operator=(const VotePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline VotePair& operator=(VotePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VotePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const VotePair* internal_default_instance() {
    return reinterpret_cast<const VotePair*>(
               &_VotePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(VotePair& a, VotePair& b) {
    a.Swap(&b);
  }
  inline void Swap(VotePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VotePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VotePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VotePair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VotePair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VotePair& from) {
    VotePair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VotePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.VotePair";
  }
  protected:
  explicit VotePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.VotePair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class RequiredVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.RequiredVersion) */ {
 public:
  inline RequiredVersion() : RequiredVersion(nullptr) {}
  ~RequiredVersion() override;
  explicit PROTOBUF_CONSTEXPR RequiredVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequiredVersion(const RequiredVersion& from);
  RequiredVersion(RequiredVersion&& from) noexcept
    : RequiredVersion() {
    *this = ::std::move(from);
  }

  inline RequiredVersion& operator=(const RequiredVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequiredVersion& operator=(RequiredVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequiredVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequiredVersion* internal_default_instance() {
    return reinterpret_cast<const RequiredVersion*>(
               &_RequiredVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(RequiredVersion& a, RequiredVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(RequiredVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequiredVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequiredVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequiredVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequiredVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequiredVersion& from) {
    RequiredVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequiredVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.RequiredVersion";
  }
  protected:
  explicit RequiredVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kBaseFieldNumber = 1,
  };
  // repeated uint32 version = 2;
  int version_size() const;
  private:
  int _internal_version_size() const;
  public:
  void clear_version();
  private:
  uint32_t _internal_version(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_version() const;
  void _internal_add_version(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_version();
  public:
  uint32_t version(int index) const;
  void set_version(int index, uint32_t value);
  void add_version(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      version() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_version();

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // @@protoc_insertion_point(class_scope:zera_txn.RequiredVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > version_;
    mutable std::atomic<int> _version_cached_byte_size_;
    ::zera_txn::BaseTXN* base_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ProposalResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ProposalResult) */ {
 public:
  inline ProposalResult() : ProposalResult(nullptr) {}
  ~ProposalResult() override;
  explicit PROTOBUF_CONSTEXPR ProposalResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProposalResult(const ProposalResult& from);
  ProposalResult(ProposalResult&& from) noexcept
    : ProposalResult() {
    *this = ::std::move(from);
  }

  inline ProposalResult& operator=(const ProposalResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalResult& operator=(ProposalResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalResult* internal_default_instance() {
    return reinterpret_cast<const ProposalResult*>(
               &_ProposalResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ProposalResult& a, ProposalResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProposalResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProposalResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProposalResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProposalResult& from) {
    ProposalResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ProposalResult";
  }
  protected:
  explicit ProposalResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionCurEquivFieldNumber = 6,
    kOptionVotesFieldNumber = 9,
    kContractIdFieldNumber = 2,
    kProposalIdFieldNumber = 3,
    kSupportCurEquivFieldNumber = 4,
    kAgainstCurEquivFieldNumber = 5,
    kBaseFieldNumber = 1,
    kSupportVotesFieldNumber = 7,
    kAgainstVotesFieldNumber = 8,
    kStageFieldNumber = 12,
    kPassedFieldNumber = 10,
    kFinalStageFieldNumber = 11,
    kFastQuorumFieldNumber = 13,
    kProposalCutFieldNumber = 14,
  };
  // repeated string option_cur_equiv = 6;
  int option_cur_equiv_size() const;
  private:
  int _internal_option_cur_equiv_size() const;
  public:
  void clear_option_cur_equiv();
  const std::string& option_cur_equiv(int index) const;
  std::string* mutable_option_cur_equiv(int index);
  void set_option_cur_equiv(int index, const std::string& value);
  void set_option_cur_equiv(int index, std::string&& value);
  void set_option_cur_equiv(int index, const char* value);
  void set_option_cur_equiv(int index, const char* value, size_t size);
  std::string* add_option_cur_equiv();
  void add_option_cur_equiv(const std::string& value);
  void add_option_cur_equiv(std::string&& value);
  void add_option_cur_equiv(const char* value);
  void add_option_cur_equiv(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& option_cur_equiv() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_option_cur_equiv();
  private:
  const std::string& _internal_option_cur_equiv(int index) const;
  std::string* _internal_add_option_cur_equiv();
  public:

  // repeated .zera_txn.Votes option_votes = 9;
  int option_votes_size() const;
  private:
  int _internal_option_votes_size() const;
  public:
  void clear_option_votes();
  ::zera_txn::Votes* mutable_option_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Votes >*
      mutable_option_votes();
  private:
  const ::zera_txn::Votes& _internal_option_votes(int index) const;
  ::zera_txn::Votes* _internal_add_option_votes();
  public:
  const ::zera_txn::Votes& option_votes(int index) const;
  ::zera_txn::Votes* add_option_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Votes >&
      option_votes() const;

  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes proposal_id = 3;
  void clear_proposal_id();
  const std::string& proposal_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proposal_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proposal_id();
  PROTOBUF_NODISCARD std::string* release_proposal_id();
  void set_allocated_proposal_id(std::string* proposal_id);
  private:
  const std::string& _internal_proposal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposal_id(const std::string& value);
  std::string* _internal_mutable_proposal_id();
  public:

  // optional string support_cur_equiv = 4;
  bool has_support_cur_equiv() const;
  private:
  bool _internal_has_support_cur_equiv() const;
  public:
  void clear_support_cur_equiv();
  const std::string& support_cur_equiv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_support_cur_equiv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_support_cur_equiv();
  PROTOBUF_NODISCARD std::string* release_support_cur_equiv();
  void set_allocated_support_cur_equiv(std::string* support_cur_equiv);
  private:
  const std::string& _internal_support_cur_equiv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_support_cur_equiv(const std::string& value);
  std::string* _internal_mutable_support_cur_equiv();
  public:

  // optional string against_cur_equiv = 5;
  bool has_against_cur_equiv() const;
  private:
  bool _internal_has_against_cur_equiv() const;
  public:
  void clear_against_cur_equiv();
  const std::string& against_cur_equiv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_against_cur_equiv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_against_cur_equiv();
  PROTOBUF_NODISCARD std::string* release_against_cur_equiv();
  void set_allocated_against_cur_equiv(std::string* against_cur_equiv);
  private:
  const std::string& _internal_against_cur_equiv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_against_cur_equiv(const std::string& value);
  std::string* _internal_mutable_against_cur_equiv();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // optional .zera_txn.Votes support_votes = 7;
  bool has_support_votes() const;
  private:
  bool _internal_has_support_votes() const;
  public:
  void clear_support_votes();
  const ::zera_txn::Votes& support_votes() const;
  PROTOBUF_NODISCARD ::zera_txn::Votes* release_support_votes();
  ::zera_txn::Votes* mutable_support_votes();
  void set_allocated_support_votes(::zera_txn::Votes* support_votes);
  private:
  const ::zera_txn::Votes& _internal_support_votes() const;
  ::zera_txn::Votes* _internal_mutable_support_votes();
  public:
  void unsafe_arena_set_allocated_support_votes(
      ::zera_txn::Votes* support_votes);
  ::zera_txn::Votes* unsafe_arena_release_support_votes();

  // optional .zera_txn.Votes against_votes = 8;
  bool has_against_votes() const;
  private:
  bool _internal_has_against_votes() const;
  public:
  void clear_against_votes();
  const ::zera_txn::Votes& against_votes() const;
  PROTOBUF_NODISCARD ::zera_txn::Votes* release_against_votes();
  ::zera_txn::Votes* mutable_against_votes();
  void set_allocated_against_votes(::zera_txn::Votes* against_votes);
  private:
  const ::zera_txn::Votes& _internal_against_votes() const;
  ::zera_txn::Votes* _internal_mutable_against_votes();
  public:
  void unsafe_arena_set_allocated_against_votes(
      ::zera_txn::Votes* against_votes);
  ::zera_txn::Votes* unsafe_arena_release_against_votes();

  // uint32 stage = 12;
  void clear_stage();
  uint32_t stage() const;
  void set_stage(uint32_t value);
  private:
  uint32_t _internal_stage() const;
  void _internal_set_stage(uint32_t value);
  public:

  // bool passed = 10;
  void clear_passed();
  bool passed() const;
  void set_passed(bool value);
  private:
  bool _internal_passed() const;
  void _internal_set_passed(bool value);
  public:

  // bool final_stage = 11;
  void clear_final_stage();
  bool final_stage() const;
  void set_final_stage(bool value);
  private:
  bool _internal_final_stage() const;
  void _internal_set_final_stage(bool value);
  public:

  // bool fast_quorum = 13;
  void clear_fast_quorum();
  bool fast_quorum() const;
  void set_fast_quorum(bool value);
  private:
  bool _internal_fast_quorum() const;
  void _internal_set_fast_quorum(bool value);
  public:

  // optional bool proposal_cut = 14;
  bool has_proposal_cut() const;
  private:
  bool _internal_has_proposal_cut() const;
  public:
  void clear_proposal_cut();
  bool proposal_cut() const;
  void set_proposal_cut(bool value);
  private:
  bool _internal_proposal_cut() const;
  void _internal_set_proposal_cut(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ProposalResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> option_cur_equiv_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Votes > option_votes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposal_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr support_cur_equiv_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr against_cur_equiv_;
    ::zera_txn::BaseTXN* base_;
    ::zera_txn::Votes* support_votes_;
    ::zera_txn::Votes* against_votes_;
    uint32_t stage_;
    bool passed_;
    bool final_stage_;
    bool fast_quorum_;
    bool proposal_cut_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class AllowanceTXN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.AllowanceTXN) */ {
 public:
  inline AllowanceTXN() : AllowanceTXN(nullptr) {}
  ~AllowanceTXN() override;
  explicit PROTOBUF_CONSTEXPR AllowanceTXN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowanceTXN(const AllowanceTXN& from);
  AllowanceTXN(AllowanceTXN&& from) noexcept
    : AllowanceTXN() {
    *this = ::std::move(from);
  }

  inline AllowanceTXN& operator=(const AllowanceTXN& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowanceTXN& operator=(AllowanceTXN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowanceTXN& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowanceTXN* internal_default_instance() {
    return reinterpret_cast<const AllowanceTXN*>(
               &_AllowanceTXN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(AllowanceTXN& a, AllowanceTXN& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowanceTXN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowanceTXN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowanceTXN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllowanceTXN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllowanceTXN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllowanceTXN& from) {
    AllowanceTXN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllowanceTXN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.AllowanceTXN";
  }
  protected:
  explicit AllowanceTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 2,
    kWalletAddressFieldNumber = 3,
    kAllowedCurrencyEquivalentFieldNumber = 4,
    kAllowedAmountFieldNumber = 5,
    kBaseFieldNumber = 1,
    kStartTimeFieldNumber = 9,
    kPeriodMonthsFieldNumber = 6,
    kPeriodSecondsFieldNumber = 7,
    kAuthorizeFieldNumber = 10,
  };
  // string contract_id = 2;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // bytes wallet_address = 3;
  void clear_wallet_address();
  const std::string& wallet_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wallet_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wallet_address();
  PROTOBUF_NODISCARD std::string* release_wallet_address();
  void set_allocated_wallet_address(std::string* wallet_address);
  private:
  const std::string& _internal_wallet_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet_address(const std::string& value);
  std::string* _internal_mutable_wallet_address();
  public:

  // optional string allowed_currency_equivalent = 4;
  bool has_allowed_currency_equivalent() const;
  private:
  bool _internal_has_allowed_currency_equivalent() const;
  public:
  void clear_allowed_currency_equivalent();
  const std::string& allowed_currency_equivalent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_allowed_currency_equivalent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_allowed_currency_equivalent();
  PROTOBUF_NODISCARD std::string* release_allowed_currency_equivalent();
  void set_allocated_allowed_currency_equivalent(std::string* allowed_currency_equivalent);
  private:
  const std::string& _internal_allowed_currency_equivalent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_allowed_currency_equivalent(const std::string& value);
  std::string* _internal_mutable_allowed_currency_equivalent();
  public:

  // optional string allowed_amount = 5;
  bool has_allowed_amount() const;
  private:
  bool _internal_has_allowed_amount() const;
  public:
  void clear_allowed_amount();
  const std::string& allowed_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_allowed_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_allowed_amount();
  PROTOBUF_NODISCARD std::string* release_allowed_amount();
  void set_allocated_allowed_amount(std::string* allowed_amount);
  private:
  const std::string& _internal_allowed_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_allowed_amount(const std::string& value);
  std::string* _internal_mutable_allowed_amount();
  public:

  // .zera_txn.BaseTXN base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::zera_txn::BaseTXN& base() const;
  PROTOBUF_NODISCARD ::zera_txn::BaseTXN* release_base();
  ::zera_txn::BaseTXN* mutable_base();
  void set_allocated_base(::zera_txn::BaseTXN* base);
  private:
  const ::zera_txn::BaseTXN& _internal_base() const;
  ::zera_txn::BaseTXN* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::zera_txn::BaseTXN* base);
  ::zera_txn::BaseTXN* unsafe_arena_release_base();

  // .google.protobuf.Timestamp start_time = 9;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // optional uint32 period_months = 6;
  bool has_period_months() const;
  private:
  bool _internal_has_period_months() const;
  public:
  void clear_period_months();
  uint32_t period_months() const;
  void set_period_months(uint32_t value);
  private:
  uint32_t _internal_period_months() const;
  void _internal_set_period_months(uint32_t value);
  public:

  // optional uint32 period_seconds = 7;
  bool has_period_seconds() const;
  private:
  bool _internal_has_period_seconds() const;
  public:
  void clear_period_seconds();
  uint32_t period_seconds() const;
  void set_period_seconds(uint32_t value);
  private:
  uint32_t _internal_period_seconds() const;
  void _internal_set_period_seconds(uint32_t value);
  public:

  // bool authorize = 10;
  void clear_authorize();
  bool authorize() const;
  void set_authorize(bool value);
  private:
  bool _internal_authorize() const;
  void _internal_set_authorize(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.AllowanceTXN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allowed_currency_equivalent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allowed_amount_;
    ::zera_txn::BaseTXN* base_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    uint32_t period_months_;
    uint32_t period_seconds_;
    bool authorize_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class TXNS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.TXNS) */ {
 public:
  inline TXNS() : TXNS(nullptr) {}
  ~TXNS() override;
  explicit PROTOBUF_CONSTEXPR TXNS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TXNS(const TXNS& from);
  TXNS(TXNS&& from) noexcept
    : TXNS() {
    *this = ::std::move(from);
  }

  inline TXNS& operator=(const TXNS& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXNS& operator=(TXNS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TXNS& default_instance() {
    return *internal_default_instance();
  }
  static inline const TXNS* internal_default_instance() {
    return reinterpret_cast<const TXNS*>(
               &_TXNS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(TXNS& a, TXNS& b) {
    a.Swap(&b);
  }
  inline void Swap(TXNS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXNS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TXNS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TXNS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TXNS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TXNS& from) {
    TXNS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXNS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.TXNS";
  }
  protected:
  explicit TXNS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoinTxnsFieldNumber = 1,
    kMintTxnsFieldNumber = 2,
    kItemMintTxnsFieldNumber = 3,
    kContractTxnsFieldNumber = 4,
    kGovernanceVotesFieldNumber = 5,
    kGovernanceProposalsFieldNumber = 6,
    kSmartContractsFieldNumber = 7,
    kSmartContractExecutesFieldNumber = 8,
    kSelfCurEquivsFieldNumber = 9,
    kAuthCurEquivsFieldNumber = 10,
    kExpenseRatiosFieldNumber = 11,
    kTxnFeesAndStatusFieldNumber = 12,
    kTokenFeesFieldNumber = 13,
    kNftTxnsFieldNumber = 14,
    kContractUpdateTxnsFieldNumber = 15,
    kValidatorRegistrationTxnsFieldNumber = 16,
    kValidatorHeartbeatTxnsFieldNumber = 17,
    kProposalResultTxnsFieldNumber = 18,
    kExpenseRatioResultTxnsFieldNumber = 19,
    kFoundationTxnsFieldNumber = 20,
    kDelegatedVotingTxnsFieldNumber = 21,
    kQuashTxnsFieldNumber = 22,
    kFastQuorumTxnsFieldNumber = 23,
    kQuashResultsFieldNumber = 24,
    kRevokeTxnsFieldNumber = 25,
    kComplianceTxnsFieldNumber = 26,
    kBurnSbtTxnsFieldNumber = 27,
    kSmartContractInstantiateTxnsFieldNumber = 28,
    kAllowanceTxnsFieldNumber = 30,
    kRequiredVersionTxnFieldNumber = 29,
  };
  // repeated .zera_txn.CoinTXN coin_txns = 1;
  int coin_txns_size() const;
  private:
  int _internal_coin_txns_size() const;
  public:
  void clear_coin_txns();
  ::zera_txn::CoinTXN* mutable_coin_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CoinTXN >*
      mutable_coin_txns();
  private:
  const ::zera_txn::CoinTXN& _internal_coin_txns(int index) const;
  ::zera_txn::CoinTXN* _internal_add_coin_txns();
  public:
  const ::zera_txn::CoinTXN& coin_txns(int index) const;
  ::zera_txn::CoinTXN* add_coin_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CoinTXN >&
      coin_txns() const;

  // repeated .zera_txn.MintTXN mint_txns = 2;
  int mint_txns_size() const;
  private:
  int _internal_mint_txns_size() const;
  public:
  void clear_mint_txns();
  ::zera_txn::MintTXN* mutable_mint_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MintTXN >*
      mutable_mint_txns();
  private:
  const ::zera_txn::MintTXN& _internal_mint_txns(int index) const;
  ::zera_txn::MintTXN* _internal_add_mint_txns();
  public:
  const ::zera_txn::MintTXN& mint_txns(int index) const;
  ::zera_txn::MintTXN* add_mint_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MintTXN >&
      mint_txns() const;

  // repeated .zera_txn.ItemizedMintTXN item_mint_txns = 3;
  int item_mint_txns_size() const;
  private:
  int _internal_item_mint_txns_size() const;
  public:
  void clear_item_mint_txns();
  ::zera_txn::ItemizedMintTXN* mutable_item_mint_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ItemizedMintTXN >*
      mutable_item_mint_txns();
  private:
  const ::zera_txn::ItemizedMintTXN& _internal_item_mint_txns(int index) const;
  ::zera_txn::ItemizedMintTXN* _internal_add_item_mint_txns();
  public:
  const ::zera_txn::ItemizedMintTXN& item_mint_txns(int index) const;
  ::zera_txn::ItemizedMintTXN* add_item_mint_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ItemizedMintTXN >&
      item_mint_txns() const;

  // repeated .zera_txn.InstrumentContract contract_txns = 4;
  int contract_txns_size() const;
  private:
  int _internal_contract_txns_size() const;
  public:
  void clear_contract_txns();
  ::zera_txn::InstrumentContract* mutable_contract_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InstrumentContract >*
      mutable_contract_txns();
  private:
  const ::zera_txn::InstrumentContract& _internal_contract_txns(int index) const;
  ::zera_txn::InstrumentContract* _internal_add_contract_txns();
  public:
  const ::zera_txn::InstrumentContract& contract_txns(int index) const;
  ::zera_txn::InstrumentContract* add_contract_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InstrumentContract >&
      contract_txns() const;

  // repeated .zera_txn.GovernanceVote governance_votes = 5;
  int governance_votes_size() const;
  private:
  int _internal_governance_votes_size() const;
  public:
  void clear_governance_votes();
  ::zera_txn::GovernanceVote* mutable_governance_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceVote >*
      mutable_governance_votes();
  private:
  const ::zera_txn::GovernanceVote& _internal_governance_votes(int index) const;
  ::zera_txn::GovernanceVote* _internal_add_governance_votes();
  public:
  const ::zera_txn::GovernanceVote& governance_votes(int index) const;
  ::zera_txn::GovernanceVote* add_governance_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceVote >&
      governance_votes() const;

  // repeated .zera_txn.GovernanceProposal governance_proposals = 6;
  int governance_proposals_size() const;
  private:
  int _internal_governance_proposals_size() const;
  public:
  void clear_governance_proposals();
  ::zera_txn::GovernanceProposal* mutable_governance_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceProposal >*
      mutable_governance_proposals();
  private:
  const ::zera_txn::GovernanceProposal& _internal_governance_proposals(int index) const;
  ::zera_txn::GovernanceProposal* _internal_add_governance_proposals();
  public:
  const ::zera_txn::GovernanceProposal& governance_proposals(int index) const;
  ::zera_txn::GovernanceProposal* add_governance_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceProposal >&
      governance_proposals() const;

  // repeated .zera_txn.SmartContractTXN smart_contracts = 7;
  int smart_contracts_size() const;
  private:
  int _internal_smart_contracts_size() const;
  public:
  void clear_smart_contracts();
  ::zera_txn::SmartContractTXN* mutable_smart_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractTXN >*
      mutable_smart_contracts();
  private:
  const ::zera_txn::SmartContractTXN& _internal_smart_contracts(int index) const;
  ::zera_txn::SmartContractTXN* _internal_add_smart_contracts();
  public:
  const ::zera_txn::SmartContractTXN& smart_contracts(int index) const;
  ::zera_txn::SmartContractTXN* add_smart_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractTXN >&
      smart_contracts() const;

  // repeated .zera_txn.SmartContractExecuteTXN smart_contract_executes = 8;
  int smart_contract_executes_size() const;
  private:
  int _internal_smart_contract_executes_size() const;
  public:
  void clear_smart_contract_executes();
  ::zera_txn::SmartContractExecuteTXN* mutable_smart_contract_executes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractExecuteTXN >*
      mutable_smart_contract_executes();
  private:
  const ::zera_txn::SmartContractExecuteTXN& _internal_smart_contract_executes(int index) const;
  ::zera_txn::SmartContractExecuteTXN* _internal_add_smart_contract_executes();
  public:
  const ::zera_txn::SmartContractExecuteTXN& smart_contract_executes(int index) const;
  ::zera_txn::SmartContractExecuteTXN* add_smart_contract_executes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractExecuteTXN >&
      smart_contract_executes() const;

  // repeated .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
  int self_cur_equivs_size() const;
  private:
  int _internal_self_cur_equivs_size() const;
  public:
  void clear_self_cur_equivs();
  ::zera_txn::SelfCurrencyEquiv* mutable_self_cur_equivs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SelfCurrencyEquiv >*
      mutable_self_cur_equivs();
  private:
  const ::zera_txn::SelfCurrencyEquiv& _internal_self_cur_equivs(int index) const;
  ::zera_txn::SelfCurrencyEquiv* _internal_add_self_cur_equivs();
  public:
  const ::zera_txn::SelfCurrencyEquiv& self_cur_equivs(int index) const;
  ::zera_txn::SelfCurrencyEquiv* add_self_cur_equivs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SelfCurrencyEquiv >&
      self_cur_equivs() const;

  // repeated .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
  int auth_cur_equivs_size() const;
  private:
  int _internal_auth_cur_equivs_size() const;
  public:
  void clear_auth_cur_equivs();
  ::zera_txn::AuthorizedCurrencyEquiv* mutable_auth_cur_equivs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AuthorizedCurrencyEquiv >*
      mutable_auth_cur_equivs();
  private:
  const ::zera_txn::AuthorizedCurrencyEquiv& _internal_auth_cur_equivs(int index) const;
  ::zera_txn::AuthorizedCurrencyEquiv* _internal_add_auth_cur_equivs();
  public:
  const ::zera_txn::AuthorizedCurrencyEquiv& auth_cur_equivs(int index) const;
  ::zera_txn::AuthorizedCurrencyEquiv* add_auth_cur_equivs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AuthorizedCurrencyEquiv >&
      auth_cur_equivs() const;

  // repeated .zera_txn.ExpenseRatioTXN expense_ratios = 11;
  int expense_ratios_size() const;
  private:
  int _internal_expense_ratios_size() const;
  public:
  void clear_expense_ratios();
  ::zera_txn::ExpenseRatioTXN* mutable_expense_ratios(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioTXN >*
      mutable_expense_ratios();
  private:
  const ::zera_txn::ExpenseRatioTXN& _internal_expense_ratios(int index) const;
  ::zera_txn::ExpenseRatioTXN* _internal_add_expense_ratios();
  public:
  const ::zera_txn::ExpenseRatioTXN& expense_ratios(int index) const;
  ::zera_txn::ExpenseRatioTXN* add_expense_ratios();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioTXN >&
      expense_ratios() const;

  // repeated .zera_txn.TXNStatusFees txn_fees_and_status = 12;
  int txn_fees_and_status_size() const;
  private:
  int _internal_txn_fees_and_status_size() const;
  public:
  void clear_txn_fees_and_status();
  ::zera_txn::TXNStatusFees* mutable_txn_fees_and_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TXNStatusFees >*
      mutable_txn_fees_and_status();
  private:
  const ::zera_txn::TXNStatusFees& _internal_txn_fees_and_status(int index) const;
  ::zera_txn::TXNStatusFees* _internal_add_txn_fees_and_status();
  public:
  const ::zera_txn::TXNStatusFees& txn_fees_and_status(int index) const;
  ::zera_txn::TXNStatusFees* add_txn_fees_and_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TXNStatusFees >&
      txn_fees_and_status() const;

  // repeated .zera_txn.TokenFees token_fees = 13;
  int token_fees_size() const;
  private:
  int _internal_token_fees_size() const;
  public:
  void clear_token_fees();
  ::zera_txn::TokenFees* mutable_token_fees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenFees >*
      mutable_token_fees();
  private:
  const ::zera_txn::TokenFees& _internal_token_fees(int index) const;
  ::zera_txn::TokenFees* _internal_add_token_fees();
  public:
  const ::zera_txn::TokenFees& token_fees(int index) const;
  ::zera_txn::TokenFees* add_token_fees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenFees >&
      token_fees() const;

  // repeated .zera_txn.NFTTXN nft_txns = 14;
  int nft_txns_size() const;
  private:
  int _internal_nft_txns_size() const;
  public:
  void clear_nft_txns();
  ::zera_txn::NFTTXN* mutable_nft_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::NFTTXN >*
      mutable_nft_txns();
  private:
  const ::zera_txn::NFTTXN& _internal_nft_txns(int index) const;
  ::zera_txn::NFTTXN* _internal_add_nft_txns();
  public:
  const ::zera_txn::NFTTXN& nft_txns(int index) const;
  ::zera_txn::NFTTXN* add_nft_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::NFTTXN >&
      nft_txns() const;

  // repeated .zera_txn.ContractUpdateTXN contract_update_txns = 15;
  int contract_update_txns_size() const;
  private:
  int _internal_contract_update_txns_size() const;
  public:
  void clear_contract_update_txns();
  ::zera_txn::ContractUpdateTXN* mutable_contract_update_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ContractUpdateTXN >*
      mutable_contract_update_txns();
  private:
  const ::zera_txn::ContractUpdateTXN& _internal_contract_update_txns(int index) const;
  ::zera_txn::ContractUpdateTXN* _internal_add_contract_update_txns();
  public:
  const ::zera_txn::ContractUpdateTXN& contract_update_txns(int index) const;
  ::zera_txn::ContractUpdateTXN* add_contract_update_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ContractUpdateTXN >&
      contract_update_txns() const;

  // repeated .zera_txn.ValidatorRegistration validator_registration_txns = 16;
  int validator_registration_txns_size() const;
  private:
  int _internal_validator_registration_txns_size() const;
  public:
  void clear_validator_registration_txns();
  ::zera_txn::ValidatorRegistration* mutable_validator_registration_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorRegistration >*
      mutable_validator_registration_txns();
  private:
  const ::zera_txn::ValidatorRegistration& _internal_validator_registration_txns(int index) const;
  ::zera_txn::ValidatorRegistration* _internal_add_validator_registration_txns();
  public:
  const ::zera_txn::ValidatorRegistration& validator_registration_txns(int index) const;
  ::zera_txn::ValidatorRegistration* add_validator_registration_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorRegistration >&
      validator_registration_txns() const;

  // repeated .zera_txn.ValidatorHeartbeat validator_heartbeat_txns = 17;
  int validator_heartbeat_txns_size() const;
  private:
  int _internal_validator_heartbeat_txns_size() const;
  public:
  void clear_validator_heartbeat_txns();
  ::zera_txn::ValidatorHeartbeat* mutable_validator_heartbeat_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorHeartbeat >*
      mutable_validator_heartbeat_txns();
  private:
  const ::zera_txn::ValidatorHeartbeat& _internal_validator_heartbeat_txns(int index) const;
  ::zera_txn::ValidatorHeartbeat* _internal_add_validator_heartbeat_txns();
  public:
  const ::zera_txn::ValidatorHeartbeat& validator_heartbeat_txns(int index) const;
  ::zera_txn::ValidatorHeartbeat* add_validator_heartbeat_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorHeartbeat >&
      validator_heartbeat_txns() const;

  // repeated .zera_txn.ProposalResult proposal_result_txns = 18;
  int proposal_result_txns_size() const;
  private:
  int _internal_proposal_result_txns_size() const;
  public:
  void clear_proposal_result_txns();
  ::zera_txn::ProposalResult* mutable_proposal_result_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalResult >*
      mutable_proposal_result_txns();
  private:
  const ::zera_txn::ProposalResult& _internal_proposal_result_txns(int index) const;
  ::zera_txn::ProposalResult* _internal_add_proposal_result_txns();
  public:
  const ::zera_txn::ProposalResult& proposal_result_txns(int index) const;
  ::zera_txn::ProposalResult* add_proposal_result_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalResult >&
      proposal_result_txns() const;

  // repeated .zera_txn.ExpenseRatioResult expense_ratio_result_txns = 19;
  int expense_ratio_result_txns_size() const;
  private:
  int _internal_expense_ratio_result_txns_size() const;
  public:
  void clear_expense_ratio_result_txns();
  ::zera_txn::ExpenseRatioResult* mutable_expense_ratio_result_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioResult >*
      mutable_expense_ratio_result_txns();
  private:
  const ::zera_txn::ExpenseRatioResult& _internal_expense_ratio_result_txns(int index) const;
  ::zera_txn::ExpenseRatioResult* _internal_add_expense_ratio_result_txns();
  public:
  const ::zera_txn::ExpenseRatioResult& expense_ratio_result_txns(int index) const;
  ::zera_txn::ExpenseRatioResult* add_expense_ratio_result_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioResult >&
      expense_ratio_result_txns() const;

  // repeated .zera_txn.FoundationTXN foundation_txns = 20;
  int foundation_txns_size() const;
  private:
  int _internal_foundation_txns_size() const;
  public:
  void clear_foundation_txns();
  ::zera_txn::FoundationTXN* mutable_foundation_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FoundationTXN >*
      mutable_foundation_txns();
  private:
  const ::zera_txn::FoundationTXN& _internal_foundation_txns(int index) const;
  ::zera_txn::FoundationTXN* _internal_add_foundation_txns();
  public:
  const ::zera_txn::FoundationTXN& foundation_txns(int index) const;
  ::zera_txn::FoundationTXN* add_foundation_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FoundationTXN >&
      foundation_txns() const;

  // repeated .zera_txn.DelegatedTXN delegated_voting_txns = 21;
  int delegated_voting_txns_size() const;
  private:
  int _internal_delegated_voting_txns_size() const;
  public:
  void clear_delegated_voting_txns();
  ::zera_txn::DelegatedTXN* mutable_delegated_voting_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedTXN >*
      mutable_delegated_voting_txns();
  private:
  const ::zera_txn::DelegatedTXN& _internal_delegated_voting_txns(int index) const;
  ::zera_txn::DelegatedTXN* _internal_add_delegated_voting_txns();
  public:
  const ::zera_txn::DelegatedTXN& delegated_voting_txns(int index) const;
  ::zera_txn::DelegatedTXN* add_delegated_voting_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedTXN >&
      delegated_voting_txns() const;

  // repeated .zera_txn.QuashTXN quash_txns = 22;
  int quash_txns_size() const;
  private:
  int _internal_quash_txns_size() const;
  public:
  void clear_quash_txns();
  ::zera_txn::QuashTXN* mutable_quash_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashTXN >*
      mutable_quash_txns();
  private:
  const ::zera_txn::QuashTXN& _internal_quash_txns(int index) const;
  ::zera_txn::QuashTXN* _internal_add_quash_txns();
  public:
  const ::zera_txn::QuashTXN& quash_txns(int index) const;
  ::zera_txn::QuashTXN* add_quash_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashTXN >&
      quash_txns() const;

  // repeated .zera_txn.FastQuorumTXN fast_quorum_txns = 23;
  int fast_quorum_txns_size() const;
  private:
  int _internal_fast_quorum_txns_size() const;
  public:
  void clear_fast_quorum_txns();
  ::zera_txn::FastQuorumTXN* mutable_fast_quorum_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FastQuorumTXN >*
      mutable_fast_quorum_txns();
  private:
  const ::zera_txn::FastQuorumTXN& _internal_fast_quorum_txns(int index) const;
  ::zera_txn::FastQuorumTXN* _internal_add_fast_quorum_txns();
  public:
  const ::zera_txn::FastQuorumTXN& fast_quorum_txns(int index) const;
  ::zera_txn::FastQuorumTXN* add_fast_quorum_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FastQuorumTXN >&
      fast_quorum_txns() const;

  // repeated .zera_txn.QuashResult quash_results = 24;
  int quash_results_size() const;
  private:
  int _internal_quash_results_size() const;
  public:
  void clear_quash_results();
  ::zera_txn::QuashResult* mutable_quash_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashResult >*
      mutable_quash_results();
  private:
  const ::zera_txn::QuashResult& _internal_quash_results(int index) const;
  ::zera_txn::QuashResult* _internal_add_quash_results();
  public:
  const ::zera_txn::QuashResult& quash_results(int index) const;
  ::zera_txn::QuashResult* add_quash_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashResult >&
      quash_results() const;

  // repeated .zera_txn.RevokeTXN revoke_txns = 25;
  int revoke_txns_size() const;
  private:
  int _internal_revoke_txns_size() const;
  public:
  void clear_revoke_txns();
  ::zera_txn::RevokeTXN* mutable_revoke_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RevokeTXN >*
      mutable_revoke_txns();
  private:
  const ::zera_txn::RevokeTXN& _internal_revoke_txns(int index) const;
  ::zera_txn::RevokeTXN* _internal_add_revoke_txns();
  public:
  const ::zera_txn::RevokeTXN& revoke_txns(int index) const;
  ::zera_txn::RevokeTXN* add_revoke_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RevokeTXN >&
      revoke_txns() const;

  // repeated .zera_txn.ComplianceTXN compliance_txns = 26;
  int compliance_txns_size() const;
  private:
  int _internal_compliance_txns_size() const;
  public:
  void clear_compliance_txns();
  ::zera_txn::ComplianceTXN* mutable_compliance_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceTXN >*
      mutable_compliance_txns();
  private:
  const ::zera_txn::ComplianceTXN& _internal_compliance_txns(int index) const;
  ::zera_txn::ComplianceTXN* _internal_add_compliance_txns();
  public:
  const ::zera_txn::ComplianceTXN& compliance_txns(int index) const;
  ::zera_txn::ComplianceTXN* add_compliance_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceTXN >&
      compliance_txns() const;

  // repeated .zera_txn.BurnSBTTXN burn_sbt_txns = 27;
  int burn_sbt_txns_size() const;
  private:
  int _internal_burn_sbt_txns_size() const;
  public:
  void clear_burn_sbt_txns();
  ::zera_txn::BurnSBTTXN* mutable_burn_sbt_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::BurnSBTTXN >*
      mutable_burn_sbt_txns();
  private:
  const ::zera_txn::BurnSBTTXN& _internal_burn_sbt_txns(int index) const;
  ::zera_txn::BurnSBTTXN* _internal_add_burn_sbt_txns();
  public:
  const ::zera_txn::BurnSBTTXN& burn_sbt_txns(int index) const;
  ::zera_txn::BurnSBTTXN* add_burn_sbt_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::BurnSBTTXN >&
      burn_sbt_txns() const;

  // repeated .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txns = 28;
  int smart_contract_instantiate_txns_size() const;
  private:
  int _internal_smart_contract_instantiate_txns_size() const;
  public:
  void clear_smart_contract_instantiate_txns();
  ::zera_txn::SmartContractInstantiateTXN* mutable_smart_contract_instantiate_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractInstantiateTXN >*
      mutable_smart_contract_instantiate_txns();
  private:
  const ::zera_txn::SmartContractInstantiateTXN& _internal_smart_contract_instantiate_txns(int index) const;
  ::zera_txn::SmartContractInstantiateTXN* _internal_add_smart_contract_instantiate_txns();
  public:
  const ::zera_txn::SmartContractInstantiateTXN& smart_contract_instantiate_txns(int index) const;
  ::zera_txn::SmartContractInstantiateTXN* add_smart_contract_instantiate_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractInstantiateTXN >&
      smart_contract_instantiate_txns() const;

  // repeated .zera_txn.AllowanceTXN allowance_txns = 30;
  int allowance_txns_size() const;
  private:
  int _internal_allowance_txns_size() const;
  public:
  void clear_allowance_txns();
  ::zera_txn::AllowanceTXN* mutable_allowance_txns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AllowanceTXN >*
      mutable_allowance_txns();
  private:
  const ::zera_txn::AllowanceTXN& _internal_allowance_txns(int index) const;
  ::zera_txn::AllowanceTXN* _internal_add_allowance_txns();
  public:
  const ::zera_txn::AllowanceTXN& allowance_txns(int index) const;
  ::zera_txn::AllowanceTXN* add_allowance_txns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AllowanceTXN >&
      allowance_txns() const;

  // optional .zera_txn.RequiredVersion required_version_txn = 29;
  bool has_required_version_txn() const;
  private:
  bool _internal_has_required_version_txn() const;
  public:
  void clear_required_version_txn();
  const ::zera_txn::RequiredVersion& required_version_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::RequiredVersion* release_required_version_txn();
  ::zera_txn::RequiredVersion* mutable_required_version_txn();
  void set_allocated_required_version_txn(::zera_txn::RequiredVersion* required_version_txn);
  private:
  const ::zera_txn::RequiredVersion& _internal_required_version_txn() const;
  ::zera_txn::RequiredVersion* _internal_mutable_required_version_txn();
  public:
  void unsafe_arena_set_allocated_required_version_txn(
      ::zera_txn::RequiredVersion* required_version_txn);
  ::zera_txn::RequiredVersion* unsafe_arena_release_required_version_txn();

  // @@protoc_insertion_point(class_scope:zera_txn.TXNS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CoinTXN > coin_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MintTXN > mint_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ItemizedMintTXN > item_mint_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InstrumentContract > contract_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceVote > governance_votes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceProposal > governance_proposals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractTXN > smart_contracts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractExecuteTXN > smart_contract_executes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SelfCurrencyEquiv > self_cur_equivs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AuthorizedCurrencyEquiv > auth_cur_equivs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioTXN > expense_ratios_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TXNStatusFees > txn_fees_and_status_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenFees > token_fees_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::NFTTXN > nft_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ContractUpdateTXN > contract_update_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorRegistration > validator_registration_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorHeartbeat > validator_heartbeat_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalResult > proposal_result_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioResult > expense_ratio_result_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FoundationTXN > foundation_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedTXN > delegated_voting_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashTXN > quash_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FastQuorumTXN > fast_quorum_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashResult > quash_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RevokeTXN > revoke_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceTXN > compliance_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::BurnSBTTXN > burn_sbt_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractInstantiateTXN > smart_contract_instantiate_txns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AllowanceTXN > allowance_txns_;
    ::zera_txn::RequiredVersion* required_version_txn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class TokenFees final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.TokenFees) */ {
 public:
  inline TokenFees() : TokenFees(nullptr) {}
  ~TokenFees() override;
  explicit PROTOBUF_CONSTEXPR TokenFees(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenFees(const TokenFees& from);
  TokenFees(TokenFees&& from) noexcept
    : TokenFees() {
    *this = ::std::move(from);
  }

  inline TokenFees& operator=(const TokenFees& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenFees& operator=(TokenFees&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenFees& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenFees* internal_default_instance() {
    return reinterpret_cast<const TokenFees*>(
               &_TokenFees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(TokenFees& a, TokenFees& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenFees* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenFees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenFees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenFees>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenFees& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenFees& from) {
    TokenFees::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenFees* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.TokenFees";
  }
  protected:
  explicit TokenFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 2,
    kAddressFieldNumber = 1,
  };
  // repeated .zera_txn.Token tokens = 2;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::zera_txn::Token* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Token >*
      mutable_tokens();
  private:
  const ::zera_txn::Token& _internal_tokens(int index) const;
  ::zera_txn::Token* _internal_add_tokens();
  public:
  const ::zera_txn::Token& tokens(int index) const;
  ::zera_txn::Token* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Token >&
      tokens() const;

  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.TokenFees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Token > tokens_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class DelegatedData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.DelegatedData) */ {
 public:
  inline DelegatedData() : DelegatedData(nullptr) {}
  ~DelegatedData() override;
  explicit PROTOBUF_CONSTEXPR DelegatedData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegatedData(const DelegatedData& from);
  DelegatedData(DelegatedData&& from) noexcept
    : DelegatedData() {
    *this = ::std::move(from);
  }

  inline DelegatedData& operator=(const DelegatedData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatedData& operator=(DelegatedData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegatedData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegatedData* internal_default_instance() {
    return reinterpret_cast<const DelegatedData*>(
               &_DelegatedData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(DelegatedData& a, DelegatedData& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatedData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatedData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegatedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegatedData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegatedData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelegatedData& from) {
    DelegatedData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatedData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.DelegatedData";
  }
  protected:
  explicit DelegatedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kFeeFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .zera_txn.Token fee = 2;
  bool has_fee() const;
  private:
  bool _internal_has_fee() const;
  public:
  void clear_fee();
  const ::zera_txn::Token& fee() const;
  PROTOBUF_NODISCARD ::zera_txn::Token* release_fee();
  ::zera_txn::Token* mutable_fee();
  void set_allocated_fee(::zera_txn::Token* fee);
  private:
  const ::zera_txn::Token& _internal_fee() const;
  ::zera_txn::Token* _internal_mutable_fee();
  public:
  void unsafe_arena_set_allocated_fee(
      ::zera_txn::Token* fee);
  ::zera_txn::Token* unsafe_arena_release_fee();

  // @@protoc_insertion_point(class_scope:zera_txn.DelegatedData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::zera_txn::Token* fee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class TXNStatusFees final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.TXNStatusFees) */ {
 public:
  inline TXNStatusFees() : TXNStatusFees(nullptr) {}
  ~TXNStatusFees() override;
  explicit PROTOBUF_CONSTEXPR TXNStatusFees(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TXNStatusFees(const TXNStatusFees& from);
  TXNStatusFees(TXNStatusFees&& from) noexcept
    : TXNStatusFees() {
    *this = ::std::move(from);
  }

  inline TXNStatusFees& operator=(const TXNStatusFees& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXNStatusFees& operator=(TXNStatusFees&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TXNStatusFees& default_instance() {
    return *internal_default_instance();
  }
  static inline const TXNStatusFees* internal_default_instance() {
    return reinterpret_cast<const TXNStatusFees*>(
               &_TXNStatusFees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(TXNStatusFees& a, TXNStatusFees& b) {
    a.Swap(&b);
  }
  inline void Swap(TXNStatusFees* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXNStatusFees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TXNStatusFees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TXNStatusFees>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TXNStatusFees& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TXNStatusFees& from) {
    TXNStatusFees::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXNStatusFees* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.TXNStatusFees";
  }
  protected:
  explicit TXNStatusFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmartContractResultFieldNumber = 10,
    kMiscFieldNumber = 11,
    kDelegatedDataFieldNumber = 14,
    kTxnHashFieldNumber = 1,
    kBaseFeesFieldNumber = 3,
    kBaseContractIdFieldNumber = 4,
    kContractFeesFieldNumber = 5,
    kContractContractIdFieldNumber = 6,
    kNativeFunctionFeesFieldNumber = 12,
    kInterfaceFeeFieldNumber = 15,
    kInterfaceFeeIdFieldNumber = 16,
    kStatusFieldNumber = 2,
    kSmartContractFieldNumber = 9,
    kGasFieldNumber = 13,
  };
  // repeated bytes smart_contract_result = 10;
  int smart_contract_result_size() const;
  private:
  int _internal_smart_contract_result_size() const;
  public:
  void clear_smart_contract_result();
  const std::string& smart_contract_result(int index) const;
  std::string* mutable_smart_contract_result(int index);
  void set_smart_contract_result(int index, const std::string& value);
  void set_smart_contract_result(int index, std::string&& value);
  void set_smart_contract_result(int index, const char* value);
  void set_smart_contract_result(int index, const void* value, size_t size);
  std::string* add_smart_contract_result();
  void add_smart_contract_result(const std::string& value);
  void add_smart_contract_result(std::string&& value);
  void add_smart_contract_result(const char* value);
  void add_smart_contract_result(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& smart_contract_result() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_smart_contract_result();
  private:
  const std::string& _internal_smart_contract_result(int index) const;
  std::string* _internal_add_smart_contract_result();
  public:

  // repeated string misc = 11;
  int misc_size() const;
  private:
  int _internal_misc_size() const;
  public:
  void clear_misc();
  const std::string& misc(int index) const;
  std::string* mutable_misc(int index);
  void set_misc(int index, const std::string& value);
  void set_misc(int index, std::string&& value);
  void set_misc(int index, const char* value);
  void set_misc(int index, const char* value, size_t size);
  std::string* add_misc();
  void add_misc(const std::string& value);
  void add_misc(std::string&& value);
  void add_misc(const char* value);
  void add_misc(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& misc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_misc();
  private:
  const std::string& _internal_misc(int index) const;
  std::string* _internal_add_misc();
  public:

  // repeated .zera_txn.DelegatedData delegated_data = 14;
  int delegated_data_size() const;
  private:
  int _internal_delegated_data_size() const;
  public:
  void clear_delegated_data();
  ::zera_txn::DelegatedData* mutable_delegated_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedData >*
      mutable_delegated_data();
  private:
  const ::zera_txn::DelegatedData& _internal_delegated_data(int index) const;
  ::zera_txn::DelegatedData* _internal_add_delegated_data();
  public:
  const ::zera_txn::DelegatedData& delegated_data(int index) const;
  ::zera_txn::DelegatedData* add_delegated_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedData >&
      delegated_data() const;

  // bytes txn_hash = 1;
  void clear_txn_hash();
  const std::string& txn_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txn_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txn_hash();
  PROTOBUF_NODISCARD std::string* release_txn_hash();
  void set_allocated_txn_hash(std::string* txn_hash);
  private:
  const std::string& _internal_txn_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txn_hash(const std::string& value);
  std::string* _internal_mutable_txn_hash();
  public:

  // string base_fees = 3;
  void clear_base_fees();
  const std::string& base_fees() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_fees(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_fees();
  PROTOBUF_NODISCARD std::string* release_base_fees();
  void set_allocated_base_fees(std::string* base_fees);
  private:
  const std::string& _internal_base_fees() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_fees(const std::string& value);
  std::string* _internal_mutable_base_fees();
  public:

  // string base_contract_id = 4;
  void clear_base_contract_id();
  const std::string& base_contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_contract_id();
  PROTOBUF_NODISCARD std::string* release_base_contract_id();
  void set_allocated_base_contract_id(std::string* base_contract_id);
  private:
  const std::string& _internal_base_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_contract_id(const std::string& value);
  std::string* _internal_mutable_base_contract_id();
  public:

  // optional string contract_fees = 5;
  bool has_contract_fees() const;
  private:
  bool _internal_has_contract_fees() const;
  public:
  void clear_contract_fees();
  const std::string& contract_fees() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_fees(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_fees();
  PROTOBUF_NODISCARD std::string* release_contract_fees();
  void set_allocated_contract_fees(std::string* contract_fees);
  private:
  const std::string& _internal_contract_fees() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_fees(const std::string& value);
  std::string* _internal_mutable_contract_fees();
  public:

  // optional string contract_contract_id = 6;
  bool has_contract_contract_id() const;
  private:
  bool _internal_has_contract_contract_id() const;
  public:
  void clear_contract_contract_id();
  const std::string& contract_contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_contract_id();
  void set_allocated_contract_contract_id(std::string* contract_contract_id);
  private:
  const std::string& _internal_contract_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_contract_id();
  public:

  // optional string native_function_fees = 12;
  bool has_native_function_fees() const;
  private:
  bool _internal_has_native_function_fees() const;
  public:
  void clear_native_function_fees();
  const std::string& native_function_fees() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_native_function_fees(ArgT0&& arg0, ArgT... args);
  std::string* mutable_native_function_fees();
  PROTOBUF_NODISCARD std::string* release_native_function_fees();
  void set_allocated_native_function_fees(std::string* native_function_fees);
  private:
  const std::string& _internal_native_function_fees() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_native_function_fees(const std::string& value);
  std::string* _internal_mutable_native_function_fees();
  public:

  // optional string interface_fee = 15;
  bool has_interface_fee() const;
  private:
  bool _internal_has_interface_fee() const;
  public:
  void clear_interface_fee();
  const std::string& interface_fee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface_fee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface_fee();
  PROTOBUF_NODISCARD std::string* release_interface_fee();
  void set_allocated_interface_fee(std::string* interface_fee);
  private:
  const std::string& _internal_interface_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_fee(const std::string& value);
  std::string* _internal_mutable_interface_fee();
  public:

  // optional string interface_fee_id = 16;
  bool has_interface_fee_id() const;
  private:
  bool _internal_has_interface_fee_id() const;
  public:
  void clear_interface_fee_id();
  const std::string& interface_fee_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface_fee_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface_fee_id();
  PROTOBUF_NODISCARD std::string* release_interface_fee_id();
  void set_allocated_interface_fee_id(std::string* interface_fee_id);
  private:
  const std::string& _internal_interface_fee_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_fee_id(const std::string& value);
  std::string* _internal_mutable_interface_fee_id();
  public:

  // .zera_txn.TXN_STATUS status = 2;
  void clear_status();
  ::zera_txn::TXN_STATUS status() const;
  void set_status(::zera_txn::TXN_STATUS value);
  private:
  ::zera_txn::TXN_STATUS _internal_status() const;
  void _internal_set_status(::zera_txn::TXN_STATUS value);
  public:

  // bool smart_contract = 9;
  void clear_smart_contract();
  bool smart_contract() const;
  void set_smart_contract(bool value);
  private:
  bool _internal_smart_contract() const;
  void _internal_set_smart_contract(bool value);
  public:

  // optional uint64 gas = 13;
  bool has_gas() const;
  private:
  bool _internal_has_gas() const;
  public:
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.TXNStatusFees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> smart_contract_result_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> misc_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedData > delegated_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txn_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_fees_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_fees_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_contract_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr native_function_fees_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_fee_id_;
    int status_;
    bool smart_contract_;
    uint64_t gas_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class ProposalContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.ProposalContract) */ {
 public:
  inline ProposalContract() : ProposalContract(nullptr) {}
  ~ProposalContract() override;
  explicit PROTOBUF_CONSTEXPR ProposalContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProposalContract(const ProposalContract& from);
  ProposalContract(ProposalContract&& from) noexcept
    : ProposalContract() {
    *this = ::std::move(from);
  }

  inline ProposalContract& operator=(const ProposalContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalContract& operator=(ProposalContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalContract* internal_default_instance() {
    return reinterpret_cast<const ProposalContract*>(
               &_ProposalContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(ProposalContract& a, ProposalContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProposalContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProposalContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProposalContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProposalContract& from) {
    ProposalContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.ProposalContract";
  }
  protected:
  explicit ProposalContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalIdsFieldNumber = 2,
    kContractIdFieldNumber = 1,
    kStageFieldNumber = 3,
  };
  // repeated bytes proposal_ids = 2;
  int proposal_ids_size() const;
  private:
  int _internal_proposal_ids_size() const;
  public:
  void clear_proposal_ids();
  const std::string& proposal_ids(int index) const;
  std::string* mutable_proposal_ids(int index);
  void set_proposal_ids(int index, const std::string& value);
  void set_proposal_ids(int index, std::string&& value);
  void set_proposal_ids(int index, const char* value);
  void set_proposal_ids(int index, const void* value, size_t size);
  std::string* add_proposal_ids();
  void add_proposal_ids(const std::string& value);
  void add_proposal_ids(std::string&& value);
  void add_proposal_ids(const char* value);
  void add_proposal_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proposal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proposal_ids();
  private:
  const std::string& _internal_proposal_ids(int index) const;
  std::string* _internal_add_proposal_ids();
  public:

  // string contract_id = 1;
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // uint32 stage = 3;
  void clear_stage();
  uint32_t stage() const;
  void set_stage(uint32_t value);
  private:
  uint32_t _internal_stage() const;
  void _internal_set_stage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zera_txn.ProposalContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proposal_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
    uint32_t stage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// -------------------------------------------------------------------

class TXNWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zera_txn.TXNWrapper) */ {
 public:
  inline TXNWrapper() : TXNWrapper(nullptr) {}
  ~TXNWrapper() override;
  explicit PROTOBUF_CONSTEXPR TXNWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TXNWrapper(const TXNWrapper& from);
  TXNWrapper(TXNWrapper&& from) noexcept
    : TXNWrapper() {
    *this = ::std::move(from);
  }

  inline TXNWrapper& operator=(const TXNWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXNWrapper& operator=(TXNWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TXNWrapper& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kCoinTxn = 1,
    kMintTxn = 2,
    kItemMintTxn = 3,
    kContractTxn = 4,
    kGovernanceVote = 5,
    kGovernanceProposal = 6,
    kSmartContract = 7,
    kSmartContractExecute = 8,
    kSelfCurEquivs = 9,
    kAuthCurEquivs = 10,
    kExpenseRatios = 11,
    kNftTxn = 12,
    kContractUpdateTxn = 13,
    kValidatorRegistrationTxn = 14,
    kValidatorHeartbeatTxn = 15,
    kFoundationTxn = 16,
    kDelegatedVotingTxn = 17,
    kQuashTxn = 18,
    kFastQuorumTxn = 19,
    kRevokeTxn = 20,
    kComplianceTxn = 21,
    kProposalResultTxn = 22,
    kBurnSbtTxn = 23,
    kRequiredVersionTxn = 24,
    kSmartContractInstantiateTxn = 25,
    kAllowanceTxn = 30,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const TXNWrapper* internal_default_instance() {
    return reinterpret_cast<const TXNWrapper*>(
               &_TXNWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(TXNWrapper& a, TXNWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(TXNWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXNWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TXNWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TXNWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TXNWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TXNWrapper& from) {
    TXNWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXNWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zera_txn.TXNWrapper";
  }
  protected:
  explicit TXNWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalIdsFieldNumber = 27,
    kProposalContractsFieldNumber = 28,
    kTxnTypeFieldNumber = 26,
    kSmartContractTxnFieldNumber = 29,
    kCoinTxnFieldNumber = 1,
    kMintTxnFieldNumber = 2,
    kItemMintTxnFieldNumber = 3,
    kContractTxnFieldNumber = 4,
    kGovernanceVoteFieldNumber = 5,
    kGovernanceProposalFieldNumber = 6,
    kSmartContractFieldNumber = 7,
    kSmartContractExecuteFieldNumber = 8,
    kSelfCurEquivsFieldNumber = 9,
    kAuthCurEquivsFieldNumber = 10,
    kExpenseRatiosFieldNumber = 11,
    kNftTxnFieldNumber = 12,
    kContractUpdateTxnFieldNumber = 13,
    kValidatorRegistrationTxnFieldNumber = 14,
    kValidatorHeartbeatTxnFieldNumber = 15,
    kFoundationTxnFieldNumber = 16,
    kDelegatedVotingTxnFieldNumber = 17,
    kQuashTxnFieldNumber = 18,
    kFastQuorumTxnFieldNumber = 19,
    kRevokeTxnFieldNumber = 20,
    kComplianceTxnFieldNumber = 21,
    kProposalResultTxnFieldNumber = 22,
    kBurnSbtTxnFieldNumber = 23,
    kRequiredVersionTxnFieldNumber = 24,
    kSmartContractInstantiateTxnFieldNumber = 25,
    kAllowanceTxnFieldNumber = 30,
  };
  // repeated bytes proposal_ids = 27;
  int proposal_ids_size() const;
  private:
  int _internal_proposal_ids_size() const;
  public:
  void clear_proposal_ids();
  const std::string& proposal_ids(int index) const;
  std::string* mutable_proposal_ids(int index);
  void set_proposal_ids(int index, const std::string& value);
  void set_proposal_ids(int index, std::string&& value);
  void set_proposal_ids(int index, const char* value);
  void set_proposal_ids(int index, const void* value, size_t size);
  std::string* add_proposal_ids();
  void add_proposal_ids(const std::string& value);
  void add_proposal_ids(std::string&& value);
  void add_proposal_ids(const char* value);
  void add_proposal_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proposal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proposal_ids();
  private:
  const std::string& _internal_proposal_ids(int index) const;
  std::string* _internal_add_proposal_ids();
  public:

  // repeated .zera_txn.ProposalContract proposal_contracts = 28;
  int proposal_contracts_size() const;
  private:
  int _internal_proposal_contracts_size() const;
  public:
  void clear_proposal_contracts();
  ::zera_txn::ProposalContract* mutable_proposal_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalContract >*
      mutable_proposal_contracts();
  private:
  const ::zera_txn::ProposalContract& _internal_proposal_contracts(int index) const;
  ::zera_txn::ProposalContract* _internal_add_proposal_contracts();
  public:
  const ::zera_txn::ProposalContract& proposal_contracts(int index) const;
  ::zera_txn::ProposalContract* add_proposal_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalContract >&
      proposal_contracts() const;

  // .zera_txn.TRANSACTION_TYPE txn_type = 26;
  void clear_txn_type();
  ::zera_txn::TRANSACTION_TYPE txn_type() const;
  void set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  private:
  ::zera_txn::TRANSACTION_TYPE _internal_txn_type() const;
  void _internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value);
  public:

  // optional bool smart_contract_txn = 29;
  bool has_smart_contract_txn() const;
  private:
  bool _internal_has_smart_contract_txn() const;
  public:
  void clear_smart_contract_txn();
  bool smart_contract_txn() const;
  void set_smart_contract_txn(bool value);
  private:
  bool _internal_smart_contract_txn() const;
  void _internal_set_smart_contract_txn(bool value);
  public:

  // .zera_txn.CoinTXN coin_txn = 1;
  bool has_coin_txn() const;
  private:
  bool _internal_has_coin_txn() const;
  public:
  void clear_coin_txn();
  const ::zera_txn::CoinTXN& coin_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::CoinTXN* release_coin_txn();
  ::zera_txn::CoinTXN* mutable_coin_txn();
  void set_allocated_coin_txn(::zera_txn::CoinTXN* coin_txn);
  private:
  const ::zera_txn::CoinTXN& _internal_coin_txn() const;
  ::zera_txn::CoinTXN* _internal_mutable_coin_txn();
  public:
  void unsafe_arena_set_allocated_coin_txn(
      ::zera_txn::CoinTXN* coin_txn);
  ::zera_txn::CoinTXN* unsafe_arena_release_coin_txn();

  // .zera_txn.MintTXN mint_txn = 2;
  bool has_mint_txn() const;
  private:
  bool _internal_has_mint_txn() const;
  public:
  void clear_mint_txn();
  const ::zera_txn::MintTXN& mint_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::MintTXN* release_mint_txn();
  ::zera_txn::MintTXN* mutable_mint_txn();
  void set_allocated_mint_txn(::zera_txn::MintTXN* mint_txn);
  private:
  const ::zera_txn::MintTXN& _internal_mint_txn() const;
  ::zera_txn::MintTXN* _internal_mutable_mint_txn();
  public:
  void unsafe_arena_set_allocated_mint_txn(
      ::zera_txn::MintTXN* mint_txn);
  ::zera_txn::MintTXN* unsafe_arena_release_mint_txn();

  // .zera_txn.ItemizedMintTXN item_mint_txn = 3;
  bool has_item_mint_txn() const;
  private:
  bool _internal_has_item_mint_txn() const;
  public:
  void clear_item_mint_txn();
  const ::zera_txn::ItemizedMintTXN& item_mint_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::ItemizedMintTXN* release_item_mint_txn();
  ::zera_txn::ItemizedMintTXN* mutable_item_mint_txn();
  void set_allocated_item_mint_txn(::zera_txn::ItemizedMintTXN* item_mint_txn);
  private:
  const ::zera_txn::ItemizedMintTXN& _internal_item_mint_txn() const;
  ::zera_txn::ItemizedMintTXN* _internal_mutable_item_mint_txn();
  public:
  void unsafe_arena_set_allocated_item_mint_txn(
      ::zera_txn::ItemizedMintTXN* item_mint_txn);
  ::zera_txn::ItemizedMintTXN* unsafe_arena_release_item_mint_txn();

  // .zera_txn.InstrumentContract contract_txn = 4;
  bool has_contract_txn() const;
  private:
  bool _internal_has_contract_txn() const;
  public:
  void clear_contract_txn();
  const ::zera_txn::InstrumentContract& contract_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::InstrumentContract* release_contract_txn();
  ::zera_txn::InstrumentContract* mutable_contract_txn();
  void set_allocated_contract_txn(::zera_txn::InstrumentContract* contract_txn);
  private:
  const ::zera_txn::InstrumentContract& _internal_contract_txn() const;
  ::zera_txn::InstrumentContract* _internal_mutable_contract_txn();
  public:
  void unsafe_arena_set_allocated_contract_txn(
      ::zera_txn::InstrumentContract* contract_txn);
  ::zera_txn::InstrumentContract* unsafe_arena_release_contract_txn();

  // .zera_txn.GovernanceVote governance_vote = 5;
  bool has_governance_vote() const;
  private:
  bool _internal_has_governance_vote() const;
  public:
  void clear_governance_vote();
  const ::zera_txn::GovernanceVote& governance_vote() const;
  PROTOBUF_NODISCARD ::zera_txn::GovernanceVote* release_governance_vote();
  ::zera_txn::GovernanceVote* mutable_governance_vote();
  void set_allocated_governance_vote(::zera_txn::GovernanceVote* governance_vote);
  private:
  const ::zera_txn::GovernanceVote& _internal_governance_vote() const;
  ::zera_txn::GovernanceVote* _internal_mutable_governance_vote();
  public:
  void unsafe_arena_set_allocated_governance_vote(
      ::zera_txn::GovernanceVote* governance_vote);
  ::zera_txn::GovernanceVote* unsafe_arena_release_governance_vote();

  // .zera_txn.GovernanceProposal governance_proposal = 6;
  bool has_governance_proposal() const;
  private:
  bool _internal_has_governance_proposal() const;
  public:
  void clear_governance_proposal();
  const ::zera_txn::GovernanceProposal& governance_proposal() const;
  PROTOBUF_NODISCARD ::zera_txn::GovernanceProposal* release_governance_proposal();
  ::zera_txn::GovernanceProposal* mutable_governance_proposal();
  void set_allocated_governance_proposal(::zera_txn::GovernanceProposal* governance_proposal);
  private:
  const ::zera_txn::GovernanceProposal& _internal_governance_proposal() const;
  ::zera_txn::GovernanceProposal* _internal_mutable_governance_proposal();
  public:
  void unsafe_arena_set_allocated_governance_proposal(
      ::zera_txn::GovernanceProposal* governance_proposal);
  ::zera_txn::GovernanceProposal* unsafe_arena_release_governance_proposal();

  // .zera_txn.SmartContractTXN smart_contract = 7;
  bool has_smart_contract() const;
  private:
  bool _internal_has_smart_contract() const;
  public:
  void clear_smart_contract();
  const ::zera_txn::SmartContractTXN& smart_contract() const;
  PROTOBUF_NODISCARD ::zera_txn::SmartContractTXN* release_smart_contract();
  ::zera_txn::SmartContractTXN* mutable_smart_contract();
  void set_allocated_smart_contract(::zera_txn::SmartContractTXN* smart_contract);
  private:
  const ::zera_txn::SmartContractTXN& _internal_smart_contract() const;
  ::zera_txn::SmartContractTXN* _internal_mutable_smart_contract();
  public:
  void unsafe_arena_set_allocated_smart_contract(
      ::zera_txn::SmartContractTXN* smart_contract);
  ::zera_txn::SmartContractTXN* unsafe_arena_release_smart_contract();

  // .zera_txn.SmartContractExecuteTXN smart_contract_execute = 8;
  bool has_smart_contract_execute() const;
  private:
  bool _internal_has_smart_contract_execute() const;
  public:
  void clear_smart_contract_execute();
  const ::zera_txn::SmartContractExecuteTXN& smart_contract_execute() const;
  PROTOBUF_NODISCARD ::zera_txn::SmartContractExecuteTXN* release_smart_contract_execute();
  ::zera_txn::SmartContractExecuteTXN* mutable_smart_contract_execute();
  void set_allocated_smart_contract_execute(::zera_txn::SmartContractExecuteTXN* smart_contract_execute);
  private:
  const ::zera_txn::SmartContractExecuteTXN& _internal_smart_contract_execute() const;
  ::zera_txn::SmartContractExecuteTXN* _internal_mutable_smart_contract_execute();
  public:
  void unsafe_arena_set_allocated_smart_contract_execute(
      ::zera_txn::SmartContractExecuteTXN* smart_contract_execute);
  ::zera_txn::SmartContractExecuteTXN* unsafe_arena_release_smart_contract_execute();

  // .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
  bool has_self_cur_equivs() const;
  private:
  bool _internal_has_self_cur_equivs() const;
  public:
  void clear_self_cur_equivs();
  const ::zera_txn::SelfCurrencyEquiv& self_cur_equivs() const;
  PROTOBUF_NODISCARD ::zera_txn::SelfCurrencyEquiv* release_self_cur_equivs();
  ::zera_txn::SelfCurrencyEquiv* mutable_self_cur_equivs();
  void set_allocated_self_cur_equivs(::zera_txn::SelfCurrencyEquiv* self_cur_equivs);
  private:
  const ::zera_txn::SelfCurrencyEquiv& _internal_self_cur_equivs() const;
  ::zera_txn::SelfCurrencyEquiv* _internal_mutable_self_cur_equivs();
  public:
  void unsafe_arena_set_allocated_self_cur_equivs(
      ::zera_txn::SelfCurrencyEquiv* self_cur_equivs);
  ::zera_txn::SelfCurrencyEquiv* unsafe_arena_release_self_cur_equivs();

  // .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
  bool has_auth_cur_equivs() const;
  private:
  bool _internal_has_auth_cur_equivs() const;
  public:
  void clear_auth_cur_equivs();
  const ::zera_txn::AuthorizedCurrencyEquiv& auth_cur_equivs() const;
  PROTOBUF_NODISCARD ::zera_txn::AuthorizedCurrencyEquiv* release_auth_cur_equivs();
  ::zera_txn::AuthorizedCurrencyEquiv* mutable_auth_cur_equivs();
  void set_allocated_auth_cur_equivs(::zera_txn::AuthorizedCurrencyEquiv* auth_cur_equivs);
  private:
  const ::zera_txn::AuthorizedCurrencyEquiv& _internal_auth_cur_equivs() const;
  ::zera_txn::AuthorizedCurrencyEquiv* _internal_mutable_auth_cur_equivs();
  public:
  void unsafe_arena_set_allocated_auth_cur_equivs(
      ::zera_txn::AuthorizedCurrencyEquiv* auth_cur_equivs);
  ::zera_txn::AuthorizedCurrencyEquiv* unsafe_arena_release_auth_cur_equivs();

  // .zera_txn.ExpenseRatioTXN expense_ratios = 11;
  bool has_expense_ratios() const;
  private:
  bool _internal_has_expense_ratios() const;
  public:
  void clear_expense_ratios();
  const ::zera_txn::ExpenseRatioTXN& expense_ratios() const;
  PROTOBUF_NODISCARD ::zera_txn::ExpenseRatioTXN* release_expense_ratios();
  ::zera_txn::ExpenseRatioTXN* mutable_expense_ratios();
  void set_allocated_expense_ratios(::zera_txn::ExpenseRatioTXN* expense_ratios);
  private:
  const ::zera_txn::ExpenseRatioTXN& _internal_expense_ratios() const;
  ::zera_txn::ExpenseRatioTXN* _internal_mutable_expense_ratios();
  public:
  void unsafe_arena_set_allocated_expense_ratios(
      ::zera_txn::ExpenseRatioTXN* expense_ratios);
  ::zera_txn::ExpenseRatioTXN* unsafe_arena_release_expense_ratios();

  // .zera_txn.NFTTXN nft_txn = 12;
  bool has_nft_txn() const;
  private:
  bool _internal_has_nft_txn() const;
  public:
  void clear_nft_txn();
  const ::zera_txn::NFTTXN& nft_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::NFTTXN* release_nft_txn();
  ::zera_txn::NFTTXN* mutable_nft_txn();
  void set_allocated_nft_txn(::zera_txn::NFTTXN* nft_txn);
  private:
  const ::zera_txn::NFTTXN& _internal_nft_txn() const;
  ::zera_txn::NFTTXN* _internal_mutable_nft_txn();
  public:
  void unsafe_arena_set_allocated_nft_txn(
      ::zera_txn::NFTTXN* nft_txn);
  ::zera_txn::NFTTXN* unsafe_arena_release_nft_txn();

  // .zera_txn.ContractUpdateTXN contract_update_txn = 13;
  bool has_contract_update_txn() const;
  private:
  bool _internal_has_contract_update_txn() const;
  public:
  void clear_contract_update_txn();
  const ::zera_txn::ContractUpdateTXN& contract_update_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::ContractUpdateTXN* release_contract_update_txn();
  ::zera_txn::ContractUpdateTXN* mutable_contract_update_txn();
  void set_allocated_contract_update_txn(::zera_txn::ContractUpdateTXN* contract_update_txn);
  private:
  const ::zera_txn::ContractUpdateTXN& _internal_contract_update_txn() const;
  ::zera_txn::ContractUpdateTXN* _internal_mutable_contract_update_txn();
  public:
  void unsafe_arena_set_allocated_contract_update_txn(
      ::zera_txn::ContractUpdateTXN* contract_update_txn);
  ::zera_txn::ContractUpdateTXN* unsafe_arena_release_contract_update_txn();

  // .zera_txn.ValidatorRegistration validator_registration_txn = 14;
  bool has_validator_registration_txn() const;
  private:
  bool _internal_has_validator_registration_txn() const;
  public:
  void clear_validator_registration_txn();
  const ::zera_txn::ValidatorRegistration& validator_registration_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::ValidatorRegistration* release_validator_registration_txn();
  ::zera_txn::ValidatorRegistration* mutable_validator_registration_txn();
  void set_allocated_validator_registration_txn(::zera_txn::ValidatorRegistration* validator_registration_txn);
  private:
  const ::zera_txn::ValidatorRegistration& _internal_validator_registration_txn() const;
  ::zera_txn::ValidatorRegistration* _internal_mutable_validator_registration_txn();
  public:
  void unsafe_arena_set_allocated_validator_registration_txn(
      ::zera_txn::ValidatorRegistration* validator_registration_txn);
  ::zera_txn::ValidatorRegistration* unsafe_arena_release_validator_registration_txn();

  // .zera_txn.ValidatorHeartbeat validator_heartbeat_txn = 15;
  bool has_validator_heartbeat_txn() const;
  private:
  bool _internal_has_validator_heartbeat_txn() const;
  public:
  void clear_validator_heartbeat_txn();
  const ::zera_txn::ValidatorHeartbeat& validator_heartbeat_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::ValidatorHeartbeat* release_validator_heartbeat_txn();
  ::zera_txn::ValidatorHeartbeat* mutable_validator_heartbeat_txn();
  void set_allocated_validator_heartbeat_txn(::zera_txn::ValidatorHeartbeat* validator_heartbeat_txn);
  private:
  const ::zera_txn::ValidatorHeartbeat& _internal_validator_heartbeat_txn() const;
  ::zera_txn::ValidatorHeartbeat* _internal_mutable_validator_heartbeat_txn();
  public:
  void unsafe_arena_set_allocated_validator_heartbeat_txn(
      ::zera_txn::ValidatorHeartbeat* validator_heartbeat_txn);
  ::zera_txn::ValidatorHeartbeat* unsafe_arena_release_validator_heartbeat_txn();

  // .zera_txn.FoundationTXN foundation_txn = 16;
  bool has_foundation_txn() const;
  private:
  bool _internal_has_foundation_txn() const;
  public:
  void clear_foundation_txn();
  const ::zera_txn::FoundationTXN& foundation_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::FoundationTXN* release_foundation_txn();
  ::zera_txn::FoundationTXN* mutable_foundation_txn();
  void set_allocated_foundation_txn(::zera_txn::FoundationTXN* foundation_txn);
  private:
  const ::zera_txn::FoundationTXN& _internal_foundation_txn() const;
  ::zera_txn::FoundationTXN* _internal_mutable_foundation_txn();
  public:
  void unsafe_arena_set_allocated_foundation_txn(
      ::zera_txn::FoundationTXN* foundation_txn);
  ::zera_txn::FoundationTXN* unsafe_arena_release_foundation_txn();

  // .zera_txn.DelegatedTXN delegated_voting_txn = 17;
  bool has_delegated_voting_txn() const;
  private:
  bool _internal_has_delegated_voting_txn() const;
  public:
  void clear_delegated_voting_txn();
  const ::zera_txn::DelegatedTXN& delegated_voting_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::DelegatedTXN* release_delegated_voting_txn();
  ::zera_txn::DelegatedTXN* mutable_delegated_voting_txn();
  void set_allocated_delegated_voting_txn(::zera_txn::DelegatedTXN* delegated_voting_txn);
  private:
  const ::zera_txn::DelegatedTXN& _internal_delegated_voting_txn() const;
  ::zera_txn::DelegatedTXN* _internal_mutable_delegated_voting_txn();
  public:
  void unsafe_arena_set_allocated_delegated_voting_txn(
      ::zera_txn::DelegatedTXN* delegated_voting_txn);
  ::zera_txn::DelegatedTXN* unsafe_arena_release_delegated_voting_txn();

  // .zera_txn.QuashTXN quash_txn = 18;
  bool has_quash_txn() const;
  private:
  bool _internal_has_quash_txn() const;
  public:
  void clear_quash_txn();
  const ::zera_txn::QuashTXN& quash_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::QuashTXN* release_quash_txn();
  ::zera_txn::QuashTXN* mutable_quash_txn();
  void set_allocated_quash_txn(::zera_txn::QuashTXN* quash_txn);
  private:
  const ::zera_txn::QuashTXN& _internal_quash_txn() const;
  ::zera_txn::QuashTXN* _internal_mutable_quash_txn();
  public:
  void unsafe_arena_set_allocated_quash_txn(
      ::zera_txn::QuashTXN* quash_txn);
  ::zera_txn::QuashTXN* unsafe_arena_release_quash_txn();

  // .zera_txn.FastQuorumTXN fast_quorum_txn = 19;
  bool has_fast_quorum_txn() const;
  private:
  bool _internal_has_fast_quorum_txn() const;
  public:
  void clear_fast_quorum_txn();
  const ::zera_txn::FastQuorumTXN& fast_quorum_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::FastQuorumTXN* release_fast_quorum_txn();
  ::zera_txn::FastQuorumTXN* mutable_fast_quorum_txn();
  void set_allocated_fast_quorum_txn(::zera_txn::FastQuorumTXN* fast_quorum_txn);
  private:
  const ::zera_txn::FastQuorumTXN& _internal_fast_quorum_txn() const;
  ::zera_txn::FastQuorumTXN* _internal_mutable_fast_quorum_txn();
  public:
  void unsafe_arena_set_allocated_fast_quorum_txn(
      ::zera_txn::FastQuorumTXN* fast_quorum_txn);
  ::zera_txn::FastQuorumTXN* unsafe_arena_release_fast_quorum_txn();

  // .zera_txn.RevokeTXN revoke_txn = 20;
  bool has_revoke_txn() const;
  private:
  bool _internal_has_revoke_txn() const;
  public:
  void clear_revoke_txn();
  const ::zera_txn::RevokeTXN& revoke_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::RevokeTXN* release_revoke_txn();
  ::zera_txn::RevokeTXN* mutable_revoke_txn();
  void set_allocated_revoke_txn(::zera_txn::RevokeTXN* revoke_txn);
  private:
  const ::zera_txn::RevokeTXN& _internal_revoke_txn() const;
  ::zera_txn::RevokeTXN* _internal_mutable_revoke_txn();
  public:
  void unsafe_arena_set_allocated_revoke_txn(
      ::zera_txn::RevokeTXN* revoke_txn);
  ::zera_txn::RevokeTXN* unsafe_arena_release_revoke_txn();

  // .zera_txn.ComplianceTXN compliance_txn = 21;
  bool has_compliance_txn() const;
  private:
  bool _internal_has_compliance_txn() const;
  public:
  void clear_compliance_txn();
  const ::zera_txn::ComplianceTXN& compliance_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::ComplianceTXN* release_compliance_txn();
  ::zera_txn::ComplianceTXN* mutable_compliance_txn();
  void set_allocated_compliance_txn(::zera_txn::ComplianceTXN* compliance_txn);
  private:
  const ::zera_txn::ComplianceTXN& _internal_compliance_txn() const;
  ::zera_txn::ComplianceTXN* _internal_mutable_compliance_txn();
  public:
  void unsafe_arena_set_allocated_compliance_txn(
      ::zera_txn::ComplianceTXN* compliance_txn);
  ::zera_txn::ComplianceTXN* unsafe_arena_release_compliance_txn();

  // bool proposal_result_txn = 22;
  bool has_proposal_result_txn() const;
  private:
  bool _internal_has_proposal_result_txn() const;
  public:
  void clear_proposal_result_txn();
  bool proposal_result_txn() const;
  void set_proposal_result_txn(bool value);
  private:
  bool _internal_proposal_result_txn() const;
  void _internal_set_proposal_result_txn(bool value);
  public:

  // .zera_txn.BurnSBTTXN burn_sbt_txn = 23;
  bool has_burn_sbt_txn() const;
  private:
  bool _internal_has_burn_sbt_txn() const;
  public:
  void clear_burn_sbt_txn();
  const ::zera_txn::BurnSBTTXN& burn_sbt_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::BurnSBTTXN* release_burn_sbt_txn();
  ::zera_txn::BurnSBTTXN* mutable_burn_sbt_txn();
  void set_allocated_burn_sbt_txn(::zera_txn::BurnSBTTXN* burn_sbt_txn);
  private:
  const ::zera_txn::BurnSBTTXN& _internal_burn_sbt_txn() const;
  ::zera_txn::BurnSBTTXN* _internal_mutable_burn_sbt_txn();
  public:
  void unsafe_arena_set_allocated_burn_sbt_txn(
      ::zera_txn::BurnSBTTXN* burn_sbt_txn);
  ::zera_txn::BurnSBTTXN* unsafe_arena_release_burn_sbt_txn();

  // .zera_txn.RequiredVersion required_version_txn = 24;
  bool has_required_version_txn() const;
  private:
  bool _internal_has_required_version_txn() const;
  public:
  void clear_required_version_txn();
  const ::zera_txn::RequiredVersion& required_version_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::RequiredVersion* release_required_version_txn();
  ::zera_txn::RequiredVersion* mutable_required_version_txn();
  void set_allocated_required_version_txn(::zera_txn::RequiredVersion* required_version_txn);
  private:
  const ::zera_txn::RequiredVersion& _internal_required_version_txn() const;
  ::zera_txn::RequiredVersion* _internal_mutable_required_version_txn();
  public:
  void unsafe_arena_set_allocated_required_version_txn(
      ::zera_txn::RequiredVersion* required_version_txn);
  ::zera_txn::RequiredVersion* unsafe_arena_release_required_version_txn();

  // .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txn = 25;
  bool has_smart_contract_instantiate_txn() const;
  private:
  bool _internal_has_smart_contract_instantiate_txn() const;
  public:
  void clear_smart_contract_instantiate_txn();
  const ::zera_txn::SmartContractInstantiateTXN& smart_contract_instantiate_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::SmartContractInstantiateTXN* release_smart_contract_instantiate_txn();
  ::zera_txn::SmartContractInstantiateTXN* mutable_smart_contract_instantiate_txn();
  void set_allocated_smart_contract_instantiate_txn(::zera_txn::SmartContractInstantiateTXN* smart_contract_instantiate_txn);
  private:
  const ::zera_txn::SmartContractInstantiateTXN& _internal_smart_contract_instantiate_txn() const;
  ::zera_txn::SmartContractInstantiateTXN* _internal_mutable_smart_contract_instantiate_txn();
  public:
  void unsafe_arena_set_allocated_smart_contract_instantiate_txn(
      ::zera_txn::SmartContractInstantiateTXN* smart_contract_instantiate_txn);
  ::zera_txn::SmartContractInstantiateTXN* unsafe_arena_release_smart_contract_instantiate_txn();

  // .zera_txn.AllowanceTXN allowance_txn = 30;
  bool has_allowance_txn() const;
  private:
  bool _internal_has_allowance_txn() const;
  public:
  void clear_allowance_txn();
  const ::zera_txn::AllowanceTXN& allowance_txn() const;
  PROTOBUF_NODISCARD ::zera_txn::AllowanceTXN* release_allowance_txn();
  ::zera_txn::AllowanceTXN* mutable_allowance_txn();
  void set_allocated_allowance_txn(::zera_txn::AllowanceTXN* allowance_txn);
  private:
  const ::zera_txn::AllowanceTXN& _internal_allowance_txn() const;
  ::zera_txn::AllowanceTXN* _internal_mutable_allowance_txn();
  public:
  void unsafe_arena_set_allocated_allowance_txn(
      ::zera_txn::AllowanceTXN* allowance_txn);
  ::zera_txn::AllowanceTXN* unsafe_arena_release_allowance_txn();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:zera_txn.TXNWrapper)
 private:
  class _Internal;
  void set_has_coin_txn();
  void set_has_mint_txn();
  void set_has_item_mint_txn();
  void set_has_contract_txn();
  void set_has_governance_vote();
  void set_has_governance_proposal();
  void set_has_smart_contract();
  void set_has_smart_contract_execute();
  void set_has_self_cur_equivs();
  void set_has_auth_cur_equivs();
  void set_has_expense_ratios();
  void set_has_nft_txn();
  void set_has_contract_update_txn();
  void set_has_validator_registration_txn();
  void set_has_validator_heartbeat_txn();
  void set_has_foundation_txn();
  void set_has_delegated_voting_txn();
  void set_has_quash_txn();
  void set_has_fast_quorum_txn();
  void set_has_revoke_txn();
  void set_has_compliance_txn();
  void set_has_proposal_result_txn();
  void set_has_burn_sbt_txn();
  void set_has_required_version_txn();
  void set_has_smart_contract_instantiate_txn();
  void set_has_allowance_txn();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proposal_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalContract > proposal_contracts_;
    int txn_type_;
    bool smart_contract_txn_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zera_txn::CoinTXN* coin_txn_;
      ::zera_txn::MintTXN* mint_txn_;
      ::zera_txn::ItemizedMintTXN* item_mint_txn_;
      ::zera_txn::InstrumentContract* contract_txn_;
      ::zera_txn::GovernanceVote* governance_vote_;
      ::zera_txn::GovernanceProposal* governance_proposal_;
      ::zera_txn::SmartContractTXN* smart_contract_;
      ::zera_txn::SmartContractExecuteTXN* smart_contract_execute_;
      ::zera_txn::SelfCurrencyEquiv* self_cur_equivs_;
      ::zera_txn::AuthorizedCurrencyEquiv* auth_cur_equivs_;
      ::zera_txn::ExpenseRatioTXN* expense_ratios_;
      ::zera_txn::NFTTXN* nft_txn_;
      ::zera_txn::ContractUpdateTXN* contract_update_txn_;
      ::zera_txn::ValidatorRegistration* validator_registration_txn_;
      ::zera_txn::ValidatorHeartbeat* validator_heartbeat_txn_;
      ::zera_txn::FoundationTXN* foundation_txn_;
      ::zera_txn::DelegatedTXN* delegated_voting_txn_;
      ::zera_txn::QuashTXN* quash_txn_;
      ::zera_txn::FastQuorumTXN* fast_quorum_txn_;
      ::zera_txn::RevokeTXN* revoke_txn_;
      ::zera_txn::ComplianceTXN* compliance_txn_;
      bool proposal_result_txn_;
      ::zera_txn::BurnSBTTXN* burn_sbt_txn_;
      ::zera_txn::RequiredVersion* required_version_txn_;
      ::zera_txn::SmartContractInstantiateTXN* smart_contract_instantiate_txn_;
      ::zera_txn::AllowanceTXN* allowance_txn_;
    } payload_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_txn_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DelegateContract

// int32 priority = 1;
inline void DelegateContract::clear_priority() {
  _impl_.priority_ = 0;
}
inline int32_t DelegateContract::_internal_priority() const {
  return _impl_.priority_;
}
inline int32_t DelegateContract::priority() const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegateContract.priority)
  return _internal_priority();
}
inline void DelegateContract::_internal_set_priority(int32_t value) {
  
  _impl_.priority_ = value;
}
inline void DelegateContract::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:zera_txn.DelegateContract.priority)
}

// string contract_id = 2;
inline void DelegateContract::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& DelegateContract::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegateContract.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateContract::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.DelegateContract.contract_id)
}
inline std::string* DelegateContract::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegateContract.contract_id)
  return _s;
}
inline const std::string& DelegateContract::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void DelegateContract::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegateContract::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DelegateContract::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.DelegateContract.contract_id)
  return _impl_.contract_id_.Release();
}
inline void DelegateContract::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.DelegateContract.contract_id)
}

// -------------------------------------------------------------------

// DelegatedTXN

// .zera_txn.BaseTXN base = 1;
inline bool DelegatedTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool DelegatedTXN::has_base() const {
  return _internal_has_base();
}
inline void DelegatedTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& DelegatedTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& DelegatedTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegatedTXN.base)
  return _internal_base();
}
inline void DelegatedTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.DelegatedTXN.base)
}
inline ::zera_txn::BaseTXN* DelegatedTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* DelegatedTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.DelegatedTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* DelegatedTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* DelegatedTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegatedTXN.base)
  return _msg;
}
inline void DelegatedTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.DelegatedTXN.base)
}

// repeated .zera_txn.DelegateVote delegate_votes = 2;
inline int DelegatedTXN::_internal_delegate_votes_size() const {
  return _impl_.delegate_votes_.size();
}
inline int DelegatedTXN::delegate_votes_size() const {
  return _internal_delegate_votes_size();
}
inline void DelegatedTXN::clear_delegate_votes() {
  _impl_.delegate_votes_.Clear();
}
inline ::zera_txn::DelegateVote* DelegatedTXN::mutable_delegate_votes(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegatedTXN.delegate_votes)
  return _impl_.delegate_votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateVote >*
DelegatedTXN::mutable_delegate_votes() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.DelegatedTXN.delegate_votes)
  return &_impl_.delegate_votes_;
}
inline const ::zera_txn::DelegateVote& DelegatedTXN::_internal_delegate_votes(int index) const {
  return _impl_.delegate_votes_.Get(index);
}
inline const ::zera_txn::DelegateVote& DelegatedTXN::delegate_votes(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegatedTXN.delegate_votes)
  return _internal_delegate_votes(index);
}
inline ::zera_txn::DelegateVote* DelegatedTXN::_internal_add_delegate_votes() {
  return _impl_.delegate_votes_.Add();
}
inline ::zera_txn::DelegateVote* DelegatedTXN::add_delegate_votes() {
  ::zera_txn::DelegateVote* _add = _internal_add_delegate_votes();
  // @@protoc_insertion_point(field_add:zera_txn.DelegatedTXN.delegate_votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateVote >&
DelegatedTXN::delegate_votes() const {
  // @@protoc_insertion_point(field_list:zera_txn.DelegatedTXN.delegate_votes)
  return _impl_.delegate_votes_;
}

// repeated .zera_txn.DelegateFees delegate_fees = 3;
inline int DelegatedTXN::_internal_delegate_fees_size() const {
  return _impl_.delegate_fees_.size();
}
inline int DelegatedTXN::delegate_fees_size() const {
  return _internal_delegate_fees_size();
}
inline void DelegatedTXN::clear_delegate_fees() {
  _impl_.delegate_fees_.Clear();
}
inline ::zera_txn::DelegateFees* DelegatedTXN::mutable_delegate_fees(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegatedTXN.delegate_fees)
  return _impl_.delegate_fees_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateFees >*
DelegatedTXN::mutable_delegate_fees() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.DelegatedTXN.delegate_fees)
  return &_impl_.delegate_fees_;
}
inline const ::zera_txn::DelegateFees& DelegatedTXN::_internal_delegate_fees(int index) const {
  return _impl_.delegate_fees_.Get(index);
}
inline const ::zera_txn::DelegateFees& DelegatedTXN::delegate_fees(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegatedTXN.delegate_fees)
  return _internal_delegate_fees(index);
}
inline ::zera_txn::DelegateFees* DelegatedTXN::_internal_add_delegate_fees() {
  return _impl_.delegate_fees_.Add();
}
inline ::zera_txn::DelegateFees* DelegatedTXN::add_delegate_fees() {
  ::zera_txn::DelegateFees* _add = _internal_add_delegate_fees();
  // @@protoc_insertion_point(field_add:zera_txn.DelegatedTXN.delegate_fees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateFees >&
DelegatedTXN::delegate_fees() const {
  // @@protoc_insertion_point(field_list:zera_txn.DelegatedTXN.delegate_fees)
  return _impl_.delegate_fees_;
}

// -------------------------------------------------------------------

// DelegateVote

// bytes address = 1;
inline void DelegateVote::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& DelegateVote::address() const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegateVote.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateVote::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.DelegateVote.address)
}
inline std::string* DelegateVote::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegateVote.address)
  return _s;
}
inline const std::string& DelegateVote::_internal_address() const {
  return _impl_.address_.Get();
}
inline void DelegateVote::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegateVote::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* DelegateVote::release_address() {
  // @@protoc_insertion_point(field_release:zera_txn.DelegateVote.address)
  return _impl_.address_.Release();
}
inline void DelegateVote::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.DelegateVote.address)
}

// repeated .zera_txn.DelegateContract contracts = 2;
inline int DelegateVote::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int DelegateVote::contracts_size() const {
  return _internal_contracts_size();
}
inline void DelegateVote::clear_contracts() {
  _impl_.contracts_.Clear();
}
inline ::zera_txn::DelegateContract* DelegateVote::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegateVote.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateContract >*
DelegateVote::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.DelegateVote.contracts)
  return &_impl_.contracts_;
}
inline const ::zera_txn::DelegateContract& DelegateVote::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::zera_txn::DelegateContract& DelegateVote::contracts(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegateVote.contracts)
  return _internal_contracts(index);
}
inline ::zera_txn::DelegateContract* DelegateVote::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::zera_txn::DelegateContract* DelegateVote::add_contracts() {
  ::zera_txn::DelegateContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:zera_txn.DelegateVote.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegateContract >&
DelegateVote::contracts() const {
  // @@protoc_insertion_point(field_list:zera_txn.DelegateVote.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// DelegateFees

// string contract_id = 1;
inline void DelegateFees::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& DelegateFees::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegateFees.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateFees::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.DelegateFees.contract_id)
}
inline std::string* DelegateFees::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegateFees.contract_id)
  return _s;
}
inline const std::string& DelegateFees::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void DelegateFees::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegateFees::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DelegateFees::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.DelegateFees.contract_id)
  return _impl_.contract_id_.Release();
}
inline void DelegateFees::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.DelegateFees.contract_id)
}

// string auth_amount = 2;
inline void DelegateFees::clear_auth_amount() {
  _impl_.auth_amount_.ClearToEmpty();
}
inline const std::string& DelegateFees::auth_amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegateFees.auth_amount)
  return _internal_auth_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateFees::set_auth_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.DelegateFees.auth_amount)
}
inline std::string* DelegateFees::mutable_auth_amount() {
  std::string* _s = _internal_mutable_auth_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegateFees.auth_amount)
  return _s;
}
inline const std::string& DelegateFees::_internal_auth_amount() const {
  return _impl_.auth_amount_.Get();
}
inline void DelegateFees::_internal_set_auth_amount(const std::string& value) {
  
  _impl_.auth_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegateFees::_internal_mutable_auth_amount() {
  
  return _impl_.auth_amount_.Mutable(GetArenaForAllocation());
}
inline std::string* DelegateFees::release_auth_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.DelegateFees.auth_amount)
  return _impl_.auth_amount_.Release();
}
inline void DelegateFees::set_allocated_auth_amount(std::string* auth_amount) {
  if (auth_amount != nullptr) {
    
  } else {
    
  }
  _impl_.auth_amount_.SetAllocated(auth_amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_amount_.IsDefault()) {
    _impl_.auth_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.DelegateFees.auth_amount)
}

// -------------------------------------------------------------------

// Compliance

// string contract_id = 1;
inline void Compliance::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& Compliance::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.Compliance.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Compliance::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Compliance.contract_id)
}
inline std::string* Compliance::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.Compliance.contract_id)
  return _s;
}
inline const std::string& Compliance::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void Compliance::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Compliance::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Compliance::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.Compliance.contract_id)
  return _impl_.contract_id_.Release();
}
inline void Compliance::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Compliance.contract_id)
}

// uint32 compliance_level = 2;
inline void Compliance::clear_compliance_level() {
  _impl_.compliance_level_ = 0u;
}
inline uint32_t Compliance::_internal_compliance_level() const {
  return _impl_.compliance_level_;
}
inline uint32_t Compliance::compliance_level() const {
  // @@protoc_insertion_point(field_get:zera_txn.Compliance.compliance_level)
  return _internal_compliance_level();
}
inline void Compliance::_internal_set_compliance_level(uint32_t value) {
  
  _impl_.compliance_level_ = value;
}
inline void Compliance::set_compliance_level(uint32_t value) {
  _internal_set_compliance_level(value);
  // @@protoc_insertion_point(field_set:zera_txn.Compliance.compliance_level)
}

// -------------------------------------------------------------------

// TokenCompliance

// repeated .zera_txn.Compliance compliance = 1;
inline int TokenCompliance::_internal_compliance_size() const {
  return _impl_.compliance_.size();
}
inline int TokenCompliance::compliance_size() const {
  return _internal_compliance_size();
}
inline void TokenCompliance::clear_compliance() {
  _impl_.compliance_.Clear();
}
inline ::zera_txn::Compliance* TokenCompliance::mutable_compliance(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TokenCompliance.compliance)
  return _impl_.compliance_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Compliance >*
TokenCompliance::mutable_compliance() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TokenCompliance.compliance)
  return &_impl_.compliance_;
}
inline const ::zera_txn::Compliance& TokenCompliance::_internal_compliance(int index) const {
  return _impl_.compliance_.Get(index);
}
inline const ::zera_txn::Compliance& TokenCompliance::compliance(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TokenCompliance.compliance)
  return _internal_compliance(index);
}
inline ::zera_txn::Compliance* TokenCompliance::_internal_add_compliance() {
  return _impl_.compliance_.Add();
}
inline ::zera_txn::Compliance* TokenCompliance::add_compliance() {
  ::zera_txn::Compliance* _add = _internal_add_compliance();
  // @@protoc_insertion_point(field_add:zera_txn.TokenCompliance.compliance)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Compliance >&
TokenCompliance::compliance() const {
  // @@protoc_insertion_point(field_list:zera_txn.TokenCompliance.compliance)
  return _impl_.compliance_;
}

// -------------------------------------------------------------------

// ExpenseRatio

// uint32 day = 1;
inline void ExpenseRatio::clear_day() {
  _impl_.day_ = 0u;
}
inline uint32_t ExpenseRatio::_internal_day() const {
  return _impl_.day_;
}
inline uint32_t ExpenseRatio::day() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatio.day)
  return _internal_day();
}
inline void ExpenseRatio::_internal_set_day(uint32_t value) {
  
  _impl_.day_ = value;
}
inline void ExpenseRatio::set_day(uint32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatio.day)
}

// uint32 month = 2;
inline void ExpenseRatio::clear_month() {
  _impl_.month_ = 0u;
}
inline uint32_t ExpenseRatio::_internal_month() const {
  return _impl_.month_;
}
inline uint32_t ExpenseRatio::month() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatio.month)
  return _internal_month();
}
inline void ExpenseRatio::_internal_set_month(uint32_t value) {
  
  _impl_.month_ = value;
}
inline void ExpenseRatio::set_month(uint32_t value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatio.month)
}

// uint32 percent = 3;
inline void ExpenseRatio::clear_percent() {
  _impl_.percent_ = 0u;
}
inline uint32_t ExpenseRatio::_internal_percent() const {
  return _impl_.percent_;
}
inline uint32_t ExpenseRatio::percent() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatio.percent)
  return _internal_percent();
}
inline void ExpenseRatio::_internal_set_percent(uint32_t value) {
  
  _impl_.percent_ = value;
}
inline void ExpenseRatio::set_percent(uint32_t value) {
  _internal_set_percent(value);
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatio.percent)
}

// -------------------------------------------------------------------

// KeyValuePair

// string key = 1;
inline void KeyValuePair::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:zera_txn.KeyValuePair.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValuePair::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.KeyValuePair.key)
}
inline std::string* KeyValuePair::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:zera_txn.KeyValuePair.key)
  return _s;
}
inline const std::string& KeyValuePair::_internal_key() const {
  return _impl_.key_.Get();
}
inline void KeyValuePair::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValuePair::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:zera_txn.KeyValuePair.key)
  return _impl_.key_.Release();
}
inline void KeyValuePair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.KeyValuePair.key)
}

// string value = 2;
inline void KeyValuePair::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:zera_txn.KeyValuePair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValuePair::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.KeyValuePair.value)
}
inline std::string* KeyValuePair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:zera_txn.KeyValuePair.value)
  return _s;
}
inline const std::string& KeyValuePair::_internal_value() const {
  return _impl_.value_.Get();
}
inline void KeyValuePair::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValuePair::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:zera_txn.KeyValuePair.value)
  return _impl_.value_.Release();
}
inline void KeyValuePair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.KeyValuePair.value)
}

// -------------------------------------------------------------------

// ByteMultiplier

// .zera_txn.TRANSACTION_TYPE txn_type = 1;
inline void ByteMultiplier::clear_txn_type() {
  _impl_.txn_type_ = 0;
}
inline ::zera_txn::TRANSACTION_TYPE ByteMultiplier::_internal_txn_type() const {
  return static_cast< ::zera_txn::TRANSACTION_TYPE >(_impl_.txn_type_);
}
inline ::zera_txn::TRANSACTION_TYPE ByteMultiplier::txn_type() const {
  // @@protoc_insertion_point(field_get:zera_txn.ByteMultiplier.txn_type)
  return _internal_txn_type();
}
inline void ByteMultiplier::_internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  
  _impl_.txn_type_ = value;
}
inline void ByteMultiplier::set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  _internal_set_txn_type(value);
  // @@protoc_insertion_point(field_set:zera_txn.ByteMultiplier.txn_type)
}

// string multiplier = 2;
inline void ByteMultiplier::clear_multiplier() {
  _impl_.multiplier_.ClearToEmpty();
}
inline const std::string& ByteMultiplier::multiplier() const {
  // @@protoc_insertion_point(field_get:zera_txn.ByteMultiplier.multiplier)
  return _internal_multiplier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ByteMultiplier::set_multiplier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.multiplier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ByteMultiplier.multiplier)
}
inline std::string* ByteMultiplier::mutable_multiplier() {
  std::string* _s = _internal_mutable_multiplier();
  // @@protoc_insertion_point(field_mutable:zera_txn.ByteMultiplier.multiplier)
  return _s;
}
inline const std::string& ByteMultiplier::_internal_multiplier() const {
  return _impl_.multiplier_.Get();
}
inline void ByteMultiplier::_internal_set_multiplier(const std::string& value) {
  
  _impl_.multiplier_.Set(value, GetArenaForAllocation());
}
inline std::string* ByteMultiplier::_internal_mutable_multiplier() {
  
  return _impl_.multiplier_.Mutable(GetArenaForAllocation());
}
inline std::string* ByteMultiplier::release_multiplier() {
  // @@protoc_insertion_point(field_release:zera_txn.ByteMultiplier.multiplier)
  return _impl_.multiplier_.Release();
}
inline void ByteMultiplier::set_allocated_multiplier(std::string* multiplier) {
  if (multiplier != nullptr) {
    
  } else {
    
  }
  _impl_.multiplier_.SetAllocated(multiplier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.multiplier_.IsDefault()) {
    _impl_.multiplier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ByteMultiplier.multiplier)
}

// -------------------------------------------------------------------

// FoundationTXN

// .zera_txn.BaseTXN base = 1;
inline bool FoundationTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool FoundationTXN::has_base() const {
  return _internal_has_base();
}
inline void FoundationTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& FoundationTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& FoundationTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.FoundationTXN.base)
  return _internal_base();
}
inline void FoundationTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.FoundationTXN.base)
}
inline ::zera_txn::BaseTXN* FoundationTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* FoundationTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.FoundationTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* FoundationTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* FoundationTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.FoundationTXN.base)
  return _msg;
}
inline void FoundationTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.FoundationTXN.base)
}

// repeated string restricted_symbols = 2;
inline int FoundationTXN::_internal_restricted_symbols_size() const {
  return _impl_.restricted_symbols_.size();
}
inline int FoundationTXN::restricted_symbols_size() const {
  return _internal_restricted_symbols_size();
}
inline void FoundationTXN::clear_restricted_symbols() {
  _impl_.restricted_symbols_.Clear();
}
inline std::string* FoundationTXN::add_restricted_symbols() {
  std::string* _s = _internal_add_restricted_symbols();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.FoundationTXN.restricted_symbols)
  return _s;
}
inline const std::string& FoundationTXN::_internal_restricted_symbols(int index) const {
  return _impl_.restricted_symbols_.Get(index);
}
inline const std::string& FoundationTXN::restricted_symbols(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.FoundationTXN.restricted_symbols)
  return _internal_restricted_symbols(index);
}
inline std::string* FoundationTXN::mutable_restricted_symbols(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.FoundationTXN.restricted_symbols)
  return _impl_.restricted_symbols_.Mutable(index);
}
inline void FoundationTXN::set_restricted_symbols(int index, const std::string& value) {
  _impl_.restricted_symbols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.FoundationTXN.restricted_symbols)
}
inline void FoundationTXN::set_restricted_symbols(int index, std::string&& value) {
  _impl_.restricted_symbols_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.FoundationTXN.restricted_symbols)
}
inline void FoundationTXN::set_restricted_symbols(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.restricted_symbols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.FoundationTXN.restricted_symbols)
}
inline void FoundationTXN::set_restricted_symbols(int index, const char* value, size_t size) {
  _impl_.restricted_symbols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.FoundationTXN.restricted_symbols)
}
inline std::string* FoundationTXN::_internal_add_restricted_symbols() {
  return _impl_.restricted_symbols_.Add();
}
inline void FoundationTXN::add_restricted_symbols(const std::string& value) {
  _impl_.restricted_symbols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.FoundationTXN.restricted_symbols)
}
inline void FoundationTXN::add_restricted_symbols(std::string&& value) {
  _impl_.restricted_symbols_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.FoundationTXN.restricted_symbols)
}
inline void FoundationTXN::add_restricted_symbols(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.restricted_symbols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.FoundationTXN.restricted_symbols)
}
inline void FoundationTXN::add_restricted_symbols(const char* value, size_t size) {
  _impl_.restricted_symbols_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.FoundationTXN.restricted_symbols)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FoundationTXN::restricted_symbols() const {
  // @@protoc_insertion_point(field_list:zera_txn.FoundationTXN.restricted_symbols)
  return _impl_.restricted_symbols_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FoundationTXN::mutable_restricted_symbols() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.FoundationTXN.restricted_symbols)
  return &_impl_.restricted_symbols_;
}

// repeated .zera_txn.ByteMultiplier byte_multiplier = 3;
inline int FoundationTXN::_internal_byte_multiplier_size() const {
  return _impl_.byte_multiplier_.size();
}
inline int FoundationTXN::byte_multiplier_size() const {
  return _internal_byte_multiplier_size();
}
inline void FoundationTXN::clear_byte_multiplier() {
  _impl_.byte_multiplier_.Clear();
}
inline ::zera_txn::ByteMultiplier* FoundationTXN::mutable_byte_multiplier(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.FoundationTXN.byte_multiplier)
  return _impl_.byte_multiplier_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ByteMultiplier >*
FoundationTXN::mutable_byte_multiplier() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.FoundationTXN.byte_multiplier)
  return &_impl_.byte_multiplier_;
}
inline const ::zera_txn::ByteMultiplier& FoundationTXN::_internal_byte_multiplier(int index) const {
  return _impl_.byte_multiplier_.Get(index);
}
inline const ::zera_txn::ByteMultiplier& FoundationTXN::byte_multiplier(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.FoundationTXN.byte_multiplier)
  return _internal_byte_multiplier(index);
}
inline ::zera_txn::ByteMultiplier* FoundationTXN::_internal_add_byte_multiplier() {
  return _impl_.byte_multiplier_.Add();
}
inline ::zera_txn::ByteMultiplier* FoundationTXN::add_byte_multiplier() {
  ::zera_txn::ByteMultiplier* _add = _internal_add_byte_multiplier();
  // @@protoc_insertion_point(field_add:zera_txn.FoundationTXN.byte_multiplier)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ByteMultiplier >&
FoundationTXN::byte_multiplier() const {
  // @@protoc_insertion_point(field_list:zera_txn.FoundationTXN.byte_multiplier)
  return _impl_.byte_multiplier_;
}

// optional string fee_ISO4217 = 4;
inline bool FoundationTXN::_internal_has_fee_iso4217() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FoundationTXN::has_fee_iso4217() const {
  return _internal_has_fee_iso4217();
}
inline void FoundationTXN::clear_fee_iso4217() {
  _impl_.fee_iso4217_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FoundationTXN::fee_iso4217() const {
  // @@protoc_insertion_point(field_get:zera_txn.FoundationTXN.fee_ISO4217)
  return _internal_fee_iso4217();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FoundationTXN::set_fee_iso4217(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.fee_iso4217_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.FoundationTXN.fee_ISO4217)
}
inline std::string* FoundationTXN::mutable_fee_iso4217() {
  std::string* _s = _internal_mutable_fee_iso4217();
  // @@protoc_insertion_point(field_mutable:zera_txn.FoundationTXN.fee_ISO4217)
  return _s;
}
inline const std::string& FoundationTXN::_internal_fee_iso4217() const {
  return _impl_.fee_iso4217_.Get();
}
inline void FoundationTXN::_internal_set_fee_iso4217(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fee_iso4217_.Set(value, GetArenaForAllocation());
}
inline std::string* FoundationTXN::_internal_mutable_fee_iso4217() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fee_iso4217_.Mutable(GetArenaForAllocation());
}
inline std::string* FoundationTXN::release_fee_iso4217() {
  // @@protoc_insertion_point(field_release:zera_txn.FoundationTXN.fee_ISO4217)
  if (!_internal_has_fee_iso4217()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.fee_iso4217_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_iso4217_.IsDefault()) {
    _impl_.fee_iso4217_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FoundationTXN::set_allocated_fee_iso4217(std::string* fee_iso4217) {
  if (fee_iso4217 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_iso4217_.SetAllocated(fee_iso4217, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_iso4217_.IsDefault()) {
    _impl_.fee_iso4217_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.FoundationTXN.fee_ISO4217)
}

// -------------------------------------------------------------------

// RevokeTXN

// .zera_txn.BaseTXN base = 1;
inline bool RevokeTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool RevokeTXN::has_base() const {
  return _internal_has_base();
}
inline void RevokeTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& RevokeTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& RevokeTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.RevokeTXN.base)
  return _internal_base();
}
inline void RevokeTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.RevokeTXN.base)
}
inline ::zera_txn::BaseTXN* RevokeTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* RevokeTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.RevokeTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* RevokeTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* RevokeTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.RevokeTXN.base)
  return _msg;
}
inline void RevokeTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.RevokeTXN.base)
}

// string contract_id = 2;
inline void RevokeTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& RevokeTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.RevokeTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevokeTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.RevokeTXN.contract_id)
}
inline std::string* RevokeTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.RevokeTXN.contract_id)
  return _s;
}
inline const std::string& RevokeTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void RevokeTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RevokeTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RevokeTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.RevokeTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void RevokeTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.RevokeTXN.contract_id)
}

// bytes recipient_address = 3;
inline void RevokeTXN::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& RevokeTXN::recipient_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.RevokeTXN.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevokeTXN::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.RevokeTXN.recipient_address)
}
inline std::string* RevokeTXN::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.RevokeTXN.recipient_address)
  return _s;
}
inline const std::string& RevokeTXN::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void RevokeTXN::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* RevokeTXN::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* RevokeTXN::release_recipient_address() {
  // @@protoc_insertion_point(field_release:zera_txn.RevokeTXN.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void RevokeTXN::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.RevokeTXN.recipient_address)
}

// string item_id = 4;
inline void RevokeTXN::clear_item_id() {
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& RevokeTXN::item_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.RevokeTXN.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevokeTXN::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.RevokeTXN.item_id)
}
inline std::string* RevokeTXN::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.RevokeTXN.item_id)
  return _s;
}
inline const std::string& RevokeTXN::_internal_item_id() const {
  return _impl_.item_id_.Get();
}
inline void RevokeTXN::_internal_set_item_id(const std::string& value) {
  
  _impl_.item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RevokeTXN::_internal_mutable_item_id() {
  
  return _impl_.item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RevokeTXN::release_item_id() {
  // @@protoc_insertion_point(field_release:zera_txn.RevokeTXN.item_id)
  return _impl_.item_id_.Release();
}
inline void RevokeTXN::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  _impl_.item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.RevokeTXN.item_id)
}

// -------------------------------------------------------------------

// FastQuorumTXN

// .zera_txn.BaseTXN base = 1;
inline bool FastQuorumTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool FastQuorumTXN::has_base() const {
  return _internal_has_base();
}
inline void FastQuorumTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& FastQuorumTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& FastQuorumTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.FastQuorumTXN.base)
  return _internal_base();
}
inline void FastQuorumTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.FastQuorumTXN.base)
}
inline ::zera_txn::BaseTXN* FastQuorumTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* FastQuorumTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.FastQuorumTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* FastQuorumTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* FastQuorumTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.FastQuorumTXN.base)
  return _msg;
}
inline void FastQuorumTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.FastQuorumTXN.base)
}

// bytes proposal_id = 2;
inline void FastQuorumTXN::clear_proposal_id() {
  _impl_.proposal_id_.ClearToEmpty();
}
inline const std::string& FastQuorumTXN::proposal_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.FastQuorumTXN.proposal_id)
  return _internal_proposal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FastQuorumTXN::set_proposal_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proposal_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.FastQuorumTXN.proposal_id)
}
inline std::string* FastQuorumTXN::mutable_proposal_id() {
  std::string* _s = _internal_mutable_proposal_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.FastQuorumTXN.proposal_id)
  return _s;
}
inline const std::string& FastQuorumTXN::_internal_proposal_id() const {
  return _impl_.proposal_id_.Get();
}
inline void FastQuorumTXN::_internal_set_proposal_id(const std::string& value) {
  
  _impl_.proposal_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FastQuorumTXN::_internal_mutable_proposal_id() {
  
  return _impl_.proposal_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FastQuorumTXN::release_proposal_id() {
  // @@protoc_insertion_point(field_release:zera_txn.FastQuorumTXN.proposal_id)
  return _impl_.proposal_id_.Release();
}
inline void FastQuorumTXN::set_allocated_proposal_id(std::string* proposal_id) {
  if (proposal_id != nullptr) {
    
  } else {
    
  }
  _impl_.proposal_id_.SetAllocated(proposal_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proposal_id_.IsDefault()) {
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.FastQuorumTXN.proposal_id)
}

// -------------------------------------------------------------------

// Governance

// .zera_txn.GOVERNANCE_TYPE type = 1;
inline void Governance::clear_type() {
  _impl_.type_ = 0;
}
inline ::zera_txn::GOVERNANCE_TYPE Governance::_internal_type() const {
  return static_cast< ::zera_txn::GOVERNANCE_TYPE >(_impl_.type_);
}
inline ::zera_txn::GOVERNANCE_TYPE Governance::type() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.type)
  return _internal_type();
}
inline void Governance::_internal_set_type(::zera_txn::GOVERNANCE_TYPE value) {
  
  _impl_.type_ = value;
}
inline void Governance::set_type(::zera_txn::GOVERNANCE_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.type)
}

// uint32 regular_quorum = 2;
inline void Governance::clear_regular_quorum() {
  _impl_.regular_quorum_ = 0u;
}
inline uint32_t Governance::_internal_regular_quorum() const {
  return _impl_.regular_quorum_;
}
inline uint32_t Governance::regular_quorum() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.regular_quorum)
  return _internal_regular_quorum();
}
inline void Governance::_internal_set_regular_quorum(uint32_t value) {
  
  _impl_.regular_quorum_ = value;
}
inline void Governance::set_regular_quorum(uint32_t value) {
  _internal_set_regular_quorum(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.regular_quorum)
}

// optional uint32 fast_quorum = 3;
inline bool Governance::_internal_has_fast_quorum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Governance::has_fast_quorum() const {
  return _internal_has_fast_quorum();
}
inline void Governance::clear_fast_quorum() {
  _impl_.fast_quorum_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Governance::_internal_fast_quorum() const {
  return _impl_.fast_quorum_;
}
inline uint32_t Governance::fast_quorum() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.fast_quorum)
  return _internal_fast_quorum();
}
inline void Governance::_internal_set_fast_quorum(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fast_quorum_ = value;
}
inline void Governance::set_fast_quorum(uint32_t value) {
  _internal_set_fast_quorum(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.fast_quorum)
}

// repeated string voting_instrument = 4;
inline int Governance::_internal_voting_instrument_size() const {
  return _impl_.voting_instrument_.size();
}
inline int Governance::voting_instrument_size() const {
  return _internal_voting_instrument_size();
}
inline void Governance::clear_voting_instrument() {
  _impl_.voting_instrument_.Clear();
}
inline std::string* Governance::add_voting_instrument() {
  std::string* _s = _internal_add_voting_instrument();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.Governance.voting_instrument)
  return _s;
}
inline const std::string& Governance::_internal_voting_instrument(int index) const {
  return _impl_.voting_instrument_.Get(index);
}
inline const std::string& Governance::voting_instrument(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.voting_instrument)
  return _internal_voting_instrument(index);
}
inline std::string* Governance::mutable_voting_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.Governance.voting_instrument)
  return _impl_.voting_instrument_.Mutable(index);
}
inline void Governance::set_voting_instrument(int index, const std::string& value) {
  _impl_.voting_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.voting_instrument)
}
inline void Governance::set_voting_instrument(int index, std::string&& value) {
  _impl_.voting_instrument_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.Governance.voting_instrument)
}
inline void Governance::set_voting_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.voting_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.Governance.voting_instrument)
}
inline void Governance::set_voting_instrument(int index, const char* value, size_t size) {
  _impl_.voting_instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.Governance.voting_instrument)
}
inline std::string* Governance::_internal_add_voting_instrument() {
  return _impl_.voting_instrument_.Add();
}
inline void Governance::add_voting_instrument(const std::string& value) {
  _impl_.voting_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.Governance.voting_instrument)
}
inline void Governance::add_voting_instrument(std::string&& value) {
  _impl_.voting_instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.Governance.voting_instrument)
}
inline void Governance::add_voting_instrument(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.voting_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.Governance.voting_instrument)
}
inline void Governance::add_voting_instrument(const char* value, size_t size) {
  _impl_.voting_instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.Governance.voting_instrument)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Governance::voting_instrument() const {
  // @@protoc_insertion_point(field_list:zera_txn.Governance.voting_instrument)
  return _impl_.voting_instrument_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Governance::mutable_voting_instrument() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.Governance.voting_instrument)
  return &_impl_.voting_instrument_;
}

// uint32 threshold = 5;
inline void Governance::clear_threshold() {
  _impl_.threshold_ = 0u;
}
inline uint32_t Governance::_internal_threshold() const {
  return _impl_.threshold_;
}
inline uint32_t Governance::threshold() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.threshold)
  return _internal_threshold();
}
inline void Governance::_internal_set_threshold(uint32_t value) {
  
  _impl_.threshold_ = value;
}
inline void Governance::set_threshold(uint32_t value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.threshold)
}

// optional bool chicken_dinner = 6;
inline bool Governance::_internal_has_chicken_dinner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Governance::has_chicken_dinner() const {
  return _internal_has_chicken_dinner();
}
inline void Governance::clear_chicken_dinner() {
  _impl_.chicken_dinner_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Governance::_internal_chicken_dinner() const {
  return _impl_.chicken_dinner_;
}
inline bool Governance::chicken_dinner() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.chicken_dinner)
  return _internal_chicken_dinner();
}
inline void Governance::_internal_set_chicken_dinner(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.chicken_dinner_ = value;
}
inline void Governance::set_chicken_dinner(bool value) {
  _internal_set_chicken_dinner(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.chicken_dinner)
}

// bool allow_multi = 7;
inline void Governance::clear_allow_multi() {
  _impl_.allow_multi_ = false;
}
inline bool Governance::_internal_allow_multi() const {
  return _impl_.allow_multi_;
}
inline bool Governance::allow_multi() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.allow_multi)
  return _internal_allow_multi();
}
inline void Governance::_internal_set_allow_multi(bool value) {
  
  _impl_.allow_multi_ = value;
}
inline void Governance::set_allow_multi(bool value) {
  _internal_set_allow_multi(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.allow_multi)
}

// optional uint32 voting_period = 8;
inline bool Governance::_internal_has_voting_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Governance::has_voting_period() const {
  return _internal_has_voting_period();
}
inline void Governance::clear_voting_period() {
  _impl_.voting_period_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Governance::_internal_voting_period() const {
  return _impl_.voting_period_;
}
inline uint32_t Governance::voting_period() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.voting_period)
  return _internal_voting_period();
}
inline void Governance::_internal_set_voting_period(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.voting_period_ = value;
}
inline void Governance::set_voting_period(uint32_t value) {
  _internal_set_voting_period(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.voting_period)
}

// repeated string allowed_proposal_instrument = 9;
inline int Governance::_internal_allowed_proposal_instrument_size() const {
  return _impl_.allowed_proposal_instrument_.size();
}
inline int Governance::allowed_proposal_instrument_size() const {
  return _internal_allowed_proposal_instrument_size();
}
inline void Governance::clear_allowed_proposal_instrument() {
  _impl_.allowed_proposal_instrument_.Clear();
}
inline std::string* Governance::add_allowed_proposal_instrument() {
  std::string* _s = _internal_add_allowed_proposal_instrument();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.Governance.allowed_proposal_instrument)
  return _s;
}
inline const std::string& Governance::_internal_allowed_proposal_instrument(int index) const {
  return _impl_.allowed_proposal_instrument_.Get(index);
}
inline const std::string& Governance::allowed_proposal_instrument(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.allowed_proposal_instrument)
  return _internal_allowed_proposal_instrument(index);
}
inline std::string* Governance::mutable_allowed_proposal_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.Governance.allowed_proposal_instrument)
  return _impl_.allowed_proposal_instrument_.Mutable(index);
}
inline void Governance::set_allowed_proposal_instrument(int index, const std::string& value) {
  _impl_.allowed_proposal_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.allowed_proposal_instrument)
}
inline void Governance::set_allowed_proposal_instrument(int index, std::string&& value) {
  _impl_.allowed_proposal_instrument_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.Governance.allowed_proposal_instrument)
}
inline void Governance::set_allowed_proposal_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_proposal_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.Governance.allowed_proposal_instrument)
}
inline void Governance::set_allowed_proposal_instrument(int index, const char* value, size_t size) {
  _impl_.allowed_proposal_instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.Governance.allowed_proposal_instrument)
}
inline std::string* Governance::_internal_add_allowed_proposal_instrument() {
  return _impl_.allowed_proposal_instrument_.Add();
}
inline void Governance::add_allowed_proposal_instrument(const std::string& value) {
  _impl_.allowed_proposal_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.Governance.allowed_proposal_instrument)
}
inline void Governance::add_allowed_proposal_instrument(std::string&& value) {
  _impl_.allowed_proposal_instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.Governance.allowed_proposal_instrument)
}
inline void Governance::add_allowed_proposal_instrument(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_proposal_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.Governance.allowed_proposal_instrument)
}
inline void Governance::add_allowed_proposal_instrument(const char* value, size_t size) {
  _impl_.allowed_proposal_instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.Governance.allowed_proposal_instrument)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Governance::allowed_proposal_instrument() const {
  // @@protoc_insertion_point(field_list:zera_txn.Governance.allowed_proposal_instrument)
  return _impl_.allowed_proposal_instrument_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Governance::mutable_allowed_proposal_instrument() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.Governance.allowed_proposal_instrument)
  return &_impl_.allowed_proposal_instrument_;
}

// optional .zera_txn.PROPOSAL_PERIOD proposal_period = 10;
inline bool Governance::_internal_has_proposal_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Governance::has_proposal_period() const {
  return _internal_has_proposal_period();
}
inline void Governance::clear_proposal_period() {
  _impl_.proposal_period_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::zera_txn::PROPOSAL_PERIOD Governance::_internal_proposal_period() const {
  return static_cast< ::zera_txn::PROPOSAL_PERIOD >(_impl_.proposal_period_);
}
inline ::zera_txn::PROPOSAL_PERIOD Governance::proposal_period() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.proposal_period)
  return _internal_proposal_period();
}
inline void Governance::_internal_set_proposal_period(::zera_txn::PROPOSAL_PERIOD value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.proposal_period_ = value;
}
inline void Governance::set_proposal_period(::zera_txn::PROPOSAL_PERIOD value) {
  _internal_set_proposal_period(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.proposal_period)
}

// repeated .zera_txn.Stage stage_length = 11;
inline int Governance::_internal_stage_length_size() const {
  return _impl_.stage_length_.size();
}
inline int Governance::stage_length_size() const {
  return _internal_stage_length_size();
}
inline void Governance::clear_stage_length() {
  _impl_.stage_length_.Clear();
}
inline ::zera_txn::Stage* Governance::mutable_stage_length(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.Governance.stage_length)
  return _impl_.stage_length_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Stage >*
Governance::mutable_stage_length() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.Governance.stage_length)
  return &_impl_.stage_length_;
}
inline const ::zera_txn::Stage& Governance::_internal_stage_length(int index) const {
  return _impl_.stage_length_.Get(index);
}
inline const ::zera_txn::Stage& Governance::stage_length(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.stage_length)
  return _internal_stage_length(index);
}
inline ::zera_txn::Stage* Governance::_internal_add_stage_length() {
  return _impl_.stage_length_.Add();
}
inline ::zera_txn::Stage* Governance::add_stage_length() {
  ::zera_txn::Stage* _add = _internal_add_stage_length();
  // @@protoc_insertion_point(field_add:zera_txn.Governance.stage_length)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Stage >&
Governance::stage_length() const {
  // @@protoc_insertion_point(field_list:zera_txn.Governance.stage_length)
  return _impl_.stage_length_;
}

// optional .google.protobuf.Timestamp start_timestamp = 12;
inline bool Governance::_internal_has_start_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_timestamp_ != nullptr);
  return value;
}
inline bool Governance::has_start_timestamp() const {
  return _internal_has_start_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Governance::_internal_start_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Governance::start_timestamp() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.start_timestamp)
  return _internal_start_timestamp();
}
inline void Governance::unsafe_arena_set_allocated_start_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_timestamp_);
  }
  _impl_.start_timestamp_ = start_timestamp;
  if (start_timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.Governance.start_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Governance::release_start_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_timestamp_;
  _impl_.start_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Governance::unsafe_arena_release_start_timestamp() {
  // @@protoc_insertion_point(field_release:zera_txn.Governance.start_timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_timestamp_;
  _impl_.start_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Governance::_internal_mutable_start_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_timestamp_ = p;
  }
  return _impl_.start_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Governance::mutable_start_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_timestamp();
  // @@protoc_insertion_point(field_mutable:zera_txn.Governance.start_timestamp)
  return _msg;
}
inline void Governance::set_allocated_start_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_timestamp_);
  }
  if (start_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_timestamp));
    if (message_arena != submessage_arena) {
      start_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_timestamp_ = start_timestamp;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Governance.start_timestamp)
}

// optional uint32 max_approved = 13;
inline bool Governance::_internal_has_max_approved() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Governance::has_max_approved() const {
  return _internal_has_max_approved();
}
inline void Governance::clear_max_approved() {
  _impl_.max_approved_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t Governance::_internal_max_approved() const {
  return _impl_.max_approved_;
}
inline uint32_t Governance::max_approved() const {
  // @@protoc_insertion_point(field_get:zera_txn.Governance.max_approved)
  return _internal_max_approved();
}
inline void Governance::_internal_set_max_approved(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.max_approved_ = value;
}
inline void Governance::set_max_approved(uint32_t value) {
  _internal_set_max_approved(value);
  // @@protoc_insertion_point(field_set:zera_txn.Governance.max_approved)
}

// -------------------------------------------------------------------

// Stage

// uint32 length = 1;
inline void Stage::clear_length() {
  _impl_.length_ = 0u;
}
inline uint32_t Stage::_internal_length() const {
  return _impl_.length_;
}
inline uint32_t Stage::length() const {
  // @@protoc_insertion_point(field_get:zera_txn.Stage.length)
  return _internal_length();
}
inline void Stage::_internal_set_length(uint32_t value) {
  
  _impl_.length_ = value;
}
inline void Stage::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:zera_txn.Stage.length)
}

// .zera_txn.PROPOSAL_PERIOD period = 2;
inline void Stage::clear_period() {
  _impl_.period_ = 0;
}
inline ::zera_txn::PROPOSAL_PERIOD Stage::_internal_period() const {
  return static_cast< ::zera_txn::PROPOSAL_PERIOD >(_impl_.period_);
}
inline ::zera_txn::PROPOSAL_PERIOD Stage::period() const {
  // @@protoc_insertion_point(field_get:zera_txn.Stage.period)
  return _internal_period();
}
inline void Stage::_internal_set_period(::zera_txn::PROPOSAL_PERIOD value) {
  
  _impl_.period_ = value;
}
inline void Stage::set_period(::zera_txn::PROPOSAL_PERIOD value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:zera_txn.Stage.period)
}

// bool break = 3;
inline void Stage::clear_break_() {
  _impl_.break__ = false;
}
inline bool Stage::_internal_break_() const {
  return _impl_.break__;
}
inline bool Stage::break_() const {
  // @@protoc_insertion_point(field_get:zera_txn.Stage.break)
  return _internal_break_();
}
inline void Stage::_internal_set_break_(bool value) {
  
  _impl_.break__ = value;
}
inline void Stage::set_break_(bool value) {
  _internal_set_break_(value);
  // @@protoc_insertion_point(field_set:zera_txn.Stage.break)
}

// uint32 max_approved = 4;
inline void Stage::clear_max_approved() {
  _impl_.max_approved_ = 0u;
}
inline uint32_t Stage::_internal_max_approved() const {
  return _impl_.max_approved_;
}
inline uint32_t Stage::max_approved() const {
  // @@protoc_insertion_point(field_get:zera_txn.Stage.max_approved)
  return _internal_max_approved();
}
inline void Stage::_internal_set_max_approved(uint32_t value) {
  
  _impl_.max_approved_ = value;
}
inline void Stage::set_max_approved(uint32_t value) {
  _internal_set_max_approved(value);
  // @@protoc_insertion_point(field_set:zera_txn.Stage.max_approved)
}

// -------------------------------------------------------------------

// CoinDenomination

// string denomination_name = 5;
inline void CoinDenomination::clear_denomination_name() {
  _impl_.denomination_name_.ClearToEmpty();
}
inline const std::string& CoinDenomination::denomination_name() const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinDenomination.denomination_name)
  return _internal_denomination_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoinDenomination::set_denomination_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.denomination_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.CoinDenomination.denomination_name)
}
inline std::string* CoinDenomination::mutable_denomination_name() {
  std::string* _s = _internal_mutable_denomination_name();
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinDenomination.denomination_name)
  return _s;
}
inline const std::string& CoinDenomination::_internal_denomination_name() const {
  return _impl_.denomination_name_.Get();
}
inline void CoinDenomination::_internal_set_denomination_name(const std::string& value) {
  
  _impl_.denomination_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CoinDenomination::_internal_mutable_denomination_name() {
  
  return _impl_.denomination_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CoinDenomination::release_denomination_name() {
  // @@protoc_insertion_point(field_release:zera_txn.CoinDenomination.denomination_name)
  return _impl_.denomination_name_.Release();
}
inline void CoinDenomination::set_allocated_denomination_name(std::string* denomination_name) {
  if (denomination_name != nullptr) {
    
  } else {
    
  }
  _impl_.denomination_name_.SetAllocated(denomination_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.denomination_name_.IsDefault()) {
    _impl_.denomination_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CoinDenomination.denomination_name)
}

// string amount = 6;
inline void CoinDenomination::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& CoinDenomination::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinDenomination.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoinDenomination::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.CoinDenomination.amount)
}
inline std::string* CoinDenomination::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinDenomination.amount)
  return _s;
}
inline const std::string& CoinDenomination::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void CoinDenomination::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* CoinDenomination::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* CoinDenomination::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.CoinDenomination.amount)
  return _impl_.amount_.Release();
}
inline void CoinDenomination::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CoinDenomination.amount)
}

// -------------------------------------------------------------------

// ContractFees

// string fee = 1;
inline void ContractFees::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& ContractFees::fee() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractFees.fee)
  return _internal_fee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFees::set_fee(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ContractFees.fee)
}
inline std::string* ContractFees::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractFees.fee)
  return _s;
}
inline const std::string& ContractFees::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void ContractFees::_internal_set_fee(const std::string& value) {
  
  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFees::_internal_mutable_fee() {
  
  return _impl_.fee_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFees::release_fee() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractFees.fee)
  return _impl_.fee_.Release();
}
inline void ContractFees::set_allocated_fee(std::string* fee) {
  if (fee != nullptr) {
    
  } else {
    
  }
  _impl_.fee_.SetAllocated(fee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_.IsDefault()) {
    _impl_.fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractFees.fee)
}

// optional bytes fee_address = 2;
inline bool ContractFees::_internal_has_fee_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractFees::has_fee_address() const {
  return _internal_has_fee_address();
}
inline void ContractFees::clear_fee_address() {
  _impl_.fee_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractFees::fee_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractFees.fee_address)
  return _internal_fee_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFees::set_fee_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.fee_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ContractFees.fee_address)
}
inline std::string* ContractFees::mutable_fee_address() {
  std::string* _s = _internal_mutable_fee_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractFees.fee_address)
  return _s;
}
inline const std::string& ContractFees::_internal_fee_address() const {
  return _impl_.fee_address_.Get();
}
inline void ContractFees::_internal_set_fee_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fee_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFees::_internal_mutable_fee_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fee_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFees::release_fee_address() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractFees.fee_address)
  if (!_internal_has_fee_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.fee_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_address_.IsDefault()) {
    _impl_.fee_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractFees::set_allocated_fee_address(std::string* fee_address) {
  if (fee_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_address_.SetAllocated(fee_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_address_.IsDefault()) {
    _impl_.fee_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractFees.fee_address)
}

// string burn = 3;
inline void ContractFees::clear_burn() {
  _impl_.burn_.ClearToEmpty();
}
inline const std::string& ContractFees::burn() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractFees.burn)
  return _internal_burn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFees::set_burn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.burn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ContractFees.burn)
}
inline std::string* ContractFees::mutable_burn() {
  std::string* _s = _internal_mutable_burn();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractFees.burn)
  return _s;
}
inline const std::string& ContractFees::_internal_burn() const {
  return _impl_.burn_.Get();
}
inline void ContractFees::_internal_set_burn(const std::string& value) {
  
  _impl_.burn_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFees::_internal_mutable_burn() {
  
  return _impl_.burn_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFees::release_burn() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractFees.burn)
  return _impl_.burn_.Release();
}
inline void ContractFees::set_allocated_burn(std::string* burn) {
  if (burn != nullptr) {
    
  } else {
    
  }
  _impl_.burn_.SetAllocated(burn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.burn_.IsDefault()) {
    _impl_.burn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractFees.burn)
}

// string validator = 4;
inline void ContractFees::clear_validator() {
  _impl_.validator_.ClearToEmpty();
}
inline const std::string& ContractFees::validator() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractFees.validator)
  return _internal_validator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFees::set_validator(ArgT0&& arg0, ArgT... args) {
 
 _impl_.validator_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ContractFees.validator)
}
inline std::string* ContractFees::mutable_validator() {
  std::string* _s = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractFees.validator)
  return _s;
}
inline const std::string& ContractFees::_internal_validator() const {
  return _impl_.validator_.Get();
}
inline void ContractFees::_internal_set_validator(const std::string& value) {
  
  _impl_.validator_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFees::_internal_mutable_validator() {
  
  return _impl_.validator_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFees::release_validator() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractFees.validator)
  return _impl_.validator_.Release();
}
inline void ContractFees::set_allocated_validator(std::string* validator) {
  if (validator != nullptr) {
    
  } else {
    
  }
  _impl_.validator_.SetAllocated(validator, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.validator_.IsDefault()) {
    _impl_.validator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractFees.validator)
}

// repeated string allowed_fee_instrument = 5;
inline int ContractFees::_internal_allowed_fee_instrument_size() const {
  return _impl_.allowed_fee_instrument_.size();
}
inline int ContractFees::allowed_fee_instrument_size() const {
  return _internal_allowed_fee_instrument_size();
}
inline void ContractFees::clear_allowed_fee_instrument() {
  _impl_.allowed_fee_instrument_.Clear();
}
inline std::string* ContractFees::add_allowed_fee_instrument() {
  std::string* _s = _internal_add_allowed_fee_instrument();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.ContractFees.allowed_fee_instrument)
  return _s;
}
inline const std::string& ContractFees::_internal_allowed_fee_instrument(int index) const {
  return _impl_.allowed_fee_instrument_.Get(index);
}
inline const std::string& ContractFees::allowed_fee_instrument(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractFees.allowed_fee_instrument)
  return _internal_allowed_fee_instrument(index);
}
inline std::string* ContractFees::mutable_allowed_fee_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractFees.allowed_fee_instrument)
  return _impl_.allowed_fee_instrument_.Mutable(index);
}
inline void ContractFees::set_allowed_fee_instrument(int index, const std::string& value) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.ContractFees.allowed_fee_instrument)
}
inline void ContractFees::set_allowed_fee_instrument(int index, std::string&& value) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.ContractFees.allowed_fee_instrument)
}
inline void ContractFees::set_allowed_fee_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.ContractFees.allowed_fee_instrument)
}
inline void ContractFees::set_allowed_fee_instrument(int index, const char* value, size_t size) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.ContractFees.allowed_fee_instrument)
}
inline std::string* ContractFees::_internal_add_allowed_fee_instrument() {
  return _impl_.allowed_fee_instrument_.Add();
}
inline void ContractFees::add_allowed_fee_instrument(const std::string& value) {
  _impl_.allowed_fee_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.ContractFees.allowed_fee_instrument)
}
inline void ContractFees::add_allowed_fee_instrument(std::string&& value) {
  _impl_.allowed_fee_instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.ContractFees.allowed_fee_instrument)
}
inline void ContractFees::add_allowed_fee_instrument(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_fee_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.ContractFees.allowed_fee_instrument)
}
inline void ContractFees::add_allowed_fee_instrument(const char* value, size_t size) {
  _impl_.allowed_fee_instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.ContractFees.allowed_fee_instrument)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContractFees::allowed_fee_instrument() const {
  // @@protoc_insertion_point(field_list:zera_txn.ContractFees.allowed_fee_instrument)
  return _impl_.allowed_fee_instrument_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContractFees::mutable_allowed_fee_instrument() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ContractFees.allowed_fee_instrument)
  return &_impl_.allowed_fee_instrument_;
}

// .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 6;
inline void ContractFees::clear_contract_fee_type() {
  _impl_.contract_fee_type_ = 0;
}
inline ::zera_txn::CONTRACT_FEE_TYPE ContractFees::_internal_contract_fee_type() const {
  return static_cast< ::zera_txn::CONTRACT_FEE_TYPE >(_impl_.contract_fee_type_);
}
inline ::zera_txn::CONTRACT_FEE_TYPE ContractFees::contract_fee_type() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractFees.contract_fee_type)
  return _internal_contract_fee_type();
}
inline void ContractFees::_internal_set_contract_fee_type(::zera_txn::CONTRACT_FEE_TYPE value) {
  
  _impl_.contract_fee_type_ = value;
}
inline void ContractFees::set_contract_fee_type(::zera_txn::CONTRACT_FEE_TYPE value) {
  _internal_set_contract_fee_type(value);
  // @@protoc_insertion_point(field_set:zera_txn.ContractFees.contract_fee_type)
}

// -------------------------------------------------------------------

// ItemContractFees

// string fee = 1;
inline void ItemContractFees::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& ItemContractFees::fee() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemContractFees.fee)
  return _internal_fee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemContractFees::set_fee(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ItemContractFees.fee)
}
inline std::string* ItemContractFees::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemContractFees.fee)
  return _s;
}
inline const std::string& ItemContractFees::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void ItemContractFees::_internal_set_fee(const std::string& value) {
  
  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemContractFees::_internal_mutable_fee() {
  
  return _impl_.fee_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemContractFees::release_fee() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemContractFees.fee)
  return _impl_.fee_.Release();
}
inline void ItemContractFees::set_allocated_fee(std::string* fee) {
  if (fee != nullptr) {
    
  } else {
    
  }
  _impl_.fee_.SetAllocated(fee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_.IsDefault()) {
    _impl_.fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemContractFees.fee)
}

// optional bytes fee_address = 2;
inline bool ItemContractFees::_internal_has_fee_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemContractFees::has_fee_address() const {
  return _internal_has_fee_address();
}
inline void ItemContractFees::clear_fee_address() {
  _impl_.fee_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ItemContractFees::fee_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemContractFees.fee_address)
  return _internal_fee_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemContractFees::set_fee_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.fee_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ItemContractFees.fee_address)
}
inline std::string* ItemContractFees::mutable_fee_address() {
  std::string* _s = _internal_mutable_fee_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemContractFees.fee_address)
  return _s;
}
inline const std::string& ItemContractFees::_internal_fee_address() const {
  return _impl_.fee_address_.Get();
}
inline void ItemContractFees::_internal_set_fee_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fee_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemContractFees::_internal_mutable_fee_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fee_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemContractFees::release_fee_address() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemContractFees.fee_address)
  if (!_internal_has_fee_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.fee_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_address_.IsDefault()) {
    _impl_.fee_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemContractFees::set_allocated_fee_address(std::string* fee_address) {
  if (fee_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_address_.SetAllocated(fee_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_address_.IsDefault()) {
    _impl_.fee_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemContractFees.fee_address)
}

// string burn = 3;
inline void ItemContractFees::clear_burn() {
  _impl_.burn_.ClearToEmpty();
}
inline const std::string& ItemContractFees::burn() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemContractFees.burn)
  return _internal_burn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemContractFees::set_burn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.burn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ItemContractFees.burn)
}
inline std::string* ItemContractFees::mutable_burn() {
  std::string* _s = _internal_mutable_burn();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemContractFees.burn)
  return _s;
}
inline const std::string& ItemContractFees::_internal_burn() const {
  return _impl_.burn_.Get();
}
inline void ItemContractFees::_internal_set_burn(const std::string& value) {
  
  _impl_.burn_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemContractFees::_internal_mutable_burn() {
  
  return _impl_.burn_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemContractFees::release_burn() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemContractFees.burn)
  return _impl_.burn_.Release();
}
inline void ItemContractFees::set_allocated_burn(std::string* burn) {
  if (burn != nullptr) {
    
  } else {
    
  }
  _impl_.burn_.SetAllocated(burn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.burn_.IsDefault()) {
    _impl_.burn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemContractFees.burn)
}

// string validator = 4;
inline void ItemContractFees::clear_validator() {
  _impl_.validator_.ClearToEmpty();
}
inline const std::string& ItemContractFees::validator() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemContractFees.validator)
  return _internal_validator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemContractFees::set_validator(ArgT0&& arg0, ArgT... args) {
 
 _impl_.validator_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ItemContractFees.validator)
}
inline std::string* ItemContractFees::mutable_validator() {
  std::string* _s = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemContractFees.validator)
  return _s;
}
inline const std::string& ItemContractFees::_internal_validator() const {
  return _impl_.validator_.Get();
}
inline void ItemContractFees::_internal_set_validator(const std::string& value) {
  
  _impl_.validator_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemContractFees::_internal_mutable_validator() {
  
  return _impl_.validator_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemContractFees::release_validator() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemContractFees.validator)
  return _impl_.validator_.Release();
}
inline void ItemContractFees::set_allocated_validator(std::string* validator) {
  if (validator != nullptr) {
    
  } else {
    
  }
  _impl_.validator_.SetAllocated(validator, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.validator_.IsDefault()) {
    _impl_.validator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemContractFees.validator)
}

// repeated string allowed_fee_instrument = 5;
inline int ItemContractFees::_internal_allowed_fee_instrument_size() const {
  return _impl_.allowed_fee_instrument_.size();
}
inline int ItemContractFees::allowed_fee_instrument_size() const {
  return _internal_allowed_fee_instrument_size();
}
inline void ItemContractFees::clear_allowed_fee_instrument() {
  _impl_.allowed_fee_instrument_.Clear();
}
inline std::string* ItemContractFees::add_allowed_fee_instrument() {
  std::string* _s = _internal_add_allowed_fee_instrument();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.ItemContractFees.allowed_fee_instrument)
  return _s;
}
inline const std::string& ItemContractFees::_internal_allowed_fee_instrument(int index) const {
  return _impl_.allowed_fee_instrument_.Get(index);
}
inline const std::string& ItemContractFees::allowed_fee_instrument(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemContractFees.allowed_fee_instrument)
  return _internal_allowed_fee_instrument(index);
}
inline std::string* ItemContractFees::mutable_allowed_fee_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemContractFees.allowed_fee_instrument)
  return _impl_.allowed_fee_instrument_.Mutable(index);
}
inline void ItemContractFees::set_allowed_fee_instrument(int index, const std::string& value) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.ItemContractFees.allowed_fee_instrument)
}
inline void ItemContractFees::set_allowed_fee_instrument(int index, std::string&& value) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.ItemContractFees.allowed_fee_instrument)
}
inline void ItemContractFees::set_allowed_fee_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.ItemContractFees.allowed_fee_instrument)
}
inline void ItemContractFees::set_allowed_fee_instrument(int index, const char* value, size_t size) {
  _impl_.allowed_fee_instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.ItemContractFees.allowed_fee_instrument)
}
inline std::string* ItemContractFees::_internal_add_allowed_fee_instrument() {
  return _impl_.allowed_fee_instrument_.Add();
}
inline void ItemContractFees::add_allowed_fee_instrument(const std::string& value) {
  _impl_.allowed_fee_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.ItemContractFees.allowed_fee_instrument)
}
inline void ItemContractFees::add_allowed_fee_instrument(std::string&& value) {
  _impl_.allowed_fee_instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.ItemContractFees.allowed_fee_instrument)
}
inline void ItemContractFees::add_allowed_fee_instrument(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_fee_instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.ItemContractFees.allowed_fee_instrument)
}
inline void ItemContractFees::add_allowed_fee_instrument(const char* value, size_t size) {
  _impl_.allowed_fee_instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.ItemContractFees.allowed_fee_instrument)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ItemContractFees::allowed_fee_instrument() const {
  // @@protoc_insertion_point(field_list:zera_txn.ItemContractFees.allowed_fee_instrument)
  return _impl_.allowed_fee_instrument_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ItemContractFees::mutable_allowed_fee_instrument() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ItemContractFees.allowed_fee_instrument)
  return &_impl_.allowed_fee_instrument_;
}

// -------------------------------------------------------------------

// RestrictedKey

// .zera_txn.PublicKey public_key = 1;
inline bool RestrictedKey::_internal_has_public_key() const {
  return this != internal_default_instance() && _impl_.public_key_ != nullptr;
}
inline bool RestrictedKey::has_public_key() const {
  return _internal_has_public_key();
}
inline void RestrictedKey::clear_public_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
}
inline const ::zera_txn::PublicKey& RestrictedKey::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = _impl_.public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::PublicKey&>(
      ::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& RestrictedKey::public_key() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.public_key)
  return _internal_public_key();
}
inline void RestrictedKey::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  _impl_.public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.RestrictedKey.public_key)
}
inline ::zera_txn::PublicKey* RestrictedKey::release_public_key() {
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::PublicKey* RestrictedKey::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_txn.RestrictedKey.public_key)
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* RestrictedKey::_internal_mutable_public_key() {
  
  if (_impl_.public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArenaForAllocation());
    _impl_.public_key_ = p;
  }
  return _impl_.public_key_;
}
inline ::zera_txn::PublicKey* RestrictedKey::mutable_public_key() {
  ::zera_txn::PublicKey* _msg = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:zera_txn.RestrictedKey.public_key)
  return _msg;
}
inline void RestrictedKey::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.public_key_;
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_key);
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.RestrictedKey.public_key)
}

// int64 time_delay = 2;
inline void RestrictedKey::clear_time_delay() {
  _impl_.time_delay_ = int64_t{0};
}
inline int64_t RestrictedKey::_internal_time_delay() const {
  return _impl_.time_delay_;
}
inline int64_t RestrictedKey::time_delay() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.time_delay)
  return _internal_time_delay();
}
inline void RestrictedKey::_internal_set_time_delay(int64_t value) {
  
  _impl_.time_delay_ = value;
}
inline void RestrictedKey::set_time_delay(int64_t value) {
  _internal_set_time_delay(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.time_delay)
}

// bool global = 3;
inline void RestrictedKey::clear_global() {
  _impl_.global_ = false;
}
inline bool RestrictedKey::_internal_global() const {
  return _impl_.global_;
}
inline bool RestrictedKey::global() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.global)
  return _internal_global();
}
inline void RestrictedKey::_internal_set_global(bool value) {
  
  _impl_.global_ = value;
}
inline void RestrictedKey::set_global(bool value) {
  _internal_set_global(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.global)
}

// bool update_contract = 4;
inline void RestrictedKey::clear_update_contract() {
  _impl_.update_contract_ = false;
}
inline bool RestrictedKey::_internal_update_contract() const {
  return _impl_.update_contract_;
}
inline bool RestrictedKey::update_contract() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.update_contract)
  return _internal_update_contract();
}
inline void RestrictedKey::_internal_set_update_contract(bool value) {
  
  _impl_.update_contract_ = value;
}
inline void RestrictedKey::set_update_contract(bool value) {
  _internal_set_update_contract(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.update_contract)
}

// bool transfer = 5;
inline void RestrictedKey::clear_transfer() {
  _impl_.transfer_ = false;
}
inline bool RestrictedKey::_internal_transfer() const {
  return _impl_.transfer_;
}
inline bool RestrictedKey::transfer() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.transfer)
  return _internal_transfer();
}
inline void RestrictedKey::_internal_set_transfer(bool value) {
  
  _impl_.transfer_ = value;
}
inline void RestrictedKey::set_transfer(bool value) {
  _internal_set_transfer(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.transfer)
}

// bool quash = 6;
inline void RestrictedKey::clear_quash() {
  _impl_.quash_ = false;
}
inline bool RestrictedKey::_internal_quash() const {
  return _impl_.quash_;
}
inline bool RestrictedKey::quash() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.quash)
  return _internal_quash();
}
inline void RestrictedKey::_internal_set_quash(bool value) {
  
  _impl_.quash_ = value;
}
inline void RestrictedKey::set_quash(bool value) {
  _internal_set_quash(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.quash)
}

// bool mint = 7;
inline void RestrictedKey::clear_mint() {
  _impl_.mint_ = false;
}
inline bool RestrictedKey::_internal_mint() const {
  return _impl_.mint_;
}
inline bool RestrictedKey::mint() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.mint)
  return _internal_mint();
}
inline void RestrictedKey::_internal_set_mint(bool value) {
  
  _impl_.mint_ = value;
}
inline void RestrictedKey::set_mint(bool value) {
  _internal_set_mint(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.mint)
}

// bool vote = 8;
inline void RestrictedKey::clear_vote() {
  _impl_.vote_ = false;
}
inline bool RestrictedKey::_internal_vote() const {
  return _impl_.vote_;
}
inline bool RestrictedKey::vote() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.vote)
  return _internal_vote();
}
inline void RestrictedKey::_internal_set_vote(bool value) {
  
  _impl_.vote_ = value;
}
inline void RestrictedKey::set_vote(bool value) {
  _internal_set_vote(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.vote)
}

// bool propose = 9;
inline void RestrictedKey::clear_propose() {
  _impl_.propose_ = false;
}
inline bool RestrictedKey::_internal_propose() const {
  return _impl_.propose_;
}
inline bool RestrictedKey::propose() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.propose)
  return _internal_propose();
}
inline void RestrictedKey::_internal_set_propose(bool value) {
  
  _impl_.propose_ = value;
}
inline void RestrictedKey::set_propose(bool value) {
  _internal_set_propose(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.propose)
}

// bool compliance = 10;
inline void RestrictedKey::clear_compliance() {
  _impl_.compliance_ = false;
}
inline bool RestrictedKey::_internal_compliance() const {
  return _impl_.compliance_;
}
inline bool RestrictedKey::compliance() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.compliance)
  return _internal_compliance();
}
inline void RestrictedKey::_internal_set_compliance(bool value) {
  
  _impl_.compliance_ = value;
}
inline void RestrictedKey::set_compliance(bool value) {
  _internal_set_compliance(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.compliance)
}

// bool expense_ratio = 11;
inline void RestrictedKey::clear_expense_ratio() {
  _impl_.expense_ratio_ = false;
}
inline bool RestrictedKey::_internal_expense_ratio() const {
  return _impl_.expense_ratio_;
}
inline bool RestrictedKey::expense_ratio() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.expense_ratio)
  return _internal_expense_ratio();
}
inline void RestrictedKey::_internal_set_expense_ratio(bool value) {
  
  _impl_.expense_ratio_ = value;
}
inline void RestrictedKey::set_expense_ratio(bool value) {
  _internal_set_expense_ratio(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.expense_ratio)
}

// bool cur_equiv = 12;
inline void RestrictedKey::clear_cur_equiv() {
  _impl_.cur_equiv_ = false;
}
inline bool RestrictedKey::_internal_cur_equiv() const {
  return _impl_.cur_equiv_;
}
inline bool RestrictedKey::cur_equiv() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.cur_equiv)
  return _internal_cur_equiv();
}
inline void RestrictedKey::_internal_set_cur_equiv(bool value) {
  
  _impl_.cur_equiv_ = value;
}
inline void RestrictedKey::set_cur_equiv(bool value) {
  _internal_set_cur_equiv(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.cur_equiv)
}

// bool revoke = 13;
inline void RestrictedKey::clear_revoke() {
  _impl_.revoke_ = false;
}
inline bool RestrictedKey::_internal_revoke() const {
  return _impl_.revoke_;
}
inline bool RestrictedKey::revoke() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.revoke)
  return _internal_revoke();
}
inline void RestrictedKey::_internal_set_revoke(bool value) {
  
  _impl_.revoke_ = value;
}
inline void RestrictedKey::set_revoke(bool value) {
  _internal_set_revoke(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.revoke)
}

// uint32 key_weight = 14;
inline void RestrictedKey::clear_key_weight() {
  _impl_.key_weight_ = 0u;
}
inline uint32_t RestrictedKey::_internal_key_weight() const {
  return _impl_.key_weight_;
}
inline uint32_t RestrictedKey::key_weight() const {
  // @@protoc_insertion_point(field_get:zera_txn.RestrictedKey.key_weight)
  return _internal_key_weight();
}
inline void RestrictedKey::_internal_set_key_weight(uint32_t value) {
  
  _impl_.key_weight_ = value;
}
inline void RestrictedKey::set_key_weight(uint32_t value) {
  _internal_set_key_weight(value);
  // @@protoc_insertion_point(field_set:zera_txn.RestrictedKey.key_weight)
}

// -------------------------------------------------------------------

// ExpenseRatioTXN

// .zera_txn.BaseTXN base = 1;
inline bool ExpenseRatioTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool ExpenseRatioTXN::has_base() const {
  return _internal_has_base();
}
inline void ExpenseRatioTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& ExpenseRatioTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ExpenseRatioTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatioTXN.base)
  return _internal_base();
}
inline void ExpenseRatioTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ExpenseRatioTXN.base)
}
inline ::zera_txn::BaseTXN* ExpenseRatioTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* ExpenseRatioTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.ExpenseRatioTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ExpenseRatioTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* ExpenseRatioTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.ExpenseRatioTXN.base)
  return _msg;
}
inline void ExpenseRatioTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ExpenseRatioTXN.base)
}

// string contract_id = 2;
inline void ExpenseRatioTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ExpenseRatioTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatioTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpenseRatioTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatioTXN.contract_id)
}
inline std::string* ExpenseRatioTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ExpenseRatioTXN.contract_id)
  return _s;
}
inline const std::string& ExpenseRatioTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void ExpenseRatioTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpenseRatioTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpenseRatioTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ExpenseRatioTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ExpenseRatioTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ExpenseRatioTXN.contract_id)
}

// repeated bytes addresses = 3;
inline int ExpenseRatioTXN::_internal_addresses_size() const {
  return _impl_.addresses_.size();
}
inline int ExpenseRatioTXN::addresses_size() const {
  return _internal_addresses_size();
}
inline void ExpenseRatioTXN::clear_addresses() {
  _impl_.addresses_.Clear();
}
inline std::string* ExpenseRatioTXN::add_addresses() {
  std::string* _s = _internal_add_addresses();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.ExpenseRatioTXN.addresses)
  return _s;
}
inline const std::string& ExpenseRatioTXN::_internal_addresses(int index) const {
  return _impl_.addresses_.Get(index);
}
inline const std::string& ExpenseRatioTXN::addresses(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatioTXN.addresses)
  return _internal_addresses(index);
}
inline std::string* ExpenseRatioTXN::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ExpenseRatioTXN.addresses)
  return _impl_.addresses_.Mutable(index);
}
inline void ExpenseRatioTXN::set_addresses(int index, const std::string& value) {
  _impl_.addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatioTXN.addresses)
}
inline void ExpenseRatioTXN::set_addresses(int index, std::string&& value) {
  _impl_.addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatioTXN.addresses)
}
inline void ExpenseRatioTXN::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.ExpenseRatioTXN.addresses)
}
inline void ExpenseRatioTXN::set_addresses(int index, const void* value, size_t size) {
  _impl_.addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.ExpenseRatioTXN.addresses)
}
inline std::string* ExpenseRatioTXN::_internal_add_addresses() {
  return _impl_.addresses_.Add();
}
inline void ExpenseRatioTXN::add_addresses(const std::string& value) {
  _impl_.addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.ExpenseRatioTXN.addresses)
}
inline void ExpenseRatioTXN::add_addresses(std::string&& value) {
  _impl_.addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.ExpenseRatioTXN.addresses)
}
inline void ExpenseRatioTXN::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.ExpenseRatioTXN.addresses)
}
inline void ExpenseRatioTXN::add_addresses(const void* value, size_t size) {
  _impl_.addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.ExpenseRatioTXN.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExpenseRatioTXN::addresses() const {
  // @@protoc_insertion_point(field_list:zera_txn.ExpenseRatioTXN.addresses)
  return _impl_.addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExpenseRatioTXN::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ExpenseRatioTXN.addresses)
  return &_impl_.addresses_;
}

// bytes output_address = 4;
inline void ExpenseRatioTXN::clear_output_address() {
  _impl_.output_address_.ClearToEmpty();
}
inline const std::string& ExpenseRatioTXN::output_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatioTXN.output_address)
  return _internal_output_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpenseRatioTXN::set_output_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatioTXN.output_address)
}
inline std::string* ExpenseRatioTXN::mutable_output_address() {
  std::string* _s = _internal_mutable_output_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.ExpenseRatioTXN.output_address)
  return _s;
}
inline const std::string& ExpenseRatioTXN::_internal_output_address() const {
  return _impl_.output_address_.Get();
}
inline void ExpenseRatioTXN::_internal_set_output_address(const std::string& value) {
  
  _impl_.output_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpenseRatioTXN::_internal_mutable_output_address() {
  
  return _impl_.output_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpenseRatioTXN::release_output_address() {
  // @@protoc_insertion_point(field_release:zera_txn.ExpenseRatioTXN.output_address)
  return _impl_.output_address_.Release();
}
inline void ExpenseRatioTXN::set_allocated_output_address(std::string* output_address) {
  if (output_address != nullptr) {
    
  } else {
    
  }
  _impl_.output_address_.SetAllocated(output_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_address_.IsDefault()) {
    _impl_.output_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ExpenseRatioTXN.output_address)
}

// -------------------------------------------------------------------

// PreMintWallet

// bytes address = 1;
inline void PreMintWallet::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& PreMintWallet::address() const {
  // @@protoc_insertion_point(field_get:zera_txn.PreMintWallet.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PreMintWallet::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.PreMintWallet.address)
}
inline std::string* PreMintWallet::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.PreMintWallet.address)
  return _s;
}
inline const std::string& PreMintWallet::_internal_address() const {
  return _impl_.address_.Get();
}
inline void PreMintWallet::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* PreMintWallet::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* PreMintWallet::release_address() {
  // @@protoc_insertion_point(field_release:zera_txn.PreMintWallet.address)
  return _impl_.address_.Release();
}
inline void PreMintWallet::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.PreMintWallet.address)
}

// string amount = 2;
inline void PreMintWallet::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& PreMintWallet::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.PreMintWallet.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PreMintWallet::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.PreMintWallet.amount)
}
inline std::string* PreMintWallet::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.PreMintWallet.amount)
  return _s;
}
inline const std::string& PreMintWallet::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void PreMintWallet::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* PreMintWallet::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* PreMintWallet::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.PreMintWallet.amount)
  return _impl_.amount_.Release();
}
inline void PreMintWallet::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.PreMintWallet.amount)
}

// -------------------------------------------------------------------

// Transfer

// bytes recipient_address = 1;
inline void Transfer::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& Transfer::recipient_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.Transfer.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Transfer.recipient_address)
}
inline std::string* Transfer::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.Transfer.recipient_address)
  return _s;
}
inline const std::string& Transfer::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void Transfer::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Transfer::release_recipient_address() {
  // @@protoc_insertion_point(field_release:zera_txn.Transfer.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void Transfer::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Transfer.recipient_address)
}

// string amount = 2;
inline void Transfer::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& Transfer::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.Transfer.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Transfer.amount)
}
inline std::string* Transfer::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.Transfer.amount)
  return _s;
}
inline const std::string& Transfer::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void Transfer::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* Transfer::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.Transfer.amount)
  return _impl_.amount_.Release();
}
inline void Transfer::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Transfer.amount)
}

// string contract_id = 3;
inline void Transfer::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& Transfer::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.Transfer.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Transfer.contract_id)
}
inline std::string* Transfer::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.Transfer.contract_id)
  return _s;
}
inline const std::string& Transfer::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void Transfer::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Transfer::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.Transfer.contract_id)
  return _impl_.contract_id_.Release();
}
inline void Transfer::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Transfer.contract_id)
}

// optional string contract_fee_amount = 4;
inline bool Transfer::_internal_has_contract_fee_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Transfer::has_contract_fee_amount() const {
  return _internal_has_contract_fee_amount();
}
inline void Transfer::clear_contract_fee_amount() {
  _impl_.contract_fee_amount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Transfer::contract_fee_amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.Transfer.contract_fee_amount)
  return _internal_contract_fee_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_contract_fee_amount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.contract_fee_amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Transfer.contract_fee_amount)
}
inline std::string* Transfer::mutable_contract_fee_amount() {
  std::string* _s = _internal_mutable_contract_fee_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.Transfer.contract_fee_amount)
  return _s;
}
inline const std::string& Transfer::_internal_contract_fee_amount() const {
  return _impl_.contract_fee_amount_.Get();
}
inline void Transfer::_internal_set_contract_fee_amount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contract_fee_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_contract_fee_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contract_fee_amount_.Mutable(GetArenaForAllocation());
}
inline std::string* Transfer::release_contract_fee_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.Transfer.contract_fee_amount)
  if (!_internal_has_contract_fee_amount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.contract_fee_amount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_amount_.IsDefault()) {
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Transfer::set_allocated_contract_fee_amount(std::string* contract_fee_amount) {
  if (contract_fee_amount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contract_fee_amount_.SetAllocated(contract_fee_amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_amount_.IsDefault()) {
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Transfer.contract_fee_amount)
}

// optional string contract_fee_id = 5;
inline bool Transfer::_internal_has_contract_fee_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Transfer::has_contract_fee_id() const {
  return _internal_has_contract_fee_id();
}
inline void Transfer::clear_contract_fee_id() {
  _impl_.contract_fee_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Transfer::contract_fee_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.Transfer.contract_fee_id)
  return _internal_contract_fee_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_contract_fee_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.contract_fee_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Transfer.contract_fee_id)
}
inline std::string* Transfer::mutable_contract_fee_id() {
  std::string* _s = _internal_mutable_contract_fee_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.Transfer.contract_fee_id)
  return _s;
}
inline const std::string& Transfer::_internal_contract_fee_id() const {
  return _impl_.contract_fee_id_.Get();
}
inline void Transfer::_internal_set_contract_fee_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.contract_fee_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_contract_fee_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.contract_fee_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Transfer::release_contract_fee_id() {
  // @@protoc_insertion_point(field_release:zera_txn.Transfer.contract_fee_id)
  if (!_internal_has_contract_fee_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.contract_fee_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_id_.IsDefault()) {
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Transfer::set_allocated_contract_fee_id(std::string* contract_fee_id) {
  if (contract_fee_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.contract_fee_id_.SetAllocated(contract_fee_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_id_.IsDefault()) {
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Transfer.contract_fee_id)
}

// string base_fee_amount = 6;
inline void Transfer::clear_base_fee_amount() {
  _impl_.base_fee_amount_.ClearToEmpty();
}
inline const std::string& Transfer::base_fee_amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.Transfer.base_fee_amount)
  return _internal_base_fee_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_base_fee_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_fee_amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Transfer.base_fee_amount)
}
inline std::string* Transfer::mutable_base_fee_amount() {
  std::string* _s = _internal_mutable_base_fee_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.Transfer.base_fee_amount)
  return _s;
}
inline const std::string& Transfer::_internal_base_fee_amount() const {
  return _impl_.base_fee_amount_.Get();
}
inline void Transfer::_internal_set_base_fee_amount(const std::string& value) {
  
  _impl_.base_fee_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_base_fee_amount() {
  
  return _impl_.base_fee_amount_.Mutable(GetArenaForAllocation());
}
inline std::string* Transfer::release_base_fee_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.Transfer.base_fee_amount)
  return _impl_.base_fee_amount_.Release();
}
inline void Transfer::set_allocated_base_fee_amount(std::string* base_fee_amount) {
  if (base_fee_amount != nullptr) {
    
  } else {
    
  }
  _impl_.base_fee_amount_.SetAllocated(base_fee_amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_fee_amount_.IsDefault()) {
    _impl_.base_fee_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Transfer.base_fee_amount)
}

// string base_fee_id = 7;
inline void Transfer::clear_base_fee_id() {
  _impl_.base_fee_id_.ClearToEmpty();
}
inline const std::string& Transfer::base_fee_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.Transfer.base_fee_id)
  return _internal_base_fee_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_base_fee_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_fee_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Transfer.base_fee_id)
}
inline std::string* Transfer::mutable_base_fee_id() {
  std::string* _s = _internal_mutable_base_fee_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.Transfer.base_fee_id)
  return _s;
}
inline const std::string& Transfer::_internal_base_fee_id() const {
  return _impl_.base_fee_id_.Get();
}
inline void Transfer::_internal_set_base_fee_id(const std::string& value) {
  
  _impl_.base_fee_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_base_fee_id() {
  
  return _impl_.base_fee_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Transfer::release_base_fee_id() {
  // @@protoc_insertion_point(field_release:zera_txn.Transfer.base_fee_id)
  return _impl_.base_fee_id_.Release();
}
inline void Transfer::set_allocated_base_fee_id(std::string* base_fee_id) {
  if (base_fee_id != nullptr) {
    
  } else {
    
  }
  _impl_.base_fee_id_.SetAllocated(base_fee_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_fee_id_.IsDefault()) {
    _impl_.base_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Transfer.base_fee_id)
}

// optional string memo = 8;
inline bool Transfer::_internal_has_memo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Transfer::has_memo() const {
  return _internal_has_memo();
}
inline void Transfer::clear_memo() {
  _impl_.memo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Transfer::memo() const {
  // @@protoc_insertion_point(field_get:zera_txn.Transfer.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transfer::set_memo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Transfer.memo)
}
inline std::string* Transfer::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:zera_txn.Transfer.memo)
  return _s;
}
inline const std::string& Transfer::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void Transfer::_internal_set_memo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* Transfer::_internal_mutable_memo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.memo_.Mutable(GetArenaForAllocation());
}
inline std::string* Transfer::release_memo() {
  // @@protoc_insertion_point(field_release:zera_txn.Transfer.memo)
  if (!_internal_has_memo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.memo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Transfer::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Transfer.memo)
}

// -------------------------------------------------------------------

// BurnSBTTXN

// .zera_txn.BaseTXN base = 1;
inline bool BurnSBTTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool BurnSBTTXN::has_base() const {
  return _internal_has_base();
}
inline void BurnSBTTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& BurnSBTTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& BurnSBTTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.BurnSBTTXN.base)
  return _internal_base();
}
inline void BurnSBTTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.BurnSBTTXN.base)
}
inline ::zera_txn::BaseTXN* BurnSBTTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* BurnSBTTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.BurnSBTTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* BurnSBTTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* BurnSBTTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.BurnSBTTXN.base)
  return _msg;
}
inline void BurnSBTTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BurnSBTTXN.base)
}

// string contract_id = 2;
inline void BurnSBTTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& BurnSBTTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.BurnSBTTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BurnSBTTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BurnSBTTXN.contract_id)
}
inline std::string* BurnSBTTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.BurnSBTTXN.contract_id)
  return _s;
}
inline const std::string& BurnSBTTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void BurnSBTTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BurnSBTTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BurnSBTTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.BurnSBTTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void BurnSBTTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BurnSBTTXN.contract_id)
}

// string item_id = 3;
inline void BurnSBTTXN::clear_item_id() {
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& BurnSBTTXN::item_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.BurnSBTTXN.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BurnSBTTXN::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BurnSBTTXN.item_id)
}
inline std::string* BurnSBTTXN::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.BurnSBTTXN.item_id)
  return _s;
}
inline const std::string& BurnSBTTXN::_internal_item_id() const {
  return _impl_.item_id_.Get();
}
inline void BurnSBTTXN::_internal_set_item_id(const std::string& value) {
  
  _impl_.item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BurnSBTTXN::_internal_mutable_item_id() {
  
  return _impl_.item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BurnSBTTXN::release_item_id() {
  // @@protoc_insertion_point(field_release:zera_txn.BurnSBTTXN.item_id)
  return _impl_.item_id_.Release();
}
inline void BurnSBTTXN::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  _impl_.item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BurnSBTTXN.item_id)
}

// -------------------------------------------------------------------

// BaseTXN

// .zera_txn.PublicKey public_key = 1;
inline bool BaseTXN::_internal_has_public_key() const {
  return this != internal_default_instance() && _impl_.public_key_ != nullptr;
}
inline bool BaseTXN::has_public_key() const {
  return _internal_has_public_key();
}
inline void BaseTXN::clear_public_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
}
inline const ::zera_txn::PublicKey& BaseTXN::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = _impl_.public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::PublicKey&>(
      ::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& BaseTXN::public_key() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.public_key)
  return _internal_public_key();
}
inline void BaseTXN::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  _impl_.public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.BaseTXN.public_key)
}
inline ::zera_txn::PublicKey* BaseTXN::release_public_key() {
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::PublicKey* BaseTXN::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.public_key)
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* BaseTXN::_internal_mutable_public_key() {
  
  if (_impl_.public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArenaForAllocation());
    _impl_.public_key_ = p;
  }
  return _impl_.public_key_;
}
inline ::zera_txn::PublicKey* BaseTXN::mutable_public_key() {
  ::zera_txn::PublicKey* _msg = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.public_key)
  return _msg;
}
inline void BaseTXN::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.public_key_;
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_key);
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.public_key)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool BaseTXN::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool BaseTXN::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BaseTXN::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BaseTXN::timestamp() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.timestamp)
  return _internal_timestamp();
}
inline void BaseTXN::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.BaseTXN.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BaseTXN::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BaseTXN::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BaseTXN::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BaseTXN::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.timestamp)
  return _msg;
}
inline void BaseTXN::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.timestamp)
}

// string fee_amount = 4;
inline void BaseTXN::clear_fee_amount() {
  _impl_.fee_amount_.ClearToEmpty();
}
inline const std::string& BaseTXN::fee_amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.fee_amount)
  return _internal_fee_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseTXN::set_fee_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fee_amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.fee_amount)
}
inline std::string* BaseTXN::mutable_fee_amount() {
  std::string* _s = _internal_mutable_fee_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.fee_amount)
  return _s;
}
inline const std::string& BaseTXN::_internal_fee_amount() const {
  return _impl_.fee_amount_.Get();
}
inline void BaseTXN::_internal_set_fee_amount(const std::string& value) {
  
  _impl_.fee_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseTXN::_internal_mutable_fee_amount() {
  
  return _impl_.fee_amount_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseTXN::release_fee_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.fee_amount)
  return _impl_.fee_amount_.Release();
}
inline void BaseTXN::set_allocated_fee_amount(std::string* fee_amount) {
  if (fee_amount != nullptr) {
    
  } else {
    
  }
  _impl_.fee_amount_.SetAllocated(fee_amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_amount_.IsDefault()) {
    _impl_.fee_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.fee_amount)
}

// string fee_id = 5;
inline void BaseTXN::clear_fee_id() {
  _impl_.fee_id_.ClearToEmpty();
}
inline const std::string& BaseTXN::fee_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.fee_id)
  return _internal_fee_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseTXN::set_fee_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fee_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.fee_id)
}
inline std::string* BaseTXN::mutable_fee_id() {
  std::string* _s = _internal_mutable_fee_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.fee_id)
  return _s;
}
inline const std::string& BaseTXN::_internal_fee_id() const {
  return _impl_.fee_id_.Get();
}
inline void BaseTXN::_internal_set_fee_id(const std::string& value) {
  
  _impl_.fee_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseTXN::_internal_mutable_fee_id() {
  
  return _impl_.fee_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseTXN::release_fee_id() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.fee_id)
  return _impl_.fee_id_.Release();
}
inline void BaseTXN::set_allocated_fee_id(std::string* fee_id) {
  if (fee_id != nullptr) {
    
  } else {
    
  }
  _impl_.fee_id_.SetAllocated(fee_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fee_id_.IsDefault()) {
    _impl_.fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.fee_id)
}

// optional bytes signature = 6;
inline bool BaseTXN::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaseTXN::has_signature() const {
  return _internal_has_signature();
}
inline void BaseTXN::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BaseTXN::signature() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseTXN::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.signature)
}
inline std::string* BaseTXN::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.signature)
  return _s;
}
inline const std::string& BaseTXN::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void BaseTXN::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseTXN::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseTXN::release_signature() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseTXN::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.signature)
}

// optional bytes hash = 7;
inline bool BaseTXN::_internal_has_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaseTXN::has_hash() const {
  return _internal_has_hash();
}
inline void BaseTXN::clear_hash() {
  _impl_.hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BaseTXN::hash() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseTXN::set_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.hash)
}
inline std::string* BaseTXN::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.hash)
  return _s;
}
inline const std::string& BaseTXN::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void BaseTXN::_internal_set_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseTXN::_internal_mutable_hash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseTXN::release_hash() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseTXN::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.hash)
}

// optional string memo = 8;
inline bool BaseTXN::_internal_has_memo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BaseTXN::has_memo() const {
  return _internal_has_memo();
}
inline void BaseTXN::clear_memo() {
  _impl_.memo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BaseTXN::memo() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseTXN::set_memo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.memo)
}
inline std::string* BaseTXN::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.memo)
  return _s;
}
inline const std::string& BaseTXN::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void BaseTXN::_internal_set_memo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseTXN::_internal_mutable_memo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.memo_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseTXN::release_memo() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.memo)
  if (!_internal_has_memo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.memo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseTXN::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.memo)
}

// optional bool safe_send = 9;
inline bool BaseTXN::_internal_has_safe_send() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BaseTXN::has_safe_send() const {
  return _internal_has_safe_send();
}
inline void BaseTXN::clear_safe_send() {
  _impl_.safe_send_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool BaseTXN::_internal_safe_send() const {
  return _impl_.safe_send_;
}
inline bool BaseTXN::safe_send() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.safe_send)
  return _internal_safe_send();
}
inline void BaseTXN::_internal_set_safe_send(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.safe_send_ = value;
}
inline void BaseTXN::set_safe_send(bool value) {
  _internal_set_safe_send(value);
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.safe_send)
}

// uint64 nonce = 10;
inline void BaseTXN::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t BaseTXN::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t BaseTXN::nonce() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.nonce)
  return _internal_nonce();
}
inline void BaseTXN::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void BaseTXN::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.nonce)
}

// optional string interface_fee = 11;
inline bool BaseTXN::_internal_has_interface_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BaseTXN::has_interface_fee() const {
  return _internal_has_interface_fee();
}
inline void BaseTXN::clear_interface_fee() {
  _impl_.interface_fee_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BaseTXN::interface_fee() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.interface_fee)
  return _internal_interface_fee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseTXN::set_interface_fee(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.interface_fee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.interface_fee)
}
inline std::string* BaseTXN::mutable_interface_fee() {
  std::string* _s = _internal_mutable_interface_fee();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.interface_fee)
  return _s;
}
inline const std::string& BaseTXN::_internal_interface_fee() const {
  return _impl_.interface_fee_.Get();
}
inline void BaseTXN::_internal_set_interface_fee(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.interface_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseTXN::_internal_mutable_interface_fee() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.interface_fee_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseTXN::release_interface_fee() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.interface_fee)
  if (!_internal_has_interface_fee()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.interface_fee_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_fee_.IsDefault()) {
    _impl_.interface_fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseTXN::set_allocated_interface_fee(std::string* interface_fee) {
  if (interface_fee != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.interface_fee_.SetAllocated(interface_fee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_fee_.IsDefault()) {
    _impl_.interface_fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.interface_fee)
}

// optional string interface_fee_id = 12;
inline bool BaseTXN::_internal_has_interface_fee_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BaseTXN::has_interface_fee_id() const {
  return _internal_has_interface_fee_id();
}
inline void BaseTXN::clear_interface_fee_id() {
  _impl_.interface_fee_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BaseTXN::interface_fee_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.interface_fee_id)
  return _internal_interface_fee_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseTXN::set_interface_fee_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.interface_fee_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.interface_fee_id)
}
inline std::string* BaseTXN::mutable_interface_fee_id() {
  std::string* _s = _internal_mutable_interface_fee_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.interface_fee_id)
  return _s;
}
inline const std::string& BaseTXN::_internal_interface_fee_id() const {
  return _impl_.interface_fee_id_.Get();
}
inline void BaseTXN::_internal_set_interface_fee_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.interface_fee_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseTXN::_internal_mutable_interface_fee_id() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.interface_fee_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseTXN::release_interface_fee_id() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.interface_fee_id)
  if (!_internal_has_interface_fee_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.interface_fee_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_fee_id_.IsDefault()) {
    _impl_.interface_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseTXN::set_allocated_interface_fee_id(std::string* interface_fee_id) {
  if (interface_fee_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.interface_fee_id_.SetAllocated(interface_fee_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_fee_id_.IsDefault()) {
    _impl_.interface_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.interface_fee_id)
}

// optional string interface_address = 13;
inline bool BaseTXN::_internal_has_interface_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BaseTXN::has_interface_address() const {
  return _internal_has_interface_address();
}
inline void BaseTXN::clear_interface_address() {
  _impl_.interface_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& BaseTXN::interface_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.BaseTXN.interface_address)
  return _internal_interface_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseTXN::set_interface_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.interface_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.BaseTXN.interface_address)
}
inline std::string* BaseTXN::mutable_interface_address() {
  std::string* _s = _internal_mutable_interface_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.BaseTXN.interface_address)
  return _s;
}
inline const std::string& BaseTXN::_internal_interface_address() const {
  return _impl_.interface_address_.Get();
}
inline void BaseTXN::_internal_set_interface_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.interface_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseTXN::_internal_mutable_interface_address() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.interface_address_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseTXN::release_interface_address() {
  // @@protoc_insertion_point(field_release:zera_txn.BaseTXN.interface_address)
  if (!_internal_has_interface_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.interface_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_address_.IsDefault()) {
    _impl_.interface_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BaseTXN::set_allocated_interface_address(std::string* interface_address) {
  if (interface_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.interface_address_.SetAllocated(interface_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_address_.IsDefault()) {
    _impl_.interface_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.BaseTXN.interface_address)
}

// -------------------------------------------------------------------

// PublicKey

// bytes single = 1;
inline void PublicKey::clear_single() {
  _impl_.single_.ClearToEmpty();
}
inline const std::string& PublicKey::single() const {
  // @@protoc_insertion_point(field_get:zera_txn.PublicKey.single)
  return _internal_single();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicKey::set_single(ArgT0&& arg0, ArgT... args) {
 
 _impl_.single_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.PublicKey.single)
}
inline std::string* PublicKey::mutable_single() {
  std::string* _s = _internal_mutable_single();
  // @@protoc_insertion_point(field_mutable:zera_txn.PublicKey.single)
  return _s;
}
inline const std::string& PublicKey::_internal_single() const {
  return _impl_.single_.Get();
}
inline void PublicKey::_internal_set_single(const std::string& value) {
  
  _impl_.single_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicKey::_internal_mutable_single() {
  
  return _impl_.single_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicKey::release_single() {
  // @@protoc_insertion_point(field_release:zera_txn.PublicKey.single)
  return _impl_.single_.Release();
}
inline void PublicKey::set_allocated_single(std::string* single) {
  if (single != nullptr) {
    
  } else {
    
  }
  _impl_.single_.SetAllocated(single, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.single_.IsDefault()) {
    _impl_.single_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.PublicKey.single)
}

// .zera_txn.MultiKey multi = 2;
inline bool PublicKey::_internal_has_multi() const {
  return this != internal_default_instance() && _impl_.multi_ != nullptr;
}
inline bool PublicKey::has_multi() const {
  return _internal_has_multi();
}
inline void PublicKey::clear_multi() {
  if (GetArenaForAllocation() == nullptr && _impl_.multi_ != nullptr) {
    delete _impl_.multi_;
  }
  _impl_.multi_ = nullptr;
}
inline const ::zera_txn::MultiKey& PublicKey::_internal_multi() const {
  const ::zera_txn::MultiKey* p = _impl_.multi_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::MultiKey&>(
      ::zera_txn::_MultiKey_default_instance_);
}
inline const ::zera_txn::MultiKey& PublicKey::multi() const {
  // @@protoc_insertion_point(field_get:zera_txn.PublicKey.multi)
  return _internal_multi();
}
inline void PublicKey::unsafe_arena_set_allocated_multi(
    ::zera_txn::MultiKey* multi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multi_);
  }
  _impl_.multi_ = multi;
  if (multi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.PublicKey.multi)
}
inline ::zera_txn::MultiKey* PublicKey::release_multi() {
  
  ::zera_txn::MultiKey* temp = _impl_.multi_;
  _impl_.multi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::MultiKey* PublicKey::unsafe_arena_release_multi() {
  // @@protoc_insertion_point(field_release:zera_txn.PublicKey.multi)
  
  ::zera_txn::MultiKey* temp = _impl_.multi_;
  _impl_.multi_ = nullptr;
  return temp;
}
inline ::zera_txn::MultiKey* PublicKey::_internal_mutable_multi() {
  
  if (_impl_.multi_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::MultiKey>(GetArenaForAllocation());
    _impl_.multi_ = p;
  }
  return _impl_.multi_;
}
inline ::zera_txn::MultiKey* PublicKey::mutable_multi() {
  ::zera_txn::MultiKey* _msg = _internal_mutable_multi();
  // @@protoc_insertion_point(field_mutable:zera_txn.PublicKey.multi)
  return _msg;
}
inline void PublicKey::set_allocated_multi(::zera_txn::MultiKey* multi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.multi_;
  }
  if (multi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multi);
    if (message_arena != submessage_arena) {
      multi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.multi_ = multi;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.PublicKey.multi)
}

// optional bytes smart_contract_auth = 3;
inline bool PublicKey::_internal_has_smart_contract_auth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublicKey::has_smart_contract_auth() const {
  return _internal_has_smart_contract_auth();
}
inline void PublicKey::clear_smart_contract_auth() {
  _impl_.smart_contract_auth_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublicKey::smart_contract_auth() const {
  // @@protoc_insertion_point(field_get:zera_txn.PublicKey.smart_contract_auth)
  return _internal_smart_contract_auth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicKey::set_smart_contract_auth(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.smart_contract_auth_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.PublicKey.smart_contract_auth)
}
inline std::string* PublicKey::mutable_smart_contract_auth() {
  std::string* _s = _internal_mutable_smart_contract_auth();
  // @@protoc_insertion_point(field_mutable:zera_txn.PublicKey.smart_contract_auth)
  return _s;
}
inline const std::string& PublicKey::_internal_smart_contract_auth() const {
  return _impl_.smart_contract_auth_.Get();
}
inline void PublicKey::_internal_set_smart_contract_auth(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.smart_contract_auth_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicKey::_internal_mutable_smart_contract_auth() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.smart_contract_auth_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicKey::release_smart_contract_auth() {
  // @@protoc_insertion_point(field_release:zera_txn.PublicKey.smart_contract_auth)
  if (!_internal_has_smart_contract_auth()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.smart_contract_auth_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smart_contract_auth_.IsDefault()) {
    _impl_.smart_contract_auth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublicKey::set_allocated_smart_contract_auth(std::string* smart_contract_auth) {
  if (smart_contract_auth != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.smart_contract_auth_.SetAllocated(smart_contract_auth, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smart_contract_auth_.IsDefault()) {
    _impl_.smart_contract_auth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.PublicKey.smart_contract_auth)
}

// optional bytes governance_auth = 4;
inline bool PublicKey::_internal_has_governance_auth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublicKey::has_governance_auth() const {
  return _internal_has_governance_auth();
}
inline void PublicKey::clear_governance_auth() {
  _impl_.governance_auth_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PublicKey::governance_auth() const {
  // @@protoc_insertion_point(field_get:zera_txn.PublicKey.governance_auth)
  return _internal_governance_auth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicKey::set_governance_auth(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.governance_auth_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.PublicKey.governance_auth)
}
inline std::string* PublicKey::mutable_governance_auth() {
  std::string* _s = _internal_mutable_governance_auth();
  // @@protoc_insertion_point(field_mutable:zera_txn.PublicKey.governance_auth)
  return _s;
}
inline const std::string& PublicKey::_internal_governance_auth() const {
  return _impl_.governance_auth_.Get();
}
inline void PublicKey::_internal_set_governance_auth(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.governance_auth_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicKey::_internal_mutable_governance_auth() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.governance_auth_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicKey::release_governance_auth() {
  // @@protoc_insertion_point(field_release:zera_txn.PublicKey.governance_auth)
  if (!_internal_has_governance_auth()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.governance_auth_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.governance_auth_.IsDefault()) {
    _impl_.governance_auth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublicKey::set_allocated_governance_auth(std::string* governance_auth) {
  if (governance_auth != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.governance_auth_.SetAllocated(governance_auth, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.governance_auth_.IsDefault()) {
    _impl_.governance_auth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.PublicKey.governance_auth)
}

// -------------------------------------------------------------------

// GovernanceAuth

// bytes auth = 1;
inline void GovernanceAuth::clear_auth() {
  _impl_.auth_.ClearToEmpty();
}
inline const std::string& GovernanceAuth::auth() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceAuth.auth)
  return _internal_auth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceAuth::set_auth(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceAuth.auth)
}
inline std::string* GovernanceAuth::mutable_auth() {
  std::string* _s = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceAuth.auth)
  return _s;
}
inline const std::string& GovernanceAuth::_internal_auth() const {
  return _impl_.auth_.Get();
}
inline void GovernanceAuth::_internal_set_auth(const std::string& value) {
  
  _impl_.auth_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceAuth::_internal_mutable_auth() {
  
  return _impl_.auth_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceAuth::release_auth() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceAuth.auth)
  return _impl_.auth_.Release();
}
inline void GovernanceAuth::set_allocated_auth(std::string* auth) {
  if (auth != nullptr) {
    
  } else {
    
  }
  _impl_.auth_.SetAllocated(auth, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_.IsDefault()) {
    _impl_.auth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceAuth.auth)
}

// bytes proposal_id = 2;
inline void GovernanceAuth::clear_proposal_id() {
  _impl_.proposal_id_.ClearToEmpty();
}
inline const std::string& GovernanceAuth::proposal_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceAuth.proposal_id)
  return _internal_proposal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceAuth::set_proposal_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proposal_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceAuth.proposal_id)
}
inline std::string* GovernanceAuth::mutable_proposal_id() {
  std::string* _s = _internal_mutable_proposal_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceAuth.proposal_id)
  return _s;
}
inline const std::string& GovernanceAuth::_internal_proposal_id() const {
  return _impl_.proposal_id_.Get();
}
inline void GovernanceAuth::_internal_set_proposal_id(const std::string& value) {
  
  _impl_.proposal_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceAuth::_internal_mutable_proposal_id() {
  
  return _impl_.proposal_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceAuth::release_proposal_id() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceAuth.proposal_id)
  return _impl_.proposal_id_.Release();
}
inline void GovernanceAuth::set_allocated_proposal_id(std::string* proposal_id) {
  if (proposal_id != nullptr) {
    
  } else {
    
  }
  _impl_.proposal_id_.SetAllocated(proposal_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proposal_id_.IsDefault()) {
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceAuth.proposal_id)
}

// -------------------------------------------------------------------

// MultiKey

// repeated bytes public_keys = 1;
inline int MultiKey::_internal_public_keys_size() const {
  return _impl_.public_keys_.size();
}
inline int MultiKey::public_keys_size() const {
  return _internal_public_keys_size();
}
inline void MultiKey::clear_public_keys() {
  _impl_.public_keys_.Clear();
}
inline std::string* MultiKey::add_public_keys() {
  std::string* _s = _internal_add_public_keys();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.MultiKey.public_keys)
  return _s;
}
inline const std::string& MultiKey::_internal_public_keys(int index) const {
  return _impl_.public_keys_.Get(index);
}
inline const std::string& MultiKey::public_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.MultiKey.public_keys)
  return _internal_public_keys(index);
}
inline std::string* MultiKey::mutable_public_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.MultiKey.public_keys)
  return _impl_.public_keys_.Mutable(index);
}
inline void MultiKey::set_public_keys(int index, const std::string& value) {
  _impl_.public_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.MultiKey.public_keys)
}
inline void MultiKey::set_public_keys(int index, std::string&& value) {
  _impl_.public_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.MultiKey.public_keys)
}
inline void MultiKey::set_public_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.public_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.MultiKey.public_keys)
}
inline void MultiKey::set_public_keys(int index, const void* value, size_t size) {
  _impl_.public_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.MultiKey.public_keys)
}
inline std::string* MultiKey::_internal_add_public_keys() {
  return _impl_.public_keys_.Add();
}
inline void MultiKey::add_public_keys(const std::string& value) {
  _impl_.public_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.MultiKey.public_keys)
}
inline void MultiKey::add_public_keys(std::string&& value) {
  _impl_.public_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.MultiKey.public_keys)
}
inline void MultiKey::add_public_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.public_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.MultiKey.public_keys)
}
inline void MultiKey::add_public_keys(const void* value, size_t size) {
  _impl_.public_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.MultiKey.public_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MultiKey::public_keys() const {
  // @@protoc_insertion_point(field_list:zera_txn.MultiKey.public_keys)
  return _impl_.public_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MultiKey::mutable_public_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.MultiKey.public_keys)
  return &_impl_.public_keys_;
}

// repeated bytes signatures = 2;
inline int MultiKey::_internal_signatures_size() const {
  return _impl_.signatures_.size();
}
inline int MultiKey::signatures_size() const {
  return _internal_signatures_size();
}
inline void MultiKey::clear_signatures() {
  _impl_.signatures_.Clear();
}
inline std::string* MultiKey::add_signatures() {
  std::string* _s = _internal_add_signatures();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.MultiKey.signatures)
  return _s;
}
inline const std::string& MultiKey::_internal_signatures(int index) const {
  return _impl_.signatures_.Get(index);
}
inline const std::string& MultiKey::signatures(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.MultiKey.signatures)
  return _internal_signatures(index);
}
inline std::string* MultiKey::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.MultiKey.signatures)
  return _impl_.signatures_.Mutable(index);
}
inline void MultiKey::set_signatures(int index, const std::string& value) {
  _impl_.signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.MultiKey.signatures)
}
inline void MultiKey::set_signatures(int index, std::string&& value) {
  _impl_.signatures_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.MultiKey.signatures)
}
inline void MultiKey::set_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.MultiKey.signatures)
}
inline void MultiKey::set_signatures(int index, const void* value, size_t size) {
  _impl_.signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.MultiKey.signatures)
}
inline std::string* MultiKey::_internal_add_signatures() {
  return _impl_.signatures_.Add();
}
inline void MultiKey::add_signatures(const std::string& value) {
  _impl_.signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.MultiKey.signatures)
}
inline void MultiKey::add_signatures(std::string&& value) {
  _impl_.signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.MultiKey.signatures)
}
inline void MultiKey::add_signatures(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.MultiKey.signatures)
}
inline void MultiKey::add_signatures(const void* value, size_t size) {
  _impl_.signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.MultiKey.signatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MultiKey::signatures() const {
  // @@protoc_insertion_point(field_list:zera_txn.MultiKey.signatures)
  return _impl_.signatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MultiKey::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.MultiKey.signatures)
  return &_impl_.signatures_;
}

// repeated .zera_txn.MultiPatterns multi_patterns = 3;
inline int MultiKey::_internal_multi_patterns_size() const {
  return _impl_.multi_patterns_.size();
}
inline int MultiKey::multi_patterns_size() const {
  return _internal_multi_patterns_size();
}
inline void MultiKey::clear_multi_patterns() {
  _impl_.multi_patterns_.Clear();
}
inline ::zera_txn::MultiPatterns* MultiKey::mutable_multi_patterns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.MultiKey.multi_patterns)
  return _impl_.multi_patterns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MultiPatterns >*
MultiKey::mutable_multi_patterns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.MultiKey.multi_patterns)
  return &_impl_.multi_patterns_;
}
inline const ::zera_txn::MultiPatterns& MultiKey::_internal_multi_patterns(int index) const {
  return _impl_.multi_patterns_.Get(index);
}
inline const ::zera_txn::MultiPatterns& MultiKey::multi_patterns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.MultiKey.multi_patterns)
  return _internal_multi_patterns(index);
}
inline ::zera_txn::MultiPatterns* MultiKey::_internal_add_multi_patterns() {
  return _impl_.multi_patterns_.Add();
}
inline ::zera_txn::MultiPatterns* MultiKey::add_multi_patterns() {
  ::zera_txn::MultiPatterns* _add = _internal_add_multi_patterns();
  // @@protoc_insertion_point(field_add:zera_txn.MultiKey.multi_patterns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MultiPatterns >&
MultiKey::multi_patterns() const {
  // @@protoc_insertion_point(field_list:zera_txn.MultiKey.multi_patterns)
  return _impl_.multi_patterns_;
}

// repeated string hash_tokens = 4;
inline int MultiKey::_internal_hash_tokens_size() const {
  return _impl_.hash_tokens_.size();
}
inline int MultiKey::hash_tokens_size() const {
  return _internal_hash_tokens_size();
}
inline void MultiKey::clear_hash_tokens() {
  _impl_.hash_tokens_.Clear();
}
inline std::string* MultiKey::add_hash_tokens() {
  std::string* _s = _internal_add_hash_tokens();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.MultiKey.hash_tokens)
  return _s;
}
inline const std::string& MultiKey::_internal_hash_tokens(int index) const {
  return _impl_.hash_tokens_.Get(index);
}
inline const std::string& MultiKey::hash_tokens(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.MultiKey.hash_tokens)
  return _internal_hash_tokens(index);
}
inline std::string* MultiKey::mutable_hash_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.MultiKey.hash_tokens)
  return _impl_.hash_tokens_.Mutable(index);
}
inline void MultiKey::set_hash_tokens(int index, const std::string& value) {
  _impl_.hash_tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.MultiKey.hash_tokens)
}
inline void MultiKey::set_hash_tokens(int index, std::string&& value) {
  _impl_.hash_tokens_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.MultiKey.hash_tokens)
}
inline void MultiKey::set_hash_tokens(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hash_tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.MultiKey.hash_tokens)
}
inline void MultiKey::set_hash_tokens(int index, const char* value, size_t size) {
  _impl_.hash_tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.MultiKey.hash_tokens)
}
inline std::string* MultiKey::_internal_add_hash_tokens() {
  return _impl_.hash_tokens_.Add();
}
inline void MultiKey::add_hash_tokens(const std::string& value) {
  _impl_.hash_tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.MultiKey.hash_tokens)
}
inline void MultiKey::add_hash_tokens(std::string&& value) {
  _impl_.hash_tokens_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.MultiKey.hash_tokens)
}
inline void MultiKey::add_hash_tokens(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hash_tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.MultiKey.hash_tokens)
}
inline void MultiKey::add_hash_tokens(const char* value, size_t size) {
  _impl_.hash_tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.MultiKey.hash_tokens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MultiKey::hash_tokens() const {
  // @@protoc_insertion_point(field_list:zera_txn.MultiKey.hash_tokens)
  return _impl_.hash_tokens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MultiKey::mutable_hash_tokens() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.MultiKey.hash_tokens)
  return &_impl_.hash_tokens_;
}

// -------------------------------------------------------------------

// MultiPatterns

// repeated uint32 class = 1;
inline int MultiPatterns::_internal_class__size() const {
  return _impl_.class__.size();
}
inline int MultiPatterns::class__size() const {
  return _internal_class__size();
}
inline void MultiPatterns::clear_class_() {
  _impl_.class__.Clear();
}
inline uint32_t MultiPatterns::_internal_class_(int index) const {
  return _impl_.class__.Get(index);
}
inline uint32_t MultiPatterns::class_(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.MultiPatterns.class)
  return _internal_class_(index);
}
inline void MultiPatterns::set_class_(int index, uint32_t value) {
  _impl_.class__.Set(index, value);
  // @@protoc_insertion_point(field_set:zera_txn.MultiPatterns.class)
}
inline void MultiPatterns::_internal_add_class_(uint32_t value) {
  _impl_.class__.Add(value);
}
inline void MultiPatterns::add_class_(uint32_t value) {
  _internal_add_class_(value);
  // @@protoc_insertion_point(field_add:zera_txn.MultiPatterns.class)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MultiPatterns::_internal_class_() const {
  return _impl_.class__;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MultiPatterns::class_() const {
  // @@protoc_insertion_point(field_list:zera_txn.MultiPatterns.class)
  return _internal_class_();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MultiPatterns::_internal_mutable_class_() {
  return &_impl_.class__;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MultiPatterns::mutable_class_() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.MultiPatterns.class)
  return _internal_mutable_class_();
}

// repeated uint32 required = 2;
inline int MultiPatterns::_internal_required_size() const {
  return _impl_.required_.size();
}
inline int MultiPatterns::required_size() const {
  return _internal_required_size();
}
inline void MultiPatterns::clear_required() {
  _impl_.required_.Clear();
}
inline uint32_t MultiPatterns::_internal_required(int index) const {
  return _impl_.required_.Get(index);
}
inline uint32_t MultiPatterns::required(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.MultiPatterns.required)
  return _internal_required(index);
}
inline void MultiPatterns::set_required(int index, uint32_t value) {
  _impl_.required_.Set(index, value);
  // @@protoc_insertion_point(field_set:zera_txn.MultiPatterns.required)
}
inline void MultiPatterns::_internal_add_required(uint32_t value) {
  _impl_.required_.Add(value);
}
inline void MultiPatterns::add_required(uint32_t value) {
  _internal_add_required(value);
  // @@protoc_insertion_point(field_add:zera_txn.MultiPatterns.required)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MultiPatterns::_internal_required() const {
  return _impl_.required_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MultiPatterns::required() const {
  // @@protoc_insertion_point(field_list:zera_txn.MultiPatterns.required)
  return _internal_required();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MultiPatterns::_internal_mutable_required() {
  return &_impl_.required_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MultiPatterns::mutable_required() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.MultiPatterns.required)
  return _internal_mutable_required();
}

// -------------------------------------------------------------------

// SelfCurrencyEquiv

// .zera_txn.BaseTXN base = 1;
inline bool SelfCurrencyEquiv::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool SelfCurrencyEquiv::has_base() const {
  return _internal_has_base();
}
inline void SelfCurrencyEquiv::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& SelfCurrencyEquiv::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& SelfCurrencyEquiv::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.SelfCurrencyEquiv.base)
  return _internal_base();
}
inline void SelfCurrencyEquiv::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.SelfCurrencyEquiv.base)
}
inline ::zera_txn::BaseTXN* SelfCurrencyEquiv::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* SelfCurrencyEquiv::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.SelfCurrencyEquiv.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* SelfCurrencyEquiv::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* SelfCurrencyEquiv::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.SelfCurrencyEquiv.base)
  return _msg;
}
inline void SelfCurrencyEquiv::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SelfCurrencyEquiv.base)
}

// repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
inline int SelfCurrencyEquiv::_internal_cur_equiv_size() const {
  return _impl_.cur_equiv_.size();
}
inline int SelfCurrencyEquiv::cur_equiv_size() const {
  return _internal_cur_equiv_size();
}
inline void SelfCurrencyEquiv::clear_cur_equiv() {
  _impl_.cur_equiv_.Clear();
}
inline ::zera_txn::CurrencyEquiv* SelfCurrencyEquiv::mutable_cur_equiv(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.SelfCurrencyEquiv.cur_equiv)
  return _impl_.cur_equiv_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv >*
SelfCurrencyEquiv::mutable_cur_equiv() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.SelfCurrencyEquiv.cur_equiv)
  return &_impl_.cur_equiv_;
}
inline const ::zera_txn::CurrencyEquiv& SelfCurrencyEquiv::_internal_cur_equiv(int index) const {
  return _impl_.cur_equiv_.Get(index);
}
inline const ::zera_txn::CurrencyEquiv& SelfCurrencyEquiv::cur_equiv(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.SelfCurrencyEquiv.cur_equiv)
  return _internal_cur_equiv(index);
}
inline ::zera_txn::CurrencyEquiv* SelfCurrencyEquiv::_internal_add_cur_equiv() {
  return _impl_.cur_equiv_.Add();
}
inline ::zera_txn::CurrencyEquiv* SelfCurrencyEquiv::add_cur_equiv() {
  ::zera_txn::CurrencyEquiv* _add = _internal_add_cur_equiv();
  // @@protoc_insertion_point(field_add:zera_txn.SelfCurrencyEquiv.cur_equiv)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv >&
SelfCurrencyEquiv::cur_equiv() const {
  // @@protoc_insertion_point(field_list:zera_txn.SelfCurrencyEquiv.cur_equiv)
  return _impl_.cur_equiv_;
}

// -------------------------------------------------------------------

// AuthorizedCurrencyEquiv

// .zera_txn.BaseTXN base = 1;
inline bool AuthorizedCurrencyEquiv::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool AuthorizedCurrencyEquiv::has_base() const {
  return _internal_has_base();
}
inline void AuthorizedCurrencyEquiv::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& AuthorizedCurrencyEquiv::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& AuthorizedCurrencyEquiv::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.AuthorizedCurrencyEquiv.base)
  return _internal_base();
}
inline void AuthorizedCurrencyEquiv::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.AuthorizedCurrencyEquiv.base)
}
inline ::zera_txn::BaseTXN* AuthorizedCurrencyEquiv::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* AuthorizedCurrencyEquiv::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.AuthorizedCurrencyEquiv.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* AuthorizedCurrencyEquiv::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* AuthorizedCurrencyEquiv::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.AuthorizedCurrencyEquiv.base)
  return _msg;
}
inline void AuthorizedCurrencyEquiv::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.AuthorizedCurrencyEquiv.base)
}

// repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
inline int AuthorizedCurrencyEquiv::_internal_cur_equiv_size() const {
  return _impl_.cur_equiv_.size();
}
inline int AuthorizedCurrencyEquiv::cur_equiv_size() const {
  return _internal_cur_equiv_size();
}
inline void AuthorizedCurrencyEquiv::clear_cur_equiv() {
  _impl_.cur_equiv_.Clear();
}
inline ::zera_txn::CurrencyEquiv* AuthorizedCurrencyEquiv::mutable_cur_equiv(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.AuthorizedCurrencyEquiv.cur_equiv)
  return _impl_.cur_equiv_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv >*
AuthorizedCurrencyEquiv::mutable_cur_equiv() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.AuthorizedCurrencyEquiv.cur_equiv)
  return &_impl_.cur_equiv_;
}
inline const ::zera_txn::CurrencyEquiv& AuthorizedCurrencyEquiv::_internal_cur_equiv(int index) const {
  return _impl_.cur_equiv_.Get(index);
}
inline const ::zera_txn::CurrencyEquiv& AuthorizedCurrencyEquiv::cur_equiv(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.AuthorizedCurrencyEquiv.cur_equiv)
  return _internal_cur_equiv(index);
}
inline ::zera_txn::CurrencyEquiv* AuthorizedCurrencyEquiv::_internal_add_cur_equiv() {
  return _impl_.cur_equiv_.Add();
}
inline ::zera_txn::CurrencyEquiv* AuthorizedCurrencyEquiv::add_cur_equiv() {
  ::zera_txn::CurrencyEquiv* _add = _internal_add_cur_equiv();
  // @@protoc_insertion_point(field_add:zera_txn.AuthorizedCurrencyEquiv.cur_equiv)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CurrencyEquiv >&
AuthorizedCurrencyEquiv::cur_equiv() const {
  // @@protoc_insertion_point(field_list:zera_txn.AuthorizedCurrencyEquiv.cur_equiv)
  return _impl_.cur_equiv_;
}

// -------------------------------------------------------------------

// CurrencyEquiv

// string contract_id = 1;
inline void CurrencyEquiv::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& CurrencyEquiv::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.CurrencyEquiv.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyEquiv::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.CurrencyEquiv.contract_id)
}
inline std::string* CurrencyEquiv::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.CurrencyEquiv.contract_id)
  return _s;
}
inline const std::string& CurrencyEquiv::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void CurrencyEquiv::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CurrencyEquiv::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CurrencyEquiv::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.CurrencyEquiv.contract_id)
  return _impl_.contract_id_.Release();
}
inline void CurrencyEquiv::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CurrencyEquiv.contract_id)
}

// string rate = 2;
inline void CurrencyEquiv::clear_rate() {
  _impl_.rate_.ClearToEmpty();
}
inline const std::string& CurrencyEquiv::rate() const {
  // @@protoc_insertion_point(field_get:zera_txn.CurrencyEquiv.rate)
  return _internal_rate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyEquiv::set_rate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.CurrencyEquiv.rate)
}
inline std::string* CurrencyEquiv::mutable_rate() {
  std::string* _s = _internal_mutable_rate();
  // @@protoc_insertion_point(field_mutable:zera_txn.CurrencyEquiv.rate)
  return _s;
}
inline const std::string& CurrencyEquiv::_internal_rate() const {
  return _impl_.rate_.Get();
}
inline void CurrencyEquiv::_internal_set_rate(const std::string& value) {
  
  _impl_.rate_.Set(value, GetArenaForAllocation());
}
inline std::string* CurrencyEquiv::_internal_mutable_rate() {
  
  return _impl_.rate_.Mutable(GetArenaForAllocation());
}
inline std::string* CurrencyEquiv::release_rate() {
  // @@protoc_insertion_point(field_release:zera_txn.CurrencyEquiv.rate)
  return _impl_.rate_.Release();
}
inline void CurrencyEquiv::set_allocated_rate(std::string* rate) {
  if (rate != nullptr) {
    
  } else {
    
  }
  _impl_.rate_.SetAllocated(rate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rate_.IsDefault()) {
    _impl_.rate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CurrencyEquiv.rate)
}

// optional bool authorized = 3;
inline bool CurrencyEquiv::_internal_has_authorized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CurrencyEquiv::has_authorized() const {
  return _internal_has_authorized();
}
inline void CurrencyEquiv::clear_authorized() {
  _impl_.authorized_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CurrencyEquiv::_internal_authorized() const {
  return _impl_.authorized_;
}
inline bool CurrencyEquiv::authorized() const {
  // @@protoc_insertion_point(field_get:zera_txn.CurrencyEquiv.authorized)
  return _internal_authorized();
}
inline void CurrencyEquiv::_internal_set_authorized(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.authorized_ = value;
}
inline void CurrencyEquiv::set_authorized(bool value) {
  _internal_set_authorized(value);
  // @@protoc_insertion_point(field_set:zera_txn.CurrencyEquiv.authorized)
}

// optional string max_stake = 4;
inline bool CurrencyEquiv::_internal_has_max_stake() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurrencyEquiv::has_max_stake() const {
  return _internal_has_max_stake();
}
inline void CurrencyEquiv::clear_max_stake() {
  _impl_.max_stake_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CurrencyEquiv::max_stake() const {
  // @@protoc_insertion_point(field_get:zera_txn.CurrencyEquiv.max_stake)
  return _internal_max_stake();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyEquiv::set_max_stake(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.max_stake_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.CurrencyEquiv.max_stake)
}
inline std::string* CurrencyEquiv::mutable_max_stake() {
  std::string* _s = _internal_mutable_max_stake();
  // @@protoc_insertion_point(field_mutable:zera_txn.CurrencyEquiv.max_stake)
  return _s;
}
inline const std::string& CurrencyEquiv::_internal_max_stake() const {
  return _impl_.max_stake_.Get();
}
inline void CurrencyEquiv::_internal_set_max_stake(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_stake_.Set(value, GetArenaForAllocation());
}
inline std::string* CurrencyEquiv::_internal_mutable_max_stake() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.max_stake_.Mutable(GetArenaForAllocation());
}
inline std::string* CurrencyEquiv::release_max_stake() {
  // @@protoc_insertion_point(field_release:zera_txn.CurrencyEquiv.max_stake)
  if (!_internal_has_max_stake()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.max_stake_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.max_stake_.IsDefault()) {
    _impl_.max_stake_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CurrencyEquiv::set_allocated_max_stake(std::string* max_stake) {
  if (max_stake != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.max_stake_.SetAllocated(max_stake, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.max_stake_.IsDefault()) {
    _impl_.max_stake_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CurrencyEquiv.max_stake)
}

// -------------------------------------------------------------------

// ExpenseRatioResult

// string contract_id = 1;
inline void ExpenseRatioResult::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ExpenseRatioResult::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatioResult.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpenseRatioResult::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatioResult.contract_id)
}
inline std::string* ExpenseRatioResult::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ExpenseRatioResult.contract_id)
  return _s;
}
inline const std::string& ExpenseRatioResult::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void ExpenseRatioResult::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpenseRatioResult::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpenseRatioResult::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ExpenseRatioResult.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ExpenseRatioResult::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ExpenseRatioResult.contract_id)
}

// repeated .zera_txn.Wallets wallets = 2;
inline int ExpenseRatioResult::_internal_wallets_size() const {
  return _impl_.wallets_.size();
}
inline int ExpenseRatioResult::wallets_size() const {
  return _internal_wallets_size();
}
inline void ExpenseRatioResult::clear_wallets() {
  _impl_.wallets_.Clear();
}
inline ::zera_txn::Wallets* ExpenseRatioResult::mutable_wallets(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ExpenseRatioResult.wallets)
  return _impl_.wallets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Wallets >*
ExpenseRatioResult::mutable_wallets() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ExpenseRatioResult.wallets)
  return &_impl_.wallets_;
}
inline const ::zera_txn::Wallets& ExpenseRatioResult::_internal_wallets(int index) const {
  return _impl_.wallets_.Get(index);
}
inline const ::zera_txn::Wallets& ExpenseRatioResult::wallets(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatioResult.wallets)
  return _internal_wallets(index);
}
inline ::zera_txn::Wallets* ExpenseRatioResult::_internal_add_wallets() {
  return _impl_.wallets_.Add();
}
inline ::zera_txn::Wallets* ExpenseRatioResult::add_wallets() {
  ::zera_txn::Wallets* _add = _internal_add_wallets();
  // @@protoc_insertion_point(field_add:zera_txn.ExpenseRatioResult.wallets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Wallets >&
ExpenseRatioResult::wallets() const {
  // @@protoc_insertion_point(field_list:zera_txn.ExpenseRatioResult.wallets)
  return _impl_.wallets_;
}

// bytes hash = 3;
inline void ExpenseRatioResult::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& ExpenseRatioResult::hash() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatioResult.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpenseRatioResult::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatioResult.hash)
}
inline std::string* ExpenseRatioResult::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:zera_txn.ExpenseRatioResult.hash)
  return _s;
}
inline const std::string& ExpenseRatioResult::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void ExpenseRatioResult::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpenseRatioResult::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpenseRatioResult::release_hash() {
  // @@protoc_insertion_point(field_release:zera_txn.ExpenseRatioResult.hash)
  return _impl_.hash_.Release();
}
inline void ExpenseRatioResult::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ExpenseRatioResult.hash)
}

// bytes recipient_address = 4;
inline void ExpenseRatioResult::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& ExpenseRatioResult::recipient_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.ExpenseRatioResult.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpenseRatioResult::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ExpenseRatioResult.recipient_address)
}
inline std::string* ExpenseRatioResult::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.ExpenseRatioResult.recipient_address)
  return _s;
}
inline const std::string& ExpenseRatioResult::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void ExpenseRatioResult::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpenseRatioResult::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpenseRatioResult::release_recipient_address() {
  // @@protoc_insertion_point(field_release:zera_txn.ExpenseRatioResult.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void ExpenseRatioResult::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ExpenseRatioResult.recipient_address)
}

// -------------------------------------------------------------------

// ComplianceAssign

// bytes recipient_address = 1;
inline void ComplianceAssign::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& ComplianceAssign::recipient_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.ComplianceAssign.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComplianceAssign::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ComplianceAssign.recipient_address)
}
inline std::string* ComplianceAssign::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.ComplianceAssign.recipient_address)
  return _s;
}
inline const std::string& ComplianceAssign::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void ComplianceAssign::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ComplianceAssign::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ComplianceAssign::release_recipient_address() {
  // @@protoc_insertion_point(field_release:zera_txn.ComplianceAssign.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void ComplianceAssign::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ComplianceAssign.recipient_address)
}

// uint32 compliance_level = 2;
inline void ComplianceAssign::clear_compliance_level() {
  _impl_.compliance_level_ = 0u;
}
inline uint32_t ComplianceAssign::_internal_compliance_level() const {
  return _impl_.compliance_level_;
}
inline uint32_t ComplianceAssign::compliance_level() const {
  // @@protoc_insertion_point(field_get:zera_txn.ComplianceAssign.compliance_level)
  return _internal_compliance_level();
}
inline void ComplianceAssign::_internal_set_compliance_level(uint32_t value) {
  
  _impl_.compliance_level_ = value;
}
inline void ComplianceAssign::set_compliance_level(uint32_t value) {
  _internal_set_compliance_level(value);
  // @@protoc_insertion_point(field_set:zera_txn.ComplianceAssign.compliance_level)
}

// bool assign_revoke = 3;
inline void ComplianceAssign::clear_assign_revoke() {
  _impl_.assign_revoke_ = false;
}
inline bool ComplianceAssign::_internal_assign_revoke() const {
  return _impl_.assign_revoke_;
}
inline bool ComplianceAssign::assign_revoke() const {
  // @@protoc_insertion_point(field_get:zera_txn.ComplianceAssign.assign_revoke)
  return _internal_assign_revoke();
}
inline void ComplianceAssign::_internal_set_assign_revoke(bool value) {
  
  _impl_.assign_revoke_ = value;
}
inline void ComplianceAssign::set_assign_revoke(bool value) {
  _internal_set_assign_revoke(value);
  // @@protoc_insertion_point(field_set:zera_txn.ComplianceAssign.assign_revoke)
}

// .google.protobuf.Timestamp expiry = 4;
inline bool ComplianceAssign::_internal_has_expiry() const {
  return this != internal_default_instance() && _impl_.expiry_ != nullptr;
}
inline bool ComplianceAssign::has_expiry() const {
  return _internal_has_expiry();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ComplianceAssign::_internal_expiry() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expiry_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ComplianceAssign::expiry() const {
  // @@protoc_insertion_point(field_get:zera_txn.ComplianceAssign.expiry)
  return _internal_expiry();
}
inline void ComplianceAssign::unsafe_arena_set_allocated_expiry(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiry_);
  }
  _impl_.expiry_ = expiry;
  if (expiry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ComplianceAssign.expiry)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ComplianceAssign::release_expiry() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expiry_;
  _impl_.expiry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ComplianceAssign::unsafe_arena_release_expiry() {
  // @@protoc_insertion_point(field_release:zera_txn.ComplianceAssign.expiry)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expiry_;
  _impl_.expiry_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ComplianceAssign::_internal_mutable_expiry() {
  
  if (_impl_.expiry_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expiry_ = p;
  }
  return _impl_.expiry_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ComplianceAssign::mutable_expiry() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expiry();
  // @@protoc_insertion_point(field_mutable:zera_txn.ComplianceAssign.expiry)
  return _msg;
}
inline void ComplianceAssign::set_allocated_expiry(::PROTOBUF_NAMESPACE_ID::Timestamp* expiry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiry_);
  }
  if (expiry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry));
    if (message_arena != submessage_arena) {
      expiry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiry, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expiry_ = expiry;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ComplianceAssign.expiry)
}

// -------------------------------------------------------------------

// ComplianceTXN

// .zera_txn.BaseTXN base = 1;
inline bool ComplianceTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool ComplianceTXN::has_base() const {
  return _internal_has_base();
}
inline void ComplianceTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& ComplianceTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ComplianceTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.ComplianceTXN.base)
  return _internal_base();
}
inline void ComplianceTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ComplianceTXN.base)
}
inline ::zera_txn::BaseTXN* ComplianceTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* ComplianceTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.ComplianceTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ComplianceTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* ComplianceTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.ComplianceTXN.base)
  return _msg;
}
inline void ComplianceTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ComplianceTXN.base)
}

// string contract_id = 2;
inline void ComplianceTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ComplianceTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ComplianceTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComplianceTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ComplianceTXN.contract_id)
}
inline std::string* ComplianceTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ComplianceTXN.contract_id)
  return _s;
}
inline const std::string& ComplianceTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void ComplianceTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ComplianceTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ComplianceTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ComplianceTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ComplianceTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ComplianceTXN.contract_id)
}

// repeated .zera_txn.ComplianceAssign compliance = 3;
inline int ComplianceTXN::_internal_compliance_size() const {
  return _impl_.compliance_.size();
}
inline int ComplianceTXN::compliance_size() const {
  return _internal_compliance_size();
}
inline void ComplianceTXN::clear_compliance() {
  _impl_.compliance_.Clear();
}
inline ::zera_txn::ComplianceAssign* ComplianceTXN::mutable_compliance(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ComplianceTXN.compliance)
  return _impl_.compliance_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceAssign >*
ComplianceTXN::mutable_compliance() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ComplianceTXN.compliance)
  return &_impl_.compliance_;
}
inline const ::zera_txn::ComplianceAssign& ComplianceTXN::_internal_compliance(int index) const {
  return _impl_.compliance_.Get(index);
}
inline const ::zera_txn::ComplianceAssign& ComplianceTXN::compliance(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ComplianceTXN.compliance)
  return _internal_compliance(index);
}
inline ::zera_txn::ComplianceAssign* ComplianceTXN::_internal_add_compliance() {
  return _impl_.compliance_.Add();
}
inline ::zera_txn::ComplianceAssign* ComplianceTXN::add_compliance() {
  ::zera_txn::ComplianceAssign* _add = _internal_add_compliance();
  // @@protoc_insertion_point(field_add:zera_txn.ComplianceTXN.compliance)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceAssign >&
ComplianceTXN::compliance() const {
  // @@protoc_insertion_point(field_list:zera_txn.ComplianceTXN.compliance)
  return _impl_.compliance_;
}

// -------------------------------------------------------------------

// Wallets

// bytes address = 1;
inline void Wallets::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Wallets::address() const {
  // @@protoc_insertion_point(field_get:zera_txn.Wallets.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Wallets::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Wallets.address)
}
inline std::string* Wallets::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.Wallets.address)
  return _s;
}
inline const std::string& Wallets::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Wallets::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Wallets::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Wallets::release_address() {
  // @@protoc_insertion_point(field_release:zera_txn.Wallets.address)
  return _impl_.address_.Release();
}
inline void Wallets::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Wallets.address)
}

// string amount = 2;
inline void Wallets::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& Wallets::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.Wallets.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Wallets::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Wallets.amount)
}
inline std::string* Wallets::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.Wallets.amount)
  return _s;
}
inline const std::string& Wallets::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void Wallets::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Wallets::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* Wallets::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.Wallets.amount)
  return _impl_.amount_.Release();
}
inline void Wallets::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Wallets.amount)
}

// -------------------------------------------------------------------

// QuashTXN

// .zera_txn.BaseTXN base = 1;
inline bool QuashTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool QuashTXN::has_base() const {
  return _internal_has_base();
}
inline void QuashTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& QuashTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& QuashTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.QuashTXN.base)
  return _internal_base();
}
inline void QuashTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.QuashTXN.base)
}
inline ::zera_txn::BaseTXN* QuashTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* QuashTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.QuashTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* QuashTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* QuashTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.QuashTXN.base)
  return _msg;
}
inline void QuashTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.QuashTXN.base)
}

// string contract_id = 2;
inline void QuashTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& QuashTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.QuashTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuashTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.QuashTXN.contract_id)
}
inline std::string* QuashTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.QuashTXN.contract_id)
  return _s;
}
inline const std::string& QuashTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void QuashTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuashTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* QuashTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.QuashTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void QuashTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.QuashTXN.contract_id)
}

// bytes txn_hash = 3;
inline void QuashTXN::clear_txn_hash() {
  _impl_.txn_hash_.ClearToEmpty();
}
inline const std::string& QuashTXN::txn_hash() const {
  // @@protoc_insertion_point(field_get:zera_txn.QuashTXN.txn_hash)
  return _internal_txn_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuashTXN::set_txn_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txn_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.QuashTXN.txn_hash)
}
inline std::string* QuashTXN::mutable_txn_hash() {
  std::string* _s = _internal_mutable_txn_hash();
  // @@protoc_insertion_point(field_mutable:zera_txn.QuashTXN.txn_hash)
  return _s;
}
inline const std::string& QuashTXN::_internal_txn_hash() const {
  return _impl_.txn_hash_.Get();
}
inline void QuashTXN::_internal_set_txn_hash(const std::string& value) {
  
  _impl_.txn_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* QuashTXN::_internal_mutable_txn_hash() {
  
  return _impl_.txn_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* QuashTXN::release_txn_hash() {
  // @@protoc_insertion_point(field_release:zera_txn.QuashTXN.txn_hash)
  return _impl_.txn_hash_.Release();
}
inline void QuashTXN::set_allocated_txn_hash(std::string* txn_hash) {
  if (txn_hash != nullptr) {
    
  } else {
    
  }
  _impl_.txn_hash_.SetAllocated(txn_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txn_hash_.IsDefault()) {
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.QuashTXN.txn_hash)
}

// -------------------------------------------------------------------

// QuashResult

// bytes txn_hash = 1;
inline void QuashResult::clear_txn_hash() {
  _impl_.txn_hash_.ClearToEmpty();
}
inline const std::string& QuashResult::txn_hash() const {
  // @@protoc_insertion_point(field_get:zera_txn.QuashResult.txn_hash)
  return _internal_txn_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuashResult::set_txn_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txn_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.QuashResult.txn_hash)
}
inline std::string* QuashResult::mutable_txn_hash() {
  std::string* _s = _internal_mutable_txn_hash();
  // @@protoc_insertion_point(field_mutable:zera_txn.QuashResult.txn_hash)
  return _s;
}
inline const std::string& QuashResult::_internal_txn_hash() const {
  return _impl_.txn_hash_.Get();
}
inline void QuashResult::_internal_set_txn_hash(const std::string& value) {
  
  _impl_.txn_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* QuashResult::_internal_mutable_txn_hash() {
  
  return _impl_.txn_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* QuashResult::release_txn_hash() {
  // @@protoc_insertion_point(field_release:zera_txn.QuashResult.txn_hash)
  return _impl_.txn_hash_.Release();
}
inline void QuashResult::set_allocated_txn_hash(std::string* txn_hash) {
  if (txn_hash != nullptr) {
    
  } else {
    
  }
  _impl_.txn_hash_.SetAllocated(txn_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txn_hash_.IsDefault()) {
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.QuashResult.txn_hash)
}

// repeated .zera_txn.PublicKey public_keys = 2;
inline int QuashResult::_internal_public_keys_size() const {
  return _impl_.public_keys_.size();
}
inline int QuashResult::public_keys_size() const {
  return _internal_public_keys_size();
}
inline void QuashResult::clear_public_keys() {
  _impl_.public_keys_.Clear();
}
inline ::zera_txn::PublicKey* QuashResult::mutable_public_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.QuashResult.public_keys)
  return _impl_.public_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >*
QuashResult::mutable_public_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.QuashResult.public_keys)
  return &_impl_.public_keys_;
}
inline const ::zera_txn::PublicKey& QuashResult::_internal_public_keys(int index) const {
  return _impl_.public_keys_.Get(index);
}
inline const ::zera_txn::PublicKey& QuashResult::public_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.QuashResult.public_keys)
  return _internal_public_keys(index);
}
inline ::zera_txn::PublicKey* QuashResult::_internal_add_public_keys() {
  return _impl_.public_keys_.Add();
}
inline ::zera_txn::PublicKey* QuashResult::add_public_keys() {
  ::zera_txn::PublicKey* _add = _internal_add_public_keys();
  // @@protoc_insertion_point(field_add:zera_txn.QuashResult.public_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >&
QuashResult::public_keys() const {
  // @@protoc_insertion_point(field_list:zera_txn.QuashResult.public_keys)
  return _impl_.public_keys_;
}

// -------------------------------------------------------------------

// CoinTXN

// .zera_txn.BaseTXN base = 1;
inline bool CoinTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool CoinTXN::has_base() const {
  return _internal_has_base();
}
inline void CoinTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& CoinTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& CoinTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinTXN.base)
  return _internal_base();
}
inline void CoinTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.CoinTXN.base)
}
inline ::zera_txn::BaseTXN* CoinTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* CoinTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.CoinTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* CoinTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* CoinTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinTXN.base)
  return _msg;
}
inline void CoinTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CoinTXN.base)
}

// string contract_id = 2;
inline void CoinTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& CoinTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoinTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.CoinTXN.contract_id)
}
inline std::string* CoinTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinTXN.contract_id)
  return _s;
}
inline const std::string& CoinTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void CoinTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CoinTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CoinTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.CoinTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void CoinTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CoinTXN.contract_id)
}

// .zera_txn.TransferAuthentication auth = 3;
inline bool CoinTXN::_internal_has_auth() const {
  return this != internal_default_instance() && _impl_.auth_ != nullptr;
}
inline bool CoinTXN::has_auth() const {
  return _internal_has_auth();
}
inline void CoinTXN::clear_auth() {
  if (GetArenaForAllocation() == nullptr && _impl_.auth_ != nullptr) {
    delete _impl_.auth_;
  }
  _impl_.auth_ = nullptr;
}
inline const ::zera_txn::TransferAuthentication& CoinTXN::_internal_auth() const {
  const ::zera_txn::TransferAuthentication* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::TransferAuthentication&>(
      ::zera_txn::_TransferAuthentication_default_instance_);
}
inline const ::zera_txn::TransferAuthentication& CoinTXN::auth() const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinTXN.auth)
  return _internal_auth();
}
inline void CoinTXN::unsafe_arena_set_allocated_auth(
    ::zera_txn::TransferAuthentication* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.CoinTXN.auth)
}
inline ::zera_txn::TransferAuthentication* CoinTXN::release_auth() {
  
  ::zera_txn::TransferAuthentication* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::TransferAuthentication* CoinTXN::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:zera_txn.CoinTXN.auth)
  
  ::zera_txn::TransferAuthentication* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::zera_txn::TransferAuthentication* CoinTXN::_internal_mutable_auth() {
  
  if (_impl_.auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::TransferAuthentication>(GetArenaForAllocation());
    _impl_.auth_ = p;
  }
  return _impl_.auth_;
}
inline ::zera_txn::TransferAuthentication* CoinTXN::mutable_auth() {
  ::zera_txn::TransferAuthentication* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinTXN.auth)
  return _msg;
}
inline void CoinTXN::set_allocated_auth(::zera_txn::TransferAuthentication* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CoinTXN.auth)
}

// repeated .zera_txn.InputTransfers input_transfers = 4;
inline int CoinTXN::_internal_input_transfers_size() const {
  return _impl_.input_transfers_.size();
}
inline int CoinTXN::input_transfers_size() const {
  return _internal_input_transfers_size();
}
inline void CoinTXN::clear_input_transfers() {
  _impl_.input_transfers_.Clear();
}
inline ::zera_txn::InputTransfers* CoinTXN::mutable_input_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinTXN.input_transfers)
  return _impl_.input_transfers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InputTransfers >*
CoinTXN::mutable_input_transfers() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.CoinTXN.input_transfers)
  return &_impl_.input_transfers_;
}
inline const ::zera_txn::InputTransfers& CoinTXN::_internal_input_transfers(int index) const {
  return _impl_.input_transfers_.Get(index);
}
inline const ::zera_txn::InputTransfers& CoinTXN::input_transfers(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinTXN.input_transfers)
  return _internal_input_transfers(index);
}
inline ::zera_txn::InputTransfers* CoinTXN::_internal_add_input_transfers() {
  return _impl_.input_transfers_.Add();
}
inline ::zera_txn::InputTransfers* CoinTXN::add_input_transfers() {
  ::zera_txn::InputTransfers* _add = _internal_add_input_transfers();
  // @@protoc_insertion_point(field_add:zera_txn.CoinTXN.input_transfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InputTransfers >&
CoinTXN::input_transfers() const {
  // @@protoc_insertion_point(field_list:zera_txn.CoinTXN.input_transfers)
  return _impl_.input_transfers_;
}

// repeated .zera_txn.OutputTransfers output_transfers = 5;
inline int CoinTXN::_internal_output_transfers_size() const {
  return _impl_.output_transfers_.size();
}
inline int CoinTXN::output_transfers_size() const {
  return _internal_output_transfers_size();
}
inline void CoinTXN::clear_output_transfers() {
  _impl_.output_transfers_.Clear();
}
inline ::zera_txn::OutputTransfers* CoinTXN::mutable_output_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinTXN.output_transfers)
  return _impl_.output_transfers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::OutputTransfers >*
CoinTXN::mutable_output_transfers() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.CoinTXN.output_transfers)
  return &_impl_.output_transfers_;
}
inline const ::zera_txn::OutputTransfers& CoinTXN::_internal_output_transfers(int index) const {
  return _impl_.output_transfers_.Get(index);
}
inline const ::zera_txn::OutputTransfers& CoinTXN::output_transfers(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinTXN.output_transfers)
  return _internal_output_transfers(index);
}
inline ::zera_txn::OutputTransfers* CoinTXN::_internal_add_output_transfers() {
  return _impl_.output_transfers_.Add();
}
inline ::zera_txn::OutputTransfers* CoinTXN::add_output_transfers() {
  ::zera_txn::OutputTransfers* _add = _internal_add_output_transfers();
  // @@protoc_insertion_point(field_add:zera_txn.CoinTXN.output_transfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::OutputTransfers >&
CoinTXN::output_transfers() const {
  // @@protoc_insertion_point(field_list:zera_txn.CoinTXN.output_transfers)
  return _impl_.output_transfers_;
}

// optional string contract_fee_id = 6;
inline bool CoinTXN::_internal_has_contract_fee_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CoinTXN::has_contract_fee_id() const {
  return _internal_has_contract_fee_id();
}
inline void CoinTXN::clear_contract_fee_id() {
  _impl_.contract_fee_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CoinTXN::contract_fee_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinTXN.contract_fee_id)
  return _internal_contract_fee_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoinTXN::set_contract_fee_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.contract_fee_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.CoinTXN.contract_fee_id)
}
inline std::string* CoinTXN::mutable_contract_fee_id() {
  std::string* _s = _internal_mutable_contract_fee_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinTXN.contract_fee_id)
  return _s;
}
inline const std::string& CoinTXN::_internal_contract_fee_id() const {
  return _impl_.contract_fee_id_.Get();
}
inline void CoinTXN::_internal_set_contract_fee_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contract_fee_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CoinTXN::_internal_mutable_contract_fee_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contract_fee_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CoinTXN::release_contract_fee_id() {
  // @@protoc_insertion_point(field_release:zera_txn.CoinTXN.contract_fee_id)
  if (!_internal_has_contract_fee_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.contract_fee_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_id_.IsDefault()) {
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CoinTXN::set_allocated_contract_fee_id(std::string* contract_fee_id) {
  if (contract_fee_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contract_fee_id_.SetAllocated(contract_fee_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_id_.IsDefault()) {
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CoinTXN.contract_fee_id)
}

// optional string contract_fee_amount = 7;
inline bool CoinTXN::_internal_has_contract_fee_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CoinTXN::has_contract_fee_amount() const {
  return _internal_has_contract_fee_amount();
}
inline void CoinTXN::clear_contract_fee_amount() {
  _impl_.contract_fee_amount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CoinTXN::contract_fee_amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.CoinTXN.contract_fee_amount)
  return _internal_contract_fee_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoinTXN::set_contract_fee_amount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.contract_fee_amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.CoinTXN.contract_fee_amount)
}
inline std::string* CoinTXN::mutable_contract_fee_amount() {
  std::string* _s = _internal_mutable_contract_fee_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.CoinTXN.contract_fee_amount)
  return _s;
}
inline const std::string& CoinTXN::_internal_contract_fee_amount() const {
  return _impl_.contract_fee_amount_.Get();
}
inline void CoinTXN::_internal_set_contract_fee_amount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.contract_fee_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* CoinTXN::_internal_mutable_contract_fee_amount() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.contract_fee_amount_.Mutable(GetArenaForAllocation());
}
inline std::string* CoinTXN::release_contract_fee_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.CoinTXN.contract_fee_amount)
  if (!_internal_has_contract_fee_amount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.contract_fee_amount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_amount_.IsDefault()) {
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CoinTXN::set_allocated_contract_fee_amount(std::string* contract_fee_amount) {
  if (contract_fee_amount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.contract_fee_amount_.SetAllocated(contract_fee_amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_amount_.IsDefault()) {
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.CoinTXN.contract_fee_amount)
}

// -------------------------------------------------------------------

// TransferAuthentication

// repeated .zera_txn.PublicKey public_key = 1;
inline int TransferAuthentication::_internal_public_key_size() const {
  return _impl_.public_key_.size();
}
inline int TransferAuthentication::public_key_size() const {
  return _internal_public_key_size();
}
inline void TransferAuthentication::clear_public_key() {
  _impl_.public_key_.Clear();
}
inline ::zera_txn::PublicKey* TransferAuthentication::mutable_public_key(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TransferAuthentication.public_key)
  return _impl_.public_key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >*
TransferAuthentication::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TransferAuthentication.public_key)
  return &_impl_.public_key_;
}
inline const ::zera_txn::PublicKey& TransferAuthentication::_internal_public_key(int index) const {
  return _impl_.public_key_.Get(index);
}
inline const ::zera_txn::PublicKey& TransferAuthentication::public_key(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TransferAuthentication.public_key)
  return _internal_public_key(index);
}
inline ::zera_txn::PublicKey* TransferAuthentication::_internal_add_public_key() {
  return _impl_.public_key_.Add();
}
inline ::zera_txn::PublicKey* TransferAuthentication::add_public_key() {
  ::zera_txn::PublicKey* _add = _internal_add_public_key();
  // @@protoc_insertion_point(field_add:zera_txn.TransferAuthentication.public_key)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PublicKey >&
TransferAuthentication::public_key() const {
  // @@protoc_insertion_point(field_list:zera_txn.TransferAuthentication.public_key)
  return _impl_.public_key_;
}

// repeated bytes signature = 2;
inline int TransferAuthentication::_internal_signature_size() const {
  return _impl_.signature_.size();
}
inline int TransferAuthentication::signature_size() const {
  return _internal_signature_size();
}
inline void TransferAuthentication::clear_signature() {
  _impl_.signature_.Clear();
}
inline std::string* TransferAuthentication::add_signature() {
  std::string* _s = _internal_add_signature();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.TransferAuthentication.signature)
  return _s;
}
inline const std::string& TransferAuthentication::_internal_signature(int index) const {
  return _impl_.signature_.Get(index);
}
inline const std::string& TransferAuthentication::signature(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TransferAuthentication.signature)
  return _internal_signature(index);
}
inline std::string* TransferAuthentication::mutable_signature(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TransferAuthentication.signature)
  return _impl_.signature_.Mutable(index);
}
inline void TransferAuthentication::set_signature(int index, const std::string& value) {
  _impl_.signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.TransferAuthentication.signature)
}
inline void TransferAuthentication::set_signature(int index, std::string&& value) {
  _impl_.signature_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.TransferAuthentication.signature)
}
inline void TransferAuthentication::set_signature(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.TransferAuthentication.signature)
}
inline void TransferAuthentication::set_signature(int index, const void* value, size_t size) {
  _impl_.signature_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.TransferAuthentication.signature)
}
inline std::string* TransferAuthentication::_internal_add_signature() {
  return _impl_.signature_.Add();
}
inline void TransferAuthentication::add_signature(const std::string& value) {
  _impl_.signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.TransferAuthentication.signature)
}
inline void TransferAuthentication::add_signature(std::string&& value) {
  _impl_.signature_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.TransferAuthentication.signature)
}
inline void TransferAuthentication::add_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.TransferAuthentication.signature)
}
inline void TransferAuthentication::add_signature(const void* value, size_t size) {
  _impl_.signature_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.TransferAuthentication.signature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransferAuthentication::signature() const {
  // @@protoc_insertion_point(field_list:zera_txn.TransferAuthentication.signature)
  return _impl_.signature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransferAuthentication::mutable_signature() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TransferAuthentication.signature)
  return &_impl_.signature_;
}

// repeated uint64 nonce = 3;
inline int TransferAuthentication::_internal_nonce_size() const {
  return _impl_.nonce_.size();
}
inline int TransferAuthentication::nonce_size() const {
  return _internal_nonce_size();
}
inline void TransferAuthentication::clear_nonce() {
  _impl_.nonce_.Clear();
}
inline uint64_t TransferAuthentication::_internal_nonce(int index) const {
  return _impl_.nonce_.Get(index);
}
inline uint64_t TransferAuthentication::nonce(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TransferAuthentication.nonce)
  return _internal_nonce(index);
}
inline void TransferAuthentication::set_nonce(int index, uint64_t value) {
  _impl_.nonce_.Set(index, value);
  // @@protoc_insertion_point(field_set:zera_txn.TransferAuthentication.nonce)
}
inline void TransferAuthentication::_internal_add_nonce(uint64_t value) {
  _impl_.nonce_.Add(value);
}
inline void TransferAuthentication::add_nonce(uint64_t value) {
  _internal_add_nonce(value);
  // @@protoc_insertion_point(field_add:zera_txn.TransferAuthentication.nonce)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TransferAuthentication::_internal_nonce() const {
  return _impl_.nonce_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TransferAuthentication::nonce() const {
  // @@protoc_insertion_point(field_list:zera_txn.TransferAuthentication.nonce)
  return _internal_nonce();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TransferAuthentication::_internal_mutable_nonce() {
  return &_impl_.nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TransferAuthentication::mutable_nonce() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TransferAuthentication.nonce)
  return _internal_mutable_nonce();
}

// repeated bytes allowance_address = 4;
inline int TransferAuthentication::_internal_allowance_address_size() const {
  return _impl_.allowance_address_.size();
}
inline int TransferAuthentication::allowance_address_size() const {
  return _internal_allowance_address_size();
}
inline void TransferAuthentication::clear_allowance_address() {
  _impl_.allowance_address_.Clear();
}
inline std::string* TransferAuthentication::add_allowance_address() {
  std::string* _s = _internal_add_allowance_address();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.TransferAuthentication.allowance_address)
  return _s;
}
inline const std::string& TransferAuthentication::_internal_allowance_address(int index) const {
  return _impl_.allowance_address_.Get(index);
}
inline const std::string& TransferAuthentication::allowance_address(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TransferAuthentication.allowance_address)
  return _internal_allowance_address(index);
}
inline std::string* TransferAuthentication::mutable_allowance_address(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TransferAuthentication.allowance_address)
  return _impl_.allowance_address_.Mutable(index);
}
inline void TransferAuthentication::set_allowance_address(int index, const std::string& value) {
  _impl_.allowance_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.TransferAuthentication.allowance_address)
}
inline void TransferAuthentication::set_allowance_address(int index, std::string&& value) {
  _impl_.allowance_address_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.TransferAuthentication.allowance_address)
}
inline void TransferAuthentication::set_allowance_address(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowance_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.TransferAuthentication.allowance_address)
}
inline void TransferAuthentication::set_allowance_address(int index, const void* value, size_t size) {
  _impl_.allowance_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.TransferAuthentication.allowance_address)
}
inline std::string* TransferAuthentication::_internal_add_allowance_address() {
  return _impl_.allowance_address_.Add();
}
inline void TransferAuthentication::add_allowance_address(const std::string& value) {
  _impl_.allowance_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.TransferAuthentication.allowance_address)
}
inline void TransferAuthentication::add_allowance_address(std::string&& value) {
  _impl_.allowance_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.TransferAuthentication.allowance_address)
}
inline void TransferAuthentication::add_allowance_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowance_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.TransferAuthentication.allowance_address)
}
inline void TransferAuthentication::add_allowance_address(const void* value, size_t size) {
  _impl_.allowance_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.TransferAuthentication.allowance_address)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransferAuthentication::allowance_address() const {
  // @@protoc_insertion_point(field_list:zera_txn.TransferAuthentication.allowance_address)
  return _impl_.allowance_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransferAuthentication::mutable_allowance_address() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TransferAuthentication.allowance_address)
  return &_impl_.allowance_address_;
}

// repeated uint64 allowance_nonce = 5;
inline int TransferAuthentication::_internal_allowance_nonce_size() const {
  return _impl_.allowance_nonce_.size();
}
inline int TransferAuthentication::allowance_nonce_size() const {
  return _internal_allowance_nonce_size();
}
inline void TransferAuthentication::clear_allowance_nonce() {
  _impl_.allowance_nonce_.Clear();
}
inline uint64_t TransferAuthentication::_internal_allowance_nonce(int index) const {
  return _impl_.allowance_nonce_.Get(index);
}
inline uint64_t TransferAuthentication::allowance_nonce(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TransferAuthentication.allowance_nonce)
  return _internal_allowance_nonce(index);
}
inline void TransferAuthentication::set_allowance_nonce(int index, uint64_t value) {
  _impl_.allowance_nonce_.Set(index, value);
  // @@protoc_insertion_point(field_set:zera_txn.TransferAuthentication.allowance_nonce)
}
inline void TransferAuthentication::_internal_add_allowance_nonce(uint64_t value) {
  _impl_.allowance_nonce_.Add(value);
}
inline void TransferAuthentication::add_allowance_nonce(uint64_t value) {
  _internal_add_allowance_nonce(value);
  // @@protoc_insertion_point(field_add:zera_txn.TransferAuthentication.allowance_nonce)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TransferAuthentication::_internal_allowance_nonce() const {
  return _impl_.allowance_nonce_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TransferAuthentication::allowance_nonce() const {
  // @@protoc_insertion_point(field_list:zera_txn.TransferAuthentication.allowance_nonce)
  return _internal_allowance_nonce();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TransferAuthentication::_internal_mutable_allowance_nonce() {
  return &_impl_.allowance_nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TransferAuthentication::mutable_allowance_nonce() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TransferAuthentication.allowance_nonce)
  return _internal_mutable_allowance_nonce();
}

// -------------------------------------------------------------------

// InputTransfers

// uint64 index = 1;
inline void InputTransfers::clear_index() {
  _impl_.index_ = uint64_t{0u};
}
inline uint64_t InputTransfers::_internal_index() const {
  return _impl_.index_;
}
inline uint64_t InputTransfers::index() const {
  // @@protoc_insertion_point(field_get:zera_txn.InputTransfers.index)
  return _internal_index();
}
inline void InputTransfers::_internal_set_index(uint64_t value) {
  
  _impl_.index_ = value;
}
inline void InputTransfers::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:zera_txn.InputTransfers.index)
}

// string amount = 2;
inline void InputTransfers::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& InputTransfers::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.InputTransfers.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputTransfers::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.InputTransfers.amount)
}
inline std::string* InputTransfers::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.InputTransfers.amount)
  return _s;
}
inline const std::string& InputTransfers::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void InputTransfers::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* InputTransfers::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* InputTransfers::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.InputTransfers.amount)
  return _impl_.amount_.Release();
}
inline void InputTransfers::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InputTransfers.amount)
}

// uint32 fee_percent = 3;
inline void InputTransfers::clear_fee_percent() {
  _impl_.fee_percent_ = 0u;
}
inline uint32_t InputTransfers::_internal_fee_percent() const {
  return _impl_.fee_percent_;
}
inline uint32_t InputTransfers::fee_percent() const {
  // @@protoc_insertion_point(field_get:zera_txn.InputTransfers.fee_percent)
  return _internal_fee_percent();
}
inline void InputTransfers::_internal_set_fee_percent(uint32_t value) {
  
  _impl_.fee_percent_ = value;
}
inline void InputTransfers::set_fee_percent(uint32_t value) {
  _internal_set_fee_percent(value);
  // @@protoc_insertion_point(field_set:zera_txn.InputTransfers.fee_percent)
}

// optional uint32 contract_fee_percent = 4;
inline bool InputTransfers::_internal_has_contract_fee_percent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InputTransfers::has_contract_fee_percent() const {
  return _internal_has_contract_fee_percent();
}
inline void InputTransfers::clear_contract_fee_percent() {
  _impl_.contract_fee_percent_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t InputTransfers::_internal_contract_fee_percent() const {
  return _impl_.contract_fee_percent_;
}
inline uint32_t InputTransfers::contract_fee_percent() const {
  // @@protoc_insertion_point(field_get:zera_txn.InputTransfers.contract_fee_percent)
  return _internal_contract_fee_percent();
}
inline void InputTransfers::_internal_set_contract_fee_percent(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contract_fee_percent_ = value;
}
inline void InputTransfers::set_contract_fee_percent(uint32_t value) {
  _internal_set_contract_fee_percent(value);
  // @@protoc_insertion_point(field_set:zera_txn.InputTransfers.contract_fee_percent)
}

// -------------------------------------------------------------------

// OutputTransfers

// bytes wallet_address = 1;
inline void OutputTransfers::clear_wallet_address() {
  _impl_.wallet_address_.ClearToEmpty();
}
inline const std::string& OutputTransfers::wallet_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.OutputTransfers.wallet_address)
  return _internal_wallet_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputTransfers::set_wallet_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wallet_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.OutputTransfers.wallet_address)
}
inline std::string* OutputTransfers::mutable_wallet_address() {
  std::string* _s = _internal_mutable_wallet_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.OutputTransfers.wallet_address)
  return _s;
}
inline const std::string& OutputTransfers::_internal_wallet_address() const {
  return _impl_.wallet_address_.Get();
}
inline void OutputTransfers::_internal_set_wallet_address(const std::string& value) {
  
  _impl_.wallet_address_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputTransfers::_internal_mutable_wallet_address() {
  
  return _impl_.wallet_address_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputTransfers::release_wallet_address() {
  // @@protoc_insertion_point(field_release:zera_txn.OutputTransfers.wallet_address)
  return _impl_.wallet_address_.Release();
}
inline void OutputTransfers::set_allocated_wallet_address(std::string* wallet_address) {
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  _impl_.wallet_address_.SetAllocated(wallet_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wallet_address_.IsDefault()) {
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.OutputTransfers.wallet_address)
}

// string amount = 2;
inline void OutputTransfers::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& OutputTransfers::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.OutputTransfers.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputTransfers::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.OutputTransfers.amount)
}
inline std::string* OutputTransfers::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.OutputTransfers.amount)
  return _s;
}
inline const std::string& OutputTransfers::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void OutputTransfers::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputTransfers::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputTransfers::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.OutputTransfers.amount)
  return _impl_.amount_.Release();
}
inline void OutputTransfers::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.OutputTransfers.amount)
}

// optional string memo = 3;
inline bool OutputTransfers::_internal_has_memo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OutputTransfers::has_memo() const {
  return _internal_has_memo();
}
inline void OutputTransfers::clear_memo() {
  _impl_.memo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OutputTransfers::memo() const {
  // @@protoc_insertion_point(field_get:zera_txn.OutputTransfers.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputTransfers::set_memo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.OutputTransfers.memo)
}
inline std::string* OutputTransfers::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:zera_txn.OutputTransfers.memo)
  return _s;
}
inline const std::string& OutputTransfers::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void OutputTransfers::_internal_set_memo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputTransfers::_internal_mutable_memo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.memo_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputTransfers::release_memo() {
  // @@protoc_insertion_point(field_release:zera_txn.OutputTransfers.memo)
  if (!_internal_has_memo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.memo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OutputTransfers::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.OutputTransfers.memo)
}

// -------------------------------------------------------------------

// MintTXN

// .zera_txn.BaseTXN base = 1;
inline bool MintTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool MintTXN::has_base() const {
  return _internal_has_base();
}
inline void MintTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& MintTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& MintTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.MintTXN.base)
  return _internal_base();
}
inline void MintTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.MintTXN.base)
}
inline ::zera_txn::BaseTXN* MintTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* MintTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.MintTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* MintTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* MintTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.MintTXN.base)
  return _msg;
}
inline void MintTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.MintTXN.base)
}

// string contract_id = 2;
inline void MintTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& MintTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.MintTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MintTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.MintTXN.contract_id)
}
inline std::string* MintTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.MintTXN.contract_id)
  return _s;
}
inline const std::string& MintTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void MintTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MintTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MintTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.MintTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void MintTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.MintTXN.contract_id)
}

// string amount = 3;
inline void MintTXN::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& MintTXN::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.MintTXN.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MintTXN::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.MintTXN.amount)
}
inline std::string* MintTXN::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.MintTXN.amount)
  return _s;
}
inline const std::string& MintTXN::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void MintTXN::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* MintTXN::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* MintTXN::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.MintTXN.amount)
  return _impl_.amount_.Release();
}
inline void MintTXN::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.MintTXN.amount)
}

// bytes recipient_address = 4;
inline void MintTXN::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& MintTXN::recipient_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.MintTXN.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MintTXN::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.MintTXN.recipient_address)
}
inline std::string* MintTXN::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.MintTXN.recipient_address)
  return _s;
}
inline const std::string& MintTXN::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void MintTXN::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MintTXN::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* MintTXN::release_recipient_address() {
  // @@protoc_insertion_point(field_release:zera_txn.MintTXN.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void MintTXN::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.MintTXN.recipient_address)
}

// -------------------------------------------------------------------

// NFTTXN

// .zera_txn.BaseTXN base = 1;
inline bool NFTTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool NFTTXN::has_base() const {
  return _internal_has_base();
}
inline void NFTTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& NFTTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& NFTTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.NFTTXN.base)
  return _internal_base();
}
inline void NFTTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.NFTTXN.base)
}
inline ::zera_txn::BaseTXN* NFTTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* NFTTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.NFTTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* NFTTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* NFTTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.NFTTXN.base)
  return _msg;
}
inline void NFTTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.NFTTXN.base)
}

// string contract_id = 2;
inline void NFTTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& NFTTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.NFTTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NFTTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.NFTTXN.contract_id)
}
inline std::string* NFTTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.NFTTXN.contract_id)
  return _s;
}
inline const std::string& NFTTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void NFTTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NFTTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NFTTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.NFTTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void NFTTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.NFTTXN.contract_id)
}

// string item_id = 3;
inline void NFTTXN::clear_item_id() {
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& NFTTXN::item_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.NFTTXN.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NFTTXN::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.NFTTXN.item_id)
}
inline std::string* NFTTXN::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.NFTTXN.item_id)
  return _s;
}
inline const std::string& NFTTXN::_internal_item_id() const {
  return _impl_.item_id_.Get();
}
inline void NFTTXN::_internal_set_item_id(const std::string& value) {
  
  _impl_.item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NFTTXN::_internal_mutable_item_id() {
  
  return _impl_.item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NFTTXN::release_item_id() {
  // @@protoc_insertion_point(field_release:zera_txn.NFTTXN.item_id)
  return _impl_.item_id_.Release();
}
inline void NFTTXN::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  _impl_.item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.NFTTXN.item_id)
}

// bytes recipient_address = 4;
inline void NFTTXN::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& NFTTXN::recipient_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.NFTTXN.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NFTTXN::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.NFTTXN.recipient_address)
}
inline std::string* NFTTXN::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.NFTTXN.recipient_address)
  return _s;
}
inline const std::string& NFTTXN::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void NFTTXN::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NFTTXN::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* NFTTXN::release_recipient_address() {
  // @@protoc_insertion_point(field_release:zera_txn.NFTTXN.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void NFTTXN::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.NFTTXN.recipient_address)
}

// optional string contract_fee_amount = 5;
inline bool NFTTXN::_internal_has_contract_fee_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NFTTXN::has_contract_fee_amount() const {
  return _internal_has_contract_fee_amount();
}
inline void NFTTXN::clear_contract_fee_amount() {
  _impl_.contract_fee_amount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NFTTXN::contract_fee_amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.NFTTXN.contract_fee_amount)
  return _internal_contract_fee_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NFTTXN::set_contract_fee_amount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.contract_fee_amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.NFTTXN.contract_fee_amount)
}
inline std::string* NFTTXN::mutable_contract_fee_amount() {
  std::string* _s = _internal_mutable_contract_fee_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.NFTTXN.contract_fee_amount)
  return _s;
}
inline const std::string& NFTTXN::_internal_contract_fee_amount() const {
  return _impl_.contract_fee_amount_.Get();
}
inline void NFTTXN::_internal_set_contract_fee_amount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contract_fee_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* NFTTXN::_internal_mutable_contract_fee_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contract_fee_amount_.Mutable(GetArenaForAllocation());
}
inline std::string* NFTTXN::release_contract_fee_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.NFTTXN.contract_fee_amount)
  if (!_internal_has_contract_fee_amount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.contract_fee_amount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_amount_.IsDefault()) {
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NFTTXN::set_allocated_contract_fee_amount(std::string* contract_fee_amount) {
  if (contract_fee_amount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contract_fee_amount_.SetAllocated(contract_fee_amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_amount_.IsDefault()) {
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.NFTTXN.contract_fee_amount)
}

// optional string contract_fee_id = 6;
inline bool NFTTXN::_internal_has_contract_fee_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NFTTXN::has_contract_fee_id() const {
  return _internal_has_contract_fee_id();
}
inline void NFTTXN::clear_contract_fee_id() {
  _impl_.contract_fee_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NFTTXN::contract_fee_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.NFTTXN.contract_fee_id)
  return _internal_contract_fee_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NFTTXN::set_contract_fee_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.contract_fee_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.NFTTXN.contract_fee_id)
}
inline std::string* NFTTXN::mutable_contract_fee_id() {
  std::string* _s = _internal_mutable_contract_fee_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.NFTTXN.contract_fee_id)
  return _s;
}
inline const std::string& NFTTXN::_internal_contract_fee_id() const {
  return _impl_.contract_fee_id_.Get();
}
inline void NFTTXN::_internal_set_contract_fee_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.contract_fee_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NFTTXN::_internal_mutable_contract_fee_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.contract_fee_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NFTTXN::release_contract_fee_id() {
  // @@protoc_insertion_point(field_release:zera_txn.NFTTXN.contract_fee_id)
  if (!_internal_has_contract_fee_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.contract_fee_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_id_.IsDefault()) {
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NFTTXN::set_allocated_contract_fee_id(std::string* contract_fee_id) {
  if (contract_fee_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.contract_fee_id_.SetAllocated(contract_fee_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fee_id_.IsDefault()) {
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.NFTTXN.contract_fee_id)
}

// -------------------------------------------------------------------

// ItemizedMintTXN

// .zera_txn.BaseTXN base = 1;
inline bool ItemizedMintTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool ItemizedMintTXN::has_base() const {
  return _internal_has_base();
}
inline void ItemizedMintTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& ItemizedMintTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ItemizedMintTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.base)
  return _internal_base();
}
inline void ItemizedMintTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ItemizedMintTXN.base)
}
inline ::zera_txn::BaseTXN* ItemizedMintTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* ItemizedMintTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemizedMintTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ItemizedMintTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* ItemizedMintTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemizedMintTXN.base)
  return _msg;
}
inline void ItemizedMintTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemizedMintTXN.base)
}

// string contract_id = 2;
inline void ItemizedMintTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ItemizedMintTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemizedMintTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ItemizedMintTXN.contract_id)
}
inline std::string* ItemizedMintTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemizedMintTXN.contract_id)
  return _s;
}
inline const std::string& ItemizedMintTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void ItemizedMintTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemizedMintTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemizedMintTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemizedMintTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ItemizedMintTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemizedMintTXN.contract_id)
}

// string item_id = 3;
inline void ItemizedMintTXN::clear_item_id() {
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& ItemizedMintTXN::item_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemizedMintTXN::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ItemizedMintTXN.item_id)
}
inline std::string* ItemizedMintTXN::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemizedMintTXN.item_id)
  return _s;
}
inline const std::string& ItemizedMintTXN::_internal_item_id() const {
  return _impl_.item_id_.Get();
}
inline void ItemizedMintTXN::_internal_set_item_id(const std::string& value) {
  
  _impl_.item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemizedMintTXN::_internal_mutable_item_id() {
  
  return _impl_.item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemizedMintTXN::release_item_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemizedMintTXN.item_id)
  return _impl_.item_id_.Release();
}
inline void ItemizedMintTXN::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  _impl_.item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemizedMintTXN.item_id)
}

// bytes recipient_address = 4;
inline void ItemizedMintTXN::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& ItemizedMintTXN::recipient_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemizedMintTXN::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ItemizedMintTXN.recipient_address)
}
inline std::string* ItemizedMintTXN::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemizedMintTXN.recipient_address)
  return _s;
}
inline const std::string& ItemizedMintTXN::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void ItemizedMintTXN::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemizedMintTXN::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemizedMintTXN::release_recipient_address() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemizedMintTXN.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void ItemizedMintTXN::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemizedMintTXN.recipient_address)
}

// optional string voting_weight = 5;
inline bool ItemizedMintTXN::_internal_has_voting_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemizedMintTXN::has_voting_weight() const {
  return _internal_has_voting_weight();
}
inline void ItemizedMintTXN::clear_voting_weight() {
  _impl_.voting_weight_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ItemizedMintTXN::voting_weight() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.voting_weight)
  return _internal_voting_weight();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemizedMintTXN::set_voting_weight(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.voting_weight_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ItemizedMintTXN.voting_weight)
}
inline std::string* ItemizedMintTXN::mutable_voting_weight() {
  std::string* _s = _internal_mutable_voting_weight();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemizedMintTXN.voting_weight)
  return _s;
}
inline const std::string& ItemizedMintTXN::_internal_voting_weight() const {
  return _impl_.voting_weight_.Get();
}
inline void ItemizedMintTXN::_internal_set_voting_weight(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.voting_weight_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemizedMintTXN::_internal_mutable_voting_weight() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.voting_weight_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemizedMintTXN::release_voting_weight() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemizedMintTXN.voting_weight)
  if (!_internal_has_voting_weight()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.voting_weight_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voting_weight_.IsDefault()) {
    _impl_.voting_weight_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemizedMintTXN::set_allocated_voting_weight(std::string* voting_weight) {
  if (voting_weight != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.voting_weight_.SetAllocated(voting_weight, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voting_weight_.IsDefault()) {
    _impl_.voting_weight_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemizedMintTXN.voting_weight)
}

// repeated .zera_txn.KeyValuePair parameters = 6;
inline int ItemizedMintTXN::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ItemizedMintTXN::parameters_size() const {
  return _internal_parameters_size();
}
inline void ItemizedMintTXN::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline ::zera_txn::KeyValuePair* ItemizedMintTXN::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemizedMintTXN.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >*
ItemizedMintTXN::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ItemizedMintTXN.parameters)
  return &_impl_.parameters_;
}
inline const ::zera_txn::KeyValuePair& ItemizedMintTXN::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::zera_txn::KeyValuePair& ItemizedMintTXN::parameters(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.parameters)
  return _internal_parameters(index);
}
inline ::zera_txn::KeyValuePair* ItemizedMintTXN::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::zera_txn::KeyValuePair* ItemizedMintTXN::add_parameters() {
  ::zera_txn::KeyValuePair* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:zera_txn.ItemizedMintTXN.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >&
ItemizedMintTXN::parameters() const {
  // @@protoc_insertion_point(field_list:zera_txn.ItemizedMintTXN.parameters)
  return _impl_.parameters_;
}

// optional uint64 expiry = 7;
inline bool ItemizedMintTXN::_internal_has_expiry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemizedMintTXN::has_expiry() const {
  return _internal_has_expiry();
}
inline void ItemizedMintTXN::clear_expiry() {
  _impl_.expiry_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ItemizedMintTXN::_internal_expiry() const {
  return _impl_.expiry_;
}
inline uint64_t ItemizedMintTXN::expiry() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.expiry)
  return _internal_expiry();
}
inline void ItemizedMintTXN::_internal_set_expiry(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.expiry_ = value;
}
inline void ItemizedMintTXN::set_expiry(uint64_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:zera_txn.ItemizedMintTXN.expiry)
}

// optional .zera_txn.ItemContractFees contract_fees = 8;
inline bool ItemizedMintTXN::_internal_has_contract_fees() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contract_fees_ != nullptr);
  return value;
}
inline bool ItemizedMintTXN::has_contract_fees() const {
  return _internal_has_contract_fees();
}
inline void ItemizedMintTXN::clear_contract_fees() {
  if (_impl_.contract_fees_ != nullptr) _impl_.contract_fees_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::zera_txn::ItemContractFees& ItemizedMintTXN::_internal_contract_fees() const {
  const ::zera_txn::ItemContractFees* p = _impl_.contract_fees_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::ItemContractFees&>(
      ::zera_txn::_ItemContractFees_default_instance_);
}
inline const ::zera_txn::ItemContractFees& ItemizedMintTXN::contract_fees() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.contract_fees)
  return _internal_contract_fees();
}
inline void ItemizedMintTXN::unsafe_arena_set_allocated_contract_fees(
    ::zera_txn::ItemContractFees* contract_fees) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_fees_);
  }
  _impl_.contract_fees_ = contract_fees;
  if (contract_fees) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ItemizedMintTXN.contract_fees)
}
inline ::zera_txn::ItemContractFees* ItemizedMintTXN::release_contract_fees() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::zera_txn::ItemContractFees* temp = _impl_.contract_fees_;
  _impl_.contract_fees_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::ItemContractFees* ItemizedMintTXN::unsafe_arena_release_contract_fees() {
  // @@protoc_insertion_point(field_release:zera_txn.ItemizedMintTXN.contract_fees)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::zera_txn::ItemContractFees* temp = _impl_.contract_fees_;
  _impl_.contract_fees_ = nullptr;
  return temp;
}
inline ::zera_txn::ItemContractFees* ItemizedMintTXN::_internal_mutable_contract_fees() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.contract_fees_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::ItemContractFees>(GetArenaForAllocation());
    _impl_.contract_fees_ = p;
  }
  return _impl_.contract_fees_;
}
inline ::zera_txn::ItemContractFees* ItemizedMintTXN::mutable_contract_fees() {
  ::zera_txn::ItemContractFees* _msg = _internal_mutable_contract_fees();
  // @@protoc_insertion_point(field_mutable:zera_txn.ItemizedMintTXN.contract_fees)
  return _msg;
}
inline void ItemizedMintTXN::set_allocated_contract_fees(::zera_txn::ItemContractFees* contract_fees) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contract_fees_;
  }
  if (contract_fees) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract_fees);
    if (message_arena != submessage_arena) {
      contract_fees = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_fees, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.contract_fees_ = contract_fees;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ItemizedMintTXN.contract_fees)
}

// optional uint64 valid_from = 9;
inline bool ItemizedMintTXN::_internal_has_valid_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemizedMintTXN::has_valid_from() const {
  return _internal_has_valid_from();
}
inline void ItemizedMintTXN::clear_valid_from() {
  _impl_.valid_from_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t ItemizedMintTXN::_internal_valid_from() const {
  return _impl_.valid_from_;
}
inline uint64_t ItemizedMintTXN::valid_from() const {
  // @@protoc_insertion_point(field_get:zera_txn.ItemizedMintTXN.valid_from)
  return _internal_valid_from();
}
inline void ItemizedMintTXN::_internal_set_valid_from(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.valid_from_ = value;
}
inline void ItemizedMintTXN::set_valid_from(uint64_t value) {
  _internal_set_valid_from(value);
  // @@protoc_insertion_point(field_set:zera_txn.ItemizedMintTXN.valid_from)
}

// -------------------------------------------------------------------

// ContractUpdateTXN

// .zera_txn.BaseTXN base = 1;
inline bool ContractUpdateTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool ContractUpdateTXN::has_base() const {
  return _internal_has_base();
}
inline void ContractUpdateTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& ContractUpdateTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ContractUpdateTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.base)
  return _internal_base();
}
inline void ContractUpdateTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ContractUpdateTXN.base)
}
inline ::zera_txn::BaseTXN* ContractUpdateTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* ContractUpdateTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractUpdateTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ContractUpdateTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* ContractUpdateTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.base)
  return _msg;
}
inline void ContractUpdateTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractUpdateTXN.base)
}

// string contract_id = 2;
inline void ContractUpdateTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ContractUpdateTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractUpdateTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ContractUpdateTXN.contract_id)
}
inline std::string* ContractUpdateTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.contract_id)
  return _s;
}
inline const std::string& ContractUpdateTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void ContractUpdateTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractUpdateTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractUpdateTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractUpdateTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ContractUpdateTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractUpdateTXN.contract_id)
}

// uint64 contract_version = 3;
inline void ContractUpdateTXN::clear_contract_version() {
  _impl_.contract_version_ = uint64_t{0u};
}
inline uint64_t ContractUpdateTXN::_internal_contract_version() const {
  return _impl_.contract_version_;
}
inline uint64_t ContractUpdateTXN::contract_version() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.contract_version)
  return _internal_contract_version();
}
inline void ContractUpdateTXN::_internal_set_contract_version(uint64_t value) {
  
  _impl_.contract_version_ = value;
}
inline void ContractUpdateTXN::set_contract_version(uint64_t value) {
  _internal_set_contract_version(value);
  // @@protoc_insertion_point(field_set:zera_txn.ContractUpdateTXN.contract_version)
}

// optional string name = 4;
inline bool ContractUpdateTXN::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractUpdateTXN::has_name() const {
  return _internal_has_name();
}
inline void ContractUpdateTXN::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractUpdateTXN::name() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractUpdateTXN::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ContractUpdateTXN.name)
}
inline std::string* ContractUpdateTXN::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.name)
  return _s;
}
inline const std::string& ContractUpdateTXN::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ContractUpdateTXN::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractUpdateTXN::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractUpdateTXN::release_name() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractUpdateTXN.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractUpdateTXN::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractUpdateTXN.name)
}

// optional .zera_txn.Governance governance = 5;
inline bool ContractUpdateTXN::_internal_has_governance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.governance_ != nullptr);
  return value;
}
inline bool ContractUpdateTXN::has_governance() const {
  return _internal_has_governance();
}
inline void ContractUpdateTXN::clear_governance() {
  if (_impl_.governance_ != nullptr) _impl_.governance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::zera_txn::Governance& ContractUpdateTXN::_internal_governance() const {
  const ::zera_txn::Governance* p = _impl_.governance_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::Governance&>(
      ::zera_txn::_Governance_default_instance_);
}
inline const ::zera_txn::Governance& ContractUpdateTXN::governance() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.governance)
  return _internal_governance();
}
inline void ContractUpdateTXN::unsafe_arena_set_allocated_governance(
    ::zera_txn::Governance* governance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.governance_);
  }
  _impl_.governance_ = governance;
  if (governance) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ContractUpdateTXN.governance)
}
inline ::zera_txn::Governance* ContractUpdateTXN::release_governance() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::zera_txn::Governance* temp = _impl_.governance_;
  _impl_.governance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::Governance* ContractUpdateTXN::unsafe_arena_release_governance() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractUpdateTXN.governance)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::zera_txn::Governance* temp = _impl_.governance_;
  _impl_.governance_ = nullptr;
  return temp;
}
inline ::zera_txn::Governance* ContractUpdateTXN::_internal_mutable_governance() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.governance_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::Governance>(GetArenaForAllocation());
    _impl_.governance_ = p;
  }
  return _impl_.governance_;
}
inline ::zera_txn::Governance* ContractUpdateTXN::mutable_governance() {
  ::zera_txn::Governance* _msg = _internal_mutable_governance();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.governance)
  return _msg;
}
inline void ContractUpdateTXN::set_allocated_governance(::zera_txn::Governance* governance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.governance_;
  }
  if (governance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(governance);
    if (message_arena != submessage_arena) {
      governance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, governance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.governance_ = governance;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractUpdateTXN.governance)
}

// repeated .zera_txn.RestrictedKey restricted_keys = 6;
inline int ContractUpdateTXN::_internal_restricted_keys_size() const {
  return _impl_.restricted_keys_.size();
}
inline int ContractUpdateTXN::restricted_keys_size() const {
  return _internal_restricted_keys_size();
}
inline void ContractUpdateTXN::clear_restricted_keys() {
  _impl_.restricted_keys_.Clear();
}
inline ::zera_txn::RestrictedKey* ContractUpdateTXN::mutable_restricted_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.restricted_keys)
  return _impl_.restricted_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey >*
ContractUpdateTXN::mutable_restricted_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ContractUpdateTXN.restricted_keys)
  return &_impl_.restricted_keys_;
}
inline const ::zera_txn::RestrictedKey& ContractUpdateTXN::_internal_restricted_keys(int index) const {
  return _impl_.restricted_keys_.Get(index);
}
inline const ::zera_txn::RestrictedKey& ContractUpdateTXN::restricted_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.restricted_keys)
  return _internal_restricted_keys(index);
}
inline ::zera_txn::RestrictedKey* ContractUpdateTXN::_internal_add_restricted_keys() {
  return _impl_.restricted_keys_.Add();
}
inline ::zera_txn::RestrictedKey* ContractUpdateTXN::add_restricted_keys() {
  ::zera_txn::RestrictedKey* _add = _internal_add_restricted_keys();
  // @@protoc_insertion_point(field_add:zera_txn.ContractUpdateTXN.restricted_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey >&
ContractUpdateTXN::restricted_keys() const {
  // @@protoc_insertion_point(field_list:zera_txn.ContractUpdateTXN.restricted_keys)
  return _impl_.restricted_keys_;
}

// optional .zera_txn.ContractFees contract_fees = 7;
inline bool ContractUpdateTXN::_internal_has_contract_fees() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contract_fees_ != nullptr);
  return value;
}
inline bool ContractUpdateTXN::has_contract_fees() const {
  return _internal_has_contract_fees();
}
inline void ContractUpdateTXN::clear_contract_fees() {
  if (_impl_.contract_fees_ != nullptr) _impl_.contract_fees_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::zera_txn::ContractFees& ContractUpdateTXN::_internal_contract_fees() const {
  const ::zera_txn::ContractFees* p = _impl_.contract_fees_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::ContractFees&>(
      ::zera_txn::_ContractFees_default_instance_);
}
inline const ::zera_txn::ContractFees& ContractUpdateTXN::contract_fees() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.contract_fees)
  return _internal_contract_fees();
}
inline void ContractUpdateTXN::unsafe_arena_set_allocated_contract_fees(
    ::zera_txn::ContractFees* contract_fees) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_fees_);
  }
  _impl_.contract_fees_ = contract_fees;
  if (contract_fees) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ContractUpdateTXN.contract_fees)
}
inline ::zera_txn::ContractFees* ContractUpdateTXN::release_contract_fees() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::zera_txn::ContractFees* temp = _impl_.contract_fees_;
  _impl_.contract_fees_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::ContractFees* ContractUpdateTXN::unsafe_arena_release_contract_fees() {
  // @@protoc_insertion_point(field_release:zera_txn.ContractUpdateTXN.contract_fees)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::zera_txn::ContractFees* temp = _impl_.contract_fees_;
  _impl_.contract_fees_ = nullptr;
  return temp;
}
inline ::zera_txn::ContractFees* ContractUpdateTXN::_internal_mutable_contract_fees() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.contract_fees_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::ContractFees>(GetArenaForAllocation());
    _impl_.contract_fees_ = p;
  }
  return _impl_.contract_fees_;
}
inline ::zera_txn::ContractFees* ContractUpdateTXN::mutable_contract_fees() {
  ::zera_txn::ContractFees* _msg = _internal_mutable_contract_fees();
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.contract_fees)
  return _msg;
}
inline void ContractUpdateTXN::set_allocated_contract_fees(::zera_txn::ContractFees* contract_fees) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contract_fees_;
  }
  if (contract_fees) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract_fees);
    if (message_arena != submessage_arena) {
      contract_fees = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_fees, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.contract_fees_ = contract_fees;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ContractUpdateTXN.contract_fees)
}

// repeated .zera_txn.KeyValuePair custom_parameters = 8;
inline int ContractUpdateTXN::_internal_custom_parameters_size() const {
  return _impl_.custom_parameters_.size();
}
inline int ContractUpdateTXN::custom_parameters_size() const {
  return _internal_custom_parameters_size();
}
inline void ContractUpdateTXN::clear_custom_parameters() {
  _impl_.custom_parameters_.Clear();
}
inline ::zera_txn::KeyValuePair* ContractUpdateTXN::mutable_custom_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.custom_parameters)
  return _impl_.custom_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >*
ContractUpdateTXN::mutable_custom_parameters() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ContractUpdateTXN.custom_parameters)
  return &_impl_.custom_parameters_;
}
inline const ::zera_txn::KeyValuePair& ContractUpdateTXN::_internal_custom_parameters(int index) const {
  return _impl_.custom_parameters_.Get(index);
}
inline const ::zera_txn::KeyValuePair& ContractUpdateTXN::custom_parameters(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.custom_parameters)
  return _internal_custom_parameters(index);
}
inline ::zera_txn::KeyValuePair* ContractUpdateTXN::_internal_add_custom_parameters() {
  return _impl_.custom_parameters_.Add();
}
inline ::zera_txn::KeyValuePair* ContractUpdateTXN::add_custom_parameters() {
  ::zera_txn::KeyValuePair* _add = _internal_add_custom_parameters();
  // @@protoc_insertion_point(field_add:zera_txn.ContractUpdateTXN.custom_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >&
ContractUpdateTXN::custom_parameters() const {
  // @@protoc_insertion_point(field_list:zera_txn.ContractUpdateTXN.custom_parameters)
  return _impl_.custom_parameters_;
}

// repeated .zera_txn.ExpenseRatio expense_ratio = 9;
inline int ContractUpdateTXN::_internal_expense_ratio_size() const {
  return _impl_.expense_ratio_.size();
}
inline int ContractUpdateTXN::expense_ratio_size() const {
  return _internal_expense_ratio_size();
}
inline void ContractUpdateTXN::clear_expense_ratio() {
  _impl_.expense_ratio_.Clear();
}
inline ::zera_txn::ExpenseRatio* ContractUpdateTXN::mutable_expense_ratio(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.expense_ratio)
  return _impl_.expense_ratio_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio >*
ContractUpdateTXN::mutable_expense_ratio() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ContractUpdateTXN.expense_ratio)
  return &_impl_.expense_ratio_;
}
inline const ::zera_txn::ExpenseRatio& ContractUpdateTXN::_internal_expense_ratio(int index) const {
  return _impl_.expense_ratio_.Get(index);
}
inline const ::zera_txn::ExpenseRatio& ContractUpdateTXN::expense_ratio(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.expense_ratio)
  return _internal_expense_ratio(index);
}
inline ::zera_txn::ExpenseRatio* ContractUpdateTXN::_internal_add_expense_ratio() {
  return _impl_.expense_ratio_.Add();
}
inline ::zera_txn::ExpenseRatio* ContractUpdateTXN::add_expense_ratio() {
  ::zera_txn::ExpenseRatio* _add = _internal_add_expense_ratio();
  // @@protoc_insertion_point(field_add:zera_txn.ContractUpdateTXN.expense_ratio)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio >&
ContractUpdateTXN::expense_ratio() const {
  // @@protoc_insertion_point(field_list:zera_txn.ContractUpdateTXN.expense_ratio)
  return _impl_.expense_ratio_;
}

// repeated .zera_txn.TokenCompliance token_compliance = 10;
inline int ContractUpdateTXN::_internal_token_compliance_size() const {
  return _impl_.token_compliance_.size();
}
inline int ContractUpdateTXN::token_compliance_size() const {
  return _internal_token_compliance_size();
}
inline void ContractUpdateTXN::clear_token_compliance() {
  _impl_.token_compliance_.Clear();
}
inline ::zera_txn::TokenCompliance* ContractUpdateTXN::mutable_token_compliance(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ContractUpdateTXN.token_compliance)
  return _impl_.token_compliance_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance >*
ContractUpdateTXN::mutable_token_compliance() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ContractUpdateTXN.token_compliance)
  return &_impl_.token_compliance_;
}
inline const ::zera_txn::TokenCompliance& ContractUpdateTXN::_internal_token_compliance(int index) const {
  return _impl_.token_compliance_.Get(index);
}
inline const ::zera_txn::TokenCompliance& ContractUpdateTXN::token_compliance(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.token_compliance)
  return _internal_token_compliance(index);
}
inline ::zera_txn::TokenCompliance* ContractUpdateTXN::_internal_add_token_compliance() {
  return _impl_.token_compliance_.Add();
}
inline ::zera_txn::TokenCompliance* ContractUpdateTXN::add_token_compliance() {
  ::zera_txn::TokenCompliance* _add = _internal_add_token_compliance();
  // @@protoc_insertion_point(field_add:zera_txn.ContractUpdateTXN.token_compliance)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance >&
ContractUpdateTXN::token_compliance() const {
  // @@protoc_insertion_point(field_list:zera_txn.ContractUpdateTXN.token_compliance)
  return _impl_.token_compliance_;
}

// optional bool kyc_status = 11;
inline bool ContractUpdateTXN::_internal_has_kyc_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContractUpdateTXN::has_kyc_status() const {
  return _internal_has_kyc_status();
}
inline void ContractUpdateTXN::clear_kyc_status() {
  _impl_.kyc_status_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ContractUpdateTXN::_internal_kyc_status() const {
  return _impl_.kyc_status_;
}
inline bool ContractUpdateTXN::kyc_status() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.kyc_status)
  return _internal_kyc_status();
}
inline void ContractUpdateTXN::_internal_set_kyc_status(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.kyc_status_ = value;
}
inline void ContractUpdateTXN::set_kyc_status(bool value) {
  _internal_set_kyc_status(value);
  // @@protoc_insertion_point(field_set:zera_txn.ContractUpdateTXN.kyc_status)
}

// optional bool immutable_kyc_status = 12;
inline bool ContractUpdateTXN::_internal_has_immutable_kyc_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContractUpdateTXN::has_immutable_kyc_status() const {
  return _internal_has_immutable_kyc_status();
}
inline void ContractUpdateTXN::clear_immutable_kyc_status() {
  _impl_.immutable_kyc_status_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ContractUpdateTXN::_internal_immutable_kyc_status() const {
  return _impl_.immutable_kyc_status_;
}
inline bool ContractUpdateTXN::immutable_kyc_status() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.immutable_kyc_status)
  return _internal_immutable_kyc_status();
}
inline void ContractUpdateTXN::_internal_set_immutable_kyc_status(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.immutable_kyc_status_ = value;
}
inline void ContractUpdateTXN::set_immutable_kyc_status(bool value) {
  _internal_set_immutable_kyc_status(value);
  // @@protoc_insertion_point(field_set:zera_txn.ContractUpdateTXN.immutable_kyc_status)
}

// optional uint32 quash_threshold = 13;
inline bool ContractUpdateTXN::_internal_has_quash_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContractUpdateTXN::has_quash_threshold() const {
  return _internal_has_quash_threshold();
}
inline void ContractUpdateTXN::clear_quash_threshold() {
  _impl_.quash_threshold_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ContractUpdateTXN::_internal_quash_threshold() const {
  return _impl_.quash_threshold_;
}
inline uint32_t ContractUpdateTXN::quash_threshold() const {
  // @@protoc_insertion_point(field_get:zera_txn.ContractUpdateTXN.quash_threshold)
  return _internal_quash_threshold();
}
inline void ContractUpdateTXN::_internal_set_quash_threshold(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.quash_threshold_ = value;
}
inline void ContractUpdateTXN::set_quash_threshold(uint32_t value) {
  _internal_set_quash_threshold(value);
  // @@protoc_insertion_point(field_set:zera_txn.ContractUpdateTXN.quash_threshold)
}

// -------------------------------------------------------------------

// InstrumentContract

// .zera_txn.BaseTXN base = 1;
inline bool InstrumentContract::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool InstrumentContract::has_base() const {
  return _internal_has_base();
}
inline void InstrumentContract::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& InstrumentContract::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& InstrumentContract::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.base)
  return _internal_base();
}
inline void InstrumentContract::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.InstrumentContract.base)
}
inline ::zera_txn::BaseTXN* InstrumentContract::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* InstrumentContract::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* InstrumentContract::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* InstrumentContract::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.base)
  return _msg;
}
inline void InstrumentContract::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.base)
}

// uint64 contract_version = 2;
inline void InstrumentContract::clear_contract_version() {
  _impl_.contract_version_ = uint64_t{0u};
}
inline uint64_t InstrumentContract::_internal_contract_version() const {
  return _impl_.contract_version_;
}
inline uint64_t InstrumentContract::contract_version() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.contract_version)
  return _internal_contract_version();
}
inline void InstrumentContract::_internal_set_contract_version(uint64_t value) {
  
  _impl_.contract_version_ = value;
}
inline void InstrumentContract::set_contract_version(uint64_t value) {
  _internal_set_contract_version(value);
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.contract_version)
}

// string symbol = 3;
inline void InstrumentContract::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& InstrumentContract::symbol() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentContract::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 _impl_.symbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.symbol)
}
inline std::string* InstrumentContract::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.symbol)
  return _s;
}
inline const std::string& InstrumentContract::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void InstrumentContract::_internal_set_symbol(const std::string& value) {
  
  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentContract::_internal_mutable_symbol() {
  
  return _impl_.symbol_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentContract::release_symbol() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.symbol)
  return _impl_.symbol_.Release();
}
inline void InstrumentContract::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  _impl_.symbol_.SetAllocated(symbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.symbol)
}

// string name = 4;
inline void InstrumentContract::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& InstrumentContract::name() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentContract::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.name)
}
inline std::string* InstrumentContract::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.name)
  return _s;
}
inline const std::string& InstrumentContract::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InstrumentContract::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentContract::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentContract::release_name() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.name)
  return _impl_.name_.Release();
}
inline void InstrumentContract::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.name)
}

// optional .zera_txn.Governance governance = 5;
inline bool InstrumentContract::_internal_has_governance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.governance_ != nullptr);
  return value;
}
inline bool InstrumentContract::has_governance() const {
  return _internal_has_governance();
}
inline void InstrumentContract::clear_governance() {
  if (_impl_.governance_ != nullptr) _impl_.governance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::zera_txn::Governance& InstrumentContract::_internal_governance() const {
  const ::zera_txn::Governance* p = _impl_.governance_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::Governance&>(
      ::zera_txn::_Governance_default_instance_);
}
inline const ::zera_txn::Governance& InstrumentContract::governance() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.governance)
  return _internal_governance();
}
inline void InstrumentContract::unsafe_arena_set_allocated_governance(
    ::zera_txn::Governance* governance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.governance_);
  }
  _impl_.governance_ = governance;
  if (governance) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.InstrumentContract.governance)
}
inline ::zera_txn::Governance* InstrumentContract::release_governance() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::zera_txn::Governance* temp = _impl_.governance_;
  _impl_.governance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::Governance* InstrumentContract::unsafe_arena_release_governance() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.governance)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::zera_txn::Governance* temp = _impl_.governance_;
  _impl_.governance_ = nullptr;
  return temp;
}
inline ::zera_txn::Governance* InstrumentContract::_internal_mutable_governance() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.governance_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::Governance>(GetArenaForAllocation());
    _impl_.governance_ = p;
  }
  return _impl_.governance_;
}
inline ::zera_txn::Governance* InstrumentContract::mutable_governance() {
  ::zera_txn::Governance* _msg = _internal_mutable_governance();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.governance)
  return _msg;
}
inline void InstrumentContract::set_allocated_governance(::zera_txn::Governance* governance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.governance_;
  }
  if (governance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(governance);
    if (message_arena != submessage_arena) {
      governance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, governance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.governance_ = governance;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.governance)
}

// repeated .zera_txn.RestrictedKey restricted_keys = 6;
inline int InstrumentContract::_internal_restricted_keys_size() const {
  return _impl_.restricted_keys_.size();
}
inline int InstrumentContract::restricted_keys_size() const {
  return _internal_restricted_keys_size();
}
inline void InstrumentContract::clear_restricted_keys() {
  _impl_.restricted_keys_.Clear();
}
inline ::zera_txn::RestrictedKey* InstrumentContract::mutable_restricted_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.restricted_keys)
  return _impl_.restricted_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey >*
InstrumentContract::mutable_restricted_keys() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.InstrumentContract.restricted_keys)
  return &_impl_.restricted_keys_;
}
inline const ::zera_txn::RestrictedKey& InstrumentContract::_internal_restricted_keys(int index) const {
  return _impl_.restricted_keys_.Get(index);
}
inline const ::zera_txn::RestrictedKey& InstrumentContract::restricted_keys(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.restricted_keys)
  return _internal_restricted_keys(index);
}
inline ::zera_txn::RestrictedKey* InstrumentContract::_internal_add_restricted_keys() {
  return _impl_.restricted_keys_.Add();
}
inline ::zera_txn::RestrictedKey* InstrumentContract::add_restricted_keys() {
  ::zera_txn::RestrictedKey* _add = _internal_add_restricted_keys();
  // @@protoc_insertion_point(field_add:zera_txn.InstrumentContract.restricted_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RestrictedKey >&
InstrumentContract::restricted_keys() const {
  // @@protoc_insertion_point(field_list:zera_txn.InstrumentContract.restricted_keys)
  return _impl_.restricted_keys_;
}

// optional string max_supply = 7;
inline bool InstrumentContract::_internal_has_max_supply() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstrumentContract::has_max_supply() const {
  return _internal_has_max_supply();
}
inline void InstrumentContract::clear_max_supply() {
  _impl_.max_supply_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstrumentContract::max_supply() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.max_supply)
  return _internal_max_supply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentContract::set_max_supply(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.max_supply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.max_supply)
}
inline std::string* InstrumentContract::mutable_max_supply() {
  std::string* _s = _internal_mutable_max_supply();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.max_supply)
  return _s;
}
inline const std::string& InstrumentContract::_internal_max_supply() const {
  return _impl_.max_supply_.Get();
}
inline void InstrumentContract::_internal_set_max_supply(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_supply_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentContract::_internal_mutable_max_supply() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.max_supply_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentContract::release_max_supply() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.max_supply)
  if (!_internal_has_max_supply()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.max_supply_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.max_supply_.IsDefault()) {
    _impl_.max_supply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstrumentContract::set_allocated_max_supply(std::string* max_supply) {
  if (max_supply != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.max_supply_.SetAllocated(max_supply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.max_supply_.IsDefault()) {
    _impl_.max_supply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.max_supply)
}

// optional .zera_txn.ContractFees contract_fees = 8;
inline bool InstrumentContract::_internal_has_contract_fees() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contract_fees_ != nullptr);
  return value;
}
inline bool InstrumentContract::has_contract_fees() const {
  return _internal_has_contract_fees();
}
inline void InstrumentContract::clear_contract_fees() {
  if (_impl_.contract_fees_ != nullptr) _impl_.contract_fees_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::zera_txn::ContractFees& InstrumentContract::_internal_contract_fees() const {
  const ::zera_txn::ContractFees* p = _impl_.contract_fees_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::ContractFees&>(
      ::zera_txn::_ContractFees_default_instance_);
}
inline const ::zera_txn::ContractFees& InstrumentContract::contract_fees() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.contract_fees)
  return _internal_contract_fees();
}
inline void InstrumentContract::unsafe_arena_set_allocated_contract_fees(
    ::zera_txn::ContractFees* contract_fees) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_fees_);
  }
  _impl_.contract_fees_ = contract_fees;
  if (contract_fees) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.InstrumentContract.contract_fees)
}
inline ::zera_txn::ContractFees* InstrumentContract::release_contract_fees() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::zera_txn::ContractFees* temp = _impl_.contract_fees_;
  _impl_.contract_fees_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::ContractFees* InstrumentContract::unsafe_arena_release_contract_fees() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.contract_fees)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::zera_txn::ContractFees* temp = _impl_.contract_fees_;
  _impl_.contract_fees_ = nullptr;
  return temp;
}
inline ::zera_txn::ContractFees* InstrumentContract::_internal_mutable_contract_fees() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.contract_fees_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::ContractFees>(GetArenaForAllocation());
    _impl_.contract_fees_ = p;
  }
  return _impl_.contract_fees_;
}
inline ::zera_txn::ContractFees* InstrumentContract::mutable_contract_fees() {
  ::zera_txn::ContractFees* _msg = _internal_mutable_contract_fees();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.contract_fees)
  return _msg;
}
inline void InstrumentContract::set_allocated_contract_fees(::zera_txn::ContractFees* contract_fees) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contract_fees_;
  }
  if (contract_fees) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract_fees);
    if (message_arena != submessage_arena) {
      contract_fees = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_fees, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.contract_fees_ = contract_fees;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.contract_fees)
}

// repeated .zera_txn.PreMintWallet premint_wallets = 9;
inline int InstrumentContract::_internal_premint_wallets_size() const {
  return _impl_.premint_wallets_.size();
}
inline int InstrumentContract::premint_wallets_size() const {
  return _internal_premint_wallets_size();
}
inline void InstrumentContract::clear_premint_wallets() {
  _impl_.premint_wallets_.Clear();
}
inline ::zera_txn::PreMintWallet* InstrumentContract::mutable_premint_wallets(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.premint_wallets)
  return _impl_.premint_wallets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PreMintWallet >*
InstrumentContract::mutable_premint_wallets() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.InstrumentContract.premint_wallets)
  return &_impl_.premint_wallets_;
}
inline const ::zera_txn::PreMintWallet& InstrumentContract::_internal_premint_wallets(int index) const {
  return _impl_.premint_wallets_.Get(index);
}
inline const ::zera_txn::PreMintWallet& InstrumentContract::premint_wallets(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.premint_wallets)
  return _internal_premint_wallets(index);
}
inline ::zera_txn::PreMintWallet* InstrumentContract::_internal_add_premint_wallets() {
  return _impl_.premint_wallets_.Add();
}
inline ::zera_txn::PreMintWallet* InstrumentContract::add_premint_wallets() {
  ::zera_txn::PreMintWallet* _add = _internal_add_premint_wallets();
  // @@protoc_insertion_point(field_add:zera_txn.InstrumentContract.premint_wallets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::PreMintWallet >&
InstrumentContract::premint_wallets() const {
  // @@protoc_insertion_point(field_list:zera_txn.InstrumentContract.premint_wallets)
  return _impl_.premint_wallets_;
}

// optional .zera_txn.CoinDenomination coin_denomination = 10;
inline bool InstrumentContract::_internal_has_coin_denomination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.coin_denomination_ != nullptr);
  return value;
}
inline bool InstrumentContract::has_coin_denomination() const {
  return _internal_has_coin_denomination();
}
inline void InstrumentContract::clear_coin_denomination() {
  if (_impl_.coin_denomination_ != nullptr) _impl_.coin_denomination_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::zera_txn::CoinDenomination& InstrumentContract::_internal_coin_denomination() const {
  const ::zera_txn::CoinDenomination* p = _impl_.coin_denomination_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::CoinDenomination&>(
      ::zera_txn::_CoinDenomination_default_instance_);
}
inline const ::zera_txn::CoinDenomination& InstrumentContract::coin_denomination() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.coin_denomination)
  return _internal_coin_denomination();
}
inline void InstrumentContract::unsafe_arena_set_allocated_coin_denomination(
    ::zera_txn::CoinDenomination* coin_denomination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coin_denomination_);
  }
  _impl_.coin_denomination_ = coin_denomination;
  if (coin_denomination) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.InstrumentContract.coin_denomination)
}
inline ::zera_txn::CoinDenomination* InstrumentContract::release_coin_denomination() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::zera_txn::CoinDenomination* temp = _impl_.coin_denomination_;
  _impl_.coin_denomination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::CoinDenomination* InstrumentContract::unsafe_arena_release_coin_denomination() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.coin_denomination)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::zera_txn::CoinDenomination* temp = _impl_.coin_denomination_;
  _impl_.coin_denomination_ = nullptr;
  return temp;
}
inline ::zera_txn::CoinDenomination* InstrumentContract::_internal_mutable_coin_denomination() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.coin_denomination_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::CoinDenomination>(GetArenaForAllocation());
    _impl_.coin_denomination_ = p;
  }
  return _impl_.coin_denomination_;
}
inline ::zera_txn::CoinDenomination* InstrumentContract::mutable_coin_denomination() {
  ::zera_txn::CoinDenomination* _msg = _internal_mutable_coin_denomination();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.coin_denomination)
  return _msg;
}
inline void InstrumentContract::set_allocated_coin_denomination(::zera_txn::CoinDenomination* coin_denomination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.coin_denomination_;
  }
  if (coin_denomination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coin_denomination);
    if (message_arena != submessage_arena) {
      coin_denomination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_denomination, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.coin_denomination_ = coin_denomination;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.coin_denomination)
}

// repeated .zera_txn.KeyValuePair custom_parameters = 11;
inline int InstrumentContract::_internal_custom_parameters_size() const {
  return _impl_.custom_parameters_.size();
}
inline int InstrumentContract::custom_parameters_size() const {
  return _internal_custom_parameters_size();
}
inline void InstrumentContract::clear_custom_parameters() {
  _impl_.custom_parameters_.Clear();
}
inline ::zera_txn::KeyValuePair* InstrumentContract::mutable_custom_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.custom_parameters)
  return _impl_.custom_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >*
InstrumentContract::mutable_custom_parameters() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.InstrumentContract.custom_parameters)
  return &_impl_.custom_parameters_;
}
inline const ::zera_txn::KeyValuePair& InstrumentContract::_internal_custom_parameters(int index) const {
  return _impl_.custom_parameters_.Get(index);
}
inline const ::zera_txn::KeyValuePair& InstrumentContract::custom_parameters(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.custom_parameters)
  return _internal_custom_parameters(index);
}
inline ::zera_txn::KeyValuePair* InstrumentContract::_internal_add_custom_parameters() {
  return _impl_.custom_parameters_.Add();
}
inline ::zera_txn::KeyValuePair* InstrumentContract::add_custom_parameters() {
  ::zera_txn::KeyValuePair* _add = _internal_add_custom_parameters();
  // @@protoc_insertion_point(field_add:zera_txn.InstrumentContract.custom_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::KeyValuePair >&
InstrumentContract::custom_parameters() const {
  // @@protoc_insertion_point(field_list:zera_txn.InstrumentContract.custom_parameters)
  return _impl_.custom_parameters_;
}

// string contract_id = 12;
inline void InstrumentContract::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& InstrumentContract::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentContract::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.contract_id)
}
inline std::string* InstrumentContract::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.contract_id)
  return _s;
}
inline const std::string& InstrumentContract::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void InstrumentContract::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentContract::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentContract::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.contract_id)
  return _impl_.contract_id_.Release();
}
inline void InstrumentContract::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.contract_id)
}

// repeated .zera_txn.ExpenseRatio expense_ratio = 13;
inline int InstrumentContract::_internal_expense_ratio_size() const {
  return _impl_.expense_ratio_.size();
}
inline int InstrumentContract::expense_ratio_size() const {
  return _internal_expense_ratio_size();
}
inline void InstrumentContract::clear_expense_ratio() {
  _impl_.expense_ratio_.Clear();
}
inline ::zera_txn::ExpenseRatio* InstrumentContract::mutable_expense_ratio(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.expense_ratio)
  return _impl_.expense_ratio_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio >*
InstrumentContract::mutable_expense_ratio() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.InstrumentContract.expense_ratio)
  return &_impl_.expense_ratio_;
}
inline const ::zera_txn::ExpenseRatio& InstrumentContract::_internal_expense_ratio(int index) const {
  return _impl_.expense_ratio_.Get(index);
}
inline const ::zera_txn::ExpenseRatio& InstrumentContract::expense_ratio(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.expense_ratio)
  return _internal_expense_ratio(index);
}
inline ::zera_txn::ExpenseRatio* InstrumentContract::_internal_add_expense_ratio() {
  return _impl_.expense_ratio_.Add();
}
inline ::zera_txn::ExpenseRatio* InstrumentContract::add_expense_ratio() {
  ::zera_txn::ExpenseRatio* _add = _internal_add_expense_ratio();
  // @@protoc_insertion_point(field_add:zera_txn.InstrumentContract.expense_ratio)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatio >&
InstrumentContract::expense_ratio() const {
  // @@protoc_insertion_point(field_list:zera_txn.InstrumentContract.expense_ratio)
  return _impl_.expense_ratio_;
}

// .zera_txn.CONTRACT_TYPE type = 14;
inline void InstrumentContract::clear_type() {
  _impl_.type_ = 0;
}
inline ::zera_txn::CONTRACT_TYPE InstrumentContract::_internal_type() const {
  return static_cast< ::zera_txn::CONTRACT_TYPE >(_impl_.type_);
}
inline ::zera_txn::CONTRACT_TYPE InstrumentContract::type() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.type)
  return _internal_type();
}
inline void InstrumentContract::_internal_set_type(::zera_txn::CONTRACT_TYPE value) {
  
  _impl_.type_ = value;
}
inline void InstrumentContract::set_type(::zera_txn::CONTRACT_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.type)
}

// bool update_contract_fees = 15;
inline void InstrumentContract::clear_update_contract_fees() {
  _impl_.update_contract_fees_ = false;
}
inline bool InstrumentContract::_internal_update_contract_fees() const {
  return _impl_.update_contract_fees_;
}
inline bool InstrumentContract::update_contract_fees() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.update_contract_fees)
  return _internal_update_contract_fees();
}
inline void InstrumentContract::_internal_set_update_contract_fees(bool value) {
  
  _impl_.update_contract_fees_ = value;
}
inline void InstrumentContract::set_update_contract_fees(bool value) {
  _internal_set_update_contract_fees(value);
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.update_contract_fees)
}

// bool update_expense_ratio = 16;
inline void InstrumentContract::clear_update_expense_ratio() {
  _impl_.update_expense_ratio_ = false;
}
inline bool InstrumentContract::_internal_update_expense_ratio() const {
  return _impl_.update_expense_ratio_;
}
inline bool InstrumentContract::update_expense_ratio() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.update_expense_ratio)
  return _internal_update_expense_ratio();
}
inline void InstrumentContract::_internal_set_update_expense_ratio(bool value) {
  
  _impl_.update_expense_ratio_ = value;
}
inline void InstrumentContract::set_update_expense_ratio(bool value) {
  _internal_set_update_expense_ratio(value);
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.update_expense_ratio)
}

// optional uint32 quash_threshold = 17;
inline bool InstrumentContract::_internal_has_quash_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InstrumentContract::has_quash_threshold() const {
  return _internal_has_quash_threshold();
}
inline void InstrumentContract::clear_quash_threshold() {
  _impl_.quash_threshold_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t InstrumentContract::_internal_quash_threshold() const {
  return _impl_.quash_threshold_;
}
inline uint32_t InstrumentContract::quash_threshold() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.quash_threshold)
  return _internal_quash_threshold();
}
inline void InstrumentContract::_internal_set_quash_threshold(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.quash_threshold_ = value;
}
inline void InstrumentContract::set_quash_threshold(uint32_t value) {
  _internal_set_quash_threshold(value);
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.quash_threshold)
}

// repeated .zera_txn.TokenCompliance token_compliance = 18;
inline int InstrumentContract::_internal_token_compliance_size() const {
  return _impl_.token_compliance_.size();
}
inline int InstrumentContract::token_compliance_size() const {
  return _internal_token_compliance_size();
}
inline void InstrumentContract::clear_token_compliance() {
  _impl_.token_compliance_.Clear();
}
inline ::zera_txn::TokenCompliance* InstrumentContract::mutable_token_compliance(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.token_compliance)
  return _impl_.token_compliance_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance >*
InstrumentContract::mutable_token_compliance() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.InstrumentContract.token_compliance)
  return &_impl_.token_compliance_;
}
inline const ::zera_txn::TokenCompliance& InstrumentContract::_internal_token_compliance(int index) const {
  return _impl_.token_compliance_.Get(index);
}
inline const ::zera_txn::TokenCompliance& InstrumentContract::token_compliance(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.token_compliance)
  return _internal_token_compliance(index);
}
inline ::zera_txn::TokenCompliance* InstrumentContract::_internal_add_token_compliance() {
  return _impl_.token_compliance_.Add();
}
inline ::zera_txn::TokenCompliance* InstrumentContract::add_token_compliance() {
  ::zera_txn::TokenCompliance* _add = _internal_add_token_compliance();
  // @@protoc_insertion_point(field_add:zera_txn.InstrumentContract.token_compliance)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenCompliance >&
InstrumentContract::token_compliance() const {
  // @@protoc_insertion_point(field_list:zera_txn.InstrumentContract.token_compliance)
  return _impl_.token_compliance_;
}

// bool kyc_status = 19;
inline void InstrumentContract::clear_kyc_status() {
  _impl_.kyc_status_ = false;
}
inline bool InstrumentContract::_internal_kyc_status() const {
  return _impl_.kyc_status_;
}
inline bool InstrumentContract::kyc_status() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.kyc_status)
  return _internal_kyc_status();
}
inline void InstrumentContract::_internal_set_kyc_status(bool value) {
  
  _impl_.kyc_status_ = value;
}
inline void InstrumentContract::set_kyc_status(bool value) {
  _internal_set_kyc_status(value);
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.kyc_status)
}

// bool immutable_kyc_status = 20;
inline void InstrumentContract::clear_immutable_kyc_status() {
  _impl_.immutable_kyc_status_ = false;
}
inline bool InstrumentContract::_internal_immutable_kyc_status() const {
  return _impl_.immutable_kyc_status_;
}
inline bool InstrumentContract::immutable_kyc_status() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.immutable_kyc_status)
  return _internal_immutable_kyc_status();
}
inline void InstrumentContract::_internal_set_immutable_kyc_status(bool value) {
  
  _impl_.immutable_kyc_status_ = value;
}
inline void InstrumentContract::set_immutable_kyc_status(bool value) {
  _internal_set_immutable_kyc_status(value);
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.immutable_kyc_status)
}

// optional string cur_equiv_start = 21;
inline bool InstrumentContract::_internal_has_cur_equiv_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstrumentContract::has_cur_equiv_start() const {
  return _internal_has_cur_equiv_start();
}
inline void InstrumentContract::clear_cur_equiv_start() {
  _impl_.cur_equiv_start_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstrumentContract::cur_equiv_start() const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.cur_equiv_start)
  return _internal_cur_equiv_start();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentContract::set_cur_equiv_start(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cur_equiv_start_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.InstrumentContract.cur_equiv_start)
}
inline std::string* InstrumentContract::mutable_cur_equiv_start() {
  std::string* _s = _internal_mutable_cur_equiv_start();
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.cur_equiv_start)
  return _s;
}
inline const std::string& InstrumentContract::_internal_cur_equiv_start() const {
  return _impl_.cur_equiv_start_.Get();
}
inline void InstrumentContract::_internal_set_cur_equiv_start(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cur_equiv_start_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentContract::_internal_mutable_cur_equiv_start() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cur_equiv_start_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentContract::release_cur_equiv_start() {
  // @@protoc_insertion_point(field_release:zera_txn.InstrumentContract.cur_equiv_start)
  if (!_internal_has_cur_equiv_start()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cur_equiv_start_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cur_equiv_start_.IsDefault()) {
    _impl_.cur_equiv_start_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstrumentContract::set_allocated_cur_equiv_start(std::string* cur_equiv_start) {
  if (cur_equiv_start != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cur_equiv_start_.SetAllocated(cur_equiv_start, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cur_equiv_start_.IsDefault()) {
    _impl_.cur_equiv_start_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.InstrumentContract.cur_equiv_start)
}

// repeated .zera_txn.MaxSupplyRelease max_supply_release = 22;
inline int InstrumentContract::_internal_max_supply_release_size() const {
  return _impl_.max_supply_release_.size();
}
inline int InstrumentContract::max_supply_release_size() const {
  return _internal_max_supply_release_size();
}
inline void InstrumentContract::clear_max_supply_release() {
  _impl_.max_supply_release_.Clear();
}
inline ::zera_txn::MaxSupplyRelease* InstrumentContract::mutable_max_supply_release(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.InstrumentContract.max_supply_release)
  return _impl_.max_supply_release_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MaxSupplyRelease >*
InstrumentContract::mutable_max_supply_release() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.InstrumentContract.max_supply_release)
  return &_impl_.max_supply_release_;
}
inline const ::zera_txn::MaxSupplyRelease& InstrumentContract::_internal_max_supply_release(int index) const {
  return _impl_.max_supply_release_.Get(index);
}
inline const ::zera_txn::MaxSupplyRelease& InstrumentContract::max_supply_release(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.InstrumentContract.max_supply_release)
  return _internal_max_supply_release(index);
}
inline ::zera_txn::MaxSupplyRelease* InstrumentContract::_internal_add_max_supply_release() {
  return _impl_.max_supply_release_.Add();
}
inline ::zera_txn::MaxSupplyRelease* InstrumentContract::add_max_supply_release() {
  ::zera_txn::MaxSupplyRelease* _add = _internal_add_max_supply_release();
  // @@protoc_insertion_point(field_add:zera_txn.InstrumentContract.max_supply_release)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MaxSupplyRelease >&
InstrumentContract::max_supply_release() const {
  // @@protoc_insertion_point(field_list:zera_txn.InstrumentContract.max_supply_release)
  return _impl_.max_supply_release_;
}

// -------------------------------------------------------------------

// MaxSupplyRelease

// .google.protobuf.Timestamp release_date = 1;
inline bool MaxSupplyRelease::_internal_has_release_date() const {
  return this != internal_default_instance() && _impl_.release_date_ != nullptr;
}
inline bool MaxSupplyRelease::has_release_date() const {
  return _internal_has_release_date();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MaxSupplyRelease::_internal_release_date() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.release_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MaxSupplyRelease::release_date() const {
  // @@protoc_insertion_point(field_get:zera_txn.MaxSupplyRelease.release_date)
  return _internal_release_date();
}
inline void MaxSupplyRelease::unsafe_arena_set_allocated_release_date(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.release_date_);
  }
  _impl_.release_date_ = release_date;
  if (release_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.MaxSupplyRelease.release_date)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MaxSupplyRelease::release_release_date() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.release_date_;
  _impl_.release_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MaxSupplyRelease::unsafe_arena_release_release_date() {
  // @@protoc_insertion_point(field_release:zera_txn.MaxSupplyRelease.release_date)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.release_date_;
  _impl_.release_date_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MaxSupplyRelease::_internal_mutable_release_date() {
  
  if (_impl_.release_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.release_date_ = p;
  }
  return _impl_.release_date_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MaxSupplyRelease::mutable_release_date() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_release_date();
  // @@protoc_insertion_point(field_mutable:zera_txn.MaxSupplyRelease.release_date)
  return _msg;
}
inline void MaxSupplyRelease::set_allocated_release_date(::PROTOBUF_NAMESPACE_ID::Timestamp* release_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.release_date_);
  }
  if (release_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(release_date));
    if (message_arena != submessage_arena) {
      release_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, release_date, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.release_date_ = release_date;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.MaxSupplyRelease.release_date)
}

// string amount = 2;
inline void MaxSupplyRelease::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& MaxSupplyRelease::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.MaxSupplyRelease.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MaxSupplyRelease::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.MaxSupplyRelease.amount)
}
inline std::string* MaxSupplyRelease::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.MaxSupplyRelease.amount)
  return _s;
}
inline const std::string& MaxSupplyRelease::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void MaxSupplyRelease::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* MaxSupplyRelease::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* MaxSupplyRelease::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.MaxSupplyRelease.amount)
  return _impl_.amount_.Release();
}
inline void MaxSupplyRelease::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.MaxSupplyRelease.amount)
}

// -------------------------------------------------------------------

// GovernanceVote

// .zera_txn.BaseTXN base = 1;
inline bool GovernanceVote::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool GovernanceVote::has_base() const {
  return _internal_has_base();
}
inline void GovernanceVote::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& GovernanceVote::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& GovernanceVote::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceVote.base)
  return _internal_base();
}
inline void GovernanceVote::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.GovernanceVote.base)
}
inline ::zera_txn::BaseTXN* GovernanceVote::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* GovernanceVote::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceVote.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* GovernanceVote::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* GovernanceVote::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceVote.base)
  return _msg;
}
inline void GovernanceVote::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceVote.base)
}

// string contract_id = 2;
inline void GovernanceVote::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& GovernanceVote::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceVote.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceVote::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceVote.contract_id)
}
inline std::string* GovernanceVote::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceVote.contract_id)
  return _s;
}
inline const std::string& GovernanceVote::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void GovernanceVote::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceVote::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceVote::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceVote.contract_id)
  return _impl_.contract_id_.Release();
}
inline void GovernanceVote::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceVote.contract_id)
}

// bytes proposal_id = 3;
inline void GovernanceVote::clear_proposal_id() {
  _impl_.proposal_id_.ClearToEmpty();
}
inline const std::string& GovernanceVote::proposal_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceVote.proposal_id)
  return _internal_proposal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceVote::set_proposal_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proposal_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceVote.proposal_id)
}
inline std::string* GovernanceVote::mutable_proposal_id() {
  std::string* _s = _internal_mutable_proposal_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceVote.proposal_id)
  return _s;
}
inline const std::string& GovernanceVote::_internal_proposal_id() const {
  return _impl_.proposal_id_.Get();
}
inline void GovernanceVote::_internal_set_proposal_id(const std::string& value) {
  
  _impl_.proposal_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceVote::_internal_mutable_proposal_id() {
  
  return _impl_.proposal_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceVote::release_proposal_id() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceVote.proposal_id)
  return _impl_.proposal_id_.Release();
}
inline void GovernanceVote::set_allocated_proposal_id(std::string* proposal_id) {
  if (proposal_id != nullptr) {
    
  } else {
    
  }
  _impl_.proposal_id_.SetAllocated(proposal_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proposal_id_.IsDefault()) {
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceVote.proposal_id)
}

// optional bool support = 4;
inline bool GovernanceVote::_internal_has_support() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GovernanceVote::has_support() const {
  return _internal_has_support();
}
inline void GovernanceVote::clear_support() {
  _impl_.support_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool GovernanceVote::_internal_support() const {
  return _impl_.support_;
}
inline bool GovernanceVote::support() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceVote.support)
  return _internal_support();
}
inline void GovernanceVote::_internal_set_support(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.support_ = value;
}
inline void GovernanceVote::set_support(bool value) {
  _internal_set_support(value);
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceVote.support)
}

// optional uint32 support_option = 5;
inline bool GovernanceVote::_internal_has_support_option() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GovernanceVote::has_support_option() const {
  return _internal_has_support_option();
}
inline void GovernanceVote::clear_support_option() {
  _impl_.support_option_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GovernanceVote::_internal_support_option() const {
  return _impl_.support_option_;
}
inline uint32_t GovernanceVote::support_option() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceVote.support_option)
  return _internal_support_option();
}
inline void GovernanceVote::_internal_set_support_option(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.support_option_ = value;
}
inline void GovernanceVote::set_support_option(uint32_t value) {
  _internal_set_support_option(value);
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceVote.support_option)
}

// -------------------------------------------------------------------

// GovernanceProposal

// .zera_txn.BaseTXN base = 1;
inline bool GovernanceProposal::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool GovernanceProposal::has_base() const {
  return _internal_has_base();
}
inline void GovernanceProposal::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& GovernanceProposal::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& GovernanceProposal::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.base)
  return _internal_base();
}
inline void GovernanceProposal::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.GovernanceProposal.base)
}
inline ::zera_txn::BaseTXN* GovernanceProposal::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* GovernanceProposal::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceProposal.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* GovernanceProposal::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* GovernanceProposal::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.base)
  return _msg;
}
inline void GovernanceProposal::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceProposal.base)
}

// string contract_id = 2;
inline void GovernanceProposal::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& GovernanceProposal::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceProposal::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceProposal.contract_id)
}
inline std::string* GovernanceProposal::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.contract_id)
  return _s;
}
inline const std::string& GovernanceProposal::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void GovernanceProposal::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceProposal::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceProposal::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceProposal.contract_id)
  return _impl_.contract_id_.Release();
}
inline void GovernanceProposal::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceProposal.contract_id)
}

// string title = 3;
inline void GovernanceProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& GovernanceProposal::title() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceProposal::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceProposal.title)
}
inline std::string* GovernanceProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.title)
  return _s;
}
inline const std::string& GovernanceProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void GovernanceProposal::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceProposal::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceProposal::release_title() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceProposal.title)
  return _impl_.title_.Release();
}
inline void GovernanceProposal::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceProposal.title)
}

// string synopsis = 4;
inline void GovernanceProposal::clear_synopsis() {
  _impl_.synopsis_.ClearToEmpty();
}
inline const std::string& GovernanceProposal::synopsis() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.synopsis)
  return _internal_synopsis();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceProposal::set_synopsis(ArgT0&& arg0, ArgT... args) {
 
 _impl_.synopsis_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceProposal.synopsis)
}
inline std::string* GovernanceProposal::mutable_synopsis() {
  std::string* _s = _internal_mutable_synopsis();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.synopsis)
  return _s;
}
inline const std::string& GovernanceProposal::_internal_synopsis() const {
  return _impl_.synopsis_.Get();
}
inline void GovernanceProposal::_internal_set_synopsis(const std::string& value) {
  
  _impl_.synopsis_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceProposal::_internal_mutable_synopsis() {
  
  return _impl_.synopsis_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceProposal::release_synopsis() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceProposal.synopsis)
  return _impl_.synopsis_.Release();
}
inline void GovernanceProposal::set_allocated_synopsis(std::string* synopsis) {
  if (synopsis != nullptr) {
    
  } else {
    
  }
  _impl_.synopsis_.SetAllocated(synopsis, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.synopsis_.IsDefault()) {
    _impl_.synopsis_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceProposal.synopsis)
}

// string body = 5;
inline void GovernanceProposal::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& GovernanceProposal::body() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceProposal::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceProposal.body)
}
inline std::string* GovernanceProposal::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.body)
  return _s;
}
inline const std::string& GovernanceProposal::_internal_body() const {
  return _impl_.body_.Get();
}
inline void GovernanceProposal::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceProposal::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceProposal::release_body() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceProposal.body)
  return _impl_.body_.Release();
}
inline void GovernanceProposal::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceProposal.body)
}

// repeated string options = 6;
inline int GovernanceProposal::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int GovernanceProposal::options_size() const {
  return _internal_options_size();
}
inline void GovernanceProposal::clear_options() {
  _impl_.options_.Clear();
}
inline std::string* GovernanceProposal::add_options() {
  std::string* _s = _internal_add_options();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.GovernanceProposal.options)
  return _s;
}
inline const std::string& GovernanceProposal::_internal_options(int index) const {
  return _impl_.options_.Get(index);
}
inline const std::string& GovernanceProposal::options(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.options)
  return _internal_options(index);
}
inline std::string* GovernanceProposal::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.options)
  return _impl_.options_.Mutable(index);
}
inline void GovernanceProposal::set_options(int index, const std::string& value) {
  _impl_.options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceProposal.options)
}
inline void GovernanceProposal::set_options(int index, std::string&& value) {
  _impl_.options_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceProposal.options)
}
inline void GovernanceProposal::set_options(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.GovernanceProposal.options)
}
inline void GovernanceProposal::set_options(int index, const char* value, size_t size) {
  _impl_.options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.GovernanceProposal.options)
}
inline std::string* GovernanceProposal::_internal_add_options() {
  return _impl_.options_.Add();
}
inline void GovernanceProposal::add_options(const std::string& value) {
  _impl_.options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.GovernanceProposal.options)
}
inline void GovernanceProposal::add_options(std::string&& value) {
  _impl_.options_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.GovernanceProposal.options)
}
inline void GovernanceProposal::add_options(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.GovernanceProposal.options)
}
inline void GovernanceProposal::add_options(const char* value, size_t size) {
  _impl_.options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.GovernanceProposal.options)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GovernanceProposal::options() const {
  // @@protoc_insertion_point(field_list:zera_txn.GovernanceProposal.options)
  return _impl_.options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GovernanceProposal::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.GovernanceProposal.options)
  return &_impl_.options_;
}

// optional .google.protobuf.Timestamp start_timestamp = 7;
inline bool GovernanceProposal::_internal_has_start_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_timestamp_ != nullptr);
  return value;
}
inline bool GovernanceProposal::has_start_timestamp() const {
  return _internal_has_start_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GovernanceProposal::_internal_start_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GovernanceProposal::start_timestamp() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.start_timestamp)
  return _internal_start_timestamp();
}
inline void GovernanceProposal::unsafe_arena_set_allocated_start_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_timestamp_);
  }
  _impl_.start_timestamp_ = start_timestamp;
  if (start_timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.GovernanceProposal.start_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GovernanceProposal::release_start_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_timestamp_;
  _impl_.start_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GovernanceProposal::unsafe_arena_release_start_timestamp() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceProposal.start_timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_timestamp_;
  _impl_.start_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GovernanceProposal::_internal_mutable_start_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_timestamp_ = p;
  }
  return _impl_.start_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GovernanceProposal::mutable_start_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_timestamp();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.start_timestamp)
  return _msg;
}
inline void GovernanceProposal::set_allocated_start_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* start_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_timestamp_);
  }
  if (start_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_timestamp));
    if (message_arena != submessage_arena) {
      start_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_timestamp_ = start_timestamp;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceProposal.start_timestamp)
}

// optional .google.protobuf.Timestamp end_timestamp = 8;
inline bool GovernanceProposal::_internal_has_end_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_timestamp_ != nullptr);
  return value;
}
inline bool GovernanceProposal::has_end_timestamp() const {
  return _internal_has_end_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GovernanceProposal::_internal_end_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GovernanceProposal::end_timestamp() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.end_timestamp)
  return _internal_end_timestamp();
}
inline void GovernanceProposal::unsafe_arena_set_allocated_end_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_timestamp_);
  }
  _impl_.end_timestamp_ = end_timestamp;
  if (end_timestamp) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.GovernanceProposal.end_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GovernanceProposal::release_end_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_timestamp_;
  _impl_.end_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GovernanceProposal::unsafe_arena_release_end_timestamp() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceProposal.end_timestamp)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_timestamp_;
  _impl_.end_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GovernanceProposal::_internal_mutable_end_timestamp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_timestamp_ = p;
  }
  return _impl_.end_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GovernanceProposal::mutable_end_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_timestamp();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.end_timestamp)
  return _msg;
}
inline void GovernanceProposal::set_allocated_end_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* end_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_timestamp_);
  }
  if (end_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_timestamp));
    if (message_arena != submessage_arena) {
      end_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.end_timestamp_ = end_timestamp;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceProposal.end_timestamp)
}

// repeated .zera_txn.GovernanceTXN governance_txn = 9;
inline int GovernanceProposal::_internal_governance_txn_size() const {
  return _impl_.governance_txn_.size();
}
inline int GovernanceProposal::governance_txn_size() const {
  return _internal_governance_txn_size();
}
inline void GovernanceProposal::clear_governance_txn() {
  _impl_.governance_txn_.Clear();
}
inline ::zera_txn::GovernanceTXN* GovernanceProposal::mutable_governance_txn(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceProposal.governance_txn)
  return _impl_.governance_txn_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN >*
GovernanceProposal::mutable_governance_txn() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.GovernanceProposal.governance_txn)
  return &_impl_.governance_txn_;
}
inline const ::zera_txn::GovernanceTXN& GovernanceProposal::_internal_governance_txn(int index) const {
  return _impl_.governance_txn_.Get(index);
}
inline const ::zera_txn::GovernanceTXN& GovernanceProposal::governance_txn(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceProposal.governance_txn)
  return _internal_governance_txn(index);
}
inline ::zera_txn::GovernanceTXN* GovernanceProposal::_internal_add_governance_txn() {
  return _impl_.governance_txn_.Add();
}
inline ::zera_txn::GovernanceTXN* GovernanceProposal::add_governance_txn() {
  ::zera_txn::GovernanceTXN* _add = _internal_add_governance_txn();
  // @@protoc_insertion_point(field_add:zera_txn.GovernanceProposal.governance_txn)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceTXN >&
GovernanceProposal::governance_txn() const {
  // @@protoc_insertion_point(field_list:zera_txn.GovernanceProposal.governance_txn)
  return _impl_.governance_txn_;
}

// -------------------------------------------------------------------

// GovernanceTXN

// .zera_txn.TRANSACTION_TYPE txn_type = 1;
inline void GovernanceTXN::clear_txn_type() {
  _impl_.txn_type_ = 0;
}
inline ::zera_txn::TRANSACTION_TYPE GovernanceTXN::_internal_txn_type() const {
  return static_cast< ::zera_txn::TRANSACTION_TYPE >(_impl_.txn_type_);
}
inline ::zera_txn::TRANSACTION_TYPE GovernanceTXN::txn_type() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceTXN.txn_type)
  return _internal_txn_type();
}
inline void GovernanceTXN::_internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  
  _impl_.txn_type_ = value;
}
inline void GovernanceTXN::set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  _internal_set_txn_type(value);
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceTXN.txn_type)
}

// bytes serialized_txn = 2;
inline void GovernanceTXN::clear_serialized_txn() {
  _impl_.serialized_txn_.ClearToEmpty();
}
inline const std::string& GovernanceTXN::serialized_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceTXN.serialized_txn)
  return _internal_serialized_txn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceTXN::set_serialized_txn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serialized_txn_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceTXN.serialized_txn)
}
inline std::string* GovernanceTXN::mutable_serialized_txn() {
  std::string* _s = _internal_mutable_serialized_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceTXN.serialized_txn)
  return _s;
}
inline const std::string& GovernanceTXN::_internal_serialized_txn() const {
  return _impl_.serialized_txn_.Get();
}
inline void GovernanceTXN::_internal_set_serialized_txn(const std::string& value) {
  
  _impl_.serialized_txn_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceTXN::_internal_mutable_serialized_txn() {
  
  return _impl_.serialized_txn_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceTXN::release_serialized_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceTXN.serialized_txn)
  return _impl_.serialized_txn_.Release();
}
inline void GovernanceTXN::set_allocated_serialized_txn(std::string* serialized_txn) {
  if (serialized_txn != nullptr) {
    
  } else {
    
  }
  _impl_.serialized_txn_.SetAllocated(serialized_txn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serialized_txn_.IsDefault()) {
    _impl_.serialized_txn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceTXN.serialized_txn)
}

// bytes txn_hash = 3;
inline void GovernanceTXN::clear_txn_hash() {
  _impl_.txn_hash_.ClearToEmpty();
}
inline const std::string& GovernanceTXN::txn_hash() const {
  // @@protoc_insertion_point(field_get:zera_txn.GovernanceTXN.txn_hash)
  return _internal_txn_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GovernanceTXN::set_txn_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txn_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.GovernanceTXN.txn_hash)
}
inline std::string* GovernanceTXN::mutable_txn_hash() {
  std::string* _s = _internal_mutable_txn_hash();
  // @@protoc_insertion_point(field_mutable:zera_txn.GovernanceTXN.txn_hash)
  return _s;
}
inline const std::string& GovernanceTXN::_internal_txn_hash() const {
  return _impl_.txn_hash_.Get();
}
inline void GovernanceTXN::_internal_set_txn_hash(const std::string& value) {
  
  _impl_.txn_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GovernanceTXN::_internal_mutable_txn_hash() {
  
  return _impl_.txn_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* GovernanceTXN::release_txn_hash() {
  // @@protoc_insertion_point(field_release:zera_txn.GovernanceTXN.txn_hash)
  return _impl_.txn_hash_.Release();
}
inline void GovernanceTXN::set_allocated_txn_hash(std::string* txn_hash) {
  if (txn_hash != nullptr) {
    
  } else {
    
  }
  _impl_.txn_hash_.SetAllocated(txn_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txn_hash_.IsDefault()) {
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.GovernanceTXN.txn_hash)
}

// -------------------------------------------------------------------

// SmartContractTXN

// .zera_txn.BaseTXN base = 1;
inline bool SmartContractTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool SmartContractTXN::has_base() const {
  return _internal_has_base();
}
inline void SmartContractTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& SmartContractTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& SmartContractTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractTXN.base)
  return _internal_base();
}
inline void SmartContractTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.SmartContractTXN.base)
}
inline ::zera_txn::BaseTXN* SmartContractTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* SmartContractTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* SmartContractTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* SmartContractTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractTXN.base)
  return _msg;
}
inline void SmartContractTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractTXN.base)
}

// string smart_contract_name = 4;
inline void SmartContractTXN::clear_smart_contract_name() {
  _impl_.smart_contract_name_.ClearToEmpty();
}
inline const std::string& SmartContractTXN::smart_contract_name() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractTXN.smart_contract_name)
  return _internal_smart_contract_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractTXN::set_smart_contract_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.smart_contract_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractTXN.smart_contract_name)
}
inline std::string* SmartContractTXN::mutable_smart_contract_name() {
  std::string* _s = _internal_mutable_smart_contract_name();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractTXN.smart_contract_name)
  return _s;
}
inline const std::string& SmartContractTXN::_internal_smart_contract_name() const {
  return _impl_.smart_contract_name_.Get();
}
inline void SmartContractTXN::_internal_set_smart_contract_name(const std::string& value) {
  
  _impl_.smart_contract_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractTXN::_internal_mutable_smart_contract_name() {
  
  return _impl_.smart_contract_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractTXN::release_smart_contract_name() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractTXN.smart_contract_name)
  return _impl_.smart_contract_name_.Release();
}
inline void SmartContractTXN::set_allocated_smart_contract_name(std::string* smart_contract_name) {
  if (smart_contract_name != nullptr) {
    
  } else {
    
  }
  _impl_.smart_contract_name_.SetAllocated(smart_contract_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smart_contract_name_.IsDefault()) {
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractTXN.smart_contract_name)
}

// bytes binary_code = 2;
inline void SmartContractTXN::clear_binary_code() {
  _impl_.binary_code_.ClearToEmpty();
}
inline const std::string& SmartContractTXN::binary_code() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractTXN.binary_code)
  return _internal_binary_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractTXN::set_binary_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.binary_code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractTXN.binary_code)
}
inline std::string* SmartContractTXN::mutable_binary_code() {
  std::string* _s = _internal_mutable_binary_code();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractTXN.binary_code)
  return _s;
}
inline const std::string& SmartContractTXN::_internal_binary_code() const {
  return _impl_.binary_code_.Get();
}
inline void SmartContractTXN::_internal_set_binary_code(const std::string& value) {
  
  _impl_.binary_code_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractTXN::_internal_mutable_binary_code() {
  
  return _impl_.binary_code_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractTXN::release_binary_code() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractTXN.binary_code)
  return _impl_.binary_code_.Release();
}
inline void SmartContractTXN::set_allocated_binary_code(std::string* binary_code) {
  if (binary_code != nullptr) {
    
  } else {
    
  }
  _impl_.binary_code_.SetAllocated(binary_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binary_code_.IsDefault()) {
    _impl_.binary_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractTXN.binary_code)
}

// bytes source_code = 7;
inline void SmartContractTXN::clear_source_code() {
  _impl_.source_code_.ClearToEmpty();
}
inline const std::string& SmartContractTXN::source_code() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractTXN.source_code)
  return _internal_source_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractTXN::set_source_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractTXN.source_code)
}
inline std::string* SmartContractTXN::mutable_source_code() {
  std::string* _s = _internal_mutable_source_code();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractTXN.source_code)
  return _s;
}
inline const std::string& SmartContractTXN::_internal_source_code() const {
  return _impl_.source_code_.Get();
}
inline void SmartContractTXN::_internal_set_source_code(const std::string& value) {
  
  _impl_.source_code_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractTXN::_internal_mutable_source_code() {
  
  return _impl_.source_code_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractTXN::release_source_code() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractTXN.source_code)
  return _impl_.source_code_.Release();
}
inline void SmartContractTXN::set_allocated_source_code(std::string* source_code) {
  if (source_code != nullptr) {
    
  } else {
    
  }
  _impl_.source_code_.SetAllocated(source_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_code_.IsDefault()) {
    _impl_.source_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractTXN.source_code)
}

// .zera_txn.LANGUAGE language = 3;
inline void SmartContractTXN::clear_language() {
  _impl_.language_ = 0;
}
inline ::zera_txn::LANGUAGE SmartContractTXN::_internal_language() const {
  return static_cast< ::zera_txn::LANGUAGE >(_impl_.language_);
}
inline ::zera_txn::LANGUAGE SmartContractTXN::language() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractTXN.language)
  return _internal_language();
}
inline void SmartContractTXN::_internal_set_language(::zera_txn::LANGUAGE value) {
  
  _impl_.language_ = value;
}
inline void SmartContractTXN::set_language(::zera_txn::LANGUAGE value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractTXN.language)
}

// repeated string functions = 5;
inline int SmartContractTXN::_internal_functions_size() const {
  return _impl_.functions_.size();
}
inline int SmartContractTXN::functions_size() const {
  return _internal_functions_size();
}
inline void SmartContractTXN::clear_functions() {
  _impl_.functions_.Clear();
}
inline std::string* SmartContractTXN::add_functions() {
  std::string* _s = _internal_add_functions();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.SmartContractTXN.functions)
  return _s;
}
inline const std::string& SmartContractTXN::_internal_functions(int index) const {
  return _impl_.functions_.Get(index);
}
inline const std::string& SmartContractTXN::functions(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractTXN.functions)
  return _internal_functions(index);
}
inline std::string* SmartContractTXN::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractTXN.functions)
  return _impl_.functions_.Mutable(index);
}
inline void SmartContractTXN::set_functions(int index, const std::string& value) {
  _impl_.functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractTXN.functions)
}
inline void SmartContractTXN::set_functions(int index, std::string&& value) {
  _impl_.functions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractTXN.functions)
}
inline void SmartContractTXN::set_functions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.SmartContractTXN.functions)
}
inline void SmartContractTXN::set_functions(int index, const char* value, size_t size) {
  _impl_.functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.SmartContractTXN.functions)
}
inline std::string* SmartContractTXN::_internal_add_functions() {
  return _impl_.functions_.Add();
}
inline void SmartContractTXN::add_functions(const std::string& value) {
  _impl_.functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.SmartContractTXN.functions)
}
inline void SmartContractTXN::add_functions(std::string&& value) {
  _impl_.functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.SmartContractTXN.functions)
}
inline void SmartContractTXN::add_functions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.SmartContractTXN.functions)
}
inline void SmartContractTXN::add_functions(const char* value, size_t size) {
  _impl_.functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.SmartContractTXN.functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SmartContractTXN::functions() const {
  // @@protoc_insertion_point(field_list:zera_txn.SmartContractTXN.functions)
  return _impl_.functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SmartContractTXN::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.SmartContractTXN.functions)
  return &_impl_.functions_;
}

// -------------------------------------------------------------------

// Parameters

// bytes value = 1;
inline void Parameters::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Parameters::value() const {
  // @@protoc_insertion_point(field_get:zera_txn.Parameters.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parameters::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Parameters.value)
}
inline std::string* Parameters::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:zera_txn.Parameters.value)
  return _s;
}
inline const std::string& Parameters::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Parameters::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Parameters::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Parameters::release_value() {
  // @@protoc_insertion_point(field_release:zera_txn.Parameters.value)
  return _impl_.value_.Release();
}
inline void Parameters::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Parameters.value)
}

// string type = 2;
inline void Parameters::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Parameters::type() const {
  // @@protoc_insertion_point(field_get:zera_txn.Parameters.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parameters::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Parameters.type)
}
inline std::string* Parameters::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:zera_txn.Parameters.type)
  return _s;
}
inline const std::string& Parameters::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Parameters::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Parameters::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Parameters::release_type() {
  // @@protoc_insertion_point(field_release:zera_txn.Parameters.type)
  return _impl_.type_.Release();
}
inline void Parameters::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Parameters.type)
}

// -------------------------------------------------------------------

// SmartContractExecuteTXN

// .zera_txn.BaseTXN base = 1;
inline bool SmartContractExecuteTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool SmartContractExecuteTXN::has_base() const {
  return _internal_has_base();
}
inline void SmartContractExecuteTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& SmartContractExecuteTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& SmartContractExecuteTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractExecuteTXN.base)
  return _internal_base();
}
inline void SmartContractExecuteTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.SmartContractExecuteTXN.base)
}
inline ::zera_txn::BaseTXN* SmartContractExecuteTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* SmartContractExecuteTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractExecuteTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* SmartContractExecuteTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* SmartContractExecuteTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractExecuteTXN.base)
  return _msg;
}
inline void SmartContractExecuteTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractExecuteTXN.base)
}

// string smart_contract_name = 2;
inline void SmartContractExecuteTXN::clear_smart_contract_name() {
  _impl_.smart_contract_name_.ClearToEmpty();
}
inline const std::string& SmartContractExecuteTXN::smart_contract_name() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractExecuteTXN.smart_contract_name)
  return _internal_smart_contract_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractExecuteTXN::set_smart_contract_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.smart_contract_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractExecuteTXN.smart_contract_name)
}
inline std::string* SmartContractExecuteTXN::mutable_smart_contract_name() {
  std::string* _s = _internal_mutable_smart_contract_name();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractExecuteTXN.smart_contract_name)
  return _s;
}
inline const std::string& SmartContractExecuteTXN::_internal_smart_contract_name() const {
  return _impl_.smart_contract_name_.Get();
}
inline void SmartContractExecuteTXN::_internal_set_smart_contract_name(const std::string& value) {
  
  _impl_.smart_contract_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractExecuteTXN::_internal_mutable_smart_contract_name() {
  
  return _impl_.smart_contract_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractExecuteTXN::release_smart_contract_name() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractExecuteTXN.smart_contract_name)
  return _impl_.smart_contract_name_.Release();
}
inline void SmartContractExecuteTXN::set_allocated_smart_contract_name(std::string* smart_contract_name) {
  if (smart_contract_name != nullptr) {
    
  } else {
    
  }
  _impl_.smart_contract_name_.SetAllocated(smart_contract_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smart_contract_name_.IsDefault()) {
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractExecuteTXN.smart_contract_name)
}

// uint32 instance = 3;
inline void SmartContractExecuteTXN::clear_instance() {
  _impl_.instance_ = 0u;
}
inline uint32_t SmartContractExecuteTXN::_internal_instance() const {
  return _impl_.instance_;
}
inline uint32_t SmartContractExecuteTXN::instance() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractExecuteTXN.instance)
  return _internal_instance();
}
inline void SmartContractExecuteTXN::_internal_set_instance(uint32_t value) {
  
  _impl_.instance_ = value;
}
inline void SmartContractExecuteTXN::set_instance(uint32_t value) {
  _internal_set_instance(value);
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractExecuteTXN.instance)
}

// string function = 4;
inline void SmartContractExecuteTXN::clear_function() {
  _impl_.function_.ClearToEmpty();
}
inline const std::string& SmartContractExecuteTXN::function() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractExecuteTXN.function)
  return _internal_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractExecuteTXN::set_function(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractExecuteTXN.function)
}
inline std::string* SmartContractExecuteTXN::mutable_function() {
  std::string* _s = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractExecuteTXN.function)
  return _s;
}
inline const std::string& SmartContractExecuteTXN::_internal_function() const {
  return _impl_.function_.Get();
}
inline void SmartContractExecuteTXN::_internal_set_function(const std::string& value) {
  
  _impl_.function_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractExecuteTXN::_internal_mutable_function() {
  
  return _impl_.function_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractExecuteTXN::release_function() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractExecuteTXN.function)
  return _impl_.function_.Release();
}
inline void SmartContractExecuteTXN::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    
  } else {
    
  }
  _impl_.function_.SetAllocated(function, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_.IsDefault()) {
    _impl_.function_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractExecuteTXN.function)
}

// repeated .zera_txn.Parameters parameters = 5;
inline int SmartContractExecuteTXN::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int SmartContractExecuteTXN::parameters_size() const {
  return _internal_parameters_size();
}
inline void SmartContractExecuteTXN::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline ::zera_txn::Parameters* SmartContractExecuteTXN::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractExecuteTXN.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters >*
SmartContractExecuteTXN::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.SmartContractExecuteTXN.parameters)
  return &_impl_.parameters_;
}
inline const ::zera_txn::Parameters& SmartContractExecuteTXN::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::zera_txn::Parameters& SmartContractExecuteTXN::parameters(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractExecuteTXN.parameters)
  return _internal_parameters(index);
}
inline ::zera_txn::Parameters* SmartContractExecuteTXN::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::zera_txn::Parameters* SmartContractExecuteTXN::add_parameters() {
  ::zera_txn::Parameters* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:zera_txn.SmartContractExecuteTXN.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters >&
SmartContractExecuteTXN::parameters() const {
  // @@protoc_insertion_point(field_list:zera_txn.SmartContractExecuteTXN.parameters)
  return _impl_.parameters_;
}

// -------------------------------------------------------------------

// SmartContractInstantiateTXN

// .zera_txn.BaseTXN base = 1;
inline bool SmartContractInstantiateTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool SmartContractInstantiateTXN::has_base() const {
  return _internal_has_base();
}
inline void SmartContractInstantiateTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& SmartContractInstantiateTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& SmartContractInstantiateTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractInstantiateTXN.base)
  return _internal_base();
}
inline void SmartContractInstantiateTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.SmartContractInstantiateTXN.base)
}
inline ::zera_txn::BaseTXN* SmartContractInstantiateTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* SmartContractInstantiateTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractInstantiateTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* SmartContractInstantiateTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* SmartContractInstantiateTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractInstantiateTXN.base)
  return _msg;
}
inline void SmartContractInstantiateTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractInstantiateTXN.base)
}

// string smart_contract_name = 2;
inline void SmartContractInstantiateTXN::clear_smart_contract_name() {
  _impl_.smart_contract_name_.ClearToEmpty();
}
inline const std::string& SmartContractInstantiateTXN::smart_contract_name() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractInstantiateTXN.smart_contract_name)
  return _internal_smart_contract_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractInstantiateTXN::set_smart_contract_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.smart_contract_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractInstantiateTXN.smart_contract_name)
}
inline std::string* SmartContractInstantiateTXN::mutable_smart_contract_name() {
  std::string* _s = _internal_mutable_smart_contract_name();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractInstantiateTXN.smart_contract_name)
  return _s;
}
inline const std::string& SmartContractInstantiateTXN::_internal_smart_contract_name() const {
  return _impl_.smart_contract_name_.Get();
}
inline void SmartContractInstantiateTXN::_internal_set_smart_contract_name(const std::string& value) {
  
  _impl_.smart_contract_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractInstantiateTXN::_internal_mutable_smart_contract_name() {
  
  return _impl_.smart_contract_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractInstantiateTXN::release_smart_contract_name() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractInstantiateTXN.smart_contract_name)
  return _impl_.smart_contract_name_.Release();
}
inline void SmartContractInstantiateTXN::set_allocated_smart_contract_name(std::string* smart_contract_name) {
  if (smart_contract_name != nullptr) {
    
  } else {
    
  }
  _impl_.smart_contract_name_.SetAllocated(smart_contract_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smart_contract_name_.IsDefault()) {
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractInstantiateTXN.smart_contract_name)
}

// uint32 instance = 3;
inline void SmartContractInstantiateTXN::clear_instance() {
  _impl_.instance_ = 0u;
}
inline uint32_t SmartContractInstantiateTXN::_internal_instance() const {
  return _impl_.instance_;
}
inline uint32_t SmartContractInstantiateTXN::instance() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractInstantiateTXN.instance)
  return _internal_instance();
}
inline void SmartContractInstantiateTXN::_internal_set_instance(uint32_t value) {
  
  _impl_.instance_ = value;
}
inline void SmartContractInstantiateTXN::set_instance(uint32_t value) {
  _internal_set_instance(value);
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractInstantiateTXN.instance)
}

// repeated .zera_txn.Parameters parameters = 4;
inline int SmartContractInstantiateTXN::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int SmartContractInstantiateTXN::parameters_size() const {
  return _internal_parameters_size();
}
inline void SmartContractInstantiateTXN::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline ::zera_txn::Parameters* SmartContractInstantiateTXN::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractInstantiateTXN.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters >*
SmartContractInstantiateTXN::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.SmartContractInstantiateTXN.parameters)
  return &_impl_.parameters_;
}
inline const ::zera_txn::Parameters& SmartContractInstantiateTXN::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::zera_txn::Parameters& SmartContractInstantiateTXN::parameters(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractInstantiateTXN.parameters)
  return _internal_parameters(index);
}
inline ::zera_txn::Parameters* SmartContractInstantiateTXN::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::zera_txn::Parameters* SmartContractInstantiateTXN::add_parameters() {
  ::zera_txn::Parameters* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:zera_txn.SmartContractInstantiateTXN.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Parameters >&
SmartContractInstantiateTXN::parameters() const {
  // @@protoc_insertion_point(field_list:zera_txn.SmartContractInstantiateTXN.parameters)
  return _impl_.parameters_;
}

// -------------------------------------------------------------------

// Validator

// .zera_txn.PublicKey public_key = 1;
inline bool Validator::_internal_has_public_key() const {
  return this != internal_default_instance() && _impl_.public_key_ != nullptr;
}
inline bool Validator::has_public_key() const {
  return _internal_has_public_key();
}
inline void Validator::clear_public_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
}
inline const ::zera_txn::PublicKey& Validator::_internal_public_key() const {
  const ::zera_txn::PublicKey* p = _impl_.public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::PublicKey&>(
      ::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& Validator::public_key() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.public_key)
  return _internal_public_key();
}
inline void Validator::unsafe_arena_set_allocated_public_key(
    ::zera_txn::PublicKey* public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_key_);
  }
  _impl_.public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.Validator.public_key)
}
inline ::zera_txn::PublicKey* Validator::release_public_key() {
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::PublicKey* Validator::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:zera_txn.Validator.public_key)
  
  ::zera_txn::PublicKey* temp = _impl_.public_key_;
  _impl_.public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* Validator::_internal_mutable_public_key() {
  
  if (_impl_.public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArenaForAllocation());
    _impl_.public_key_ = p;
  }
  return _impl_.public_key_;
}
inline ::zera_txn::PublicKey* Validator::mutable_public_key() {
  ::zera_txn::PublicKey* _msg = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:zera_txn.Validator.public_key)
  return _msg;
}
inline void Validator::set_allocated_public_key(::zera_txn::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.public_key_;
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_key);
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Validator.public_key)
}

// string host = 2;
inline void Validator::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& Validator::host() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Validator::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Validator.host)
}
inline std::string* Validator::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:zera_txn.Validator.host)
  return _s;
}
inline const std::string& Validator::_internal_host() const {
  return _impl_.host_.Get();
}
inline void Validator::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* Validator::release_host() {
  // @@protoc_insertion_point(field_release:zera_txn.Validator.host)
  return _impl_.host_.Release();
}
inline void Validator::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Validator.host)
}

// string client_port = 3;
inline void Validator::clear_client_port() {
  _impl_.client_port_.ClearToEmpty();
}
inline const std::string& Validator::client_port() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.client_port)
  return _internal_client_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Validator::set_client_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Validator.client_port)
}
inline std::string* Validator::mutable_client_port() {
  std::string* _s = _internal_mutable_client_port();
  // @@protoc_insertion_point(field_mutable:zera_txn.Validator.client_port)
  return _s;
}
inline const std::string& Validator::_internal_client_port() const {
  return _impl_.client_port_.Get();
}
inline void Validator::_internal_set_client_port(const std::string& value) {
  
  _impl_.client_port_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_client_port() {
  
  return _impl_.client_port_.Mutable(GetArenaForAllocation());
}
inline std::string* Validator::release_client_port() {
  // @@protoc_insertion_point(field_release:zera_txn.Validator.client_port)
  return _impl_.client_port_.Release();
}
inline void Validator::set_allocated_client_port(std::string* client_port) {
  if (client_port != nullptr) {
    
  } else {
    
  }
  _impl_.client_port_.SetAllocated(client_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_port_.IsDefault()) {
    _impl_.client_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Validator.client_port)
}

// string validator_port = 4;
inline void Validator::clear_validator_port() {
  _impl_.validator_port_.ClearToEmpty();
}
inline const std::string& Validator::validator_port() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.validator_port)
  return _internal_validator_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Validator::set_validator_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.validator_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Validator.validator_port)
}
inline std::string* Validator::mutable_validator_port() {
  std::string* _s = _internal_mutable_validator_port();
  // @@protoc_insertion_point(field_mutable:zera_txn.Validator.validator_port)
  return _s;
}
inline const std::string& Validator::_internal_validator_port() const {
  return _impl_.validator_port_.Get();
}
inline void Validator::_internal_set_validator_port(const std::string& value) {
  
  _impl_.validator_port_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_validator_port() {
  
  return _impl_.validator_port_.Mutable(GetArenaForAllocation());
}
inline std::string* Validator::release_validator_port() {
  // @@protoc_insertion_point(field_release:zera_txn.Validator.validator_port)
  return _impl_.validator_port_.Release();
}
inline void Validator::set_allocated_validator_port(std::string* validator_port) {
  if (validator_port != nullptr) {
    
  } else {
    
  }
  _impl_.validator_port_.SetAllocated(validator_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.validator_port_.IsDefault()) {
    _impl_.validator_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Validator.validator_port)
}

// repeated string staked_contract_ids = 5;
inline int Validator::_internal_staked_contract_ids_size() const {
  return _impl_.staked_contract_ids_.size();
}
inline int Validator::staked_contract_ids_size() const {
  return _internal_staked_contract_ids_size();
}
inline void Validator::clear_staked_contract_ids() {
  _impl_.staked_contract_ids_.Clear();
}
inline std::string* Validator::add_staked_contract_ids() {
  std::string* _s = _internal_add_staked_contract_ids();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.Validator.staked_contract_ids)
  return _s;
}
inline const std::string& Validator::_internal_staked_contract_ids(int index) const {
  return _impl_.staked_contract_ids_.Get(index);
}
inline const std::string& Validator::staked_contract_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.staked_contract_ids)
  return _internal_staked_contract_ids(index);
}
inline std::string* Validator::mutable_staked_contract_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.Validator.staked_contract_ids)
  return _impl_.staked_contract_ids_.Mutable(index);
}
inline void Validator::set_staked_contract_ids(int index, const std::string& value) {
  _impl_.staked_contract_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.Validator.staked_contract_ids)
}
inline void Validator::set_staked_contract_ids(int index, std::string&& value) {
  _impl_.staked_contract_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.Validator.staked_contract_ids)
}
inline void Validator::set_staked_contract_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.staked_contract_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.Validator.staked_contract_ids)
}
inline void Validator::set_staked_contract_ids(int index, const char* value, size_t size) {
  _impl_.staked_contract_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.Validator.staked_contract_ids)
}
inline std::string* Validator::_internal_add_staked_contract_ids() {
  return _impl_.staked_contract_ids_.Add();
}
inline void Validator::add_staked_contract_ids(const std::string& value) {
  _impl_.staked_contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.Validator.staked_contract_ids)
}
inline void Validator::add_staked_contract_ids(std::string&& value) {
  _impl_.staked_contract_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.Validator.staked_contract_ids)
}
inline void Validator::add_staked_contract_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.staked_contract_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.Validator.staked_contract_ids)
}
inline void Validator::add_staked_contract_ids(const char* value, size_t size) {
  _impl_.staked_contract_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.Validator.staked_contract_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Validator::staked_contract_ids() const {
  // @@protoc_insertion_point(field_list:zera_txn.Validator.staked_contract_ids)
  return _impl_.staked_contract_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Validator::mutable_staked_contract_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.Validator.staked_contract_ids)
  return &_impl_.staked_contract_ids_;
}

// uint64 benchmark = 6;
inline void Validator::clear_benchmark() {
  _impl_.benchmark_ = uint64_t{0u};
}
inline uint64_t Validator::_internal_benchmark() const {
  return _impl_.benchmark_;
}
inline uint64_t Validator::benchmark() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.benchmark)
  return _internal_benchmark();
}
inline void Validator::_internal_set_benchmark(uint64_t value) {
  
  _impl_.benchmark_ = value;
}
inline void Validator::set_benchmark(uint64_t value) {
  _internal_set_benchmark(value);
  // @@protoc_insertion_point(field_set:zera_txn.Validator.benchmark)
}

// .google.protobuf.Timestamp timestamp = 7;
inline bool Validator::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Validator::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Validator::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Validator::timestamp() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.timestamp)
  return _internal_timestamp();
}
inline void Validator::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.Validator.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Validator::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Validator::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:zera_txn.Validator.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Validator::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Validator::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:zera_txn.Validator.timestamp)
  return _msg;
}
inline void Validator::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Validator.timestamp)
}

// bool lite = 8;
inline void Validator::clear_lite() {
  _impl_.lite_ = false;
}
inline bool Validator::_internal_lite() const {
  return _impl_.lite_;
}
inline bool Validator::lite() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.lite)
  return _internal_lite();
}
inline void Validator::_internal_set_lite(bool value) {
  
  _impl_.lite_ = value;
}
inline void Validator::set_lite(bool value) {
  _internal_set_lite(value);
  // @@protoc_insertion_point(field_set:zera_txn.Validator.lite)
}

// bool online = 9;
inline void Validator::clear_online() {
  _impl_.online_ = false;
}
inline bool Validator::_internal_online() const {
  return _impl_.online_;
}
inline bool Validator::online() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.online)
  return _internal_online();
}
inline void Validator::_internal_set_online(bool value) {
  
  _impl_.online_ = value;
}
inline void Validator::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:zera_txn.Validator.online)
}

// uint32 version = 10;
inline void Validator::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t Validator::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t Validator::version() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.version)
  return _internal_version();
}
inline void Validator::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void Validator::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:zera_txn.Validator.version)
}

// uint64 last_heartbeat = 11;
inline void Validator::clear_last_heartbeat() {
  _impl_.last_heartbeat_ = uint64_t{0u};
}
inline uint64_t Validator::_internal_last_heartbeat() const {
  return _impl_.last_heartbeat_;
}
inline uint64_t Validator::last_heartbeat() const {
  // @@protoc_insertion_point(field_get:zera_txn.Validator.last_heartbeat)
  return _internal_last_heartbeat();
}
inline void Validator::_internal_set_last_heartbeat(uint64_t value) {
  
  _impl_.last_heartbeat_ = value;
}
inline void Validator::set_last_heartbeat(uint64_t value) {
  _internal_set_last_heartbeat(value);
  // @@protoc_insertion_point(field_set:zera_txn.Validator.last_heartbeat)
}

// -------------------------------------------------------------------

// ValidatorRegistration

// .zera_txn.BaseTXN base = 1;
inline bool ValidatorRegistration::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool ValidatorRegistration::has_base() const {
  return _internal_has_base();
}
inline void ValidatorRegistration::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& ValidatorRegistration::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ValidatorRegistration::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.ValidatorRegistration.base)
  return _internal_base();
}
inline void ValidatorRegistration::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ValidatorRegistration.base)
}
inline ::zera_txn::BaseTXN* ValidatorRegistration::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* ValidatorRegistration::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.ValidatorRegistration.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ValidatorRegistration::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* ValidatorRegistration::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.ValidatorRegistration.base)
  return _msg;
}
inline void ValidatorRegistration::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ValidatorRegistration.base)
}

// .zera_txn.Validator validator = 2;
inline bool ValidatorRegistration::_internal_has_validator() const {
  return this != internal_default_instance() && _impl_.validator_ != nullptr;
}
inline bool ValidatorRegistration::has_validator() const {
  return _internal_has_validator();
}
inline void ValidatorRegistration::clear_validator() {
  if (GetArenaForAllocation() == nullptr && _impl_.validator_ != nullptr) {
    delete _impl_.validator_;
  }
  _impl_.validator_ = nullptr;
}
inline const ::zera_txn::Validator& ValidatorRegistration::_internal_validator() const {
  const ::zera_txn::Validator* p = _impl_.validator_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::Validator&>(
      ::zera_txn::_Validator_default_instance_);
}
inline const ::zera_txn::Validator& ValidatorRegistration::validator() const {
  // @@protoc_insertion_point(field_get:zera_txn.ValidatorRegistration.validator)
  return _internal_validator();
}
inline void ValidatorRegistration::unsafe_arena_set_allocated_validator(
    ::zera_txn::Validator* validator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.validator_);
  }
  _impl_.validator_ = validator;
  if (validator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ValidatorRegistration.validator)
}
inline ::zera_txn::Validator* ValidatorRegistration::release_validator() {
  
  ::zera_txn::Validator* temp = _impl_.validator_;
  _impl_.validator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::Validator* ValidatorRegistration::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_release:zera_txn.ValidatorRegistration.validator)
  
  ::zera_txn::Validator* temp = _impl_.validator_;
  _impl_.validator_ = nullptr;
  return temp;
}
inline ::zera_txn::Validator* ValidatorRegistration::_internal_mutable_validator() {
  
  if (_impl_.validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::Validator>(GetArenaForAllocation());
    _impl_.validator_ = p;
  }
  return _impl_.validator_;
}
inline ::zera_txn::Validator* ValidatorRegistration::mutable_validator() {
  ::zera_txn::Validator* _msg = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:zera_txn.ValidatorRegistration.validator)
  return _msg;
}
inline void ValidatorRegistration::set_allocated_validator(::zera_txn::Validator* validator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.validator_;
  }
  if (validator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(validator);
    if (message_arena != submessage_arena) {
      validator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ValidatorRegistration.validator)
}

// bool register = 3;
inline void ValidatorRegistration::clear_register_() {
  _impl_.register__ = false;
}
inline bool ValidatorRegistration::_internal_register_() const {
  return _impl_.register__;
}
inline bool ValidatorRegistration::register_() const {
  // @@protoc_insertion_point(field_get:zera_txn.ValidatorRegistration.register)
  return _internal_register_();
}
inline void ValidatorRegistration::_internal_set_register_(bool value) {
  
  _impl_.register__ = value;
}
inline void ValidatorRegistration::set_register_(bool value) {
  _internal_set_register_(value);
  // @@protoc_insertion_point(field_set:zera_txn.ValidatorRegistration.register)
}

// .zera_txn.PublicKey generated_public_key = 4;
inline bool ValidatorRegistration::_internal_has_generated_public_key() const {
  return this != internal_default_instance() && _impl_.generated_public_key_ != nullptr;
}
inline bool ValidatorRegistration::has_generated_public_key() const {
  return _internal_has_generated_public_key();
}
inline void ValidatorRegistration::clear_generated_public_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.generated_public_key_ != nullptr) {
    delete _impl_.generated_public_key_;
  }
  _impl_.generated_public_key_ = nullptr;
}
inline const ::zera_txn::PublicKey& ValidatorRegistration::_internal_generated_public_key() const {
  const ::zera_txn::PublicKey* p = _impl_.generated_public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::PublicKey&>(
      ::zera_txn::_PublicKey_default_instance_);
}
inline const ::zera_txn::PublicKey& ValidatorRegistration::generated_public_key() const {
  // @@protoc_insertion_point(field_get:zera_txn.ValidatorRegistration.generated_public_key)
  return _internal_generated_public_key();
}
inline void ValidatorRegistration::unsafe_arena_set_allocated_generated_public_key(
    ::zera_txn::PublicKey* generated_public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.generated_public_key_);
  }
  _impl_.generated_public_key_ = generated_public_key;
  if (generated_public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ValidatorRegistration.generated_public_key)
}
inline ::zera_txn::PublicKey* ValidatorRegistration::release_generated_public_key() {
  
  ::zera_txn::PublicKey* temp = _impl_.generated_public_key_;
  _impl_.generated_public_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorRegistration::unsafe_arena_release_generated_public_key() {
  // @@protoc_insertion_point(field_release:zera_txn.ValidatorRegistration.generated_public_key)
  
  ::zera_txn::PublicKey* temp = _impl_.generated_public_key_;
  _impl_.generated_public_key_ = nullptr;
  return temp;
}
inline ::zera_txn::PublicKey* ValidatorRegistration::_internal_mutable_generated_public_key() {
  
  if (_impl_.generated_public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::PublicKey>(GetArenaForAllocation());
    _impl_.generated_public_key_ = p;
  }
  return _impl_.generated_public_key_;
}
inline ::zera_txn::PublicKey* ValidatorRegistration::mutable_generated_public_key() {
  ::zera_txn::PublicKey* _msg = _internal_mutable_generated_public_key();
  // @@protoc_insertion_point(field_mutable:zera_txn.ValidatorRegistration.generated_public_key)
  return _msg;
}
inline void ValidatorRegistration::set_allocated_generated_public_key(::zera_txn::PublicKey* generated_public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.generated_public_key_;
  }
  if (generated_public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(generated_public_key);
    if (message_arena != submessage_arena) {
      generated_public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generated_public_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.generated_public_key_ = generated_public_key;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ValidatorRegistration.generated_public_key)
}

// bytes generated_signature = 5;
inline void ValidatorRegistration::clear_generated_signature() {
  _impl_.generated_signature_.ClearToEmpty();
}
inline const std::string& ValidatorRegistration::generated_signature() const {
  // @@protoc_insertion_point(field_get:zera_txn.ValidatorRegistration.generated_signature)
  return _internal_generated_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidatorRegistration::set_generated_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.generated_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ValidatorRegistration.generated_signature)
}
inline std::string* ValidatorRegistration::mutable_generated_signature() {
  std::string* _s = _internal_mutable_generated_signature();
  // @@protoc_insertion_point(field_mutable:zera_txn.ValidatorRegistration.generated_signature)
  return _s;
}
inline const std::string& ValidatorRegistration::_internal_generated_signature() const {
  return _impl_.generated_signature_.Get();
}
inline void ValidatorRegistration::_internal_set_generated_signature(const std::string& value) {
  
  _impl_.generated_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidatorRegistration::_internal_mutable_generated_signature() {
  
  return _impl_.generated_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidatorRegistration::release_generated_signature() {
  // @@protoc_insertion_point(field_release:zera_txn.ValidatorRegistration.generated_signature)
  return _impl_.generated_signature_.Release();
}
inline void ValidatorRegistration::set_allocated_generated_signature(std::string* generated_signature) {
  if (generated_signature != nullptr) {
    
  } else {
    
  }
  _impl_.generated_signature_.SetAllocated(generated_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.generated_signature_.IsDefault()) {
    _impl_.generated_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ValidatorRegistration.generated_signature)
}

// -------------------------------------------------------------------

// ValidatorHeartbeat

// .zera_txn.BaseTXN base = 1;
inline bool ValidatorHeartbeat::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool ValidatorHeartbeat::has_base() const {
  return _internal_has_base();
}
inline void ValidatorHeartbeat::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& ValidatorHeartbeat::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ValidatorHeartbeat::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.ValidatorHeartbeat.base)
  return _internal_base();
}
inline void ValidatorHeartbeat::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ValidatorHeartbeat.base)
}
inline ::zera_txn::BaseTXN* ValidatorHeartbeat::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* ValidatorHeartbeat::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.ValidatorHeartbeat.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ValidatorHeartbeat::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* ValidatorHeartbeat::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.ValidatorHeartbeat.base)
  return _msg;
}
inline void ValidatorHeartbeat::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ValidatorHeartbeat.base)
}

// bool online = 2;
inline void ValidatorHeartbeat::clear_online() {
  _impl_.online_ = false;
}
inline bool ValidatorHeartbeat::_internal_online() const {
  return _impl_.online_;
}
inline bool ValidatorHeartbeat::online() const {
  // @@protoc_insertion_point(field_get:zera_txn.ValidatorHeartbeat.online)
  return _internal_online();
}
inline void ValidatorHeartbeat::_internal_set_online(bool value) {
  
  _impl_.online_ = value;
}
inline void ValidatorHeartbeat::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:zera_txn.ValidatorHeartbeat.online)
}

// uint32 version = 3;
inline void ValidatorHeartbeat::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t ValidatorHeartbeat::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t ValidatorHeartbeat::version() const {
  // @@protoc_insertion_point(field_get:zera_txn.ValidatorHeartbeat.version)
  return _internal_version();
}
inline void ValidatorHeartbeat::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void ValidatorHeartbeat::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:zera_txn.ValidatorHeartbeat.version)
}

// -------------------------------------------------------------------

// SmartContractParameter

// uint32 index = 1;
inline void SmartContractParameter::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t SmartContractParameter::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t SmartContractParameter::index() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractParameter.index)
  return _internal_index();
}
inline void SmartContractParameter::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void SmartContractParameter::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractParameter.index)
}

// .zera_txn.VARIABLE_TYPE type = 2;
inline void SmartContractParameter::clear_type() {
  _impl_.type_ = 0;
}
inline ::zera_txn::VARIABLE_TYPE SmartContractParameter::_internal_type() const {
  return static_cast< ::zera_txn::VARIABLE_TYPE >(_impl_.type_);
}
inline ::zera_txn::VARIABLE_TYPE SmartContractParameter::type() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractParameter.type)
  return _internal_type();
}
inline void SmartContractParameter::_internal_set_type(::zera_txn::VARIABLE_TYPE value) {
  
  _impl_.type_ = value;
}
inline void SmartContractParameter::set_type(::zera_txn::VARIABLE_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractParameter.type)
}

// optional string value = 3;
inline bool SmartContractParameter::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SmartContractParameter::has_value() const {
  return _internal_has_value();
}
inline void SmartContractParameter::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SmartContractParameter::value() const {
  // @@protoc_insertion_point(field_get:zera_txn.SmartContractParameter.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractParameter::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.SmartContractParameter.value)
}
inline std::string* SmartContractParameter::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:zera_txn.SmartContractParameter.value)
  return _s;
}
inline const std::string& SmartContractParameter::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SmartContractParameter::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractParameter::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractParameter::release_value() {
  // @@protoc_insertion_point(field_release:zera_txn.SmartContractParameter.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SmartContractParameter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.SmartContractParameter.value)
}

// -------------------------------------------------------------------

// Votes

// repeated .zera_txn.VotePair votes = 1;
inline int Votes::_internal_votes_size() const {
  return _impl_.votes_.size();
}
inline int Votes::votes_size() const {
  return _internal_votes_size();
}
inline void Votes::clear_votes() {
  _impl_.votes_.Clear();
}
inline ::zera_txn::VotePair* Votes::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.Votes.votes)
  return _impl_.votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::VotePair >*
Votes::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.Votes.votes)
  return &_impl_.votes_;
}
inline const ::zera_txn::VotePair& Votes::_internal_votes(int index) const {
  return _impl_.votes_.Get(index);
}
inline const ::zera_txn::VotePair& Votes::votes(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.Votes.votes)
  return _internal_votes(index);
}
inline ::zera_txn::VotePair* Votes::_internal_add_votes() {
  return _impl_.votes_.Add();
}
inline ::zera_txn::VotePair* Votes::add_votes() {
  ::zera_txn::VotePair* _add = _internal_add_votes();
  // @@protoc_insertion_point(field_add:zera_txn.Votes.votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::VotePair >&
Votes::votes() const {
  // @@protoc_insertion_point(field_list:zera_txn.Votes.votes)
  return _impl_.votes_;
}

// -------------------------------------------------------------------

// VotePair

// string contract_id = 1;
inline void VotePair::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& VotePair::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.VotePair.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VotePair::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.VotePair.contract_id)
}
inline std::string* VotePair::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.VotePair.contract_id)
  return _s;
}
inline const std::string& VotePair::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void VotePair::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VotePair::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* VotePair::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.VotePair.contract_id)
  return _impl_.contract_id_.Release();
}
inline void VotePair::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.VotePair.contract_id)
}

// string amount = 2;
inline void VotePair::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& VotePair::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.VotePair.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VotePair::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.VotePair.amount)
}
inline std::string* VotePair::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.VotePair.amount)
  return _s;
}
inline const std::string& VotePair::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void VotePair::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* VotePair::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* VotePair::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.VotePair.amount)
  return _impl_.amount_.Release();
}
inline void VotePair::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.VotePair.amount)
}

// -------------------------------------------------------------------

// RequiredVersion

// .zera_txn.BaseTXN base = 1;
inline bool RequiredVersion::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool RequiredVersion::has_base() const {
  return _internal_has_base();
}
inline void RequiredVersion::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& RequiredVersion::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& RequiredVersion::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.RequiredVersion.base)
  return _internal_base();
}
inline void RequiredVersion::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.RequiredVersion.base)
}
inline ::zera_txn::BaseTXN* RequiredVersion::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* RequiredVersion::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.RequiredVersion.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* RequiredVersion::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* RequiredVersion::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.RequiredVersion.base)
  return _msg;
}
inline void RequiredVersion::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.RequiredVersion.base)
}

// repeated uint32 version = 2;
inline int RequiredVersion::_internal_version_size() const {
  return _impl_.version_.size();
}
inline int RequiredVersion::version_size() const {
  return _internal_version_size();
}
inline void RequiredVersion::clear_version() {
  _impl_.version_.Clear();
}
inline uint32_t RequiredVersion::_internal_version(int index) const {
  return _impl_.version_.Get(index);
}
inline uint32_t RequiredVersion::version(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.RequiredVersion.version)
  return _internal_version(index);
}
inline void RequiredVersion::set_version(int index, uint32_t value) {
  _impl_.version_.Set(index, value);
  // @@protoc_insertion_point(field_set:zera_txn.RequiredVersion.version)
}
inline void RequiredVersion::_internal_add_version(uint32_t value) {
  _impl_.version_.Add(value);
}
inline void RequiredVersion::add_version(uint32_t value) {
  _internal_add_version(value);
  // @@protoc_insertion_point(field_add:zera_txn.RequiredVersion.version)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
RequiredVersion::_internal_version() const {
  return _impl_.version_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
RequiredVersion::version() const {
  // @@protoc_insertion_point(field_list:zera_txn.RequiredVersion.version)
  return _internal_version();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
RequiredVersion::_internal_mutable_version() {
  return &_impl_.version_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
RequiredVersion::mutable_version() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.RequiredVersion.version)
  return _internal_mutable_version();
}

// -------------------------------------------------------------------

// ProposalResult

// .zera_txn.BaseTXN base = 1;
inline bool ProposalResult::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool ProposalResult::has_base() const {
  return _internal_has_base();
}
inline void ProposalResult::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& ProposalResult::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& ProposalResult::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.base)
  return _internal_base();
}
inline void ProposalResult::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ProposalResult.base)
}
inline ::zera_txn::BaseTXN* ProposalResult::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* ProposalResult::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.ProposalResult.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* ProposalResult::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* ProposalResult::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.base)
  return _msg;
}
inline void ProposalResult::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ProposalResult.base)
}

// string contract_id = 2;
inline void ProposalResult::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ProposalResult::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalResult::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.contract_id)
}
inline std::string* ProposalResult::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.contract_id)
  return _s;
}
inline const std::string& ProposalResult::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void ProposalResult::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalResult::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalResult::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ProposalResult.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ProposalResult::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ProposalResult.contract_id)
}

// bytes proposal_id = 3;
inline void ProposalResult::clear_proposal_id() {
  _impl_.proposal_id_.ClearToEmpty();
}
inline const std::string& ProposalResult::proposal_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.proposal_id)
  return _internal_proposal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalResult::set_proposal_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proposal_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.proposal_id)
}
inline std::string* ProposalResult::mutable_proposal_id() {
  std::string* _s = _internal_mutable_proposal_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.proposal_id)
  return _s;
}
inline const std::string& ProposalResult::_internal_proposal_id() const {
  return _impl_.proposal_id_.Get();
}
inline void ProposalResult::_internal_set_proposal_id(const std::string& value) {
  
  _impl_.proposal_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalResult::_internal_mutable_proposal_id() {
  
  return _impl_.proposal_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalResult::release_proposal_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ProposalResult.proposal_id)
  return _impl_.proposal_id_.Release();
}
inline void ProposalResult::set_allocated_proposal_id(std::string* proposal_id) {
  if (proposal_id != nullptr) {
    
  } else {
    
  }
  _impl_.proposal_id_.SetAllocated(proposal_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proposal_id_.IsDefault()) {
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ProposalResult.proposal_id)
}

// optional string support_cur_equiv = 4;
inline bool ProposalResult::_internal_has_support_cur_equiv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProposalResult::has_support_cur_equiv() const {
  return _internal_has_support_cur_equiv();
}
inline void ProposalResult::clear_support_cur_equiv() {
  _impl_.support_cur_equiv_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProposalResult::support_cur_equiv() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.support_cur_equiv)
  return _internal_support_cur_equiv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalResult::set_support_cur_equiv(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.support_cur_equiv_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.support_cur_equiv)
}
inline std::string* ProposalResult::mutable_support_cur_equiv() {
  std::string* _s = _internal_mutable_support_cur_equiv();
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.support_cur_equiv)
  return _s;
}
inline const std::string& ProposalResult::_internal_support_cur_equiv() const {
  return _impl_.support_cur_equiv_.Get();
}
inline void ProposalResult::_internal_set_support_cur_equiv(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.support_cur_equiv_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalResult::_internal_mutable_support_cur_equiv() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.support_cur_equiv_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalResult::release_support_cur_equiv() {
  // @@protoc_insertion_point(field_release:zera_txn.ProposalResult.support_cur_equiv)
  if (!_internal_has_support_cur_equiv()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.support_cur_equiv_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.support_cur_equiv_.IsDefault()) {
    _impl_.support_cur_equiv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProposalResult::set_allocated_support_cur_equiv(std::string* support_cur_equiv) {
  if (support_cur_equiv != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.support_cur_equiv_.SetAllocated(support_cur_equiv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.support_cur_equiv_.IsDefault()) {
    _impl_.support_cur_equiv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ProposalResult.support_cur_equiv)
}

// optional string against_cur_equiv = 5;
inline bool ProposalResult::_internal_has_against_cur_equiv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProposalResult::has_against_cur_equiv() const {
  return _internal_has_against_cur_equiv();
}
inline void ProposalResult::clear_against_cur_equiv() {
  _impl_.against_cur_equiv_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProposalResult::against_cur_equiv() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.against_cur_equiv)
  return _internal_against_cur_equiv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalResult::set_against_cur_equiv(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.against_cur_equiv_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.against_cur_equiv)
}
inline std::string* ProposalResult::mutable_against_cur_equiv() {
  std::string* _s = _internal_mutable_against_cur_equiv();
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.against_cur_equiv)
  return _s;
}
inline const std::string& ProposalResult::_internal_against_cur_equiv() const {
  return _impl_.against_cur_equiv_.Get();
}
inline void ProposalResult::_internal_set_against_cur_equiv(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.against_cur_equiv_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalResult::_internal_mutable_against_cur_equiv() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.against_cur_equiv_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalResult::release_against_cur_equiv() {
  // @@protoc_insertion_point(field_release:zera_txn.ProposalResult.against_cur_equiv)
  if (!_internal_has_against_cur_equiv()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.against_cur_equiv_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.against_cur_equiv_.IsDefault()) {
    _impl_.against_cur_equiv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProposalResult::set_allocated_against_cur_equiv(std::string* against_cur_equiv) {
  if (against_cur_equiv != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.against_cur_equiv_.SetAllocated(against_cur_equiv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.against_cur_equiv_.IsDefault()) {
    _impl_.against_cur_equiv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ProposalResult.against_cur_equiv)
}

// repeated string option_cur_equiv = 6;
inline int ProposalResult::_internal_option_cur_equiv_size() const {
  return _impl_.option_cur_equiv_.size();
}
inline int ProposalResult::option_cur_equiv_size() const {
  return _internal_option_cur_equiv_size();
}
inline void ProposalResult::clear_option_cur_equiv() {
  _impl_.option_cur_equiv_.Clear();
}
inline std::string* ProposalResult::add_option_cur_equiv() {
  std::string* _s = _internal_add_option_cur_equiv();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.ProposalResult.option_cur_equiv)
  return _s;
}
inline const std::string& ProposalResult::_internal_option_cur_equiv(int index) const {
  return _impl_.option_cur_equiv_.Get(index);
}
inline const std::string& ProposalResult::option_cur_equiv(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.option_cur_equiv)
  return _internal_option_cur_equiv(index);
}
inline std::string* ProposalResult::mutable_option_cur_equiv(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.option_cur_equiv)
  return _impl_.option_cur_equiv_.Mutable(index);
}
inline void ProposalResult::set_option_cur_equiv(int index, const std::string& value) {
  _impl_.option_cur_equiv_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.option_cur_equiv)
}
inline void ProposalResult::set_option_cur_equiv(int index, std::string&& value) {
  _impl_.option_cur_equiv_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.option_cur_equiv)
}
inline void ProposalResult::set_option_cur_equiv(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.option_cur_equiv_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.ProposalResult.option_cur_equiv)
}
inline void ProposalResult::set_option_cur_equiv(int index, const char* value, size_t size) {
  _impl_.option_cur_equiv_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.ProposalResult.option_cur_equiv)
}
inline std::string* ProposalResult::_internal_add_option_cur_equiv() {
  return _impl_.option_cur_equiv_.Add();
}
inline void ProposalResult::add_option_cur_equiv(const std::string& value) {
  _impl_.option_cur_equiv_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.ProposalResult.option_cur_equiv)
}
inline void ProposalResult::add_option_cur_equiv(std::string&& value) {
  _impl_.option_cur_equiv_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.ProposalResult.option_cur_equiv)
}
inline void ProposalResult::add_option_cur_equiv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.option_cur_equiv_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.ProposalResult.option_cur_equiv)
}
inline void ProposalResult::add_option_cur_equiv(const char* value, size_t size) {
  _impl_.option_cur_equiv_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.ProposalResult.option_cur_equiv)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalResult::option_cur_equiv() const {
  // @@protoc_insertion_point(field_list:zera_txn.ProposalResult.option_cur_equiv)
  return _impl_.option_cur_equiv_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalResult::mutable_option_cur_equiv() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ProposalResult.option_cur_equiv)
  return &_impl_.option_cur_equiv_;
}

// optional .zera_txn.Votes support_votes = 7;
inline bool ProposalResult::_internal_has_support_votes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.support_votes_ != nullptr);
  return value;
}
inline bool ProposalResult::has_support_votes() const {
  return _internal_has_support_votes();
}
inline void ProposalResult::clear_support_votes() {
  if (_impl_.support_votes_ != nullptr) _impl_.support_votes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::zera_txn::Votes& ProposalResult::_internal_support_votes() const {
  const ::zera_txn::Votes* p = _impl_.support_votes_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::Votes&>(
      ::zera_txn::_Votes_default_instance_);
}
inline const ::zera_txn::Votes& ProposalResult::support_votes() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.support_votes)
  return _internal_support_votes();
}
inline void ProposalResult::unsafe_arena_set_allocated_support_votes(
    ::zera_txn::Votes* support_votes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.support_votes_);
  }
  _impl_.support_votes_ = support_votes;
  if (support_votes) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ProposalResult.support_votes)
}
inline ::zera_txn::Votes* ProposalResult::release_support_votes() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::zera_txn::Votes* temp = _impl_.support_votes_;
  _impl_.support_votes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::Votes* ProposalResult::unsafe_arena_release_support_votes() {
  // @@protoc_insertion_point(field_release:zera_txn.ProposalResult.support_votes)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::zera_txn::Votes* temp = _impl_.support_votes_;
  _impl_.support_votes_ = nullptr;
  return temp;
}
inline ::zera_txn::Votes* ProposalResult::_internal_mutable_support_votes() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.support_votes_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::Votes>(GetArenaForAllocation());
    _impl_.support_votes_ = p;
  }
  return _impl_.support_votes_;
}
inline ::zera_txn::Votes* ProposalResult::mutable_support_votes() {
  ::zera_txn::Votes* _msg = _internal_mutable_support_votes();
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.support_votes)
  return _msg;
}
inline void ProposalResult::set_allocated_support_votes(::zera_txn::Votes* support_votes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.support_votes_;
  }
  if (support_votes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(support_votes);
    if (message_arena != submessage_arena) {
      support_votes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, support_votes, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.support_votes_ = support_votes;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ProposalResult.support_votes)
}

// optional .zera_txn.Votes against_votes = 8;
inline bool ProposalResult::_internal_has_against_votes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.against_votes_ != nullptr);
  return value;
}
inline bool ProposalResult::has_against_votes() const {
  return _internal_has_against_votes();
}
inline void ProposalResult::clear_against_votes() {
  if (_impl_.against_votes_ != nullptr) _impl_.against_votes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::zera_txn::Votes& ProposalResult::_internal_against_votes() const {
  const ::zera_txn::Votes* p = _impl_.against_votes_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::Votes&>(
      ::zera_txn::_Votes_default_instance_);
}
inline const ::zera_txn::Votes& ProposalResult::against_votes() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.against_votes)
  return _internal_against_votes();
}
inline void ProposalResult::unsafe_arena_set_allocated_against_votes(
    ::zera_txn::Votes* against_votes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.against_votes_);
  }
  _impl_.against_votes_ = against_votes;
  if (against_votes) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.ProposalResult.against_votes)
}
inline ::zera_txn::Votes* ProposalResult::release_against_votes() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::zera_txn::Votes* temp = _impl_.against_votes_;
  _impl_.against_votes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::Votes* ProposalResult::unsafe_arena_release_against_votes() {
  // @@protoc_insertion_point(field_release:zera_txn.ProposalResult.against_votes)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::zera_txn::Votes* temp = _impl_.against_votes_;
  _impl_.against_votes_ = nullptr;
  return temp;
}
inline ::zera_txn::Votes* ProposalResult::_internal_mutable_against_votes() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.against_votes_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::Votes>(GetArenaForAllocation());
    _impl_.against_votes_ = p;
  }
  return _impl_.against_votes_;
}
inline ::zera_txn::Votes* ProposalResult::mutable_against_votes() {
  ::zera_txn::Votes* _msg = _internal_mutable_against_votes();
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.against_votes)
  return _msg;
}
inline void ProposalResult::set_allocated_against_votes(::zera_txn::Votes* against_votes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.against_votes_;
  }
  if (against_votes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(against_votes);
    if (message_arena != submessage_arena) {
      against_votes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, against_votes, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.against_votes_ = against_votes;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ProposalResult.against_votes)
}

// repeated .zera_txn.Votes option_votes = 9;
inline int ProposalResult::_internal_option_votes_size() const {
  return _impl_.option_votes_.size();
}
inline int ProposalResult::option_votes_size() const {
  return _internal_option_votes_size();
}
inline void ProposalResult::clear_option_votes() {
  _impl_.option_votes_.Clear();
}
inline ::zera_txn::Votes* ProposalResult::mutable_option_votes(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalResult.option_votes)
  return _impl_.option_votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Votes >*
ProposalResult::mutable_option_votes() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ProposalResult.option_votes)
  return &_impl_.option_votes_;
}
inline const ::zera_txn::Votes& ProposalResult::_internal_option_votes(int index) const {
  return _impl_.option_votes_.Get(index);
}
inline const ::zera_txn::Votes& ProposalResult::option_votes(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.option_votes)
  return _internal_option_votes(index);
}
inline ::zera_txn::Votes* ProposalResult::_internal_add_option_votes() {
  return _impl_.option_votes_.Add();
}
inline ::zera_txn::Votes* ProposalResult::add_option_votes() {
  ::zera_txn::Votes* _add = _internal_add_option_votes();
  // @@protoc_insertion_point(field_add:zera_txn.ProposalResult.option_votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Votes >&
ProposalResult::option_votes() const {
  // @@protoc_insertion_point(field_list:zera_txn.ProposalResult.option_votes)
  return _impl_.option_votes_;
}

// bool passed = 10;
inline void ProposalResult::clear_passed() {
  _impl_.passed_ = false;
}
inline bool ProposalResult::_internal_passed() const {
  return _impl_.passed_;
}
inline bool ProposalResult::passed() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.passed)
  return _internal_passed();
}
inline void ProposalResult::_internal_set_passed(bool value) {
  
  _impl_.passed_ = value;
}
inline void ProposalResult::set_passed(bool value) {
  _internal_set_passed(value);
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.passed)
}

// bool final_stage = 11;
inline void ProposalResult::clear_final_stage() {
  _impl_.final_stage_ = false;
}
inline bool ProposalResult::_internal_final_stage() const {
  return _impl_.final_stage_;
}
inline bool ProposalResult::final_stage() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.final_stage)
  return _internal_final_stage();
}
inline void ProposalResult::_internal_set_final_stage(bool value) {
  
  _impl_.final_stage_ = value;
}
inline void ProposalResult::set_final_stage(bool value) {
  _internal_set_final_stage(value);
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.final_stage)
}

// uint32 stage = 12;
inline void ProposalResult::clear_stage() {
  _impl_.stage_ = 0u;
}
inline uint32_t ProposalResult::_internal_stage() const {
  return _impl_.stage_;
}
inline uint32_t ProposalResult::stage() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.stage)
  return _internal_stage();
}
inline void ProposalResult::_internal_set_stage(uint32_t value) {
  
  _impl_.stage_ = value;
}
inline void ProposalResult::set_stage(uint32_t value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.stage)
}

// bool fast_quorum = 13;
inline void ProposalResult::clear_fast_quorum() {
  _impl_.fast_quorum_ = false;
}
inline bool ProposalResult::_internal_fast_quorum() const {
  return _impl_.fast_quorum_;
}
inline bool ProposalResult::fast_quorum() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.fast_quorum)
  return _internal_fast_quorum();
}
inline void ProposalResult::_internal_set_fast_quorum(bool value) {
  
  _impl_.fast_quorum_ = value;
}
inline void ProposalResult::set_fast_quorum(bool value) {
  _internal_set_fast_quorum(value);
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.fast_quorum)
}

// optional bool proposal_cut = 14;
inline bool ProposalResult::_internal_has_proposal_cut() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ProposalResult::has_proposal_cut() const {
  return _internal_has_proposal_cut();
}
inline void ProposalResult::clear_proposal_cut() {
  _impl_.proposal_cut_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ProposalResult::_internal_proposal_cut() const {
  return _impl_.proposal_cut_;
}
inline bool ProposalResult::proposal_cut() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalResult.proposal_cut)
  return _internal_proposal_cut();
}
inline void ProposalResult::_internal_set_proposal_cut(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.proposal_cut_ = value;
}
inline void ProposalResult::set_proposal_cut(bool value) {
  _internal_set_proposal_cut(value);
  // @@protoc_insertion_point(field_set:zera_txn.ProposalResult.proposal_cut)
}

// -------------------------------------------------------------------

// AllowanceTXN

// .zera_txn.BaseTXN base = 1;
inline bool AllowanceTXN::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool AllowanceTXN::has_base() const {
  return _internal_has_base();
}
inline void AllowanceTXN::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::zera_txn::BaseTXN& AllowanceTXN::_internal_base() const {
  const ::zera_txn::BaseTXN* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::BaseTXN&>(
      ::zera_txn::_BaseTXN_default_instance_);
}
inline const ::zera_txn::BaseTXN& AllowanceTXN::base() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.base)
  return _internal_base();
}
inline void AllowanceTXN::unsafe_arena_set_allocated_base(
    ::zera_txn::BaseTXN* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.AllowanceTXN.base)
}
inline ::zera_txn::BaseTXN* AllowanceTXN::release_base() {
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::BaseTXN* AllowanceTXN::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:zera_txn.AllowanceTXN.base)
  
  ::zera_txn::BaseTXN* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::zera_txn::BaseTXN* AllowanceTXN::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::BaseTXN>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::zera_txn::BaseTXN* AllowanceTXN::mutable_base() {
  ::zera_txn::BaseTXN* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:zera_txn.AllowanceTXN.base)
  return _msg;
}
inline void AllowanceTXN::set_allocated_base(::zera_txn::BaseTXN* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.AllowanceTXN.base)
}

// string contract_id = 2;
inline void AllowanceTXN::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& AllowanceTXN::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllowanceTXN::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.AllowanceTXN.contract_id)
}
inline std::string* AllowanceTXN::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.AllowanceTXN.contract_id)
  return _s;
}
inline const std::string& AllowanceTXN::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void AllowanceTXN::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AllowanceTXN::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AllowanceTXN::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.AllowanceTXN.contract_id)
  return _impl_.contract_id_.Release();
}
inline void AllowanceTXN::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.AllowanceTXN.contract_id)
}

// bytes wallet_address = 3;
inline void AllowanceTXN::clear_wallet_address() {
  _impl_.wallet_address_.ClearToEmpty();
}
inline const std::string& AllowanceTXN::wallet_address() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.wallet_address)
  return _internal_wallet_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllowanceTXN::set_wallet_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wallet_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.AllowanceTXN.wallet_address)
}
inline std::string* AllowanceTXN::mutable_wallet_address() {
  std::string* _s = _internal_mutable_wallet_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.AllowanceTXN.wallet_address)
  return _s;
}
inline const std::string& AllowanceTXN::_internal_wallet_address() const {
  return _impl_.wallet_address_.Get();
}
inline void AllowanceTXN::_internal_set_wallet_address(const std::string& value) {
  
  _impl_.wallet_address_.Set(value, GetArenaForAllocation());
}
inline std::string* AllowanceTXN::_internal_mutable_wallet_address() {
  
  return _impl_.wallet_address_.Mutable(GetArenaForAllocation());
}
inline std::string* AllowanceTXN::release_wallet_address() {
  // @@protoc_insertion_point(field_release:zera_txn.AllowanceTXN.wallet_address)
  return _impl_.wallet_address_.Release();
}
inline void AllowanceTXN::set_allocated_wallet_address(std::string* wallet_address) {
  if (wallet_address != nullptr) {
    
  } else {
    
  }
  _impl_.wallet_address_.SetAllocated(wallet_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wallet_address_.IsDefault()) {
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.AllowanceTXN.wallet_address)
}

// optional string allowed_currency_equivalent = 4;
inline bool AllowanceTXN::_internal_has_allowed_currency_equivalent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllowanceTXN::has_allowed_currency_equivalent() const {
  return _internal_has_allowed_currency_equivalent();
}
inline void AllowanceTXN::clear_allowed_currency_equivalent() {
  _impl_.allowed_currency_equivalent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllowanceTXN::allowed_currency_equivalent() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.allowed_currency_equivalent)
  return _internal_allowed_currency_equivalent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllowanceTXN::set_allowed_currency_equivalent(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.allowed_currency_equivalent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.AllowanceTXN.allowed_currency_equivalent)
}
inline std::string* AllowanceTXN::mutable_allowed_currency_equivalent() {
  std::string* _s = _internal_mutable_allowed_currency_equivalent();
  // @@protoc_insertion_point(field_mutable:zera_txn.AllowanceTXN.allowed_currency_equivalent)
  return _s;
}
inline const std::string& AllowanceTXN::_internal_allowed_currency_equivalent() const {
  return _impl_.allowed_currency_equivalent_.Get();
}
inline void AllowanceTXN::_internal_set_allowed_currency_equivalent(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allowed_currency_equivalent_.Set(value, GetArenaForAllocation());
}
inline std::string* AllowanceTXN::_internal_mutable_allowed_currency_equivalent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.allowed_currency_equivalent_.Mutable(GetArenaForAllocation());
}
inline std::string* AllowanceTXN::release_allowed_currency_equivalent() {
  // @@protoc_insertion_point(field_release:zera_txn.AllowanceTXN.allowed_currency_equivalent)
  if (!_internal_has_allowed_currency_equivalent()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.allowed_currency_equivalent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.allowed_currency_equivalent_.IsDefault()) {
    _impl_.allowed_currency_equivalent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AllowanceTXN::set_allocated_allowed_currency_equivalent(std::string* allowed_currency_equivalent) {
  if (allowed_currency_equivalent != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.allowed_currency_equivalent_.SetAllocated(allowed_currency_equivalent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.allowed_currency_equivalent_.IsDefault()) {
    _impl_.allowed_currency_equivalent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.AllowanceTXN.allowed_currency_equivalent)
}

// optional string allowed_amount = 5;
inline bool AllowanceTXN::_internal_has_allowed_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AllowanceTXN::has_allowed_amount() const {
  return _internal_has_allowed_amount();
}
inline void AllowanceTXN::clear_allowed_amount() {
  _impl_.allowed_amount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AllowanceTXN::allowed_amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.allowed_amount)
  return _internal_allowed_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllowanceTXN::set_allowed_amount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.allowed_amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.AllowanceTXN.allowed_amount)
}
inline std::string* AllowanceTXN::mutable_allowed_amount() {
  std::string* _s = _internal_mutable_allowed_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.AllowanceTXN.allowed_amount)
  return _s;
}
inline const std::string& AllowanceTXN::_internal_allowed_amount() const {
  return _impl_.allowed_amount_.Get();
}
inline void AllowanceTXN::_internal_set_allowed_amount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.allowed_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* AllowanceTXN::_internal_mutable_allowed_amount() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.allowed_amount_.Mutable(GetArenaForAllocation());
}
inline std::string* AllowanceTXN::release_allowed_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.AllowanceTXN.allowed_amount)
  if (!_internal_has_allowed_amount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.allowed_amount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.allowed_amount_.IsDefault()) {
    _impl_.allowed_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AllowanceTXN::set_allocated_allowed_amount(std::string* allowed_amount) {
  if (allowed_amount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.allowed_amount_.SetAllocated(allowed_amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.allowed_amount_.IsDefault()) {
    _impl_.allowed_amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.AllowanceTXN.allowed_amount)
}

// optional uint32 period_months = 6;
inline bool AllowanceTXN::_internal_has_period_months() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AllowanceTXN::has_period_months() const {
  return _internal_has_period_months();
}
inline void AllowanceTXN::clear_period_months() {
  _impl_.period_months_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AllowanceTXN::_internal_period_months() const {
  return _impl_.period_months_;
}
inline uint32_t AllowanceTXN::period_months() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.period_months)
  return _internal_period_months();
}
inline void AllowanceTXN::_internal_set_period_months(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.period_months_ = value;
}
inline void AllowanceTXN::set_period_months(uint32_t value) {
  _internal_set_period_months(value);
  // @@protoc_insertion_point(field_set:zera_txn.AllowanceTXN.period_months)
}

// optional uint32 period_seconds = 7;
inline bool AllowanceTXN::_internal_has_period_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AllowanceTXN::has_period_seconds() const {
  return _internal_has_period_seconds();
}
inline void AllowanceTXN::clear_period_seconds() {
  _impl_.period_seconds_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t AllowanceTXN::_internal_period_seconds() const {
  return _impl_.period_seconds_;
}
inline uint32_t AllowanceTXN::period_seconds() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.period_seconds)
  return _internal_period_seconds();
}
inline void AllowanceTXN::_internal_set_period_seconds(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.period_seconds_ = value;
}
inline void AllowanceTXN::set_period_seconds(uint32_t value) {
  _internal_set_period_seconds(value);
  // @@protoc_insertion_point(field_set:zera_txn.AllowanceTXN.period_seconds)
}

// .google.protobuf.Timestamp start_time = 9;
inline bool AllowanceTXN::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool AllowanceTXN::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AllowanceTXN::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AllowanceTXN::start_time() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.start_time)
  return _internal_start_time();
}
inline void AllowanceTXN::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.AllowanceTXN.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceTXN::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceTXN::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:zera_txn.AllowanceTXN.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceTXN::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AllowanceTXN::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:zera_txn.AllowanceTXN.start_time)
  return _msg;
}
inline void AllowanceTXN::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.AllowanceTXN.start_time)
}

// bool authorize = 10;
inline void AllowanceTXN::clear_authorize() {
  _impl_.authorize_ = false;
}
inline bool AllowanceTXN::_internal_authorize() const {
  return _impl_.authorize_;
}
inline bool AllowanceTXN::authorize() const {
  // @@protoc_insertion_point(field_get:zera_txn.AllowanceTXN.authorize)
  return _internal_authorize();
}
inline void AllowanceTXN::_internal_set_authorize(bool value) {
  
  _impl_.authorize_ = value;
}
inline void AllowanceTXN::set_authorize(bool value) {
  _internal_set_authorize(value);
  // @@protoc_insertion_point(field_set:zera_txn.AllowanceTXN.authorize)
}

// -------------------------------------------------------------------

// TXNS

// repeated .zera_txn.CoinTXN coin_txns = 1;
inline int TXNS::_internal_coin_txns_size() const {
  return _impl_.coin_txns_.size();
}
inline int TXNS::coin_txns_size() const {
  return _internal_coin_txns_size();
}
inline void TXNS::clear_coin_txns() {
  _impl_.coin_txns_.Clear();
}
inline ::zera_txn::CoinTXN* TXNS::mutable_coin_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.coin_txns)
  return _impl_.coin_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CoinTXN >*
TXNS::mutable_coin_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.coin_txns)
  return &_impl_.coin_txns_;
}
inline const ::zera_txn::CoinTXN& TXNS::_internal_coin_txns(int index) const {
  return _impl_.coin_txns_.Get(index);
}
inline const ::zera_txn::CoinTXN& TXNS::coin_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.coin_txns)
  return _internal_coin_txns(index);
}
inline ::zera_txn::CoinTXN* TXNS::_internal_add_coin_txns() {
  return _impl_.coin_txns_.Add();
}
inline ::zera_txn::CoinTXN* TXNS::add_coin_txns() {
  ::zera_txn::CoinTXN* _add = _internal_add_coin_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.coin_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::CoinTXN >&
TXNS::coin_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.coin_txns)
  return _impl_.coin_txns_;
}

// repeated .zera_txn.MintTXN mint_txns = 2;
inline int TXNS::_internal_mint_txns_size() const {
  return _impl_.mint_txns_.size();
}
inline int TXNS::mint_txns_size() const {
  return _internal_mint_txns_size();
}
inline void TXNS::clear_mint_txns() {
  _impl_.mint_txns_.Clear();
}
inline ::zera_txn::MintTXN* TXNS::mutable_mint_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.mint_txns)
  return _impl_.mint_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MintTXN >*
TXNS::mutable_mint_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.mint_txns)
  return &_impl_.mint_txns_;
}
inline const ::zera_txn::MintTXN& TXNS::_internal_mint_txns(int index) const {
  return _impl_.mint_txns_.Get(index);
}
inline const ::zera_txn::MintTXN& TXNS::mint_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.mint_txns)
  return _internal_mint_txns(index);
}
inline ::zera_txn::MintTXN* TXNS::_internal_add_mint_txns() {
  return _impl_.mint_txns_.Add();
}
inline ::zera_txn::MintTXN* TXNS::add_mint_txns() {
  ::zera_txn::MintTXN* _add = _internal_add_mint_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.mint_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::MintTXN >&
TXNS::mint_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.mint_txns)
  return _impl_.mint_txns_;
}

// repeated .zera_txn.ItemizedMintTXN item_mint_txns = 3;
inline int TXNS::_internal_item_mint_txns_size() const {
  return _impl_.item_mint_txns_.size();
}
inline int TXNS::item_mint_txns_size() const {
  return _internal_item_mint_txns_size();
}
inline void TXNS::clear_item_mint_txns() {
  _impl_.item_mint_txns_.Clear();
}
inline ::zera_txn::ItemizedMintTXN* TXNS::mutable_item_mint_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.item_mint_txns)
  return _impl_.item_mint_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ItemizedMintTXN >*
TXNS::mutable_item_mint_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.item_mint_txns)
  return &_impl_.item_mint_txns_;
}
inline const ::zera_txn::ItemizedMintTXN& TXNS::_internal_item_mint_txns(int index) const {
  return _impl_.item_mint_txns_.Get(index);
}
inline const ::zera_txn::ItemizedMintTXN& TXNS::item_mint_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.item_mint_txns)
  return _internal_item_mint_txns(index);
}
inline ::zera_txn::ItemizedMintTXN* TXNS::_internal_add_item_mint_txns() {
  return _impl_.item_mint_txns_.Add();
}
inline ::zera_txn::ItemizedMintTXN* TXNS::add_item_mint_txns() {
  ::zera_txn::ItemizedMintTXN* _add = _internal_add_item_mint_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.item_mint_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ItemizedMintTXN >&
TXNS::item_mint_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.item_mint_txns)
  return _impl_.item_mint_txns_;
}

// repeated .zera_txn.InstrumentContract contract_txns = 4;
inline int TXNS::_internal_contract_txns_size() const {
  return _impl_.contract_txns_.size();
}
inline int TXNS::contract_txns_size() const {
  return _internal_contract_txns_size();
}
inline void TXNS::clear_contract_txns() {
  _impl_.contract_txns_.Clear();
}
inline ::zera_txn::InstrumentContract* TXNS::mutable_contract_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.contract_txns)
  return _impl_.contract_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InstrumentContract >*
TXNS::mutable_contract_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.contract_txns)
  return &_impl_.contract_txns_;
}
inline const ::zera_txn::InstrumentContract& TXNS::_internal_contract_txns(int index) const {
  return _impl_.contract_txns_.Get(index);
}
inline const ::zera_txn::InstrumentContract& TXNS::contract_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.contract_txns)
  return _internal_contract_txns(index);
}
inline ::zera_txn::InstrumentContract* TXNS::_internal_add_contract_txns() {
  return _impl_.contract_txns_.Add();
}
inline ::zera_txn::InstrumentContract* TXNS::add_contract_txns() {
  ::zera_txn::InstrumentContract* _add = _internal_add_contract_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.contract_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::InstrumentContract >&
TXNS::contract_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.contract_txns)
  return _impl_.contract_txns_;
}

// repeated .zera_txn.GovernanceVote governance_votes = 5;
inline int TXNS::_internal_governance_votes_size() const {
  return _impl_.governance_votes_.size();
}
inline int TXNS::governance_votes_size() const {
  return _internal_governance_votes_size();
}
inline void TXNS::clear_governance_votes() {
  _impl_.governance_votes_.Clear();
}
inline ::zera_txn::GovernanceVote* TXNS::mutable_governance_votes(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.governance_votes)
  return _impl_.governance_votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceVote >*
TXNS::mutable_governance_votes() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.governance_votes)
  return &_impl_.governance_votes_;
}
inline const ::zera_txn::GovernanceVote& TXNS::_internal_governance_votes(int index) const {
  return _impl_.governance_votes_.Get(index);
}
inline const ::zera_txn::GovernanceVote& TXNS::governance_votes(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.governance_votes)
  return _internal_governance_votes(index);
}
inline ::zera_txn::GovernanceVote* TXNS::_internal_add_governance_votes() {
  return _impl_.governance_votes_.Add();
}
inline ::zera_txn::GovernanceVote* TXNS::add_governance_votes() {
  ::zera_txn::GovernanceVote* _add = _internal_add_governance_votes();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.governance_votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceVote >&
TXNS::governance_votes() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.governance_votes)
  return _impl_.governance_votes_;
}

// repeated .zera_txn.GovernanceProposal governance_proposals = 6;
inline int TXNS::_internal_governance_proposals_size() const {
  return _impl_.governance_proposals_.size();
}
inline int TXNS::governance_proposals_size() const {
  return _internal_governance_proposals_size();
}
inline void TXNS::clear_governance_proposals() {
  _impl_.governance_proposals_.Clear();
}
inline ::zera_txn::GovernanceProposal* TXNS::mutable_governance_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.governance_proposals)
  return _impl_.governance_proposals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceProposal >*
TXNS::mutable_governance_proposals() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.governance_proposals)
  return &_impl_.governance_proposals_;
}
inline const ::zera_txn::GovernanceProposal& TXNS::_internal_governance_proposals(int index) const {
  return _impl_.governance_proposals_.Get(index);
}
inline const ::zera_txn::GovernanceProposal& TXNS::governance_proposals(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.governance_proposals)
  return _internal_governance_proposals(index);
}
inline ::zera_txn::GovernanceProposal* TXNS::_internal_add_governance_proposals() {
  return _impl_.governance_proposals_.Add();
}
inline ::zera_txn::GovernanceProposal* TXNS::add_governance_proposals() {
  ::zera_txn::GovernanceProposal* _add = _internal_add_governance_proposals();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.governance_proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::GovernanceProposal >&
TXNS::governance_proposals() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.governance_proposals)
  return _impl_.governance_proposals_;
}

// repeated .zera_txn.SmartContractTXN smart_contracts = 7;
inline int TXNS::_internal_smart_contracts_size() const {
  return _impl_.smart_contracts_.size();
}
inline int TXNS::smart_contracts_size() const {
  return _internal_smart_contracts_size();
}
inline void TXNS::clear_smart_contracts() {
  _impl_.smart_contracts_.Clear();
}
inline ::zera_txn::SmartContractTXN* TXNS::mutable_smart_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.smart_contracts)
  return _impl_.smart_contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractTXN >*
TXNS::mutable_smart_contracts() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.smart_contracts)
  return &_impl_.smart_contracts_;
}
inline const ::zera_txn::SmartContractTXN& TXNS::_internal_smart_contracts(int index) const {
  return _impl_.smart_contracts_.Get(index);
}
inline const ::zera_txn::SmartContractTXN& TXNS::smart_contracts(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.smart_contracts)
  return _internal_smart_contracts(index);
}
inline ::zera_txn::SmartContractTXN* TXNS::_internal_add_smart_contracts() {
  return _impl_.smart_contracts_.Add();
}
inline ::zera_txn::SmartContractTXN* TXNS::add_smart_contracts() {
  ::zera_txn::SmartContractTXN* _add = _internal_add_smart_contracts();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.smart_contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractTXN >&
TXNS::smart_contracts() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.smart_contracts)
  return _impl_.smart_contracts_;
}

// repeated .zera_txn.SmartContractExecuteTXN smart_contract_executes = 8;
inline int TXNS::_internal_smart_contract_executes_size() const {
  return _impl_.smart_contract_executes_.size();
}
inline int TXNS::smart_contract_executes_size() const {
  return _internal_smart_contract_executes_size();
}
inline void TXNS::clear_smart_contract_executes() {
  _impl_.smart_contract_executes_.Clear();
}
inline ::zera_txn::SmartContractExecuteTXN* TXNS::mutable_smart_contract_executes(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.smart_contract_executes)
  return _impl_.smart_contract_executes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractExecuteTXN >*
TXNS::mutable_smart_contract_executes() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.smart_contract_executes)
  return &_impl_.smart_contract_executes_;
}
inline const ::zera_txn::SmartContractExecuteTXN& TXNS::_internal_smart_contract_executes(int index) const {
  return _impl_.smart_contract_executes_.Get(index);
}
inline const ::zera_txn::SmartContractExecuteTXN& TXNS::smart_contract_executes(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.smart_contract_executes)
  return _internal_smart_contract_executes(index);
}
inline ::zera_txn::SmartContractExecuteTXN* TXNS::_internal_add_smart_contract_executes() {
  return _impl_.smart_contract_executes_.Add();
}
inline ::zera_txn::SmartContractExecuteTXN* TXNS::add_smart_contract_executes() {
  ::zera_txn::SmartContractExecuteTXN* _add = _internal_add_smart_contract_executes();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.smart_contract_executes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractExecuteTXN >&
TXNS::smart_contract_executes() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.smart_contract_executes)
  return _impl_.smart_contract_executes_;
}

// repeated .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
inline int TXNS::_internal_self_cur_equivs_size() const {
  return _impl_.self_cur_equivs_.size();
}
inline int TXNS::self_cur_equivs_size() const {
  return _internal_self_cur_equivs_size();
}
inline void TXNS::clear_self_cur_equivs() {
  _impl_.self_cur_equivs_.Clear();
}
inline ::zera_txn::SelfCurrencyEquiv* TXNS::mutable_self_cur_equivs(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.self_cur_equivs)
  return _impl_.self_cur_equivs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SelfCurrencyEquiv >*
TXNS::mutable_self_cur_equivs() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.self_cur_equivs)
  return &_impl_.self_cur_equivs_;
}
inline const ::zera_txn::SelfCurrencyEquiv& TXNS::_internal_self_cur_equivs(int index) const {
  return _impl_.self_cur_equivs_.Get(index);
}
inline const ::zera_txn::SelfCurrencyEquiv& TXNS::self_cur_equivs(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.self_cur_equivs)
  return _internal_self_cur_equivs(index);
}
inline ::zera_txn::SelfCurrencyEquiv* TXNS::_internal_add_self_cur_equivs() {
  return _impl_.self_cur_equivs_.Add();
}
inline ::zera_txn::SelfCurrencyEquiv* TXNS::add_self_cur_equivs() {
  ::zera_txn::SelfCurrencyEquiv* _add = _internal_add_self_cur_equivs();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.self_cur_equivs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SelfCurrencyEquiv >&
TXNS::self_cur_equivs() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.self_cur_equivs)
  return _impl_.self_cur_equivs_;
}

// repeated .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
inline int TXNS::_internal_auth_cur_equivs_size() const {
  return _impl_.auth_cur_equivs_.size();
}
inline int TXNS::auth_cur_equivs_size() const {
  return _internal_auth_cur_equivs_size();
}
inline void TXNS::clear_auth_cur_equivs() {
  _impl_.auth_cur_equivs_.Clear();
}
inline ::zera_txn::AuthorizedCurrencyEquiv* TXNS::mutable_auth_cur_equivs(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.auth_cur_equivs)
  return _impl_.auth_cur_equivs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AuthorizedCurrencyEquiv >*
TXNS::mutable_auth_cur_equivs() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.auth_cur_equivs)
  return &_impl_.auth_cur_equivs_;
}
inline const ::zera_txn::AuthorizedCurrencyEquiv& TXNS::_internal_auth_cur_equivs(int index) const {
  return _impl_.auth_cur_equivs_.Get(index);
}
inline const ::zera_txn::AuthorizedCurrencyEquiv& TXNS::auth_cur_equivs(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.auth_cur_equivs)
  return _internal_auth_cur_equivs(index);
}
inline ::zera_txn::AuthorizedCurrencyEquiv* TXNS::_internal_add_auth_cur_equivs() {
  return _impl_.auth_cur_equivs_.Add();
}
inline ::zera_txn::AuthorizedCurrencyEquiv* TXNS::add_auth_cur_equivs() {
  ::zera_txn::AuthorizedCurrencyEquiv* _add = _internal_add_auth_cur_equivs();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.auth_cur_equivs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AuthorizedCurrencyEquiv >&
TXNS::auth_cur_equivs() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.auth_cur_equivs)
  return _impl_.auth_cur_equivs_;
}

// repeated .zera_txn.ExpenseRatioTXN expense_ratios = 11;
inline int TXNS::_internal_expense_ratios_size() const {
  return _impl_.expense_ratios_.size();
}
inline int TXNS::expense_ratios_size() const {
  return _internal_expense_ratios_size();
}
inline void TXNS::clear_expense_ratios() {
  _impl_.expense_ratios_.Clear();
}
inline ::zera_txn::ExpenseRatioTXN* TXNS::mutable_expense_ratios(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.expense_ratios)
  return _impl_.expense_ratios_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioTXN >*
TXNS::mutable_expense_ratios() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.expense_ratios)
  return &_impl_.expense_ratios_;
}
inline const ::zera_txn::ExpenseRatioTXN& TXNS::_internal_expense_ratios(int index) const {
  return _impl_.expense_ratios_.Get(index);
}
inline const ::zera_txn::ExpenseRatioTXN& TXNS::expense_ratios(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.expense_ratios)
  return _internal_expense_ratios(index);
}
inline ::zera_txn::ExpenseRatioTXN* TXNS::_internal_add_expense_ratios() {
  return _impl_.expense_ratios_.Add();
}
inline ::zera_txn::ExpenseRatioTXN* TXNS::add_expense_ratios() {
  ::zera_txn::ExpenseRatioTXN* _add = _internal_add_expense_ratios();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.expense_ratios)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioTXN >&
TXNS::expense_ratios() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.expense_ratios)
  return _impl_.expense_ratios_;
}

// repeated .zera_txn.TXNStatusFees txn_fees_and_status = 12;
inline int TXNS::_internal_txn_fees_and_status_size() const {
  return _impl_.txn_fees_and_status_.size();
}
inline int TXNS::txn_fees_and_status_size() const {
  return _internal_txn_fees_and_status_size();
}
inline void TXNS::clear_txn_fees_and_status() {
  _impl_.txn_fees_and_status_.Clear();
}
inline ::zera_txn::TXNStatusFees* TXNS::mutable_txn_fees_and_status(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.txn_fees_and_status)
  return _impl_.txn_fees_and_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TXNStatusFees >*
TXNS::mutable_txn_fees_and_status() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.txn_fees_and_status)
  return &_impl_.txn_fees_and_status_;
}
inline const ::zera_txn::TXNStatusFees& TXNS::_internal_txn_fees_and_status(int index) const {
  return _impl_.txn_fees_and_status_.Get(index);
}
inline const ::zera_txn::TXNStatusFees& TXNS::txn_fees_and_status(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.txn_fees_and_status)
  return _internal_txn_fees_and_status(index);
}
inline ::zera_txn::TXNStatusFees* TXNS::_internal_add_txn_fees_and_status() {
  return _impl_.txn_fees_and_status_.Add();
}
inline ::zera_txn::TXNStatusFees* TXNS::add_txn_fees_and_status() {
  ::zera_txn::TXNStatusFees* _add = _internal_add_txn_fees_and_status();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.txn_fees_and_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TXNStatusFees >&
TXNS::txn_fees_and_status() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.txn_fees_and_status)
  return _impl_.txn_fees_and_status_;
}

// repeated .zera_txn.TokenFees token_fees = 13;
inline int TXNS::_internal_token_fees_size() const {
  return _impl_.token_fees_.size();
}
inline int TXNS::token_fees_size() const {
  return _internal_token_fees_size();
}
inline void TXNS::clear_token_fees() {
  _impl_.token_fees_.Clear();
}
inline ::zera_txn::TokenFees* TXNS::mutable_token_fees(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.token_fees)
  return _impl_.token_fees_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenFees >*
TXNS::mutable_token_fees() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.token_fees)
  return &_impl_.token_fees_;
}
inline const ::zera_txn::TokenFees& TXNS::_internal_token_fees(int index) const {
  return _impl_.token_fees_.Get(index);
}
inline const ::zera_txn::TokenFees& TXNS::token_fees(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.token_fees)
  return _internal_token_fees(index);
}
inline ::zera_txn::TokenFees* TXNS::_internal_add_token_fees() {
  return _impl_.token_fees_.Add();
}
inline ::zera_txn::TokenFees* TXNS::add_token_fees() {
  ::zera_txn::TokenFees* _add = _internal_add_token_fees();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.token_fees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::TokenFees >&
TXNS::token_fees() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.token_fees)
  return _impl_.token_fees_;
}

// repeated .zera_txn.NFTTXN nft_txns = 14;
inline int TXNS::_internal_nft_txns_size() const {
  return _impl_.nft_txns_.size();
}
inline int TXNS::nft_txns_size() const {
  return _internal_nft_txns_size();
}
inline void TXNS::clear_nft_txns() {
  _impl_.nft_txns_.Clear();
}
inline ::zera_txn::NFTTXN* TXNS::mutable_nft_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.nft_txns)
  return _impl_.nft_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::NFTTXN >*
TXNS::mutable_nft_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.nft_txns)
  return &_impl_.nft_txns_;
}
inline const ::zera_txn::NFTTXN& TXNS::_internal_nft_txns(int index) const {
  return _impl_.nft_txns_.Get(index);
}
inline const ::zera_txn::NFTTXN& TXNS::nft_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.nft_txns)
  return _internal_nft_txns(index);
}
inline ::zera_txn::NFTTXN* TXNS::_internal_add_nft_txns() {
  return _impl_.nft_txns_.Add();
}
inline ::zera_txn::NFTTXN* TXNS::add_nft_txns() {
  ::zera_txn::NFTTXN* _add = _internal_add_nft_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.nft_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::NFTTXN >&
TXNS::nft_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.nft_txns)
  return _impl_.nft_txns_;
}

// repeated .zera_txn.ContractUpdateTXN contract_update_txns = 15;
inline int TXNS::_internal_contract_update_txns_size() const {
  return _impl_.contract_update_txns_.size();
}
inline int TXNS::contract_update_txns_size() const {
  return _internal_contract_update_txns_size();
}
inline void TXNS::clear_contract_update_txns() {
  _impl_.contract_update_txns_.Clear();
}
inline ::zera_txn::ContractUpdateTXN* TXNS::mutable_contract_update_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.contract_update_txns)
  return _impl_.contract_update_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ContractUpdateTXN >*
TXNS::mutable_contract_update_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.contract_update_txns)
  return &_impl_.contract_update_txns_;
}
inline const ::zera_txn::ContractUpdateTXN& TXNS::_internal_contract_update_txns(int index) const {
  return _impl_.contract_update_txns_.Get(index);
}
inline const ::zera_txn::ContractUpdateTXN& TXNS::contract_update_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.contract_update_txns)
  return _internal_contract_update_txns(index);
}
inline ::zera_txn::ContractUpdateTXN* TXNS::_internal_add_contract_update_txns() {
  return _impl_.contract_update_txns_.Add();
}
inline ::zera_txn::ContractUpdateTXN* TXNS::add_contract_update_txns() {
  ::zera_txn::ContractUpdateTXN* _add = _internal_add_contract_update_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.contract_update_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ContractUpdateTXN >&
TXNS::contract_update_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.contract_update_txns)
  return _impl_.contract_update_txns_;
}

// repeated .zera_txn.ValidatorRegistration validator_registration_txns = 16;
inline int TXNS::_internal_validator_registration_txns_size() const {
  return _impl_.validator_registration_txns_.size();
}
inline int TXNS::validator_registration_txns_size() const {
  return _internal_validator_registration_txns_size();
}
inline void TXNS::clear_validator_registration_txns() {
  _impl_.validator_registration_txns_.Clear();
}
inline ::zera_txn::ValidatorRegistration* TXNS::mutable_validator_registration_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.validator_registration_txns)
  return _impl_.validator_registration_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorRegistration >*
TXNS::mutable_validator_registration_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.validator_registration_txns)
  return &_impl_.validator_registration_txns_;
}
inline const ::zera_txn::ValidatorRegistration& TXNS::_internal_validator_registration_txns(int index) const {
  return _impl_.validator_registration_txns_.Get(index);
}
inline const ::zera_txn::ValidatorRegistration& TXNS::validator_registration_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.validator_registration_txns)
  return _internal_validator_registration_txns(index);
}
inline ::zera_txn::ValidatorRegistration* TXNS::_internal_add_validator_registration_txns() {
  return _impl_.validator_registration_txns_.Add();
}
inline ::zera_txn::ValidatorRegistration* TXNS::add_validator_registration_txns() {
  ::zera_txn::ValidatorRegistration* _add = _internal_add_validator_registration_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.validator_registration_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorRegistration >&
TXNS::validator_registration_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.validator_registration_txns)
  return _impl_.validator_registration_txns_;
}

// repeated .zera_txn.ValidatorHeartbeat validator_heartbeat_txns = 17;
inline int TXNS::_internal_validator_heartbeat_txns_size() const {
  return _impl_.validator_heartbeat_txns_.size();
}
inline int TXNS::validator_heartbeat_txns_size() const {
  return _internal_validator_heartbeat_txns_size();
}
inline void TXNS::clear_validator_heartbeat_txns() {
  _impl_.validator_heartbeat_txns_.Clear();
}
inline ::zera_txn::ValidatorHeartbeat* TXNS::mutable_validator_heartbeat_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.validator_heartbeat_txns)
  return _impl_.validator_heartbeat_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorHeartbeat >*
TXNS::mutable_validator_heartbeat_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.validator_heartbeat_txns)
  return &_impl_.validator_heartbeat_txns_;
}
inline const ::zera_txn::ValidatorHeartbeat& TXNS::_internal_validator_heartbeat_txns(int index) const {
  return _impl_.validator_heartbeat_txns_.Get(index);
}
inline const ::zera_txn::ValidatorHeartbeat& TXNS::validator_heartbeat_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.validator_heartbeat_txns)
  return _internal_validator_heartbeat_txns(index);
}
inline ::zera_txn::ValidatorHeartbeat* TXNS::_internal_add_validator_heartbeat_txns() {
  return _impl_.validator_heartbeat_txns_.Add();
}
inline ::zera_txn::ValidatorHeartbeat* TXNS::add_validator_heartbeat_txns() {
  ::zera_txn::ValidatorHeartbeat* _add = _internal_add_validator_heartbeat_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.validator_heartbeat_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ValidatorHeartbeat >&
TXNS::validator_heartbeat_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.validator_heartbeat_txns)
  return _impl_.validator_heartbeat_txns_;
}

// repeated .zera_txn.ProposalResult proposal_result_txns = 18;
inline int TXNS::_internal_proposal_result_txns_size() const {
  return _impl_.proposal_result_txns_.size();
}
inline int TXNS::proposal_result_txns_size() const {
  return _internal_proposal_result_txns_size();
}
inline void TXNS::clear_proposal_result_txns() {
  _impl_.proposal_result_txns_.Clear();
}
inline ::zera_txn::ProposalResult* TXNS::mutable_proposal_result_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.proposal_result_txns)
  return _impl_.proposal_result_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalResult >*
TXNS::mutable_proposal_result_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.proposal_result_txns)
  return &_impl_.proposal_result_txns_;
}
inline const ::zera_txn::ProposalResult& TXNS::_internal_proposal_result_txns(int index) const {
  return _impl_.proposal_result_txns_.Get(index);
}
inline const ::zera_txn::ProposalResult& TXNS::proposal_result_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.proposal_result_txns)
  return _internal_proposal_result_txns(index);
}
inline ::zera_txn::ProposalResult* TXNS::_internal_add_proposal_result_txns() {
  return _impl_.proposal_result_txns_.Add();
}
inline ::zera_txn::ProposalResult* TXNS::add_proposal_result_txns() {
  ::zera_txn::ProposalResult* _add = _internal_add_proposal_result_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.proposal_result_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalResult >&
TXNS::proposal_result_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.proposal_result_txns)
  return _impl_.proposal_result_txns_;
}

// repeated .zera_txn.ExpenseRatioResult expense_ratio_result_txns = 19;
inline int TXNS::_internal_expense_ratio_result_txns_size() const {
  return _impl_.expense_ratio_result_txns_.size();
}
inline int TXNS::expense_ratio_result_txns_size() const {
  return _internal_expense_ratio_result_txns_size();
}
inline void TXNS::clear_expense_ratio_result_txns() {
  _impl_.expense_ratio_result_txns_.Clear();
}
inline ::zera_txn::ExpenseRatioResult* TXNS::mutable_expense_ratio_result_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.expense_ratio_result_txns)
  return _impl_.expense_ratio_result_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioResult >*
TXNS::mutable_expense_ratio_result_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.expense_ratio_result_txns)
  return &_impl_.expense_ratio_result_txns_;
}
inline const ::zera_txn::ExpenseRatioResult& TXNS::_internal_expense_ratio_result_txns(int index) const {
  return _impl_.expense_ratio_result_txns_.Get(index);
}
inline const ::zera_txn::ExpenseRatioResult& TXNS::expense_ratio_result_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.expense_ratio_result_txns)
  return _internal_expense_ratio_result_txns(index);
}
inline ::zera_txn::ExpenseRatioResult* TXNS::_internal_add_expense_ratio_result_txns() {
  return _impl_.expense_ratio_result_txns_.Add();
}
inline ::zera_txn::ExpenseRatioResult* TXNS::add_expense_ratio_result_txns() {
  ::zera_txn::ExpenseRatioResult* _add = _internal_add_expense_ratio_result_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.expense_ratio_result_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ExpenseRatioResult >&
TXNS::expense_ratio_result_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.expense_ratio_result_txns)
  return _impl_.expense_ratio_result_txns_;
}

// repeated .zera_txn.FoundationTXN foundation_txns = 20;
inline int TXNS::_internal_foundation_txns_size() const {
  return _impl_.foundation_txns_.size();
}
inline int TXNS::foundation_txns_size() const {
  return _internal_foundation_txns_size();
}
inline void TXNS::clear_foundation_txns() {
  _impl_.foundation_txns_.Clear();
}
inline ::zera_txn::FoundationTXN* TXNS::mutable_foundation_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.foundation_txns)
  return _impl_.foundation_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FoundationTXN >*
TXNS::mutable_foundation_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.foundation_txns)
  return &_impl_.foundation_txns_;
}
inline const ::zera_txn::FoundationTXN& TXNS::_internal_foundation_txns(int index) const {
  return _impl_.foundation_txns_.Get(index);
}
inline const ::zera_txn::FoundationTXN& TXNS::foundation_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.foundation_txns)
  return _internal_foundation_txns(index);
}
inline ::zera_txn::FoundationTXN* TXNS::_internal_add_foundation_txns() {
  return _impl_.foundation_txns_.Add();
}
inline ::zera_txn::FoundationTXN* TXNS::add_foundation_txns() {
  ::zera_txn::FoundationTXN* _add = _internal_add_foundation_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.foundation_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FoundationTXN >&
TXNS::foundation_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.foundation_txns)
  return _impl_.foundation_txns_;
}

// repeated .zera_txn.DelegatedTXN delegated_voting_txns = 21;
inline int TXNS::_internal_delegated_voting_txns_size() const {
  return _impl_.delegated_voting_txns_.size();
}
inline int TXNS::delegated_voting_txns_size() const {
  return _internal_delegated_voting_txns_size();
}
inline void TXNS::clear_delegated_voting_txns() {
  _impl_.delegated_voting_txns_.Clear();
}
inline ::zera_txn::DelegatedTXN* TXNS::mutable_delegated_voting_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.delegated_voting_txns)
  return _impl_.delegated_voting_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedTXN >*
TXNS::mutable_delegated_voting_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.delegated_voting_txns)
  return &_impl_.delegated_voting_txns_;
}
inline const ::zera_txn::DelegatedTXN& TXNS::_internal_delegated_voting_txns(int index) const {
  return _impl_.delegated_voting_txns_.Get(index);
}
inline const ::zera_txn::DelegatedTXN& TXNS::delegated_voting_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.delegated_voting_txns)
  return _internal_delegated_voting_txns(index);
}
inline ::zera_txn::DelegatedTXN* TXNS::_internal_add_delegated_voting_txns() {
  return _impl_.delegated_voting_txns_.Add();
}
inline ::zera_txn::DelegatedTXN* TXNS::add_delegated_voting_txns() {
  ::zera_txn::DelegatedTXN* _add = _internal_add_delegated_voting_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.delegated_voting_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedTXN >&
TXNS::delegated_voting_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.delegated_voting_txns)
  return _impl_.delegated_voting_txns_;
}

// repeated .zera_txn.QuashTXN quash_txns = 22;
inline int TXNS::_internal_quash_txns_size() const {
  return _impl_.quash_txns_.size();
}
inline int TXNS::quash_txns_size() const {
  return _internal_quash_txns_size();
}
inline void TXNS::clear_quash_txns() {
  _impl_.quash_txns_.Clear();
}
inline ::zera_txn::QuashTXN* TXNS::mutable_quash_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.quash_txns)
  return _impl_.quash_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashTXN >*
TXNS::mutable_quash_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.quash_txns)
  return &_impl_.quash_txns_;
}
inline const ::zera_txn::QuashTXN& TXNS::_internal_quash_txns(int index) const {
  return _impl_.quash_txns_.Get(index);
}
inline const ::zera_txn::QuashTXN& TXNS::quash_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.quash_txns)
  return _internal_quash_txns(index);
}
inline ::zera_txn::QuashTXN* TXNS::_internal_add_quash_txns() {
  return _impl_.quash_txns_.Add();
}
inline ::zera_txn::QuashTXN* TXNS::add_quash_txns() {
  ::zera_txn::QuashTXN* _add = _internal_add_quash_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.quash_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashTXN >&
TXNS::quash_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.quash_txns)
  return _impl_.quash_txns_;
}

// repeated .zera_txn.FastQuorumTXN fast_quorum_txns = 23;
inline int TXNS::_internal_fast_quorum_txns_size() const {
  return _impl_.fast_quorum_txns_.size();
}
inline int TXNS::fast_quorum_txns_size() const {
  return _internal_fast_quorum_txns_size();
}
inline void TXNS::clear_fast_quorum_txns() {
  _impl_.fast_quorum_txns_.Clear();
}
inline ::zera_txn::FastQuorumTXN* TXNS::mutable_fast_quorum_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.fast_quorum_txns)
  return _impl_.fast_quorum_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FastQuorumTXN >*
TXNS::mutable_fast_quorum_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.fast_quorum_txns)
  return &_impl_.fast_quorum_txns_;
}
inline const ::zera_txn::FastQuorumTXN& TXNS::_internal_fast_quorum_txns(int index) const {
  return _impl_.fast_quorum_txns_.Get(index);
}
inline const ::zera_txn::FastQuorumTXN& TXNS::fast_quorum_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.fast_quorum_txns)
  return _internal_fast_quorum_txns(index);
}
inline ::zera_txn::FastQuorumTXN* TXNS::_internal_add_fast_quorum_txns() {
  return _impl_.fast_quorum_txns_.Add();
}
inline ::zera_txn::FastQuorumTXN* TXNS::add_fast_quorum_txns() {
  ::zera_txn::FastQuorumTXN* _add = _internal_add_fast_quorum_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.fast_quorum_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::FastQuorumTXN >&
TXNS::fast_quorum_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.fast_quorum_txns)
  return _impl_.fast_quorum_txns_;
}

// repeated .zera_txn.QuashResult quash_results = 24;
inline int TXNS::_internal_quash_results_size() const {
  return _impl_.quash_results_.size();
}
inline int TXNS::quash_results_size() const {
  return _internal_quash_results_size();
}
inline void TXNS::clear_quash_results() {
  _impl_.quash_results_.Clear();
}
inline ::zera_txn::QuashResult* TXNS::mutable_quash_results(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.quash_results)
  return _impl_.quash_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashResult >*
TXNS::mutable_quash_results() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.quash_results)
  return &_impl_.quash_results_;
}
inline const ::zera_txn::QuashResult& TXNS::_internal_quash_results(int index) const {
  return _impl_.quash_results_.Get(index);
}
inline const ::zera_txn::QuashResult& TXNS::quash_results(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.quash_results)
  return _internal_quash_results(index);
}
inline ::zera_txn::QuashResult* TXNS::_internal_add_quash_results() {
  return _impl_.quash_results_.Add();
}
inline ::zera_txn::QuashResult* TXNS::add_quash_results() {
  ::zera_txn::QuashResult* _add = _internal_add_quash_results();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.quash_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::QuashResult >&
TXNS::quash_results() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.quash_results)
  return _impl_.quash_results_;
}

// repeated .zera_txn.RevokeTXN revoke_txns = 25;
inline int TXNS::_internal_revoke_txns_size() const {
  return _impl_.revoke_txns_.size();
}
inline int TXNS::revoke_txns_size() const {
  return _internal_revoke_txns_size();
}
inline void TXNS::clear_revoke_txns() {
  _impl_.revoke_txns_.Clear();
}
inline ::zera_txn::RevokeTXN* TXNS::mutable_revoke_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.revoke_txns)
  return _impl_.revoke_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RevokeTXN >*
TXNS::mutable_revoke_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.revoke_txns)
  return &_impl_.revoke_txns_;
}
inline const ::zera_txn::RevokeTXN& TXNS::_internal_revoke_txns(int index) const {
  return _impl_.revoke_txns_.Get(index);
}
inline const ::zera_txn::RevokeTXN& TXNS::revoke_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.revoke_txns)
  return _internal_revoke_txns(index);
}
inline ::zera_txn::RevokeTXN* TXNS::_internal_add_revoke_txns() {
  return _impl_.revoke_txns_.Add();
}
inline ::zera_txn::RevokeTXN* TXNS::add_revoke_txns() {
  ::zera_txn::RevokeTXN* _add = _internal_add_revoke_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.revoke_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::RevokeTXN >&
TXNS::revoke_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.revoke_txns)
  return _impl_.revoke_txns_;
}

// repeated .zera_txn.ComplianceTXN compliance_txns = 26;
inline int TXNS::_internal_compliance_txns_size() const {
  return _impl_.compliance_txns_.size();
}
inline int TXNS::compliance_txns_size() const {
  return _internal_compliance_txns_size();
}
inline void TXNS::clear_compliance_txns() {
  _impl_.compliance_txns_.Clear();
}
inline ::zera_txn::ComplianceTXN* TXNS::mutable_compliance_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.compliance_txns)
  return _impl_.compliance_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceTXN >*
TXNS::mutable_compliance_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.compliance_txns)
  return &_impl_.compliance_txns_;
}
inline const ::zera_txn::ComplianceTXN& TXNS::_internal_compliance_txns(int index) const {
  return _impl_.compliance_txns_.Get(index);
}
inline const ::zera_txn::ComplianceTXN& TXNS::compliance_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.compliance_txns)
  return _internal_compliance_txns(index);
}
inline ::zera_txn::ComplianceTXN* TXNS::_internal_add_compliance_txns() {
  return _impl_.compliance_txns_.Add();
}
inline ::zera_txn::ComplianceTXN* TXNS::add_compliance_txns() {
  ::zera_txn::ComplianceTXN* _add = _internal_add_compliance_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.compliance_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ComplianceTXN >&
TXNS::compliance_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.compliance_txns)
  return _impl_.compliance_txns_;
}

// repeated .zera_txn.BurnSBTTXN burn_sbt_txns = 27;
inline int TXNS::_internal_burn_sbt_txns_size() const {
  return _impl_.burn_sbt_txns_.size();
}
inline int TXNS::burn_sbt_txns_size() const {
  return _internal_burn_sbt_txns_size();
}
inline void TXNS::clear_burn_sbt_txns() {
  _impl_.burn_sbt_txns_.Clear();
}
inline ::zera_txn::BurnSBTTXN* TXNS::mutable_burn_sbt_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.burn_sbt_txns)
  return _impl_.burn_sbt_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::BurnSBTTXN >*
TXNS::mutable_burn_sbt_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.burn_sbt_txns)
  return &_impl_.burn_sbt_txns_;
}
inline const ::zera_txn::BurnSBTTXN& TXNS::_internal_burn_sbt_txns(int index) const {
  return _impl_.burn_sbt_txns_.Get(index);
}
inline const ::zera_txn::BurnSBTTXN& TXNS::burn_sbt_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.burn_sbt_txns)
  return _internal_burn_sbt_txns(index);
}
inline ::zera_txn::BurnSBTTXN* TXNS::_internal_add_burn_sbt_txns() {
  return _impl_.burn_sbt_txns_.Add();
}
inline ::zera_txn::BurnSBTTXN* TXNS::add_burn_sbt_txns() {
  ::zera_txn::BurnSBTTXN* _add = _internal_add_burn_sbt_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.burn_sbt_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::BurnSBTTXN >&
TXNS::burn_sbt_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.burn_sbt_txns)
  return _impl_.burn_sbt_txns_;
}

// repeated .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txns = 28;
inline int TXNS::_internal_smart_contract_instantiate_txns_size() const {
  return _impl_.smart_contract_instantiate_txns_.size();
}
inline int TXNS::smart_contract_instantiate_txns_size() const {
  return _internal_smart_contract_instantiate_txns_size();
}
inline void TXNS::clear_smart_contract_instantiate_txns() {
  _impl_.smart_contract_instantiate_txns_.Clear();
}
inline ::zera_txn::SmartContractInstantiateTXN* TXNS::mutable_smart_contract_instantiate_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.smart_contract_instantiate_txns)
  return _impl_.smart_contract_instantiate_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractInstantiateTXN >*
TXNS::mutable_smart_contract_instantiate_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.smart_contract_instantiate_txns)
  return &_impl_.smart_contract_instantiate_txns_;
}
inline const ::zera_txn::SmartContractInstantiateTXN& TXNS::_internal_smart_contract_instantiate_txns(int index) const {
  return _impl_.smart_contract_instantiate_txns_.Get(index);
}
inline const ::zera_txn::SmartContractInstantiateTXN& TXNS::smart_contract_instantiate_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.smart_contract_instantiate_txns)
  return _internal_smart_contract_instantiate_txns(index);
}
inline ::zera_txn::SmartContractInstantiateTXN* TXNS::_internal_add_smart_contract_instantiate_txns() {
  return _impl_.smart_contract_instantiate_txns_.Add();
}
inline ::zera_txn::SmartContractInstantiateTXN* TXNS::add_smart_contract_instantiate_txns() {
  ::zera_txn::SmartContractInstantiateTXN* _add = _internal_add_smart_contract_instantiate_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.smart_contract_instantiate_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::SmartContractInstantiateTXN >&
TXNS::smart_contract_instantiate_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.smart_contract_instantiate_txns)
  return _impl_.smart_contract_instantiate_txns_;
}

// optional .zera_txn.RequiredVersion required_version_txn = 29;
inline bool TXNS::_internal_has_required_version_txn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.required_version_txn_ != nullptr);
  return value;
}
inline bool TXNS::has_required_version_txn() const {
  return _internal_has_required_version_txn();
}
inline void TXNS::clear_required_version_txn() {
  if (_impl_.required_version_txn_ != nullptr) _impl_.required_version_txn_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::zera_txn::RequiredVersion& TXNS::_internal_required_version_txn() const {
  const ::zera_txn::RequiredVersion* p = _impl_.required_version_txn_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::RequiredVersion&>(
      ::zera_txn::_RequiredVersion_default_instance_);
}
inline const ::zera_txn::RequiredVersion& TXNS::required_version_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.required_version_txn)
  return _internal_required_version_txn();
}
inline void TXNS::unsafe_arena_set_allocated_required_version_txn(
    ::zera_txn::RequiredVersion* required_version_txn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.required_version_txn_);
  }
  _impl_.required_version_txn_ = required_version_txn;
  if (required_version_txn) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNS.required_version_txn)
}
inline ::zera_txn::RequiredVersion* TXNS::release_required_version_txn() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zera_txn::RequiredVersion* temp = _impl_.required_version_txn_;
  _impl_.required_version_txn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::RequiredVersion* TXNS::unsafe_arena_release_required_version_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNS.required_version_txn)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zera_txn::RequiredVersion* temp = _impl_.required_version_txn_;
  _impl_.required_version_txn_ = nullptr;
  return temp;
}
inline ::zera_txn::RequiredVersion* TXNS::_internal_mutable_required_version_txn() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.required_version_txn_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::RequiredVersion>(GetArenaForAllocation());
    _impl_.required_version_txn_ = p;
  }
  return _impl_.required_version_txn_;
}
inline ::zera_txn::RequiredVersion* TXNS::mutable_required_version_txn() {
  ::zera_txn::RequiredVersion* _msg = _internal_mutable_required_version_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.required_version_txn)
  return _msg;
}
inline void TXNS::set_allocated_required_version_txn(::zera_txn::RequiredVersion* required_version_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.required_version_txn_;
  }
  if (required_version_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(required_version_txn);
    if (message_arena != submessage_arena) {
      required_version_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, required_version_txn, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.required_version_txn_ = required_version_txn;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNS.required_version_txn)
}

// repeated .zera_txn.AllowanceTXN allowance_txns = 30;
inline int TXNS::_internal_allowance_txns_size() const {
  return _impl_.allowance_txns_.size();
}
inline int TXNS::allowance_txns_size() const {
  return _internal_allowance_txns_size();
}
inline void TXNS::clear_allowance_txns() {
  _impl_.allowance_txns_.Clear();
}
inline ::zera_txn::AllowanceTXN* TXNS::mutable_allowance_txns(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNS.allowance_txns)
  return _impl_.allowance_txns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AllowanceTXN >*
TXNS::mutable_allowance_txns() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNS.allowance_txns)
  return &_impl_.allowance_txns_;
}
inline const ::zera_txn::AllowanceTXN& TXNS::_internal_allowance_txns(int index) const {
  return _impl_.allowance_txns_.Get(index);
}
inline const ::zera_txn::AllowanceTXN& TXNS::allowance_txns(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNS.allowance_txns)
  return _internal_allowance_txns(index);
}
inline ::zera_txn::AllowanceTXN* TXNS::_internal_add_allowance_txns() {
  return _impl_.allowance_txns_.Add();
}
inline ::zera_txn::AllowanceTXN* TXNS::add_allowance_txns() {
  ::zera_txn::AllowanceTXN* _add = _internal_add_allowance_txns();
  // @@protoc_insertion_point(field_add:zera_txn.TXNS.allowance_txns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::AllowanceTXN >&
TXNS::allowance_txns() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNS.allowance_txns)
  return _impl_.allowance_txns_;
}

// -------------------------------------------------------------------

// Token

// string contract_id = 1;
inline void Token::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& Token::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.Token.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Token.contract_id)
}
inline std::string* Token::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.Token.contract_id)
  return _s;
}
inline const std::string& Token::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void Token::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.Token.contract_id)
  return _impl_.contract_id_.Release();
}
inline void Token::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Token.contract_id)
}

// string amount = 2;
inline void Token::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& Token::amount() const {
  // @@protoc_insertion_point(field_get:zera_txn.Token.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.Token.amount)
}
inline std::string* Token::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:zera_txn.Token.amount)
  return _s;
}
inline const std::string& Token::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void Token::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_amount() {
  // @@protoc_insertion_point(field_release:zera_txn.Token.amount)
  return _impl_.amount_.Release();
}
inline void Token::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.Token.amount)
}

// -------------------------------------------------------------------

// TokenFees

// bytes address = 1;
inline void TokenFees::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& TokenFees::address() const {
  // @@protoc_insertion_point(field_get:zera_txn.TokenFees.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenFees::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TokenFees.address)
}
inline std::string* TokenFees::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.TokenFees.address)
  return _s;
}
inline const std::string& TokenFees::_internal_address() const {
  return _impl_.address_.Get();
}
inline void TokenFees::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenFees::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenFees::release_address() {
  // @@protoc_insertion_point(field_release:zera_txn.TokenFees.address)
  return _impl_.address_.Release();
}
inline void TokenFees::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TokenFees.address)
}

// repeated .zera_txn.Token tokens = 2;
inline int TokenFees::_internal_tokens_size() const {
  return _impl_.tokens_.size();
}
inline int TokenFees::tokens_size() const {
  return _internal_tokens_size();
}
inline void TokenFees::clear_tokens() {
  _impl_.tokens_.Clear();
}
inline ::zera_txn::Token* TokenFees::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TokenFees.tokens)
  return _impl_.tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Token >*
TokenFees::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TokenFees.tokens)
  return &_impl_.tokens_;
}
inline const ::zera_txn::Token& TokenFees::_internal_tokens(int index) const {
  return _impl_.tokens_.Get(index);
}
inline const ::zera_txn::Token& TokenFees::tokens(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TokenFees.tokens)
  return _internal_tokens(index);
}
inline ::zera_txn::Token* TokenFees::_internal_add_tokens() {
  return _impl_.tokens_.Add();
}
inline ::zera_txn::Token* TokenFees::add_tokens() {
  ::zera_txn::Token* _add = _internal_add_tokens();
  // @@protoc_insertion_point(field_add:zera_txn.TokenFees.tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::Token >&
TokenFees::tokens() const {
  // @@protoc_insertion_point(field_list:zera_txn.TokenFees.tokens)
  return _impl_.tokens_;
}

// -------------------------------------------------------------------

// DelegatedData

// bytes address = 1;
inline void DelegatedData::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& DelegatedData::address() const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegatedData.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegatedData::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.DelegatedData.address)
}
inline std::string* DelegatedData::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegatedData.address)
  return _s;
}
inline const std::string& DelegatedData::_internal_address() const {
  return _impl_.address_.Get();
}
inline void DelegatedData::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegatedData::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* DelegatedData::release_address() {
  // @@protoc_insertion_point(field_release:zera_txn.DelegatedData.address)
  return _impl_.address_.Release();
}
inline void DelegatedData::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.DelegatedData.address)
}

// .zera_txn.Token fee = 2;
inline bool DelegatedData::_internal_has_fee() const {
  return this != internal_default_instance() && _impl_.fee_ != nullptr;
}
inline bool DelegatedData::has_fee() const {
  return _internal_has_fee();
}
inline void DelegatedData::clear_fee() {
  if (GetArenaForAllocation() == nullptr && _impl_.fee_ != nullptr) {
    delete _impl_.fee_;
  }
  _impl_.fee_ = nullptr;
}
inline const ::zera_txn::Token& DelegatedData::_internal_fee() const {
  const ::zera_txn::Token* p = _impl_.fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::zera_txn::Token&>(
      ::zera_txn::_Token_default_instance_);
}
inline const ::zera_txn::Token& DelegatedData::fee() const {
  // @@protoc_insertion_point(field_get:zera_txn.DelegatedData.fee)
  return _internal_fee();
}
inline void DelegatedData::unsafe_arena_set_allocated_fee(
    ::zera_txn::Token* fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_);
  }
  _impl_.fee_ = fee;
  if (fee) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.DelegatedData.fee)
}
inline ::zera_txn::Token* DelegatedData::release_fee() {
  
  ::zera_txn::Token* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zera_txn::Token* DelegatedData::unsafe_arena_release_fee() {
  // @@protoc_insertion_point(field_release:zera_txn.DelegatedData.fee)
  
  ::zera_txn::Token* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
  return temp;
}
inline ::zera_txn::Token* DelegatedData::_internal_mutable_fee() {
  
  if (_impl_.fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::zera_txn::Token>(GetArenaForAllocation());
    _impl_.fee_ = p;
  }
  return _impl_.fee_;
}
inline ::zera_txn::Token* DelegatedData::mutable_fee() {
  ::zera_txn::Token* _msg = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:zera_txn.DelegatedData.fee)
  return _msg;
}
inline void DelegatedData::set_allocated_fee(::zera_txn::Token* fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fee_;
  }
  if (fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fee);
    if (message_arena != submessage_arena) {
      fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:zera_txn.DelegatedData.fee)
}

// -------------------------------------------------------------------

// TXNStatusFees

// bytes txn_hash = 1;
inline void TXNStatusFees::clear_txn_hash() {
  _impl_.txn_hash_.ClearToEmpty();
}
inline const std::string& TXNStatusFees::txn_hash() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.txn_hash)
  return _internal_txn_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXNStatusFees::set_txn_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txn_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.txn_hash)
}
inline std::string* TXNStatusFees::mutable_txn_hash() {
  std::string* _s = _internal_mutable_txn_hash();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.txn_hash)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_txn_hash() const {
  return _impl_.txn_hash_.Get();
}
inline void TXNStatusFees::_internal_set_txn_hash(const std::string& value) {
  
  _impl_.txn_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TXNStatusFees::_internal_mutable_txn_hash() {
  
  return _impl_.txn_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* TXNStatusFees::release_txn_hash() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNStatusFees.txn_hash)
  return _impl_.txn_hash_.Release();
}
inline void TXNStatusFees::set_allocated_txn_hash(std::string* txn_hash) {
  if (txn_hash != nullptr) {
    
  } else {
    
  }
  _impl_.txn_hash_.SetAllocated(txn_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txn_hash_.IsDefault()) {
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNStatusFees.txn_hash)
}

// .zera_txn.TXN_STATUS status = 2;
inline void TXNStatusFees::clear_status() {
  _impl_.status_ = 0;
}
inline ::zera_txn::TXN_STATUS TXNStatusFees::_internal_status() const {
  return static_cast< ::zera_txn::TXN_STATUS >(_impl_.status_);
}
inline ::zera_txn::TXN_STATUS TXNStatusFees::status() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.status)
  return _internal_status();
}
inline void TXNStatusFees::_internal_set_status(::zera_txn::TXN_STATUS value) {
  
  _impl_.status_ = value;
}
inline void TXNStatusFees::set_status(::zera_txn::TXN_STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.status)
}

// string base_fees = 3;
inline void TXNStatusFees::clear_base_fees() {
  _impl_.base_fees_.ClearToEmpty();
}
inline const std::string& TXNStatusFees::base_fees() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.base_fees)
  return _internal_base_fees();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXNStatusFees::set_base_fees(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_fees_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.base_fees)
}
inline std::string* TXNStatusFees::mutable_base_fees() {
  std::string* _s = _internal_mutable_base_fees();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.base_fees)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_base_fees() const {
  return _impl_.base_fees_.Get();
}
inline void TXNStatusFees::_internal_set_base_fees(const std::string& value) {
  
  _impl_.base_fees_.Set(value, GetArenaForAllocation());
}
inline std::string* TXNStatusFees::_internal_mutable_base_fees() {
  
  return _impl_.base_fees_.Mutable(GetArenaForAllocation());
}
inline std::string* TXNStatusFees::release_base_fees() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNStatusFees.base_fees)
  return _impl_.base_fees_.Release();
}
inline void TXNStatusFees::set_allocated_base_fees(std::string* base_fees) {
  if (base_fees != nullptr) {
    
  } else {
    
  }
  _impl_.base_fees_.SetAllocated(base_fees, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_fees_.IsDefault()) {
    _impl_.base_fees_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNStatusFees.base_fees)
}

// string base_contract_id = 4;
inline void TXNStatusFees::clear_base_contract_id() {
  _impl_.base_contract_id_.ClearToEmpty();
}
inline const std::string& TXNStatusFees::base_contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.base_contract_id)
  return _internal_base_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXNStatusFees::set_base_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.base_contract_id)
}
inline std::string* TXNStatusFees::mutable_base_contract_id() {
  std::string* _s = _internal_mutable_base_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.base_contract_id)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_base_contract_id() const {
  return _impl_.base_contract_id_.Get();
}
inline void TXNStatusFees::_internal_set_base_contract_id(const std::string& value) {
  
  _impl_.base_contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TXNStatusFees::_internal_mutable_base_contract_id() {
  
  return _impl_.base_contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TXNStatusFees::release_base_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNStatusFees.base_contract_id)
  return _impl_.base_contract_id_.Release();
}
inline void TXNStatusFees::set_allocated_base_contract_id(std::string* base_contract_id) {
  if (base_contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.base_contract_id_.SetAllocated(base_contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_contract_id_.IsDefault()) {
    _impl_.base_contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNStatusFees.base_contract_id)
}

// optional string contract_fees = 5;
inline bool TXNStatusFees::_internal_has_contract_fees() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TXNStatusFees::has_contract_fees() const {
  return _internal_has_contract_fees();
}
inline void TXNStatusFees::clear_contract_fees() {
  _impl_.contract_fees_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TXNStatusFees::contract_fees() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.contract_fees)
  return _internal_contract_fees();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXNStatusFees::set_contract_fees(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.contract_fees_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.contract_fees)
}
inline std::string* TXNStatusFees::mutable_contract_fees() {
  std::string* _s = _internal_mutable_contract_fees();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.contract_fees)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_contract_fees() const {
  return _impl_.contract_fees_.Get();
}
inline void TXNStatusFees::_internal_set_contract_fees(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contract_fees_.Set(value, GetArenaForAllocation());
}
inline std::string* TXNStatusFees::_internal_mutable_contract_fees() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contract_fees_.Mutable(GetArenaForAllocation());
}
inline std::string* TXNStatusFees::release_contract_fees() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNStatusFees.contract_fees)
  if (!_internal_has_contract_fees()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.contract_fees_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fees_.IsDefault()) {
    _impl_.contract_fees_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TXNStatusFees::set_allocated_contract_fees(std::string* contract_fees) {
  if (contract_fees != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contract_fees_.SetAllocated(contract_fees, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_fees_.IsDefault()) {
    _impl_.contract_fees_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNStatusFees.contract_fees)
}

// optional string contract_contract_id = 6;
inline bool TXNStatusFees::_internal_has_contract_contract_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TXNStatusFees::has_contract_contract_id() const {
  return _internal_has_contract_contract_id();
}
inline void TXNStatusFees::clear_contract_contract_id() {
  _impl_.contract_contract_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TXNStatusFees::contract_contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.contract_contract_id)
  return _internal_contract_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXNStatusFees::set_contract_contract_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.contract_contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.contract_contract_id)
}
inline std::string* TXNStatusFees::mutable_contract_contract_id() {
  std::string* _s = _internal_mutable_contract_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.contract_contract_id)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_contract_contract_id() const {
  return _impl_.contract_contract_id_.Get();
}
inline void TXNStatusFees::_internal_set_contract_contract_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.contract_contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TXNStatusFees::_internal_mutable_contract_contract_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.contract_contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TXNStatusFees::release_contract_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNStatusFees.contract_contract_id)
  if (!_internal_has_contract_contract_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.contract_contract_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_contract_id_.IsDefault()) {
    _impl_.contract_contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TXNStatusFees::set_allocated_contract_contract_id(std::string* contract_contract_id) {
  if (contract_contract_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.contract_contract_id_.SetAllocated(contract_contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_contract_id_.IsDefault()) {
    _impl_.contract_contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNStatusFees.contract_contract_id)
}

// bool smart_contract = 9;
inline void TXNStatusFees::clear_smart_contract() {
  _impl_.smart_contract_ = false;
}
inline bool TXNStatusFees::_internal_smart_contract() const {
  return _impl_.smart_contract_;
}
inline bool TXNStatusFees::smart_contract() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.smart_contract)
  return _internal_smart_contract();
}
inline void TXNStatusFees::_internal_set_smart_contract(bool value) {
  
  _impl_.smart_contract_ = value;
}
inline void TXNStatusFees::set_smart_contract(bool value) {
  _internal_set_smart_contract(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.smart_contract)
}

// repeated bytes smart_contract_result = 10;
inline int TXNStatusFees::_internal_smart_contract_result_size() const {
  return _impl_.smart_contract_result_.size();
}
inline int TXNStatusFees::smart_contract_result_size() const {
  return _internal_smart_contract_result_size();
}
inline void TXNStatusFees::clear_smart_contract_result() {
  _impl_.smart_contract_result_.Clear();
}
inline std::string* TXNStatusFees::add_smart_contract_result() {
  std::string* _s = _internal_add_smart_contract_result();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.TXNStatusFees.smart_contract_result)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_smart_contract_result(int index) const {
  return _impl_.smart_contract_result_.Get(index);
}
inline const std::string& TXNStatusFees::smart_contract_result(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.smart_contract_result)
  return _internal_smart_contract_result(index);
}
inline std::string* TXNStatusFees::mutable_smart_contract_result(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.smart_contract_result)
  return _impl_.smart_contract_result_.Mutable(index);
}
inline void TXNStatusFees::set_smart_contract_result(int index, const std::string& value) {
  _impl_.smart_contract_result_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.smart_contract_result)
}
inline void TXNStatusFees::set_smart_contract_result(int index, std::string&& value) {
  _impl_.smart_contract_result_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.smart_contract_result)
}
inline void TXNStatusFees::set_smart_contract_result(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.smart_contract_result_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.TXNStatusFees.smart_contract_result)
}
inline void TXNStatusFees::set_smart_contract_result(int index, const void* value, size_t size) {
  _impl_.smart_contract_result_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.TXNStatusFees.smart_contract_result)
}
inline std::string* TXNStatusFees::_internal_add_smart_contract_result() {
  return _impl_.smart_contract_result_.Add();
}
inline void TXNStatusFees::add_smart_contract_result(const std::string& value) {
  _impl_.smart_contract_result_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.TXNStatusFees.smart_contract_result)
}
inline void TXNStatusFees::add_smart_contract_result(std::string&& value) {
  _impl_.smart_contract_result_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.TXNStatusFees.smart_contract_result)
}
inline void TXNStatusFees::add_smart_contract_result(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.smart_contract_result_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.TXNStatusFees.smart_contract_result)
}
inline void TXNStatusFees::add_smart_contract_result(const void* value, size_t size) {
  _impl_.smart_contract_result_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.TXNStatusFees.smart_contract_result)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TXNStatusFees::smart_contract_result() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNStatusFees.smart_contract_result)
  return _impl_.smart_contract_result_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TXNStatusFees::mutable_smart_contract_result() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNStatusFees.smart_contract_result)
  return &_impl_.smart_contract_result_;
}

// repeated string misc = 11;
inline int TXNStatusFees::_internal_misc_size() const {
  return _impl_.misc_.size();
}
inline int TXNStatusFees::misc_size() const {
  return _internal_misc_size();
}
inline void TXNStatusFees::clear_misc() {
  _impl_.misc_.Clear();
}
inline std::string* TXNStatusFees::add_misc() {
  std::string* _s = _internal_add_misc();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.TXNStatusFees.misc)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_misc(int index) const {
  return _impl_.misc_.Get(index);
}
inline const std::string& TXNStatusFees::misc(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.misc)
  return _internal_misc(index);
}
inline std::string* TXNStatusFees::mutable_misc(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.misc)
  return _impl_.misc_.Mutable(index);
}
inline void TXNStatusFees::set_misc(int index, const std::string& value) {
  _impl_.misc_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.misc)
}
inline void TXNStatusFees::set_misc(int index, std::string&& value) {
  _impl_.misc_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.misc)
}
inline void TXNStatusFees::set_misc(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.misc_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.TXNStatusFees.misc)
}
inline void TXNStatusFees::set_misc(int index, const char* value, size_t size) {
  _impl_.misc_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.TXNStatusFees.misc)
}
inline std::string* TXNStatusFees::_internal_add_misc() {
  return _impl_.misc_.Add();
}
inline void TXNStatusFees::add_misc(const std::string& value) {
  _impl_.misc_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.TXNStatusFees.misc)
}
inline void TXNStatusFees::add_misc(std::string&& value) {
  _impl_.misc_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.TXNStatusFees.misc)
}
inline void TXNStatusFees::add_misc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.misc_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.TXNStatusFees.misc)
}
inline void TXNStatusFees::add_misc(const char* value, size_t size) {
  _impl_.misc_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.TXNStatusFees.misc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TXNStatusFees::misc() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNStatusFees.misc)
  return _impl_.misc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TXNStatusFees::mutable_misc() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNStatusFees.misc)
  return &_impl_.misc_;
}

// optional string native_function_fees = 12;
inline bool TXNStatusFees::_internal_has_native_function_fees() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TXNStatusFees::has_native_function_fees() const {
  return _internal_has_native_function_fees();
}
inline void TXNStatusFees::clear_native_function_fees() {
  _impl_.native_function_fees_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TXNStatusFees::native_function_fees() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.native_function_fees)
  return _internal_native_function_fees();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXNStatusFees::set_native_function_fees(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.native_function_fees_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.native_function_fees)
}
inline std::string* TXNStatusFees::mutable_native_function_fees() {
  std::string* _s = _internal_mutable_native_function_fees();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.native_function_fees)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_native_function_fees() const {
  return _impl_.native_function_fees_.Get();
}
inline void TXNStatusFees::_internal_set_native_function_fees(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.native_function_fees_.Set(value, GetArenaForAllocation());
}
inline std::string* TXNStatusFees::_internal_mutable_native_function_fees() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.native_function_fees_.Mutable(GetArenaForAllocation());
}
inline std::string* TXNStatusFees::release_native_function_fees() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNStatusFees.native_function_fees)
  if (!_internal_has_native_function_fees()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.native_function_fees_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.native_function_fees_.IsDefault()) {
    _impl_.native_function_fees_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TXNStatusFees::set_allocated_native_function_fees(std::string* native_function_fees) {
  if (native_function_fees != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.native_function_fees_.SetAllocated(native_function_fees, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.native_function_fees_.IsDefault()) {
    _impl_.native_function_fees_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNStatusFees.native_function_fees)
}

// optional uint64 gas = 13;
inline bool TXNStatusFees::_internal_has_gas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TXNStatusFees::has_gas() const {
  return _internal_has_gas();
}
inline void TXNStatusFees::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t TXNStatusFees::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TXNStatusFees::gas() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.gas)
  return _internal_gas();
}
inline void TXNStatusFees::_internal_set_gas(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.gas_ = value;
}
inline void TXNStatusFees::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.gas)
}

// repeated .zera_txn.DelegatedData delegated_data = 14;
inline int TXNStatusFees::_internal_delegated_data_size() const {
  return _impl_.delegated_data_.size();
}
inline int TXNStatusFees::delegated_data_size() const {
  return _internal_delegated_data_size();
}
inline void TXNStatusFees::clear_delegated_data() {
  _impl_.delegated_data_.Clear();
}
inline ::zera_txn::DelegatedData* TXNStatusFees::mutable_delegated_data(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.delegated_data)
  return _impl_.delegated_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedData >*
TXNStatusFees::mutable_delegated_data() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNStatusFees.delegated_data)
  return &_impl_.delegated_data_;
}
inline const ::zera_txn::DelegatedData& TXNStatusFees::_internal_delegated_data(int index) const {
  return _impl_.delegated_data_.Get(index);
}
inline const ::zera_txn::DelegatedData& TXNStatusFees::delegated_data(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.delegated_data)
  return _internal_delegated_data(index);
}
inline ::zera_txn::DelegatedData* TXNStatusFees::_internal_add_delegated_data() {
  return _impl_.delegated_data_.Add();
}
inline ::zera_txn::DelegatedData* TXNStatusFees::add_delegated_data() {
  ::zera_txn::DelegatedData* _add = _internal_add_delegated_data();
  // @@protoc_insertion_point(field_add:zera_txn.TXNStatusFees.delegated_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::DelegatedData >&
TXNStatusFees::delegated_data() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNStatusFees.delegated_data)
  return _impl_.delegated_data_;
}

// optional string interface_fee = 15;
inline bool TXNStatusFees::_internal_has_interface_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TXNStatusFees::has_interface_fee() const {
  return _internal_has_interface_fee();
}
inline void TXNStatusFees::clear_interface_fee() {
  _impl_.interface_fee_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TXNStatusFees::interface_fee() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.interface_fee)
  return _internal_interface_fee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXNStatusFees::set_interface_fee(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.interface_fee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.interface_fee)
}
inline std::string* TXNStatusFees::mutable_interface_fee() {
  std::string* _s = _internal_mutable_interface_fee();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.interface_fee)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_interface_fee() const {
  return _impl_.interface_fee_.Get();
}
inline void TXNStatusFees::_internal_set_interface_fee(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.interface_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* TXNStatusFees::_internal_mutable_interface_fee() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.interface_fee_.Mutable(GetArenaForAllocation());
}
inline std::string* TXNStatusFees::release_interface_fee() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNStatusFees.interface_fee)
  if (!_internal_has_interface_fee()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.interface_fee_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_fee_.IsDefault()) {
    _impl_.interface_fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TXNStatusFees::set_allocated_interface_fee(std::string* interface_fee) {
  if (interface_fee != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.interface_fee_.SetAllocated(interface_fee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_fee_.IsDefault()) {
    _impl_.interface_fee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNStatusFees.interface_fee)
}

// optional string interface_fee_id = 16;
inline bool TXNStatusFees::_internal_has_interface_fee_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TXNStatusFees::has_interface_fee_id() const {
  return _internal_has_interface_fee_id();
}
inline void TXNStatusFees::clear_interface_fee_id() {
  _impl_.interface_fee_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TXNStatusFees::interface_fee_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNStatusFees.interface_fee_id)
  return _internal_interface_fee_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXNStatusFees::set_interface_fee_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.interface_fee_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.TXNStatusFees.interface_fee_id)
}
inline std::string* TXNStatusFees::mutable_interface_fee_id() {
  std::string* _s = _internal_mutable_interface_fee_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNStatusFees.interface_fee_id)
  return _s;
}
inline const std::string& TXNStatusFees::_internal_interface_fee_id() const {
  return _impl_.interface_fee_id_.Get();
}
inline void TXNStatusFees::_internal_set_interface_fee_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.interface_fee_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TXNStatusFees::_internal_mutable_interface_fee_id() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.interface_fee_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TXNStatusFees::release_interface_fee_id() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNStatusFees.interface_fee_id)
  if (!_internal_has_interface_fee_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.interface_fee_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_fee_id_.IsDefault()) {
    _impl_.interface_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TXNStatusFees::set_allocated_interface_fee_id(std::string* interface_fee_id) {
  if (interface_fee_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.interface_fee_id_.SetAllocated(interface_fee_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_fee_id_.IsDefault()) {
    _impl_.interface_fee_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNStatusFees.interface_fee_id)
}

// -------------------------------------------------------------------

// ProposalContract

// string contract_id = 1;
inline void ProposalContract::clear_contract_id() {
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ProposalContract::contract_id() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalContract.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalContract::set_contract_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zera_txn.ProposalContract.contract_id)
}
inline std::string* ProposalContract::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalContract.contract_id)
  return _s;
}
inline const std::string& ProposalContract::_internal_contract_id() const {
  return _impl_.contract_id_.Get();
}
inline void ProposalContract::_internal_set_contract_id(const std::string& value) {
  
  _impl_.contract_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalContract::_internal_mutable_contract_id() {
  
  return _impl_.contract_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalContract::release_contract_id() {
  // @@protoc_insertion_point(field_release:zera_txn.ProposalContract.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ProposalContract::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    
  } else {
    
  }
  _impl_.contract_id_.SetAllocated(contract_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zera_txn.ProposalContract.contract_id)
}

// repeated bytes proposal_ids = 2;
inline int ProposalContract::_internal_proposal_ids_size() const {
  return _impl_.proposal_ids_.size();
}
inline int ProposalContract::proposal_ids_size() const {
  return _internal_proposal_ids_size();
}
inline void ProposalContract::clear_proposal_ids() {
  _impl_.proposal_ids_.Clear();
}
inline std::string* ProposalContract::add_proposal_ids() {
  std::string* _s = _internal_add_proposal_ids();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.ProposalContract.proposal_ids)
  return _s;
}
inline const std::string& ProposalContract::_internal_proposal_ids(int index) const {
  return _impl_.proposal_ids_.Get(index);
}
inline const std::string& ProposalContract::proposal_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalContract.proposal_ids)
  return _internal_proposal_ids(index);
}
inline std::string* ProposalContract::mutable_proposal_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.ProposalContract.proposal_ids)
  return _impl_.proposal_ids_.Mutable(index);
}
inline void ProposalContract::set_proposal_ids(int index, const std::string& value) {
  _impl_.proposal_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.ProposalContract.proposal_ids)
}
inline void ProposalContract::set_proposal_ids(int index, std::string&& value) {
  _impl_.proposal_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.ProposalContract.proposal_ids)
}
inline void ProposalContract::set_proposal_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proposal_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.ProposalContract.proposal_ids)
}
inline void ProposalContract::set_proposal_ids(int index, const void* value, size_t size) {
  _impl_.proposal_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.ProposalContract.proposal_ids)
}
inline std::string* ProposalContract::_internal_add_proposal_ids() {
  return _impl_.proposal_ids_.Add();
}
inline void ProposalContract::add_proposal_ids(const std::string& value) {
  _impl_.proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.ProposalContract.proposal_ids)
}
inline void ProposalContract::add_proposal_ids(std::string&& value) {
  _impl_.proposal_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.ProposalContract.proposal_ids)
}
inline void ProposalContract::add_proposal_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.ProposalContract.proposal_ids)
}
inline void ProposalContract::add_proposal_ids(const void* value, size_t size) {
  _impl_.proposal_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.ProposalContract.proposal_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProposalContract::proposal_ids() const {
  // @@protoc_insertion_point(field_list:zera_txn.ProposalContract.proposal_ids)
  return _impl_.proposal_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProposalContract::mutable_proposal_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.ProposalContract.proposal_ids)
  return &_impl_.proposal_ids_;
}

// uint32 stage = 3;
inline void ProposalContract::clear_stage() {
  _impl_.stage_ = 0u;
}
inline uint32_t ProposalContract::_internal_stage() const {
  return _impl_.stage_;
}
inline uint32_t ProposalContract::stage() const {
  // @@protoc_insertion_point(field_get:zera_txn.ProposalContract.stage)
  return _internal_stage();
}
inline void ProposalContract::_internal_set_stage(uint32_t value) {
  
  _impl_.stage_ = value;
}
inline void ProposalContract::set_stage(uint32_t value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:zera_txn.ProposalContract.stage)
}

// -------------------------------------------------------------------

// TXNWrapper

// .zera_txn.CoinTXN coin_txn = 1;
inline bool TXNWrapper::_internal_has_coin_txn() const {
  return payload_case() == kCoinTxn;
}
inline bool TXNWrapper::has_coin_txn() const {
  return _internal_has_coin_txn();
}
inline void TXNWrapper::set_has_coin_txn() {
  _impl_._oneof_case_[0] = kCoinTxn;
}
inline void TXNWrapper::clear_coin_txn() {
  if (_internal_has_coin_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.coin_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::CoinTXN* TXNWrapper::release_coin_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.coin_txn)
  if (_internal_has_coin_txn()) {
    clear_has_payload();
    ::zera_txn::CoinTXN* temp = _impl_.payload_.coin_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.coin_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::CoinTXN& TXNWrapper::_internal_coin_txn() const {
  return _internal_has_coin_txn()
      ? *_impl_.payload_.coin_txn_
      : reinterpret_cast< ::zera_txn::CoinTXN&>(::zera_txn::_CoinTXN_default_instance_);
}
inline const ::zera_txn::CoinTXN& TXNWrapper::coin_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.coin_txn)
  return _internal_coin_txn();
}
inline ::zera_txn::CoinTXN* TXNWrapper::unsafe_arena_release_coin_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.coin_txn)
  if (_internal_has_coin_txn()) {
    clear_has_payload();
    ::zera_txn::CoinTXN* temp = _impl_.payload_.coin_txn_;
    _impl_.payload_.coin_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_coin_txn(::zera_txn::CoinTXN* coin_txn) {
  clear_payload();
  if (coin_txn) {
    set_has_coin_txn();
    _impl_.payload_.coin_txn_ = coin_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.coin_txn)
}
inline ::zera_txn::CoinTXN* TXNWrapper::_internal_mutable_coin_txn() {
  if (!_internal_has_coin_txn()) {
    clear_payload();
    set_has_coin_txn();
    _impl_.payload_.coin_txn_ = CreateMaybeMessage< ::zera_txn::CoinTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.coin_txn_;
}
inline ::zera_txn::CoinTXN* TXNWrapper::mutable_coin_txn() {
  ::zera_txn::CoinTXN* _msg = _internal_mutable_coin_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.coin_txn)
  return _msg;
}

// .zera_txn.MintTXN mint_txn = 2;
inline bool TXNWrapper::_internal_has_mint_txn() const {
  return payload_case() == kMintTxn;
}
inline bool TXNWrapper::has_mint_txn() const {
  return _internal_has_mint_txn();
}
inline void TXNWrapper::set_has_mint_txn() {
  _impl_._oneof_case_[0] = kMintTxn;
}
inline void TXNWrapper::clear_mint_txn() {
  if (_internal_has_mint_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.mint_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::MintTXN* TXNWrapper::release_mint_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.mint_txn)
  if (_internal_has_mint_txn()) {
    clear_has_payload();
    ::zera_txn::MintTXN* temp = _impl_.payload_.mint_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.mint_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::MintTXN& TXNWrapper::_internal_mint_txn() const {
  return _internal_has_mint_txn()
      ? *_impl_.payload_.mint_txn_
      : reinterpret_cast< ::zera_txn::MintTXN&>(::zera_txn::_MintTXN_default_instance_);
}
inline const ::zera_txn::MintTXN& TXNWrapper::mint_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.mint_txn)
  return _internal_mint_txn();
}
inline ::zera_txn::MintTXN* TXNWrapper::unsafe_arena_release_mint_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.mint_txn)
  if (_internal_has_mint_txn()) {
    clear_has_payload();
    ::zera_txn::MintTXN* temp = _impl_.payload_.mint_txn_;
    _impl_.payload_.mint_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_mint_txn(::zera_txn::MintTXN* mint_txn) {
  clear_payload();
  if (mint_txn) {
    set_has_mint_txn();
    _impl_.payload_.mint_txn_ = mint_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.mint_txn)
}
inline ::zera_txn::MintTXN* TXNWrapper::_internal_mutable_mint_txn() {
  if (!_internal_has_mint_txn()) {
    clear_payload();
    set_has_mint_txn();
    _impl_.payload_.mint_txn_ = CreateMaybeMessage< ::zera_txn::MintTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.mint_txn_;
}
inline ::zera_txn::MintTXN* TXNWrapper::mutable_mint_txn() {
  ::zera_txn::MintTXN* _msg = _internal_mutable_mint_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.mint_txn)
  return _msg;
}

// .zera_txn.ItemizedMintTXN item_mint_txn = 3;
inline bool TXNWrapper::_internal_has_item_mint_txn() const {
  return payload_case() == kItemMintTxn;
}
inline bool TXNWrapper::has_item_mint_txn() const {
  return _internal_has_item_mint_txn();
}
inline void TXNWrapper::set_has_item_mint_txn() {
  _impl_._oneof_case_[0] = kItemMintTxn;
}
inline void TXNWrapper::clear_item_mint_txn() {
  if (_internal_has_item_mint_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.item_mint_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::ItemizedMintTXN* TXNWrapper::release_item_mint_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.item_mint_txn)
  if (_internal_has_item_mint_txn()) {
    clear_has_payload();
    ::zera_txn::ItemizedMintTXN* temp = _impl_.payload_.item_mint_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.item_mint_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::ItemizedMintTXN& TXNWrapper::_internal_item_mint_txn() const {
  return _internal_has_item_mint_txn()
      ? *_impl_.payload_.item_mint_txn_
      : reinterpret_cast< ::zera_txn::ItemizedMintTXN&>(::zera_txn::_ItemizedMintTXN_default_instance_);
}
inline const ::zera_txn::ItemizedMintTXN& TXNWrapper::item_mint_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.item_mint_txn)
  return _internal_item_mint_txn();
}
inline ::zera_txn::ItemizedMintTXN* TXNWrapper::unsafe_arena_release_item_mint_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.item_mint_txn)
  if (_internal_has_item_mint_txn()) {
    clear_has_payload();
    ::zera_txn::ItemizedMintTXN* temp = _impl_.payload_.item_mint_txn_;
    _impl_.payload_.item_mint_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_item_mint_txn(::zera_txn::ItemizedMintTXN* item_mint_txn) {
  clear_payload();
  if (item_mint_txn) {
    set_has_item_mint_txn();
    _impl_.payload_.item_mint_txn_ = item_mint_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.item_mint_txn)
}
inline ::zera_txn::ItemizedMintTXN* TXNWrapper::_internal_mutable_item_mint_txn() {
  if (!_internal_has_item_mint_txn()) {
    clear_payload();
    set_has_item_mint_txn();
    _impl_.payload_.item_mint_txn_ = CreateMaybeMessage< ::zera_txn::ItemizedMintTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.item_mint_txn_;
}
inline ::zera_txn::ItemizedMintTXN* TXNWrapper::mutable_item_mint_txn() {
  ::zera_txn::ItemizedMintTXN* _msg = _internal_mutable_item_mint_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.item_mint_txn)
  return _msg;
}

// .zera_txn.InstrumentContract contract_txn = 4;
inline bool TXNWrapper::_internal_has_contract_txn() const {
  return payload_case() == kContractTxn;
}
inline bool TXNWrapper::has_contract_txn() const {
  return _internal_has_contract_txn();
}
inline void TXNWrapper::set_has_contract_txn() {
  _impl_._oneof_case_[0] = kContractTxn;
}
inline void TXNWrapper::clear_contract_txn() {
  if (_internal_has_contract_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.contract_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::InstrumentContract* TXNWrapper::release_contract_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.contract_txn)
  if (_internal_has_contract_txn()) {
    clear_has_payload();
    ::zera_txn::InstrumentContract* temp = _impl_.payload_.contract_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.contract_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::InstrumentContract& TXNWrapper::_internal_contract_txn() const {
  return _internal_has_contract_txn()
      ? *_impl_.payload_.contract_txn_
      : reinterpret_cast< ::zera_txn::InstrumentContract&>(::zera_txn::_InstrumentContract_default_instance_);
}
inline const ::zera_txn::InstrumentContract& TXNWrapper::contract_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.contract_txn)
  return _internal_contract_txn();
}
inline ::zera_txn::InstrumentContract* TXNWrapper::unsafe_arena_release_contract_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.contract_txn)
  if (_internal_has_contract_txn()) {
    clear_has_payload();
    ::zera_txn::InstrumentContract* temp = _impl_.payload_.contract_txn_;
    _impl_.payload_.contract_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_contract_txn(::zera_txn::InstrumentContract* contract_txn) {
  clear_payload();
  if (contract_txn) {
    set_has_contract_txn();
    _impl_.payload_.contract_txn_ = contract_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.contract_txn)
}
inline ::zera_txn::InstrumentContract* TXNWrapper::_internal_mutable_contract_txn() {
  if (!_internal_has_contract_txn()) {
    clear_payload();
    set_has_contract_txn();
    _impl_.payload_.contract_txn_ = CreateMaybeMessage< ::zera_txn::InstrumentContract >(GetArenaForAllocation());
  }
  return _impl_.payload_.contract_txn_;
}
inline ::zera_txn::InstrumentContract* TXNWrapper::mutable_contract_txn() {
  ::zera_txn::InstrumentContract* _msg = _internal_mutable_contract_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.contract_txn)
  return _msg;
}

// .zera_txn.GovernanceVote governance_vote = 5;
inline bool TXNWrapper::_internal_has_governance_vote() const {
  return payload_case() == kGovernanceVote;
}
inline bool TXNWrapper::has_governance_vote() const {
  return _internal_has_governance_vote();
}
inline void TXNWrapper::set_has_governance_vote() {
  _impl_._oneof_case_[0] = kGovernanceVote;
}
inline void TXNWrapper::clear_governance_vote() {
  if (_internal_has_governance_vote()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.governance_vote_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::GovernanceVote* TXNWrapper::release_governance_vote() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.governance_vote)
  if (_internal_has_governance_vote()) {
    clear_has_payload();
    ::zera_txn::GovernanceVote* temp = _impl_.payload_.governance_vote_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.governance_vote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::GovernanceVote& TXNWrapper::_internal_governance_vote() const {
  return _internal_has_governance_vote()
      ? *_impl_.payload_.governance_vote_
      : reinterpret_cast< ::zera_txn::GovernanceVote&>(::zera_txn::_GovernanceVote_default_instance_);
}
inline const ::zera_txn::GovernanceVote& TXNWrapper::governance_vote() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.governance_vote)
  return _internal_governance_vote();
}
inline ::zera_txn::GovernanceVote* TXNWrapper::unsafe_arena_release_governance_vote() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.governance_vote)
  if (_internal_has_governance_vote()) {
    clear_has_payload();
    ::zera_txn::GovernanceVote* temp = _impl_.payload_.governance_vote_;
    _impl_.payload_.governance_vote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_governance_vote(::zera_txn::GovernanceVote* governance_vote) {
  clear_payload();
  if (governance_vote) {
    set_has_governance_vote();
    _impl_.payload_.governance_vote_ = governance_vote;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.governance_vote)
}
inline ::zera_txn::GovernanceVote* TXNWrapper::_internal_mutable_governance_vote() {
  if (!_internal_has_governance_vote()) {
    clear_payload();
    set_has_governance_vote();
    _impl_.payload_.governance_vote_ = CreateMaybeMessage< ::zera_txn::GovernanceVote >(GetArenaForAllocation());
  }
  return _impl_.payload_.governance_vote_;
}
inline ::zera_txn::GovernanceVote* TXNWrapper::mutable_governance_vote() {
  ::zera_txn::GovernanceVote* _msg = _internal_mutable_governance_vote();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.governance_vote)
  return _msg;
}

// .zera_txn.GovernanceProposal governance_proposal = 6;
inline bool TXNWrapper::_internal_has_governance_proposal() const {
  return payload_case() == kGovernanceProposal;
}
inline bool TXNWrapper::has_governance_proposal() const {
  return _internal_has_governance_proposal();
}
inline void TXNWrapper::set_has_governance_proposal() {
  _impl_._oneof_case_[0] = kGovernanceProposal;
}
inline void TXNWrapper::clear_governance_proposal() {
  if (_internal_has_governance_proposal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.governance_proposal_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::GovernanceProposal* TXNWrapper::release_governance_proposal() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.governance_proposal)
  if (_internal_has_governance_proposal()) {
    clear_has_payload();
    ::zera_txn::GovernanceProposal* temp = _impl_.payload_.governance_proposal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.governance_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::GovernanceProposal& TXNWrapper::_internal_governance_proposal() const {
  return _internal_has_governance_proposal()
      ? *_impl_.payload_.governance_proposal_
      : reinterpret_cast< ::zera_txn::GovernanceProposal&>(::zera_txn::_GovernanceProposal_default_instance_);
}
inline const ::zera_txn::GovernanceProposal& TXNWrapper::governance_proposal() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.governance_proposal)
  return _internal_governance_proposal();
}
inline ::zera_txn::GovernanceProposal* TXNWrapper::unsafe_arena_release_governance_proposal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.governance_proposal)
  if (_internal_has_governance_proposal()) {
    clear_has_payload();
    ::zera_txn::GovernanceProposal* temp = _impl_.payload_.governance_proposal_;
    _impl_.payload_.governance_proposal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_governance_proposal(::zera_txn::GovernanceProposal* governance_proposal) {
  clear_payload();
  if (governance_proposal) {
    set_has_governance_proposal();
    _impl_.payload_.governance_proposal_ = governance_proposal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.governance_proposal)
}
inline ::zera_txn::GovernanceProposal* TXNWrapper::_internal_mutable_governance_proposal() {
  if (!_internal_has_governance_proposal()) {
    clear_payload();
    set_has_governance_proposal();
    _impl_.payload_.governance_proposal_ = CreateMaybeMessage< ::zera_txn::GovernanceProposal >(GetArenaForAllocation());
  }
  return _impl_.payload_.governance_proposal_;
}
inline ::zera_txn::GovernanceProposal* TXNWrapper::mutable_governance_proposal() {
  ::zera_txn::GovernanceProposal* _msg = _internal_mutable_governance_proposal();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.governance_proposal)
  return _msg;
}

// .zera_txn.SmartContractTXN smart_contract = 7;
inline bool TXNWrapper::_internal_has_smart_contract() const {
  return payload_case() == kSmartContract;
}
inline bool TXNWrapper::has_smart_contract() const {
  return _internal_has_smart_contract();
}
inline void TXNWrapper::set_has_smart_contract() {
  _impl_._oneof_case_[0] = kSmartContract;
}
inline void TXNWrapper::clear_smart_contract() {
  if (_internal_has_smart_contract()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.smart_contract_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::SmartContractTXN* TXNWrapper::release_smart_contract() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.smart_contract)
  if (_internal_has_smart_contract()) {
    clear_has_payload();
    ::zera_txn::SmartContractTXN* temp = _impl_.payload_.smart_contract_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.smart_contract_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::SmartContractTXN& TXNWrapper::_internal_smart_contract() const {
  return _internal_has_smart_contract()
      ? *_impl_.payload_.smart_contract_
      : reinterpret_cast< ::zera_txn::SmartContractTXN&>(::zera_txn::_SmartContractTXN_default_instance_);
}
inline const ::zera_txn::SmartContractTXN& TXNWrapper::smart_contract() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.smart_contract)
  return _internal_smart_contract();
}
inline ::zera_txn::SmartContractTXN* TXNWrapper::unsafe_arena_release_smart_contract() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.smart_contract)
  if (_internal_has_smart_contract()) {
    clear_has_payload();
    ::zera_txn::SmartContractTXN* temp = _impl_.payload_.smart_contract_;
    _impl_.payload_.smart_contract_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_smart_contract(::zera_txn::SmartContractTXN* smart_contract) {
  clear_payload();
  if (smart_contract) {
    set_has_smart_contract();
    _impl_.payload_.smart_contract_ = smart_contract;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.smart_contract)
}
inline ::zera_txn::SmartContractTXN* TXNWrapper::_internal_mutable_smart_contract() {
  if (!_internal_has_smart_contract()) {
    clear_payload();
    set_has_smart_contract();
    _impl_.payload_.smart_contract_ = CreateMaybeMessage< ::zera_txn::SmartContractTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.smart_contract_;
}
inline ::zera_txn::SmartContractTXN* TXNWrapper::mutable_smart_contract() {
  ::zera_txn::SmartContractTXN* _msg = _internal_mutable_smart_contract();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.smart_contract)
  return _msg;
}

// .zera_txn.SmartContractExecuteTXN smart_contract_execute = 8;
inline bool TXNWrapper::_internal_has_smart_contract_execute() const {
  return payload_case() == kSmartContractExecute;
}
inline bool TXNWrapper::has_smart_contract_execute() const {
  return _internal_has_smart_contract_execute();
}
inline void TXNWrapper::set_has_smart_contract_execute() {
  _impl_._oneof_case_[0] = kSmartContractExecute;
}
inline void TXNWrapper::clear_smart_contract_execute() {
  if (_internal_has_smart_contract_execute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.smart_contract_execute_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::SmartContractExecuteTXN* TXNWrapper::release_smart_contract_execute() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.smart_contract_execute)
  if (_internal_has_smart_contract_execute()) {
    clear_has_payload();
    ::zera_txn::SmartContractExecuteTXN* temp = _impl_.payload_.smart_contract_execute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.smart_contract_execute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::SmartContractExecuteTXN& TXNWrapper::_internal_smart_contract_execute() const {
  return _internal_has_smart_contract_execute()
      ? *_impl_.payload_.smart_contract_execute_
      : reinterpret_cast< ::zera_txn::SmartContractExecuteTXN&>(::zera_txn::_SmartContractExecuteTXN_default_instance_);
}
inline const ::zera_txn::SmartContractExecuteTXN& TXNWrapper::smart_contract_execute() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.smart_contract_execute)
  return _internal_smart_contract_execute();
}
inline ::zera_txn::SmartContractExecuteTXN* TXNWrapper::unsafe_arena_release_smart_contract_execute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.smart_contract_execute)
  if (_internal_has_smart_contract_execute()) {
    clear_has_payload();
    ::zera_txn::SmartContractExecuteTXN* temp = _impl_.payload_.smart_contract_execute_;
    _impl_.payload_.smart_contract_execute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_smart_contract_execute(::zera_txn::SmartContractExecuteTXN* smart_contract_execute) {
  clear_payload();
  if (smart_contract_execute) {
    set_has_smart_contract_execute();
    _impl_.payload_.smart_contract_execute_ = smart_contract_execute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.smart_contract_execute)
}
inline ::zera_txn::SmartContractExecuteTXN* TXNWrapper::_internal_mutable_smart_contract_execute() {
  if (!_internal_has_smart_contract_execute()) {
    clear_payload();
    set_has_smart_contract_execute();
    _impl_.payload_.smart_contract_execute_ = CreateMaybeMessage< ::zera_txn::SmartContractExecuteTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.smart_contract_execute_;
}
inline ::zera_txn::SmartContractExecuteTXN* TXNWrapper::mutable_smart_contract_execute() {
  ::zera_txn::SmartContractExecuteTXN* _msg = _internal_mutable_smart_contract_execute();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.smart_contract_execute)
  return _msg;
}

// .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
inline bool TXNWrapper::_internal_has_self_cur_equivs() const {
  return payload_case() == kSelfCurEquivs;
}
inline bool TXNWrapper::has_self_cur_equivs() const {
  return _internal_has_self_cur_equivs();
}
inline void TXNWrapper::set_has_self_cur_equivs() {
  _impl_._oneof_case_[0] = kSelfCurEquivs;
}
inline void TXNWrapper::clear_self_cur_equivs() {
  if (_internal_has_self_cur_equivs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.self_cur_equivs_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::SelfCurrencyEquiv* TXNWrapper::release_self_cur_equivs() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.self_cur_equivs)
  if (_internal_has_self_cur_equivs()) {
    clear_has_payload();
    ::zera_txn::SelfCurrencyEquiv* temp = _impl_.payload_.self_cur_equivs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.self_cur_equivs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::SelfCurrencyEquiv& TXNWrapper::_internal_self_cur_equivs() const {
  return _internal_has_self_cur_equivs()
      ? *_impl_.payload_.self_cur_equivs_
      : reinterpret_cast< ::zera_txn::SelfCurrencyEquiv&>(::zera_txn::_SelfCurrencyEquiv_default_instance_);
}
inline const ::zera_txn::SelfCurrencyEquiv& TXNWrapper::self_cur_equivs() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.self_cur_equivs)
  return _internal_self_cur_equivs();
}
inline ::zera_txn::SelfCurrencyEquiv* TXNWrapper::unsafe_arena_release_self_cur_equivs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.self_cur_equivs)
  if (_internal_has_self_cur_equivs()) {
    clear_has_payload();
    ::zera_txn::SelfCurrencyEquiv* temp = _impl_.payload_.self_cur_equivs_;
    _impl_.payload_.self_cur_equivs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_self_cur_equivs(::zera_txn::SelfCurrencyEquiv* self_cur_equivs) {
  clear_payload();
  if (self_cur_equivs) {
    set_has_self_cur_equivs();
    _impl_.payload_.self_cur_equivs_ = self_cur_equivs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.self_cur_equivs)
}
inline ::zera_txn::SelfCurrencyEquiv* TXNWrapper::_internal_mutable_self_cur_equivs() {
  if (!_internal_has_self_cur_equivs()) {
    clear_payload();
    set_has_self_cur_equivs();
    _impl_.payload_.self_cur_equivs_ = CreateMaybeMessage< ::zera_txn::SelfCurrencyEquiv >(GetArenaForAllocation());
  }
  return _impl_.payload_.self_cur_equivs_;
}
inline ::zera_txn::SelfCurrencyEquiv* TXNWrapper::mutable_self_cur_equivs() {
  ::zera_txn::SelfCurrencyEquiv* _msg = _internal_mutable_self_cur_equivs();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.self_cur_equivs)
  return _msg;
}

// .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
inline bool TXNWrapper::_internal_has_auth_cur_equivs() const {
  return payload_case() == kAuthCurEquivs;
}
inline bool TXNWrapper::has_auth_cur_equivs() const {
  return _internal_has_auth_cur_equivs();
}
inline void TXNWrapper::set_has_auth_cur_equivs() {
  _impl_._oneof_case_[0] = kAuthCurEquivs;
}
inline void TXNWrapper::clear_auth_cur_equivs() {
  if (_internal_has_auth_cur_equivs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.auth_cur_equivs_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::AuthorizedCurrencyEquiv* TXNWrapper::release_auth_cur_equivs() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.auth_cur_equivs)
  if (_internal_has_auth_cur_equivs()) {
    clear_has_payload();
    ::zera_txn::AuthorizedCurrencyEquiv* temp = _impl_.payload_.auth_cur_equivs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.auth_cur_equivs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::AuthorizedCurrencyEquiv& TXNWrapper::_internal_auth_cur_equivs() const {
  return _internal_has_auth_cur_equivs()
      ? *_impl_.payload_.auth_cur_equivs_
      : reinterpret_cast< ::zera_txn::AuthorizedCurrencyEquiv&>(::zera_txn::_AuthorizedCurrencyEquiv_default_instance_);
}
inline const ::zera_txn::AuthorizedCurrencyEquiv& TXNWrapper::auth_cur_equivs() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.auth_cur_equivs)
  return _internal_auth_cur_equivs();
}
inline ::zera_txn::AuthorizedCurrencyEquiv* TXNWrapper::unsafe_arena_release_auth_cur_equivs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.auth_cur_equivs)
  if (_internal_has_auth_cur_equivs()) {
    clear_has_payload();
    ::zera_txn::AuthorizedCurrencyEquiv* temp = _impl_.payload_.auth_cur_equivs_;
    _impl_.payload_.auth_cur_equivs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_auth_cur_equivs(::zera_txn::AuthorizedCurrencyEquiv* auth_cur_equivs) {
  clear_payload();
  if (auth_cur_equivs) {
    set_has_auth_cur_equivs();
    _impl_.payload_.auth_cur_equivs_ = auth_cur_equivs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.auth_cur_equivs)
}
inline ::zera_txn::AuthorizedCurrencyEquiv* TXNWrapper::_internal_mutable_auth_cur_equivs() {
  if (!_internal_has_auth_cur_equivs()) {
    clear_payload();
    set_has_auth_cur_equivs();
    _impl_.payload_.auth_cur_equivs_ = CreateMaybeMessage< ::zera_txn::AuthorizedCurrencyEquiv >(GetArenaForAllocation());
  }
  return _impl_.payload_.auth_cur_equivs_;
}
inline ::zera_txn::AuthorizedCurrencyEquiv* TXNWrapper::mutable_auth_cur_equivs() {
  ::zera_txn::AuthorizedCurrencyEquiv* _msg = _internal_mutable_auth_cur_equivs();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.auth_cur_equivs)
  return _msg;
}

// .zera_txn.ExpenseRatioTXN expense_ratios = 11;
inline bool TXNWrapper::_internal_has_expense_ratios() const {
  return payload_case() == kExpenseRatios;
}
inline bool TXNWrapper::has_expense_ratios() const {
  return _internal_has_expense_ratios();
}
inline void TXNWrapper::set_has_expense_ratios() {
  _impl_._oneof_case_[0] = kExpenseRatios;
}
inline void TXNWrapper::clear_expense_ratios() {
  if (_internal_has_expense_ratios()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.expense_ratios_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::ExpenseRatioTXN* TXNWrapper::release_expense_ratios() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.expense_ratios)
  if (_internal_has_expense_ratios()) {
    clear_has_payload();
    ::zera_txn::ExpenseRatioTXN* temp = _impl_.payload_.expense_ratios_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.expense_ratios_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::ExpenseRatioTXN& TXNWrapper::_internal_expense_ratios() const {
  return _internal_has_expense_ratios()
      ? *_impl_.payload_.expense_ratios_
      : reinterpret_cast< ::zera_txn::ExpenseRatioTXN&>(::zera_txn::_ExpenseRatioTXN_default_instance_);
}
inline const ::zera_txn::ExpenseRatioTXN& TXNWrapper::expense_ratios() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.expense_ratios)
  return _internal_expense_ratios();
}
inline ::zera_txn::ExpenseRatioTXN* TXNWrapper::unsafe_arena_release_expense_ratios() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.expense_ratios)
  if (_internal_has_expense_ratios()) {
    clear_has_payload();
    ::zera_txn::ExpenseRatioTXN* temp = _impl_.payload_.expense_ratios_;
    _impl_.payload_.expense_ratios_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_expense_ratios(::zera_txn::ExpenseRatioTXN* expense_ratios) {
  clear_payload();
  if (expense_ratios) {
    set_has_expense_ratios();
    _impl_.payload_.expense_ratios_ = expense_ratios;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.expense_ratios)
}
inline ::zera_txn::ExpenseRatioTXN* TXNWrapper::_internal_mutable_expense_ratios() {
  if (!_internal_has_expense_ratios()) {
    clear_payload();
    set_has_expense_ratios();
    _impl_.payload_.expense_ratios_ = CreateMaybeMessage< ::zera_txn::ExpenseRatioTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.expense_ratios_;
}
inline ::zera_txn::ExpenseRatioTXN* TXNWrapper::mutable_expense_ratios() {
  ::zera_txn::ExpenseRatioTXN* _msg = _internal_mutable_expense_ratios();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.expense_ratios)
  return _msg;
}

// .zera_txn.NFTTXN nft_txn = 12;
inline bool TXNWrapper::_internal_has_nft_txn() const {
  return payload_case() == kNftTxn;
}
inline bool TXNWrapper::has_nft_txn() const {
  return _internal_has_nft_txn();
}
inline void TXNWrapper::set_has_nft_txn() {
  _impl_._oneof_case_[0] = kNftTxn;
}
inline void TXNWrapper::clear_nft_txn() {
  if (_internal_has_nft_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.nft_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::NFTTXN* TXNWrapper::release_nft_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.nft_txn)
  if (_internal_has_nft_txn()) {
    clear_has_payload();
    ::zera_txn::NFTTXN* temp = _impl_.payload_.nft_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nft_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::NFTTXN& TXNWrapper::_internal_nft_txn() const {
  return _internal_has_nft_txn()
      ? *_impl_.payload_.nft_txn_
      : reinterpret_cast< ::zera_txn::NFTTXN&>(::zera_txn::_NFTTXN_default_instance_);
}
inline const ::zera_txn::NFTTXN& TXNWrapper::nft_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.nft_txn)
  return _internal_nft_txn();
}
inline ::zera_txn::NFTTXN* TXNWrapper::unsafe_arena_release_nft_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.nft_txn)
  if (_internal_has_nft_txn()) {
    clear_has_payload();
    ::zera_txn::NFTTXN* temp = _impl_.payload_.nft_txn_;
    _impl_.payload_.nft_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_nft_txn(::zera_txn::NFTTXN* nft_txn) {
  clear_payload();
  if (nft_txn) {
    set_has_nft_txn();
    _impl_.payload_.nft_txn_ = nft_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.nft_txn)
}
inline ::zera_txn::NFTTXN* TXNWrapper::_internal_mutable_nft_txn() {
  if (!_internal_has_nft_txn()) {
    clear_payload();
    set_has_nft_txn();
    _impl_.payload_.nft_txn_ = CreateMaybeMessage< ::zera_txn::NFTTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.nft_txn_;
}
inline ::zera_txn::NFTTXN* TXNWrapper::mutable_nft_txn() {
  ::zera_txn::NFTTXN* _msg = _internal_mutable_nft_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.nft_txn)
  return _msg;
}

// .zera_txn.ContractUpdateTXN contract_update_txn = 13;
inline bool TXNWrapper::_internal_has_contract_update_txn() const {
  return payload_case() == kContractUpdateTxn;
}
inline bool TXNWrapper::has_contract_update_txn() const {
  return _internal_has_contract_update_txn();
}
inline void TXNWrapper::set_has_contract_update_txn() {
  _impl_._oneof_case_[0] = kContractUpdateTxn;
}
inline void TXNWrapper::clear_contract_update_txn() {
  if (_internal_has_contract_update_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.contract_update_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::ContractUpdateTXN* TXNWrapper::release_contract_update_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.contract_update_txn)
  if (_internal_has_contract_update_txn()) {
    clear_has_payload();
    ::zera_txn::ContractUpdateTXN* temp = _impl_.payload_.contract_update_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.contract_update_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::ContractUpdateTXN& TXNWrapper::_internal_contract_update_txn() const {
  return _internal_has_contract_update_txn()
      ? *_impl_.payload_.contract_update_txn_
      : reinterpret_cast< ::zera_txn::ContractUpdateTXN&>(::zera_txn::_ContractUpdateTXN_default_instance_);
}
inline const ::zera_txn::ContractUpdateTXN& TXNWrapper::contract_update_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.contract_update_txn)
  return _internal_contract_update_txn();
}
inline ::zera_txn::ContractUpdateTXN* TXNWrapper::unsafe_arena_release_contract_update_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.contract_update_txn)
  if (_internal_has_contract_update_txn()) {
    clear_has_payload();
    ::zera_txn::ContractUpdateTXN* temp = _impl_.payload_.contract_update_txn_;
    _impl_.payload_.contract_update_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_contract_update_txn(::zera_txn::ContractUpdateTXN* contract_update_txn) {
  clear_payload();
  if (contract_update_txn) {
    set_has_contract_update_txn();
    _impl_.payload_.contract_update_txn_ = contract_update_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.contract_update_txn)
}
inline ::zera_txn::ContractUpdateTXN* TXNWrapper::_internal_mutable_contract_update_txn() {
  if (!_internal_has_contract_update_txn()) {
    clear_payload();
    set_has_contract_update_txn();
    _impl_.payload_.contract_update_txn_ = CreateMaybeMessage< ::zera_txn::ContractUpdateTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.contract_update_txn_;
}
inline ::zera_txn::ContractUpdateTXN* TXNWrapper::mutable_contract_update_txn() {
  ::zera_txn::ContractUpdateTXN* _msg = _internal_mutable_contract_update_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.contract_update_txn)
  return _msg;
}

// .zera_txn.ValidatorRegistration validator_registration_txn = 14;
inline bool TXNWrapper::_internal_has_validator_registration_txn() const {
  return payload_case() == kValidatorRegistrationTxn;
}
inline bool TXNWrapper::has_validator_registration_txn() const {
  return _internal_has_validator_registration_txn();
}
inline void TXNWrapper::set_has_validator_registration_txn() {
  _impl_._oneof_case_[0] = kValidatorRegistrationTxn;
}
inline void TXNWrapper::clear_validator_registration_txn() {
  if (_internal_has_validator_registration_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.validator_registration_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::ValidatorRegistration* TXNWrapper::release_validator_registration_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.validator_registration_txn)
  if (_internal_has_validator_registration_txn()) {
    clear_has_payload();
    ::zera_txn::ValidatorRegistration* temp = _impl_.payload_.validator_registration_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.validator_registration_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::ValidatorRegistration& TXNWrapper::_internal_validator_registration_txn() const {
  return _internal_has_validator_registration_txn()
      ? *_impl_.payload_.validator_registration_txn_
      : reinterpret_cast< ::zera_txn::ValidatorRegistration&>(::zera_txn::_ValidatorRegistration_default_instance_);
}
inline const ::zera_txn::ValidatorRegistration& TXNWrapper::validator_registration_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.validator_registration_txn)
  return _internal_validator_registration_txn();
}
inline ::zera_txn::ValidatorRegistration* TXNWrapper::unsafe_arena_release_validator_registration_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.validator_registration_txn)
  if (_internal_has_validator_registration_txn()) {
    clear_has_payload();
    ::zera_txn::ValidatorRegistration* temp = _impl_.payload_.validator_registration_txn_;
    _impl_.payload_.validator_registration_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_validator_registration_txn(::zera_txn::ValidatorRegistration* validator_registration_txn) {
  clear_payload();
  if (validator_registration_txn) {
    set_has_validator_registration_txn();
    _impl_.payload_.validator_registration_txn_ = validator_registration_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.validator_registration_txn)
}
inline ::zera_txn::ValidatorRegistration* TXNWrapper::_internal_mutable_validator_registration_txn() {
  if (!_internal_has_validator_registration_txn()) {
    clear_payload();
    set_has_validator_registration_txn();
    _impl_.payload_.validator_registration_txn_ = CreateMaybeMessage< ::zera_txn::ValidatorRegistration >(GetArenaForAllocation());
  }
  return _impl_.payload_.validator_registration_txn_;
}
inline ::zera_txn::ValidatorRegistration* TXNWrapper::mutable_validator_registration_txn() {
  ::zera_txn::ValidatorRegistration* _msg = _internal_mutable_validator_registration_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.validator_registration_txn)
  return _msg;
}

// .zera_txn.ValidatorHeartbeat validator_heartbeat_txn = 15;
inline bool TXNWrapper::_internal_has_validator_heartbeat_txn() const {
  return payload_case() == kValidatorHeartbeatTxn;
}
inline bool TXNWrapper::has_validator_heartbeat_txn() const {
  return _internal_has_validator_heartbeat_txn();
}
inline void TXNWrapper::set_has_validator_heartbeat_txn() {
  _impl_._oneof_case_[0] = kValidatorHeartbeatTxn;
}
inline void TXNWrapper::clear_validator_heartbeat_txn() {
  if (_internal_has_validator_heartbeat_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.validator_heartbeat_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::ValidatorHeartbeat* TXNWrapper::release_validator_heartbeat_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.validator_heartbeat_txn)
  if (_internal_has_validator_heartbeat_txn()) {
    clear_has_payload();
    ::zera_txn::ValidatorHeartbeat* temp = _impl_.payload_.validator_heartbeat_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.validator_heartbeat_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::ValidatorHeartbeat& TXNWrapper::_internal_validator_heartbeat_txn() const {
  return _internal_has_validator_heartbeat_txn()
      ? *_impl_.payload_.validator_heartbeat_txn_
      : reinterpret_cast< ::zera_txn::ValidatorHeartbeat&>(::zera_txn::_ValidatorHeartbeat_default_instance_);
}
inline const ::zera_txn::ValidatorHeartbeat& TXNWrapper::validator_heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.validator_heartbeat_txn)
  return _internal_validator_heartbeat_txn();
}
inline ::zera_txn::ValidatorHeartbeat* TXNWrapper::unsafe_arena_release_validator_heartbeat_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.validator_heartbeat_txn)
  if (_internal_has_validator_heartbeat_txn()) {
    clear_has_payload();
    ::zera_txn::ValidatorHeartbeat* temp = _impl_.payload_.validator_heartbeat_txn_;
    _impl_.payload_.validator_heartbeat_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_validator_heartbeat_txn(::zera_txn::ValidatorHeartbeat* validator_heartbeat_txn) {
  clear_payload();
  if (validator_heartbeat_txn) {
    set_has_validator_heartbeat_txn();
    _impl_.payload_.validator_heartbeat_txn_ = validator_heartbeat_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.validator_heartbeat_txn)
}
inline ::zera_txn::ValidatorHeartbeat* TXNWrapper::_internal_mutable_validator_heartbeat_txn() {
  if (!_internal_has_validator_heartbeat_txn()) {
    clear_payload();
    set_has_validator_heartbeat_txn();
    _impl_.payload_.validator_heartbeat_txn_ = CreateMaybeMessage< ::zera_txn::ValidatorHeartbeat >(GetArenaForAllocation());
  }
  return _impl_.payload_.validator_heartbeat_txn_;
}
inline ::zera_txn::ValidatorHeartbeat* TXNWrapper::mutable_validator_heartbeat_txn() {
  ::zera_txn::ValidatorHeartbeat* _msg = _internal_mutable_validator_heartbeat_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.validator_heartbeat_txn)
  return _msg;
}

// .zera_txn.FoundationTXN foundation_txn = 16;
inline bool TXNWrapper::_internal_has_foundation_txn() const {
  return payload_case() == kFoundationTxn;
}
inline bool TXNWrapper::has_foundation_txn() const {
  return _internal_has_foundation_txn();
}
inline void TXNWrapper::set_has_foundation_txn() {
  _impl_._oneof_case_[0] = kFoundationTxn;
}
inline void TXNWrapper::clear_foundation_txn() {
  if (_internal_has_foundation_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.foundation_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::FoundationTXN* TXNWrapper::release_foundation_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.foundation_txn)
  if (_internal_has_foundation_txn()) {
    clear_has_payload();
    ::zera_txn::FoundationTXN* temp = _impl_.payload_.foundation_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.foundation_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::FoundationTXN& TXNWrapper::_internal_foundation_txn() const {
  return _internal_has_foundation_txn()
      ? *_impl_.payload_.foundation_txn_
      : reinterpret_cast< ::zera_txn::FoundationTXN&>(::zera_txn::_FoundationTXN_default_instance_);
}
inline const ::zera_txn::FoundationTXN& TXNWrapper::foundation_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.foundation_txn)
  return _internal_foundation_txn();
}
inline ::zera_txn::FoundationTXN* TXNWrapper::unsafe_arena_release_foundation_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.foundation_txn)
  if (_internal_has_foundation_txn()) {
    clear_has_payload();
    ::zera_txn::FoundationTXN* temp = _impl_.payload_.foundation_txn_;
    _impl_.payload_.foundation_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_foundation_txn(::zera_txn::FoundationTXN* foundation_txn) {
  clear_payload();
  if (foundation_txn) {
    set_has_foundation_txn();
    _impl_.payload_.foundation_txn_ = foundation_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.foundation_txn)
}
inline ::zera_txn::FoundationTXN* TXNWrapper::_internal_mutable_foundation_txn() {
  if (!_internal_has_foundation_txn()) {
    clear_payload();
    set_has_foundation_txn();
    _impl_.payload_.foundation_txn_ = CreateMaybeMessage< ::zera_txn::FoundationTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.foundation_txn_;
}
inline ::zera_txn::FoundationTXN* TXNWrapper::mutable_foundation_txn() {
  ::zera_txn::FoundationTXN* _msg = _internal_mutable_foundation_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.foundation_txn)
  return _msg;
}

// .zera_txn.DelegatedTXN delegated_voting_txn = 17;
inline bool TXNWrapper::_internal_has_delegated_voting_txn() const {
  return payload_case() == kDelegatedVotingTxn;
}
inline bool TXNWrapper::has_delegated_voting_txn() const {
  return _internal_has_delegated_voting_txn();
}
inline void TXNWrapper::set_has_delegated_voting_txn() {
  _impl_._oneof_case_[0] = kDelegatedVotingTxn;
}
inline void TXNWrapper::clear_delegated_voting_txn() {
  if (_internal_has_delegated_voting_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.delegated_voting_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::DelegatedTXN* TXNWrapper::release_delegated_voting_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.delegated_voting_txn)
  if (_internal_has_delegated_voting_txn()) {
    clear_has_payload();
    ::zera_txn::DelegatedTXN* temp = _impl_.payload_.delegated_voting_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delegated_voting_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::DelegatedTXN& TXNWrapper::_internal_delegated_voting_txn() const {
  return _internal_has_delegated_voting_txn()
      ? *_impl_.payload_.delegated_voting_txn_
      : reinterpret_cast< ::zera_txn::DelegatedTXN&>(::zera_txn::_DelegatedTXN_default_instance_);
}
inline const ::zera_txn::DelegatedTXN& TXNWrapper::delegated_voting_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.delegated_voting_txn)
  return _internal_delegated_voting_txn();
}
inline ::zera_txn::DelegatedTXN* TXNWrapper::unsafe_arena_release_delegated_voting_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.delegated_voting_txn)
  if (_internal_has_delegated_voting_txn()) {
    clear_has_payload();
    ::zera_txn::DelegatedTXN* temp = _impl_.payload_.delegated_voting_txn_;
    _impl_.payload_.delegated_voting_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_delegated_voting_txn(::zera_txn::DelegatedTXN* delegated_voting_txn) {
  clear_payload();
  if (delegated_voting_txn) {
    set_has_delegated_voting_txn();
    _impl_.payload_.delegated_voting_txn_ = delegated_voting_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.delegated_voting_txn)
}
inline ::zera_txn::DelegatedTXN* TXNWrapper::_internal_mutable_delegated_voting_txn() {
  if (!_internal_has_delegated_voting_txn()) {
    clear_payload();
    set_has_delegated_voting_txn();
    _impl_.payload_.delegated_voting_txn_ = CreateMaybeMessage< ::zera_txn::DelegatedTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.delegated_voting_txn_;
}
inline ::zera_txn::DelegatedTXN* TXNWrapper::mutable_delegated_voting_txn() {
  ::zera_txn::DelegatedTXN* _msg = _internal_mutable_delegated_voting_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.delegated_voting_txn)
  return _msg;
}

// .zera_txn.QuashTXN quash_txn = 18;
inline bool TXNWrapper::_internal_has_quash_txn() const {
  return payload_case() == kQuashTxn;
}
inline bool TXNWrapper::has_quash_txn() const {
  return _internal_has_quash_txn();
}
inline void TXNWrapper::set_has_quash_txn() {
  _impl_._oneof_case_[0] = kQuashTxn;
}
inline void TXNWrapper::clear_quash_txn() {
  if (_internal_has_quash_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.quash_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::QuashTXN* TXNWrapper::release_quash_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.quash_txn)
  if (_internal_has_quash_txn()) {
    clear_has_payload();
    ::zera_txn::QuashTXN* temp = _impl_.payload_.quash_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.quash_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::QuashTXN& TXNWrapper::_internal_quash_txn() const {
  return _internal_has_quash_txn()
      ? *_impl_.payload_.quash_txn_
      : reinterpret_cast< ::zera_txn::QuashTXN&>(::zera_txn::_QuashTXN_default_instance_);
}
inline const ::zera_txn::QuashTXN& TXNWrapper::quash_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.quash_txn)
  return _internal_quash_txn();
}
inline ::zera_txn::QuashTXN* TXNWrapper::unsafe_arena_release_quash_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.quash_txn)
  if (_internal_has_quash_txn()) {
    clear_has_payload();
    ::zera_txn::QuashTXN* temp = _impl_.payload_.quash_txn_;
    _impl_.payload_.quash_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_quash_txn(::zera_txn::QuashTXN* quash_txn) {
  clear_payload();
  if (quash_txn) {
    set_has_quash_txn();
    _impl_.payload_.quash_txn_ = quash_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.quash_txn)
}
inline ::zera_txn::QuashTXN* TXNWrapper::_internal_mutable_quash_txn() {
  if (!_internal_has_quash_txn()) {
    clear_payload();
    set_has_quash_txn();
    _impl_.payload_.quash_txn_ = CreateMaybeMessage< ::zera_txn::QuashTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.quash_txn_;
}
inline ::zera_txn::QuashTXN* TXNWrapper::mutable_quash_txn() {
  ::zera_txn::QuashTXN* _msg = _internal_mutable_quash_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.quash_txn)
  return _msg;
}

// .zera_txn.FastQuorumTXN fast_quorum_txn = 19;
inline bool TXNWrapper::_internal_has_fast_quorum_txn() const {
  return payload_case() == kFastQuorumTxn;
}
inline bool TXNWrapper::has_fast_quorum_txn() const {
  return _internal_has_fast_quorum_txn();
}
inline void TXNWrapper::set_has_fast_quorum_txn() {
  _impl_._oneof_case_[0] = kFastQuorumTxn;
}
inline void TXNWrapper::clear_fast_quorum_txn() {
  if (_internal_has_fast_quorum_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.fast_quorum_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::FastQuorumTXN* TXNWrapper::release_fast_quorum_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.fast_quorum_txn)
  if (_internal_has_fast_quorum_txn()) {
    clear_has_payload();
    ::zera_txn::FastQuorumTXN* temp = _impl_.payload_.fast_quorum_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.fast_quorum_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::FastQuorumTXN& TXNWrapper::_internal_fast_quorum_txn() const {
  return _internal_has_fast_quorum_txn()
      ? *_impl_.payload_.fast_quorum_txn_
      : reinterpret_cast< ::zera_txn::FastQuorumTXN&>(::zera_txn::_FastQuorumTXN_default_instance_);
}
inline const ::zera_txn::FastQuorumTXN& TXNWrapper::fast_quorum_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.fast_quorum_txn)
  return _internal_fast_quorum_txn();
}
inline ::zera_txn::FastQuorumTXN* TXNWrapper::unsafe_arena_release_fast_quorum_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.fast_quorum_txn)
  if (_internal_has_fast_quorum_txn()) {
    clear_has_payload();
    ::zera_txn::FastQuorumTXN* temp = _impl_.payload_.fast_quorum_txn_;
    _impl_.payload_.fast_quorum_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_fast_quorum_txn(::zera_txn::FastQuorumTXN* fast_quorum_txn) {
  clear_payload();
  if (fast_quorum_txn) {
    set_has_fast_quorum_txn();
    _impl_.payload_.fast_quorum_txn_ = fast_quorum_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.fast_quorum_txn)
}
inline ::zera_txn::FastQuorumTXN* TXNWrapper::_internal_mutable_fast_quorum_txn() {
  if (!_internal_has_fast_quorum_txn()) {
    clear_payload();
    set_has_fast_quorum_txn();
    _impl_.payload_.fast_quorum_txn_ = CreateMaybeMessage< ::zera_txn::FastQuorumTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.fast_quorum_txn_;
}
inline ::zera_txn::FastQuorumTXN* TXNWrapper::mutable_fast_quorum_txn() {
  ::zera_txn::FastQuorumTXN* _msg = _internal_mutable_fast_quorum_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.fast_quorum_txn)
  return _msg;
}

// .zera_txn.RevokeTXN revoke_txn = 20;
inline bool TXNWrapper::_internal_has_revoke_txn() const {
  return payload_case() == kRevokeTxn;
}
inline bool TXNWrapper::has_revoke_txn() const {
  return _internal_has_revoke_txn();
}
inline void TXNWrapper::set_has_revoke_txn() {
  _impl_._oneof_case_[0] = kRevokeTxn;
}
inline void TXNWrapper::clear_revoke_txn() {
  if (_internal_has_revoke_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.revoke_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::RevokeTXN* TXNWrapper::release_revoke_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.revoke_txn)
  if (_internal_has_revoke_txn()) {
    clear_has_payload();
    ::zera_txn::RevokeTXN* temp = _impl_.payload_.revoke_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.revoke_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::RevokeTXN& TXNWrapper::_internal_revoke_txn() const {
  return _internal_has_revoke_txn()
      ? *_impl_.payload_.revoke_txn_
      : reinterpret_cast< ::zera_txn::RevokeTXN&>(::zera_txn::_RevokeTXN_default_instance_);
}
inline const ::zera_txn::RevokeTXN& TXNWrapper::revoke_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.revoke_txn)
  return _internal_revoke_txn();
}
inline ::zera_txn::RevokeTXN* TXNWrapper::unsafe_arena_release_revoke_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.revoke_txn)
  if (_internal_has_revoke_txn()) {
    clear_has_payload();
    ::zera_txn::RevokeTXN* temp = _impl_.payload_.revoke_txn_;
    _impl_.payload_.revoke_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_revoke_txn(::zera_txn::RevokeTXN* revoke_txn) {
  clear_payload();
  if (revoke_txn) {
    set_has_revoke_txn();
    _impl_.payload_.revoke_txn_ = revoke_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.revoke_txn)
}
inline ::zera_txn::RevokeTXN* TXNWrapper::_internal_mutable_revoke_txn() {
  if (!_internal_has_revoke_txn()) {
    clear_payload();
    set_has_revoke_txn();
    _impl_.payload_.revoke_txn_ = CreateMaybeMessage< ::zera_txn::RevokeTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.revoke_txn_;
}
inline ::zera_txn::RevokeTXN* TXNWrapper::mutable_revoke_txn() {
  ::zera_txn::RevokeTXN* _msg = _internal_mutable_revoke_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.revoke_txn)
  return _msg;
}

// .zera_txn.ComplianceTXN compliance_txn = 21;
inline bool TXNWrapper::_internal_has_compliance_txn() const {
  return payload_case() == kComplianceTxn;
}
inline bool TXNWrapper::has_compliance_txn() const {
  return _internal_has_compliance_txn();
}
inline void TXNWrapper::set_has_compliance_txn() {
  _impl_._oneof_case_[0] = kComplianceTxn;
}
inline void TXNWrapper::clear_compliance_txn() {
  if (_internal_has_compliance_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.compliance_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::ComplianceTXN* TXNWrapper::release_compliance_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.compliance_txn)
  if (_internal_has_compliance_txn()) {
    clear_has_payload();
    ::zera_txn::ComplianceTXN* temp = _impl_.payload_.compliance_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.compliance_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::ComplianceTXN& TXNWrapper::_internal_compliance_txn() const {
  return _internal_has_compliance_txn()
      ? *_impl_.payload_.compliance_txn_
      : reinterpret_cast< ::zera_txn::ComplianceTXN&>(::zera_txn::_ComplianceTXN_default_instance_);
}
inline const ::zera_txn::ComplianceTXN& TXNWrapper::compliance_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.compliance_txn)
  return _internal_compliance_txn();
}
inline ::zera_txn::ComplianceTXN* TXNWrapper::unsafe_arena_release_compliance_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.compliance_txn)
  if (_internal_has_compliance_txn()) {
    clear_has_payload();
    ::zera_txn::ComplianceTXN* temp = _impl_.payload_.compliance_txn_;
    _impl_.payload_.compliance_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_compliance_txn(::zera_txn::ComplianceTXN* compliance_txn) {
  clear_payload();
  if (compliance_txn) {
    set_has_compliance_txn();
    _impl_.payload_.compliance_txn_ = compliance_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.compliance_txn)
}
inline ::zera_txn::ComplianceTXN* TXNWrapper::_internal_mutable_compliance_txn() {
  if (!_internal_has_compliance_txn()) {
    clear_payload();
    set_has_compliance_txn();
    _impl_.payload_.compliance_txn_ = CreateMaybeMessage< ::zera_txn::ComplianceTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.compliance_txn_;
}
inline ::zera_txn::ComplianceTXN* TXNWrapper::mutable_compliance_txn() {
  ::zera_txn::ComplianceTXN* _msg = _internal_mutable_compliance_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.compliance_txn)
  return _msg;
}

// bool proposal_result_txn = 22;
inline bool TXNWrapper::_internal_has_proposal_result_txn() const {
  return payload_case() == kProposalResultTxn;
}
inline bool TXNWrapper::has_proposal_result_txn() const {
  return _internal_has_proposal_result_txn();
}
inline void TXNWrapper::set_has_proposal_result_txn() {
  _impl_._oneof_case_[0] = kProposalResultTxn;
}
inline void TXNWrapper::clear_proposal_result_txn() {
  if (_internal_has_proposal_result_txn()) {
    _impl_.payload_.proposal_result_txn_ = false;
    clear_has_payload();
  }
}
inline bool TXNWrapper::_internal_proposal_result_txn() const {
  if (_internal_has_proposal_result_txn()) {
    return _impl_.payload_.proposal_result_txn_;
  }
  return false;
}
inline void TXNWrapper::_internal_set_proposal_result_txn(bool value) {
  if (!_internal_has_proposal_result_txn()) {
    clear_payload();
    set_has_proposal_result_txn();
  }
  _impl_.payload_.proposal_result_txn_ = value;
}
inline bool TXNWrapper::proposal_result_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.proposal_result_txn)
  return _internal_proposal_result_txn();
}
inline void TXNWrapper::set_proposal_result_txn(bool value) {
  _internal_set_proposal_result_txn(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNWrapper.proposal_result_txn)
}

// .zera_txn.BurnSBTTXN burn_sbt_txn = 23;
inline bool TXNWrapper::_internal_has_burn_sbt_txn() const {
  return payload_case() == kBurnSbtTxn;
}
inline bool TXNWrapper::has_burn_sbt_txn() const {
  return _internal_has_burn_sbt_txn();
}
inline void TXNWrapper::set_has_burn_sbt_txn() {
  _impl_._oneof_case_[0] = kBurnSbtTxn;
}
inline void TXNWrapper::clear_burn_sbt_txn() {
  if (_internal_has_burn_sbt_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.burn_sbt_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::BurnSBTTXN* TXNWrapper::release_burn_sbt_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.burn_sbt_txn)
  if (_internal_has_burn_sbt_txn()) {
    clear_has_payload();
    ::zera_txn::BurnSBTTXN* temp = _impl_.payload_.burn_sbt_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.burn_sbt_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::BurnSBTTXN& TXNWrapper::_internal_burn_sbt_txn() const {
  return _internal_has_burn_sbt_txn()
      ? *_impl_.payload_.burn_sbt_txn_
      : reinterpret_cast< ::zera_txn::BurnSBTTXN&>(::zera_txn::_BurnSBTTXN_default_instance_);
}
inline const ::zera_txn::BurnSBTTXN& TXNWrapper::burn_sbt_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.burn_sbt_txn)
  return _internal_burn_sbt_txn();
}
inline ::zera_txn::BurnSBTTXN* TXNWrapper::unsafe_arena_release_burn_sbt_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.burn_sbt_txn)
  if (_internal_has_burn_sbt_txn()) {
    clear_has_payload();
    ::zera_txn::BurnSBTTXN* temp = _impl_.payload_.burn_sbt_txn_;
    _impl_.payload_.burn_sbt_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_burn_sbt_txn(::zera_txn::BurnSBTTXN* burn_sbt_txn) {
  clear_payload();
  if (burn_sbt_txn) {
    set_has_burn_sbt_txn();
    _impl_.payload_.burn_sbt_txn_ = burn_sbt_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.burn_sbt_txn)
}
inline ::zera_txn::BurnSBTTXN* TXNWrapper::_internal_mutable_burn_sbt_txn() {
  if (!_internal_has_burn_sbt_txn()) {
    clear_payload();
    set_has_burn_sbt_txn();
    _impl_.payload_.burn_sbt_txn_ = CreateMaybeMessage< ::zera_txn::BurnSBTTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.burn_sbt_txn_;
}
inline ::zera_txn::BurnSBTTXN* TXNWrapper::mutable_burn_sbt_txn() {
  ::zera_txn::BurnSBTTXN* _msg = _internal_mutable_burn_sbt_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.burn_sbt_txn)
  return _msg;
}

// .zera_txn.RequiredVersion required_version_txn = 24;
inline bool TXNWrapper::_internal_has_required_version_txn() const {
  return payload_case() == kRequiredVersionTxn;
}
inline bool TXNWrapper::has_required_version_txn() const {
  return _internal_has_required_version_txn();
}
inline void TXNWrapper::set_has_required_version_txn() {
  _impl_._oneof_case_[0] = kRequiredVersionTxn;
}
inline void TXNWrapper::clear_required_version_txn() {
  if (_internal_has_required_version_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.required_version_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::RequiredVersion* TXNWrapper::release_required_version_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.required_version_txn)
  if (_internal_has_required_version_txn()) {
    clear_has_payload();
    ::zera_txn::RequiredVersion* temp = _impl_.payload_.required_version_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.required_version_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::RequiredVersion& TXNWrapper::_internal_required_version_txn() const {
  return _internal_has_required_version_txn()
      ? *_impl_.payload_.required_version_txn_
      : reinterpret_cast< ::zera_txn::RequiredVersion&>(::zera_txn::_RequiredVersion_default_instance_);
}
inline const ::zera_txn::RequiredVersion& TXNWrapper::required_version_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.required_version_txn)
  return _internal_required_version_txn();
}
inline ::zera_txn::RequiredVersion* TXNWrapper::unsafe_arena_release_required_version_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.required_version_txn)
  if (_internal_has_required_version_txn()) {
    clear_has_payload();
    ::zera_txn::RequiredVersion* temp = _impl_.payload_.required_version_txn_;
    _impl_.payload_.required_version_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_required_version_txn(::zera_txn::RequiredVersion* required_version_txn) {
  clear_payload();
  if (required_version_txn) {
    set_has_required_version_txn();
    _impl_.payload_.required_version_txn_ = required_version_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.required_version_txn)
}
inline ::zera_txn::RequiredVersion* TXNWrapper::_internal_mutable_required_version_txn() {
  if (!_internal_has_required_version_txn()) {
    clear_payload();
    set_has_required_version_txn();
    _impl_.payload_.required_version_txn_ = CreateMaybeMessage< ::zera_txn::RequiredVersion >(GetArenaForAllocation());
  }
  return _impl_.payload_.required_version_txn_;
}
inline ::zera_txn::RequiredVersion* TXNWrapper::mutable_required_version_txn() {
  ::zera_txn::RequiredVersion* _msg = _internal_mutable_required_version_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.required_version_txn)
  return _msg;
}

// .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txn = 25;
inline bool TXNWrapper::_internal_has_smart_contract_instantiate_txn() const {
  return payload_case() == kSmartContractInstantiateTxn;
}
inline bool TXNWrapper::has_smart_contract_instantiate_txn() const {
  return _internal_has_smart_contract_instantiate_txn();
}
inline void TXNWrapper::set_has_smart_contract_instantiate_txn() {
  _impl_._oneof_case_[0] = kSmartContractInstantiateTxn;
}
inline void TXNWrapper::clear_smart_contract_instantiate_txn() {
  if (_internal_has_smart_contract_instantiate_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.smart_contract_instantiate_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::SmartContractInstantiateTXN* TXNWrapper::release_smart_contract_instantiate_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.smart_contract_instantiate_txn)
  if (_internal_has_smart_contract_instantiate_txn()) {
    clear_has_payload();
    ::zera_txn::SmartContractInstantiateTXN* temp = _impl_.payload_.smart_contract_instantiate_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.smart_contract_instantiate_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::SmartContractInstantiateTXN& TXNWrapper::_internal_smart_contract_instantiate_txn() const {
  return _internal_has_smart_contract_instantiate_txn()
      ? *_impl_.payload_.smart_contract_instantiate_txn_
      : reinterpret_cast< ::zera_txn::SmartContractInstantiateTXN&>(::zera_txn::_SmartContractInstantiateTXN_default_instance_);
}
inline const ::zera_txn::SmartContractInstantiateTXN& TXNWrapper::smart_contract_instantiate_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.smart_contract_instantiate_txn)
  return _internal_smart_contract_instantiate_txn();
}
inline ::zera_txn::SmartContractInstantiateTXN* TXNWrapper::unsafe_arena_release_smart_contract_instantiate_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.smart_contract_instantiate_txn)
  if (_internal_has_smart_contract_instantiate_txn()) {
    clear_has_payload();
    ::zera_txn::SmartContractInstantiateTXN* temp = _impl_.payload_.smart_contract_instantiate_txn_;
    _impl_.payload_.smart_contract_instantiate_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_smart_contract_instantiate_txn(::zera_txn::SmartContractInstantiateTXN* smart_contract_instantiate_txn) {
  clear_payload();
  if (smart_contract_instantiate_txn) {
    set_has_smart_contract_instantiate_txn();
    _impl_.payload_.smart_contract_instantiate_txn_ = smart_contract_instantiate_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.smart_contract_instantiate_txn)
}
inline ::zera_txn::SmartContractInstantiateTXN* TXNWrapper::_internal_mutable_smart_contract_instantiate_txn() {
  if (!_internal_has_smart_contract_instantiate_txn()) {
    clear_payload();
    set_has_smart_contract_instantiate_txn();
    _impl_.payload_.smart_contract_instantiate_txn_ = CreateMaybeMessage< ::zera_txn::SmartContractInstantiateTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.smart_contract_instantiate_txn_;
}
inline ::zera_txn::SmartContractInstantiateTXN* TXNWrapper::mutable_smart_contract_instantiate_txn() {
  ::zera_txn::SmartContractInstantiateTXN* _msg = _internal_mutable_smart_contract_instantiate_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.smart_contract_instantiate_txn)
  return _msg;
}

// .zera_txn.AllowanceTXN allowance_txn = 30;
inline bool TXNWrapper::_internal_has_allowance_txn() const {
  return payload_case() == kAllowanceTxn;
}
inline bool TXNWrapper::has_allowance_txn() const {
  return _internal_has_allowance_txn();
}
inline void TXNWrapper::set_has_allowance_txn() {
  _impl_._oneof_case_[0] = kAllowanceTxn;
}
inline void TXNWrapper::clear_allowance_txn() {
  if (_internal_has_allowance_txn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.allowance_txn_;
    }
    clear_has_payload();
  }
}
inline ::zera_txn::AllowanceTXN* TXNWrapper::release_allowance_txn() {
  // @@protoc_insertion_point(field_release:zera_txn.TXNWrapper.allowance_txn)
  if (_internal_has_allowance_txn()) {
    clear_has_payload();
    ::zera_txn::AllowanceTXN* temp = _impl_.payload_.allowance_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.allowance_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zera_txn::AllowanceTXN& TXNWrapper::_internal_allowance_txn() const {
  return _internal_has_allowance_txn()
      ? *_impl_.payload_.allowance_txn_
      : reinterpret_cast< ::zera_txn::AllowanceTXN&>(::zera_txn::_AllowanceTXN_default_instance_);
}
inline const ::zera_txn::AllowanceTXN& TXNWrapper::allowance_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.allowance_txn)
  return _internal_allowance_txn();
}
inline ::zera_txn::AllowanceTXN* TXNWrapper::unsafe_arena_release_allowance_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zera_txn.TXNWrapper.allowance_txn)
  if (_internal_has_allowance_txn()) {
    clear_has_payload();
    ::zera_txn::AllowanceTXN* temp = _impl_.payload_.allowance_txn_;
    _impl_.payload_.allowance_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TXNWrapper::unsafe_arena_set_allocated_allowance_txn(::zera_txn::AllowanceTXN* allowance_txn) {
  clear_payload();
  if (allowance_txn) {
    set_has_allowance_txn();
    _impl_.payload_.allowance_txn_ = allowance_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zera_txn.TXNWrapper.allowance_txn)
}
inline ::zera_txn::AllowanceTXN* TXNWrapper::_internal_mutable_allowance_txn() {
  if (!_internal_has_allowance_txn()) {
    clear_payload();
    set_has_allowance_txn();
    _impl_.payload_.allowance_txn_ = CreateMaybeMessage< ::zera_txn::AllowanceTXN >(GetArenaForAllocation());
  }
  return _impl_.payload_.allowance_txn_;
}
inline ::zera_txn::AllowanceTXN* TXNWrapper::mutable_allowance_txn() {
  ::zera_txn::AllowanceTXN* _msg = _internal_mutable_allowance_txn();
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.allowance_txn)
  return _msg;
}

// .zera_txn.TRANSACTION_TYPE txn_type = 26;
inline void TXNWrapper::clear_txn_type() {
  _impl_.txn_type_ = 0;
}
inline ::zera_txn::TRANSACTION_TYPE TXNWrapper::_internal_txn_type() const {
  return static_cast< ::zera_txn::TRANSACTION_TYPE >(_impl_.txn_type_);
}
inline ::zera_txn::TRANSACTION_TYPE TXNWrapper::txn_type() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.txn_type)
  return _internal_txn_type();
}
inline void TXNWrapper::_internal_set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  
  _impl_.txn_type_ = value;
}
inline void TXNWrapper::set_txn_type(::zera_txn::TRANSACTION_TYPE value) {
  _internal_set_txn_type(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNWrapper.txn_type)
}

// repeated bytes proposal_ids = 27;
inline int TXNWrapper::_internal_proposal_ids_size() const {
  return _impl_.proposal_ids_.size();
}
inline int TXNWrapper::proposal_ids_size() const {
  return _internal_proposal_ids_size();
}
inline void TXNWrapper::clear_proposal_ids() {
  _impl_.proposal_ids_.Clear();
}
inline std::string* TXNWrapper::add_proposal_ids() {
  std::string* _s = _internal_add_proposal_ids();
  // @@protoc_insertion_point(field_add_mutable:zera_txn.TXNWrapper.proposal_ids)
  return _s;
}
inline const std::string& TXNWrapper::_internal_proposal_ids(int index) const {
  return _impl_.proposal_ids_.Get(index);
}
inline const std::string& TXNWrapper::proposal_ids(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.proposal_ids)
  return _internal_proposal_ids(index);
}
inline std::string* TXNWrapper::mutable_proposal_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.proposal_ids)
  return _impl_.proposal_ids_.Mutable(index);
}
inline void TXNWrapper::set_proposal_ids(int index, const std::string& value) {
  _impl_.proposal_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNWrapper.proposal_ids)
}
inline void TXNWrapper::set_proposal_ids(int index, std::string&& value) {
  _impl_.proposal_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zera_txn.TXNWrapper.proposal_ids)
}
inline void TXNWrapper::set_proposal_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proposal_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zera_txn.TXNWrapper.proposal_ids)
}
inline void TXNWrapper::set_proposal_ids(int index, const void* value, size_t size) {
  _impl_.proposal_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zera_txn.TXNWrapper.proposal_ids)
}
inline std::string* TXNWrapper::_internal_add_proposal_ids() {
  return _impl_.proposal_ids_.Add();
}
inline void TXNWrapper::add_proposal_ids(const std::string& value) {
  _impl_.proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zera_txn.TXNWrapper.proposal_ids)
}
inline void TXNWrapper::add_proposal_ids(std::string&& value) {
  _impl_.proposal_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zera_txn.TXNWrapper.proposal_ids)
}
inline void TXNWrapper::add_proposal_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proposal_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zera_txn.TXNWrapper.proposal_ids)
}
inline void TXNWrapper::add_proposal_ids(const void* value, size_t size) {
  _impl_.proposal_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zera_txn.TXNWrapper.proposal_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TXNWrapper::proposal_ids() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNWrapper.proposal_ids)
  return _impl_.proposal_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TXNWrapper::mutable_proposal_ids() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNWrapper.proposal_ids)
  return &_impl_.proposal_ids_;
}

// repeated .zera_txn.ProposalContract proposal_contracts = 28;
inline int TXNWrapper::_internal_proposal_contracts_size() const {
  return _impl_.proposal_contracts_.size();
}
inline int TXNWrapper::proposal_contracts_size() const {
  return _internal_proposal_contracts_size();
}
inline void TXNWrapper::clear_proposal_contracts() {
  _impl_.proposal_contracts_.Clear();
}
inline ::zera_txn::ProposalContract* TXNWrapper::mutable_proposal_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:zera_txn.TXNWrapper.proposal_contracts)
  return _impl_.proposal_contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalContract >*
TXNWrapper::mutable_proposal_contracts() {
  // @@protoc_insertion_point(field_mutable_list:zera_txn.TXNWrapper.proposal_contracts)
  return &_impl_.proposal_contracts_;
}
inline const ::zera_txn::ProposalContract& TXNWrapper::_internal_proposal_contracts(int index) const {
  return _impl_.proposal_contracts_.Get(index);
}
inline const ::zera_txn::ProposalContract& TXNWrapper::proposal_contracts(int index) const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.proposal_contracts)
  return _internal_proposal_contracts(index);
}
inline ::zera_txn::ProposalContract* TXNWrapper::_internal_add_proposal_contracts() {
  return _impl_.proposal_contracts_.Add();
}
inline ::zera_txn::ProposalContract* TXNWrapper::add_proposal_contracts() {
  ::zera_txn::ProposalContract* _add = _internal_add_proposal_contracts();
  // @@protoc_insertion_point(field_add:zera_txn.TXNWrapper.proposal_contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zera_txn::ProposalContract >&
TXNWrapper::proposal_contracts() const {
  // @@protoc_insertion_point(field_list:zera_txn.TXNWrapper.proposal_contracts)
  return _impl_.proposal_contracts_;
}

// optional bool smart_contract_txn = 29;
inline bool TXNWrapper::_internal_has_smart_contract_txn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TXNWrapper::has_smart_contract_txn() const {
  return _internal_has_smart_contract_txn();
}
inline void TXNWrapper::clear_smart_contract_txn() {
  _impl_.smart_contract_txn_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool TXNWrapper::_internal_smart_contract_txn() const {
  return _impl_.smart_contract_txn_;
}
inline bool TXNWrapper::smart_contract_txn() const {
  // @@protoc_insertion_point(field_get:zera_txn.TXNWrapper.smart_contract_txn)
  return _internal_smart_contract_txn();
}
inline void TXNWrapper::_internal_set_smart_contract_txn(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.smart_contract_txn_ = value;
}
inline void TXNWrapper::set_smart_contract_txn(bool value) {
  _internal_set_smart_contract_txn(value);
  // @@protoc_insertion_point(field_set:zera_txn.TXNWrapper.smart_contract_txn)
}

inline bool TXNWrapper::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void TXNWrapper::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline TXNWrapper::PayloadCase TXNWrapper::payload_case() const {
  return TXNWrapper::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zera_txn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zera_txn::TXN_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_txn::TXN_STATUS>() {
  return ::zera_txn::TXN_STATUS_descriptor();
}
template <> struct is_proto_enum< ::zera_txn::TRANSACTION_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_txn::TRANSACTION_TYPE>() {
  return ::zera_txn::TRANSACTION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::zera_txn::LANGUAGE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_txn::LANGUAGE>() {
  return ::zera_txn::LANGUAGE_descriptor();
}
template <> struct is_proto_enum< ::zera_txn::PROPOSAL_PERIOD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_txn::PROPOSAL_PERIOD>() {
  return ::zera_txn::PROPOSAL_PERIOD_descriptor();
}
template <> struct is_proto_enum< ::zera_txn::VARIABLE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_txn::VARIABLE_TYPE>() {
  return ::zera_txn::VARIABLE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::zera_txn::CONTRACT_FEE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_txn::CONTRACT_FEE_TYPE>() {
  return ::zera_txn::CONTRACT_FEE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::zera_txn::GOVERNANCE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_txn::GOVERNANCE_TYPE>() {
  return ::zera_txn::GOVERNANCE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::zera_txn::CONTRACT_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zera_txn::CONTRACT_TYPE>() {
  return ::zera_txn::CONTRACT_TYPE_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_txn_2eproto
