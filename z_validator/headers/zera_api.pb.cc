// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zera_api.proto

#include "zera_api.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace zera_api {
PROTOBUF_CONSTEXPR ProposalLedgerRequest::ProposalLedgerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProposalLedgerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProposalLedgerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProposalLedgerRequestDefaultTypeInternal() {}
  union {
    ProposalLedgerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProposalLedgerRequestDefaultTypeInternal _ProposalLedgerRequest_default_instance_;
PROTOBUF_CONSTEXPR ProposalLedgerResponse::ProposalLedgerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ledger_keys_)*/{}
  , /*decltype(_impl_.ledger_values_)*/{}
  , /*decltype(_impl_.proposal_keys_)*/{}
  , /*decltype(_impl_.proposal_values_)*/{}
  , /*decltype(_impl_.wallets_keys_)*/{}
  , /*decltype(_impl_.wallets_values_)*/{}
  , /*decltype(_impl_.temp_keys_)*/{}
  , /*decltype(_impl_.temp_values_)*/{}
  , /*decltype(_impl_.voted_keys_)*/{}
  , /*decltype(_impl_.voted_values_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProposalLedgerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProposalLedgerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProposalLedgerResponseDefaultTypeInternal() {}
  union {
    ProposalLedgerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProposalLedgerResponseDefaultTypeInternal _ProposalLedgerResponse_default_instance_;
PROTOBUF_CONSTEXPR BlockRequest::BlockRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.encoded_)*/false
  , /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BlockRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockRequestDefaultTypeInternal() {}
  union {
    BlockRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockRequestDefaultTypeInternal _BlockRequest_default_instance_;
PROTOBUF_CONSTEXPR BlockResponse::BlockResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BlockResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockResponseDefaultTypeInternal() {}
  union {
    BlockResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
PROTOBUF_CONSTEXPR NonceRequest::NonceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wallet_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encoded_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NonceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NonceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NonceRequestDefaultTypeInternal() {}
  union {
    NonceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NonceRequestDefaultTypeInternal _NonceRequest_default_instance_;
PROTOBUF_CONSTEXPR NonceResponse::NonceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nonce_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NonceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NonceResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NonceResponseDefaultTypeInternal() {}
  union {
    NonceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NonceResponseDefaultTypeInternal _NonceResponse_default_instance_;
PROTOBUF_CONSTEXPR BalanceRequest::BalanceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wallet_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encoded_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BalanceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BalanceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BalanceRequestDefaultTypeInternal() {}
  union {
    BalanceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BalanceRequestDefaultTypeInternal _BalanceRequest_default_instance_;
PROTOBUF_CONSTEXPR BalanceResponse::BalanceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.balance_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.denomination_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BalanceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BalanceResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BalanceResponseDefaultTypeInternal() {}
  union {
    BalanceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BalanceResponseDefaultTypeInternal _BalanceResponse_default_instance_;
PROTOBUF_CONSTEXPR ContractFeeRequest::ContractFeeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContractFeeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractFeeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractFeeRequestDefaultTypeInternal() {}
  union {
    ContractFeeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractFeeRequestDefaultTypeInternal _ContractFeeRequest_default_instance_;
PROTOBUF_CONSTEXPR ContractFeeResponse::ContractFeeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.allowed_fee_instrument_)*/{}
  , /*decltype(_impl_.fee_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fee_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContractFeeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractFeeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractFeeResponseDefaultTypeInternal() {}
  union {
    ContractFeeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractFeeResponseDefaultTypeInternal _ContractFeeResponse_default_instance_;
PROTOBUF_CONSTEXPR BaseFeeRequest::BaseFeeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.public_key_)*/nullptr
  , /*decltype(_impl_.txn_type_)*/0} {}
struct BaseFeeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BaseFeeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BaseFeeRequestDefaultTypeInternal() {}
  union {
    BaseFeeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BaseFeeRequestDefaultTypeInternal _BaseFeeRequest_default_instance_;
PROTOBUF_CONSTEXPR BaseFeeResponse::BaseFeeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_fee_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.byte_fee_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BaseFeeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BaseFeeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BaseFeeResponseDefaultTypeInternal() {}
  union {
    BaseFeeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BaseFeeResponseDefaultTypeInternal _BaseFeeResponse_default_instance_;
PROTOBUF_CONSTEXPR TokenFeeInfo::TokenFeeInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.denomination_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fees_)*/nullptr
  , /*decltype(_impl_.authorized_)*/false} {}
struct TokenFeeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenFeeInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenFeeInfoDefaultTypeInternal() {}
  union {
    TokenFeeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenFeeInfoDefaultTypeInternal _TokenFeeInfo_default_instance_;
PROTOBUF_CONSTEXPR TokenFeeInfoRequest::TokenFeeInfoRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenFeeInfoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenFeeInfoRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenFeeInfoRequestDefaultTypeInternal() {}
  union {
    TokenFeeInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenFeeInfoRequestDefaultTypeInternal _TokenFeeInfoRequest_default_instance_;
PROTOBUF_CONSTEXPR TokenFeeInfoResponse::TokenFeeInfoResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tokens_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenFeeInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenFeeInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenFeeInfoResponseDefaultTypeInternal() {}
  union {
    TokenFeeInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenFeeInfoResponseDefaultTypeInternal _TokenFeeInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR Item::Item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.item_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemDefaultTypeInternal() {}
  union {
    Item _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemDefaultTypeInternal _Item_default_instance_;
PROTOBUF_CONSTEXPR ItemRequest::ItemRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wallet_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encoded_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ItemRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemRequestDefaultTypeInternal() {}
  union {
    ItemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemRequestDefaultTypeInternal _ItemRequest_default_instance_;
PROTOBUF_CONSTEXPR ItemResponse::ItemResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ItemResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemResponseDefaultTypeInternal() {}
  union {
    ItemResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemResponseDefaultTypeInternal _ItemResponse_default_instance_;
PROTOBUF_CONSTEXPR DenominationRequest::DenominationRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DenominationRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DenominationRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DenominationRequestDefaultTypeInternal() {}
  union {
    DenominationRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DenominationRequestDefaultTypeInternal _DenominationRequest_default_instance_;
PROTOBUF_CONSTEXPR DenominationResponse::DenominationResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.denomination_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DenominationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DenominationResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DenominationResponseDefaultTypeInternal() {}
  union {
    DenominationResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DenominationResponseDefaultTypeInternal _DenominationResponse_default_instance_;
PROTOBUF_CONSTEXPR DatabaseRequest::DatabaseRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DatabaseRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DatabaseRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DatabaseRequestDefaultTypeInternal() {}
  union {
    DatabaseRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DatabaseRequestDefaultTypeInternal _DatabaseRequest_default_instance_;
PROTOBUF_CONSTEXPR DatabaseResponse::DatabaseResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DatabaseResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DatabaseResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DatabaseResponseDefaultTypeInternal() {}
  union {
    DatabaseResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DatabaseResponseDefaultTypeInternal _DatabaseResponse_default_instance_;
PROTOBUF_CONSTEXPR ActivityRequest::ActivityRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.smart_contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.public_key_)*/nullptr
  , /*decltype(_impl_.instance_)*/uint64_t{0u}
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_.nonce_)*/uint64_t{0u}
  , /*decltype(_impl_.subscribe_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ActivityRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActivityRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActivityRequestDefaultTypeInternal() {}
  union {
    ActivityRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActivityRequestDefaultTypeInternal _ActivityRequest_default_instance_;
PROTOBUF_CONSTEXPR SmartContractEventsResponse::SmartContractEventsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.smart_contract_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storage_fee_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.event_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.function_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.block_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.caller_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.public_key_)*/nullptr
  , /*decltype(_impl_.instance_)*/uint64_t{0u}
  , /*decltype(_impl_.gas_used_)*/uint64_t{0u}
  , /*decltype(_impl_.gas_approved_)*/uint64_t{0u}
  , /*decltype(_impl_.block_height_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SmartContractEventsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartContractEventsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartContractEventsResponseDefaultTypeInternal() {}
  union {
    SmartContractEventsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartContractEventsResponseDefaultTypeInternal _SmartContractEventsResponse_default_instance_;
PROTOBUF_CONSTEXPR SmartContractSubscription_SubscibersEntry_DoNotUse::SmartContractSubscription_SubscibersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct SmartContractSubscription_SubscibersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartContractSubscription_SubscibersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartContractSubscription_SubscibersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SmartContractSubscription_SubscibersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartContractSubscription_SubscibersEntry_DoNotUseDefaultTypeInternal _SmartContractSubscription_SubscibersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SmartContractSubscription::SmartContractSubscription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subscibers_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SmartContractSubscriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartContractSubscriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartContractSubscriptionDefaultTypeInternal() {}
  union {
    SmartContractSubscription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartContractSubscriptionDefaultTypeInternal _SmartContractSubscription_default_instance_;
PROTOBUF_CONSTEXPR Subscriber::Subscriber(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubscriberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubscriberDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubscriberDefaultTypeInternal() {}
  union {
    Subscriber _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubscriberDefaultTypeInternal _Subscriber_default_instance_;
PROTOBUF_CONSTEXPR WalletChange::WalletChange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_ids_)*/{}
  , /*decltype(_impl_.old_balances_)*/{}
  , /*decltype(_impl_.new_balances_)*/{}
  , /*decltype(_impl_.wallet_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WalletChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WalletChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WalletChangeDefaultTypeInternal() {}
  union {
    WalletChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WalletChangeDefaultTypeInternal _WalletChange_default_instance_;
}  // namespace zera_api
static ::_pb::Metadata file_level_metadata_zera_5fapi_2eproto[28];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_zera_5fapi_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_zera_5fapi_2eproto = nullptr;

const uint32_t TableStruct_zera_5fapi_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerRequest, _impl_.key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.ledger_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.ledger_values_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.proposal_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.proposal_values_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.wallets_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.wallets_values_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.temp_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.temp_values_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.voted_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ProposalLedgerResponse, _impl_.voted_values_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::BlockRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::zera_api::BlockRequest, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::zera_api::BlockRequest, _impl_.encoded_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BlockRequest, _impl_.payload_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::BlockResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::BlockResponse, _impl_.block_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::NonceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::NonceRequest, _impl_.wallet_address_),
  PROTOBUF_FIELD_OFFSET(::zera_api::NonceRequest, _impl_.encoded_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::NonceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::NonceResponse, _impl_.nonce_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::BalanceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::BalanceRequest, _impl_.wallet_address_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BalanceRequest, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BalanceRequest, _impl_.encoded_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::BalanceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::BalanceResponse, _impl_.balance_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BalanceResponse, _impl_.denomination_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BalanceResponse, _impl_.rate_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::ContractFeeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::ContractFeeRequest, _impl_.contract_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::ContractFeeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::ContractFeeResponse, _impl_.contract_fee_type_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ContractFeeResponse, _impl_.allowed_fee_instrument_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ContractFeeResponse, _impl_.fee_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BaseFeeRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BaseFeeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::BaseFeeRequest, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BaseFeeRequest, _impl_.txn_type_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::BaseFeeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::BaseFeeResponse, _impl_.key_fee_),
  PROTOBUF_FIELD_OFFSET(::zera_api::BaseFeeResponse, _impl_.byte_fee_),
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfo, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfo, _impl_.rate_),
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfo, _impl_.authorized_),
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfo, _impl_.denomination_),
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfo, _impl_.contract_fees_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfoRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfoRequest, _impl_.contract_ids_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::TokenFeeInfoResponse, _impl_.tokens_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::Item, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::Item, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_api::Item, _impl_.item_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::ItemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::ItemRequest, _impl_.wallet_address_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ItemRequest, _impl_.encoded_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::ItemResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::ItemResponse, _impl_.items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::DenominationRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::DenominationRequest, _impl_.contract_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::DenominationResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::DenominationResponse, _impl_.denomination_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::DatabaseRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::DatabaseRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::zera_api::DatabaseRequest, _impl_.key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::DatabaseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::DatabaseResponse, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.smart_contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.instance_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.host_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.subscribe_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::zera_api::ActivityRequest, _impl_.nonce_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.smart_contract_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.instance_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.gas_used_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.gas_approved_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.storage_fee_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.caller_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.event_data_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.function_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.block_height_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.block_hash_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.txn_hash_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractEventsResponse, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractSubscription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::SmartContractSubscription, _impl_.subscibers_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::Subscriber, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::Subscriber, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::zera_api::Subscriber, _impl_.host_),
  PROTOBUF_FIELD_OFFSET(::zera_api::Subscriber, _impl_.port_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_api::WalletChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_api::WalletChange, _impl_.wallet_address_),
  PROTOBUF_FIELD_OFFSET(::zera_api::WalletChange, _impl_.contract_ids_),
  PROTOBUF_FIELD_OFFSET(::zera_api::WalletChange, _impl_.old_balances_),
  PROTOBUF_FIELD_OFFSET(::zera_api::WalletChange, _impl_.new_balances_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::zera_api::ProposalLedgerRequest)},
  { 8, -1, -1, sizeof(::zera_api::ProposalLedgerResponse)},
  { 24, -1, -1, sizeof(::zera_api::BlockRequest)},
  { 34, -1, -1, sizeof(::zera_api::BlockResponse)},
  { 41, -1, -1, sizeof(::zera_api::NonceRequest)},
  { 49, -1, -1, sizeof(::zera_api::NonceResponse)},
  { 56, -1, -1, sizeof(::zera_api::BalanceRequest)},
  { 65, -1, -1, sizeof(::zera_api::BalanceResponse)},
  { 74, -1, -1, sizeof(::zera_api::ContractFeeRequest)},
  { 81, -1, -1, sizeof(::zera_api::ContractFeeResponse)},
  { 90, 98, -1, sizeof(::zera_api::BaseFeeRequest)},
  { 100, -1, -1, sizeof(::zera_api::BaseFeeResponse)},
  { 108, 119, -1, sizeof(::zera_api::TokenFeeInfo)},
  { 124, -1, -1, sizeof(::zera_api::TokenFeeInfoRequest)},
  { 131, -1, -1, sizeof(::zera_api::TokenFeeInfoResponse)},
  { 138, -1, -1, sizeof(::zera_api::Item)},
  { 146, -1, -1, sizeof(::zera_api::ItemRequest)},
  { 154, -1, -1, sizeof(::zera_api::ItemResponse)},
  { 161, -1, -1, sizeof(::zera_api::DenominationRequest)},
  { 168, -1, -1, sizeof(::zera_api::DenominationResponse)},
  { 175, -1, -1, sizeof(::zera_api::DatabaseRequest)},
  { 183, -1, -1, sizeof(::zera_api::DatabaseResponse)},
  { 190, -1, -1, sizeof(::zera_api::ActivityRequest)},
  { 205, -1, -1, sizeof(::zera_api::SmartContractEventsResponse)},
  { 225, 233, -1, sizeof(::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse)},
  { 235, -1, -1, sizeof(::zera_api::SmartContractSubscription)},
  { 242, -1, -1, sizeof(::zera_api::Subscriber)},
  { 251, -1, -1, sizeof(::zera_api::WalletChange)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::zera_api::_ProposalLedgerRequest_default_instance_._instance,
  &::zera_api::_ProposalLedgerResponse_default_instance_._instance,
  &::zera_api::_BlockRequest_default_instance_._instance,
  &::zera_api::_BlockResponse_default_instance_._instance,
  &::zera_api::_NonceRequest_default_instance_._instance,
  &::zera_api::_NonceResponse_default_instance_._instance,
  &::zera_api::_BalanceRequest_default_instance_._instance,
  &::zera_api::_BalanceResponse_default_instance_._instance,
  &::zera_api::_ContractFeeRequest_default_instance_._instance,
  &::zera_api::_ContractFeeResponse_default_instance_._instance,
  &::zera_api::_BaseFeeRequest_default_instance_._instance,
  &::zera_api::_BaseFeeResponse_default_instance_._instance,
  &::zera_api::_TokenFeeInfo_default_instance_._instance,
  &::zera_api::_TokenFeeInfoRequest_default_instance_._instance,
  &::zera_api::_TokenFeeInfoResponse_default_instance_._instance,
  &::zera_api::_Item_default_instance_._instance,
  &::zera_api::_ItemRequest_default_instance_._instance,
  &::zera_api::_ItemResponse_default_instance_._instance,
  &::zera_api::_DenominationRequest_default_instance_._instance,
  &::zera_api::_DenominationResponse_default_instance_._instance,
  &::zera_api::_DatabaseRequest_default_instance_._instance,
  &::zera_api::_DatabaseResponse_default_instance_._instance,
  &::zera_api::_ActivityRequest_default_instance_._instance,
  &::zera_api::_SmartContractEventsResponse_default_instance_._instance,
  &::zera_api::_SmartContractSubscription_SubscibersEntry_DoNotUse_default_instance_._instance,
  &::zera_api::_SmartContractSubscription_default_instance_._instance,
  &::zera_api::_Subscriber_default_instance_._instance,
  &::zera_api::_WalletChange_default_instance_._instance,
};

const char descriptor_table_protodef_zera_5fapi_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016zera_api.proto\022\010zera_api\032\033google/proto"
  "buf/empty.proto\032\037google/protobuf/timesta"
  "mp.proto\032\ttxn.proto\032\017validator.proto\"K\n\025"
  "ProposalLedgerRequest\022%\n\004type\030\001 \001(\0162\027.ze"
  "ra_api.DATABASE_TYPE\022\013\n\003key\030\002 \001(\t\"\364\001\n\026Pr"
  "oposalLedgerResponse\022\023\n\013ledger_keys\030\001 \003("
  "\t\022\025\n\rledger_values\030\002 \003(\t\022\025\n\rproposal_key"
  "s\030\003 \003(\t\022\027\n\017proposal_values\030\004 \003(\t\022\024\n\014wall"
  "ets_keys\030\005 \003(\t\022\026\n\016wallets_values\030\006 \003(\t\022\021"
  "\n\ttemp_keys\030\007 \003(\t\022\023\n\013temp_values\030\010 \003(\t\022\022"
  "\n\nvoted_keys\030\t \003(\t\022\024\n\014voted_values\030\n \003(\t"
  "\"X\n\014BlockRequest\022\026\n\014block_height\030\001 \001(\004H\000"
  "\022\024\n\nblock_hash\030\002 \001(\tH\000\022\017\n\007encoded\030\003 \001(\010B"
  "\t\n\007payload\"5\n\rBlockResponse\022$\n\005block\030\001 \001"
  "(\0132\025.zera_validator.Block\"7\n\014NonceReques"
  "t\022\026\n\016wallet_address\030\001 \001(\014\022\017\n\007encoded\030\003 \001"
  "(\010\"\036\n\rNonceResponse\022\r\n\005nonce\030\001 \001(\004\"N\n\016Ba"
  "lanceRequest\022\026\n\016wallet_address\030\001 \001(\014\022\023\n\013"
  "contract_id\030\002 \001(\t\022\017\n\007encoded\030\003 \001(\010\"F\n\017Ba"
  "lanceResponse\022\017\n\007balance\030\001 \001(\t\022\024\n\014denomi"
  "nation\030\002 \001(\t\022\014\n\004rate\030\003 \001(\t\")\n\022ContractFe"
  "eRequest\022\023\n\013contract_id\030\001 \001(\t\"z\n\023Contrac"
  "tFeeResponse\0226\n\021contract_fee_type\030\001 \001(\0162"
  "\033.zera_txn.CONTRACT_FEE_TYPE\022\036\n\026allowed_"
  "fee_instrument\030\002 \003(\t\022\013\n\003fee\030\003 \001(\t\"{\n\016Bas"
  "eFeeRequest\022,\n\npublic_key\030\001 \001(\0132\023.zera_t"
  "xn.PublicKeyH\000\210\001\001\022,\n\010txn_type\030\002 \001(\0162\032.ze"
  "ra_txn.TRANSACTION_TYPEB\r\n\013_public_key\"4"
  "\n\017BaseFeeResponse\022\017\n\007key_fee\030\001 \001(\t\022\020\n\010by"
  "te_fee\030\002 \001(\t\"\241\001\n\014TokenFeeInfo\022\023\n\013contrac"
  "t_id\030\001 \001(\t\022\014\n\004rate\030\002 \001(\t\022\022\n\nauthorized\030\003"
  " \001(\010\022\024\n\014denomination\030\004 \001(\t\0222\n\rcontract_f"
  "ees\030\005 \001(\0132\026.zera_txn.ContractFeesH\000\210\001\001B\020"
  "\n\016_contract_fees\"+\n\023TokenFeeInfoRequest\022"
  "\024\n\014contract_ids\030\001 \003(\t\">\n\024TokenFeeInfoRes"
  "ponse\022&\n\006tokens\030\001 \003(\0132\026.zera_api.TokenFe"
  "eInfo\",\n\004Item\022\023\n\013contract_id\030\001 \001(\t\022\017\n\007it"
  "em_id\030\002 \001(\t\"6\n\013ItemRequest\022\026\n\016wallet_add"
  "ress\030\001 \001(\014\022\017\n\007encoded\030\002 \001(\010\"-\n\014ItemRespo"
  "nse\022\035\n\005items\030\001 \003(\0132\016.zera_api.Item\"*\n\023De"
  "nominationRequest\022\023\n\013contract_id\030\001 \001(\t\","
  "\n\024DenominationResponse\022\024\n\014denomination\030\001"
  " \001(\t\"E\n\017DatabaseRequest\022%\n\004type\030\001 \001(\0162\027."
  "zera_api.DATABASE_TYPE\022\013\n\003key\030\002 \001(\t\"!\n\020D"
  "atabaseResponse\022\r\n\005value\030\001 \001(\t\"\345\001\n\017Activ"
  "ityRequest\022\031\n\021smart_contract_id\030\001 \001(\t\022\020\n"
  "\010instance\030\002 \001(\004\022+\n\005level\030\003 \001(\0162\034.zera_ap"
  "i.CONFIRMATION_LEVEL\022\014\n\004host\030\004 \001(\t\022\014\n\004po"
  "rt\030\005 \001(\005\022\021\n\tsubscribe\030\006 \001(\010\022\'\n\npublic_ke"
  "y\030\007 \001(\0132\023.zera_txn.PublicKey\022\021\n\tsignatur"
  "e\030\010 \001(\014\022\r\n\005nonce\030\t \001(\004\"\366\002\n\033SmartContract"
  "EventsResponse\022\026\n\016smart_contract\030\001 \001(\t\022\020"
  "\n\010instance\030\002 \001(\004\022\020\n\010gas_used\030\003 \001(\004\022\024\n\014ga"
  "s_approved\030\004 \001(\004\022\023\n\013storage_fee\030\005 \001(\t\022#\n"
  "\006caller\030\006 \001(\0132\023.zera_txn.PublicKey\022\022\n\nev"
  "ent_data\030\007 \001(\014\022\020\n\010function\030\010 \001(\t\022\024\n\014bloc"
  "k_height\030\t \001(\004\022-\n\ttimestamp\030\n \001(\0132\032.goog"
  "le.protobuf.Timestamp\022\022\n\nblock_hash\030\013 \001("
  "\t\022\020\n\010txn_hash\030\014 \001(\t\022\'\n\npublic_key\030\r \001(\0132"
  "\023.zera_txn.PublicKey\022\021\n\tsignature\030\016 \001(\014\""
  "\255\001\n\031SmartContractSubscription\022G\n\nsubscib"
  "ers\030\001 \003(\01323.zera_api.SmartContractSubscr"
  "iption.SubscibersEntry\032G\n\017SubscibersEntr"
  "y\022\013\n\003key\030\001 \001(\t\022#\n\005value\030\002 \001(\0132\024.zera_api"
  ".Subscriber:\0028\001\"U\n\nSubscriber\022+\n\005level\030\001"
  " \001(\0162\034.zera_api.CONFIRMATION_LEVEL\022\014\n\004ho"
  "st\030\002 \001(\t\022\014\n\004port\030\003 \001(\005\"h\n\014WalletChange\022\026"
  "\n\016wallet_address\030\001 \001(\014\022\024\n\014contract_ids\030\002"
  " \003(\t\022\024\n\014old_balances\030\003 \003(\t\022\024\n\014new_balanc"
  "es\030\004 \003(\t*A\n\022CONFIRMATION_LEVEL\022\r\n\tPROCES"
  "SED\020\000\022\r\n\tFINALIZED\020\001\022\r\n\tCONFIRMED\020\002*\305\002\n\r"
  "DATABASE_TYPE\022\013\n\007UNKNOWN\020\000\022\r\n\tCONTRACTS\020"
  "\001\022\016\n\nHASH_INDEX\020\002\022\023\n\017CONTRACT_SUPPLY\020\003\022\023"
  "\n\017SMART_CONTRACTS\020\004\022\016\n\nVALIDATORS\020\005\022\n\n\006B"
  "LOCKS\020\006\022\013\n\007HEADERS\020\007\022\020\n\014TRANSACTIONS\020\010\022\022"
  "\n\016CONTRACT_ITEMS\020\t\022\027\n\023VALIDATOR_UNBONDIN"
  "G\020\n\022\023\n\017PROPOSAL_LEDGER\020\013\022\r\n\tPROPOSALS\020\014\022"
  "\030\n\024CURRENCY_EQUIVALENTS\020\r\022\021\n\rEXPENSE_RAT"
  "IO\020\016\022\017\n\013ATTESTATION\020\017\022\024\n\020CONFIRMED_BLOCK"
  "S\020\020*Y\n\rPROPOSAL_TYPE\022\021\n\rALL_PROPOSALS\020\000\022"
  "\017\n\013ALL_LEDGERS\020\001\022\022\n\016PROPOSAL_BY_ID\020\002\022\020\n\014"
  "LEDGER_BY_ID\020\0032\346\006\n\nAPIService\022>\n\007Balance"
  "\022\030.zera_api.BalanceRequest\032\031.zera_api.Ba"
  "lanceResponse\0228\n\005Nonce\022\026.zera_api.NonceR"
  "equest\032\027.zera_api.NonceResponse\022J\n\013Contr"
  "actFee\022\034.zera_api.ContractFeeRequest\032\035.z"
  "era_api.ContractFeeResponse\022>\n\007BaseFee\022\030"
  ".zera_api.BaseFeeRequest\032\031.zera_api.Base"
  "FeeResponse\022P\n\017GetTokenFeeInfo\022\035.zera_ap"
  "i.TokenFeeInfoRequest\032\036.zera_api.TokenFe"
  "eInfoResponse\0226\n\005Items\022\025.zera_api.ItemRe"
  "quest\032\026.zera_api.ItemResponse\022M\n\014Denomin"
  "ation\022\035.zera_api.DenominationRequest\032\036.z"
  "era_api.DenominationResponse\022A\n\010Database"
  "\022\031.zera_api.DatabaseRequest\032\032.zera_api.D"
  "atabaseResponse\0228\n\005Block\022\026.zera_api.Bloc"
  "kRequest\032\027.zera_api.BlockResponse\022S\n\016Pro"
  "posalLedger\022\037.zera_api.ProposalLedgerReq"
  "uest\032 .zera_api.ProposalLedgerResponse\022Q"
  "\n\034SmartContractActivityRequest\022\031.zera_ap"
  "i.ActivityRequest\032\026.google.protobuf.Empt"
  "y\022T\n\023SmartContractEvents\022%.zera_api.Smar"
  "tContractEventsResponse\032\026.google.protobu"
  "f.EmptyB\002H\001b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_zera_5fapi_2eproto_deps[4] = {
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
  &::descriptor_table_txn_2eproto,
  &::descriptor_table_validator_2eproto,
};
static ::_pbi::once_flag descriptor_table_zera_5fapi_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_zera_5fapi_2eproto = {
    false, false, 4139, descriptor_table_protodef_zera_5fapi_2eproto,
    "zera_api.proto",
    &descriptor_table_zera_5fapi_2eproto_once, descriptor_table_zera_5fapi_2eproto_deps, 4, 28,
    schemas, file_default_instances, TableStruct_zera_5fapi_2eproto::offsets,
    file_level_metadata_zera_5fapi_2eproto, file_level_enum_descriptors_zera_5fapi_2eproto,
    file_level_service_descriptors_zera_5fapi_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_zera_5fapi_2eproto_getter() {
  return &descriptor_table_zera_5fapi_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_zera_5fapi_2eproto(&descriptor_table_zera_5fapi_2eproto);
namespace zera_api {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CONFIRMATION_LEVEL_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_zera_5fapi_2eproto);
  return file_level_enum_descriptors_zera_5fapi_2eproto[0];
}
bool CONFIRMATION_LEVEL_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DATABASE_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_zera_5fapi_2eproto);
  return file_level_enum_descriptors_zera_5fapi_2eproto[1];
}
bool DATABASE_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PROPOSAL_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_zera_5fapi_2eproto);
  return file_level_enum_descriptors_zera_5fapi_2eproto[2];
}
bool PROPOSAL_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ProposalLedgerRequest::_Internal {
 public:
};

ProposalLedgerRequest::ProposalLedgerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.ProposalLedgerRequest)
}
ProposalLedgerRequest::ProposalLedgerRequest(const ProposalLedgerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProposalLedgerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:zera_api.ProposalLedgerRequest)
}

inline void ProposalLedgerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProposalLedgerRequest::~ProposalLedgerRequest() {
  // @@protoc_insertion_point(destructor:zera_api.ProposalLedgerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProposalLedgerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void ProposalLedgerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProposalLedgerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.ProposalLedgerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProposalLedgerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_api.DATABASE_TYPE type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::zera_api::DATABASE_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // string key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerRequest.key"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProposalLedgerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.ProposalLedgerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_api.DATABASE_TYPE type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // string key = 2;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerRequest.key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.ProposalLedgerRequest)
  return target;
}

size_t ProposalLedgerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.ProposalLedgerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // .zera_api.DATABASE_TYPE type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProposalLedgerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProposalLedgerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProposalLedgerRequest::GetClassData() const { return &_class_data_; }


void ProposalLedgerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProposalLedgerRequest*>(&to_msg);
  auto& from = static_cast<const ProposalLedgerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.ProposalLedgerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProposalLedgerRequest::CopyFrom(const ProposalLedgerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.ProposalLedgerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProposalLedgerRequest::IsInitialized() const {
  return true;
}

void ProposalLedgerRequest::InternalSwap(ProposalLedgerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProposalLedgerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[0]);
}

// ===================================================================

class ProposalLedgerResponse::_Internal {
 public:
};

ProposalLedgerResponse::ProposalLedgerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.ProposalLedgerResponse)
}
ProposalLedgerResponse::ProposalLedgerResponse(const ProposalLedgerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProposalLedgerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ledger_keys_){from._impl_.ledger_keys_}
    , decltype(_impl_.ledger_values_){from._impl_.ledger_values_}
    , decltype(_impl_.proposal_keys_){from._impl_.proposal_keys_}
    , decltype(_impl_.proposal_values_){from._impl_.proposal_values_}
    , decltype(_impl_.wallets_keys_){from._impl_.wallets_keys_}
    , decltype(_impl_.wallets_values_){from._impl_.wallets_values_}
    , decltype(_impl_.temp_keys_){from._impl_.temp_keys_}
    , decltype(_impl_.temp_values_){from._impl_.temp_values_}
    , decltype(_impl_.voted_keys_){from._impl_.voted_keys_}
    , decltype(_impl_.voted_values_){from._impl_.voted_values_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_api.ProposalLedgerResponse)
}

inline void ProposalLedgerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ledger_keys_){arena}
    , decltype(_impl_.ledger_values_){arena}
    , decltype(_impl_.proposal_keys_){arena}
    , decltype(_impl_.proposal_values_){arena}
    , decltype(_impl_.wallets_keys_){arena}
    , decltype(_impl_.wallets_values_){arena}
    , decltype(_impl_.temp_keys_){arena}
    , decltype(_impl_.temp_values_){arena}
    , decltype(_impl_.voted_keys_){arena}
    , decltype(_impl_.voted_values_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProposalLedgerResponse::~ProposalLedgerResponse() {
  // @@protoc_insertion_point(destructor:zera_api.ProposalLedgerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProposalLedgerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ledger_keys_.~RepeatedPtrField();
  _impl_.ledger_values_.~RepeatedPtrField();
  _impl_.proposal_keys_.~RepeatedPtrField();
  _impl_.proposal_values_.~RepeatedPtrField();
  _impl_.wallets_keys_.~RepeatedPtrField();
  _impl_.wallets_values_.~RepeatedPtrField();
  _impl_.temp_keys_.~RepeatedPtrField();
  _impl_.temp_values_.~RepeatedPtrField();
  _impl_.voted_keys_.~RepeatedPtrField();
  _impl_.voted_values_.~RepeatedPtrField();
}

void ProposalLedgerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProposalLedgerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.ProposalLedgerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ledger_keys_.Clear();
  _impl_.ledger_values_.Clear();
  _impl_.proposal_keys_.Clear();
  _impl_.proposal_values_.Clear();
  _impl_.wallets_keys_.Clear();
  _impl_.wallets_values_.Clear();
  _impl_.temp_keys_.Clear();
  _impl_.temp_values_.Clear();
  _impl_.voted_keys_.Clear();
  _impl_.voted_values_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProposalLedgerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string ledger_keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_ledger_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.ledger_keys"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string ledger_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_ledger_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.ledger_values"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string proposal_keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_proposal_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.proposal_keys"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string proposal_values = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_proposal_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.proposal_values"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string wallets_keys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_wallets_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.wallets_keys"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string wallets_values = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_wallets_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.wallets_values"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string temp_keys = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_temp_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.temp_keys"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string temp_values = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_temp_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.temp_values"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string voted_keys = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_voted_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.voted_keys"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string voted_values = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_voted_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ProposalLedgerResponse.voted_values"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProposalLedgerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.ProposalLedgerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string ledger_keys = 1;
  for (int i = 0, n = this->_internal_ledger_keys_size(); i < n; i++) {
    const auto& s = this->_internal_ledger_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.ledger_keys");
    target = stream->WriteString(1, s, target);
  }

  // repeated string ledger_values = 2;
  for (int i = 0, n = this->_internal_ledger_values_size(); i < n; i++) {
    const auto& s = this->_internal_ledger_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.ledger_values");
    target = stream->WriteString(2, s, target);
  }

  // repeated string proposal_keys = 3;
  for (int i = 0, n = this->_internal_proposal_keys_size(); i < n; i++) {
    const auto& s = this->_internal_proposal_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.proposal_keys");
    target = stream->WriteString(3, s, target);
  }

  // repeated string proposal_values = 4;
  for (int i = 0, n = this->_internal_proposal_values_size(); i < n; i++) {
    const auto& s = this->_internal_proposal_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.proposal_values");
    target = stream->WriteString(4, s, target);
  }

  // repeated string wallets_keys = 5;
  for (int i = 0, n = this->_internal_wallets_keys_size(); i < n; i++) {
    const auto& s = this->_internal_wallets_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.wallets_keys");
    target = stream->WriteString(5, s, target);
  }

  // repeated string wallets_values = 6;
  for (int i = 0, n = this->_internal_wallets_values_size(); i < n; i++) {
    const auto& s = this->_internal_wallets_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.wallets_values");
    target = stream->WriteString(6, s, target);
  }

  // repeated string temp_keys = 7;
  for (int i = 0, n = this->_internal_temp_keys_size(); i < n; i++) {
    const auto& s = this->_internal_temp_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.temp_keys");
    target = stream->WriteString(7, s, target);
  }

  // repeated string temp_values = 8;
  for (int i = 0, n = this->_internal_temp_values_size(); i < n; i++) {
    const auto& s = this->_internal_temp_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.temp_values");
    target = stream->WriteString(8, s, target);
  }

  // repeated string voted_keys = 9;
  for (int i = 0, n = this->_internal_voted_keys_size(); i < n; i++) {
    const auto& s = this->_internal_voted_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.voted_keys");
    target = stream->WriteString(9, s, target);
  }

  // repeated string voted_values = 10;
  for (int i = 0, n = this->_internal_voted_values_size(); i < n; i++) {
    const auto& s = this->_internal_voted_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ProposalLedgerResponse.voted_values");
    target = stream->WriteString(10, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.ProposalLedgerResponse)
  return target;
}

size_t ProposalLedgerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.ProposalLedgerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string ledger_keys = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.ledger_keys_.size());
  for (int i = 0, n = _impl_.ledger_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.ledger_keys_.Get(i));
  }

  // repeated string ledger_values = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.ledger_values_.size());
  for (int i = 0, n = _impl_.ledger_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.ledger_values_.Get(i));
  }

  // repeated string proposal_keys = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.proposal_keys_.size());
  for (int i = 0, n = _impl_.proposal_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.proposal_keys_.Get(i));
  }

  // repeated string proposal_values = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.proposal_values_.size());
  for (int i = 0, n = _impl_.proposal_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.proposal_values_.Get(i));
  }

  // repeated string wallets_keys = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.wallets_keys_.size());
  for (int i = 0, n = _impl_.wallets_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.wallets_keys_.Get(i));
  }

  // repeated string wallets_values = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.wallets_values_.size());
  for (int i = 0, n = _impl_.wallets_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.wallets_values_.Get(i));
  }

  // repeated string temp_keys = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.temp_keys_.size());
  for (int i = 0, n = _impl_.temp_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.temp_keys_.Get(i));
  }

  // repeated string temp_values = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.temp_values_.size());
  for (int i = 0, n = _impl_.temp_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.temp_values_.Get(i));
  }

  // repeated string voted_keys = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.voted_keys_.size());
  for (int i = 0, n = _impl_.voted_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.voted_keys_.Get(i));
  }

  // repeated string voted_values = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.voted_values_.size());
  for (int i = 0, n = _impl_.voted_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.voted_values_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProposalLedgerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProposalLedgerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProposalLedgerResponse::GetClassData() const { return &_class_data_; }


void ProposalLedgerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProposalLedgerResponse*>(&to_msg);
  auto& from = static_cast<const ProposalLedgerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.ProposalLedgerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ledger_keys_.MergeFrom(from._impl_.ledger_keys_);
  _this->_impl_.ledger_values_.MergeFrom(from._impl_.ledger_values_);
  _this->_impl_.proposal_keys_.MergeFrom(from._impl_.proposal_keys_);
  _this->_impl_.proposal_values_.MergeFrom(from._impl_.proposal_values_);
  _this->_impl_.wallets_keys_.MergeFrom(from._impl_.wallets_keys_);
  _this->_impl_.wallets_values_.MergeFrom(from._impl_.wallets_values_);
  _this->_impl_.temp_keys_.MergeFrom(from._impl_.temp_keys_);
  _this->_impl_.temp_values_.MergeFrom(from._impl_.temp_values_);
  _this->_impl_.voted_keys_.MergeFrom(from._impl_.voted_keys_);
  _this->_impl_.voted_values_.MergeFrom(from._impl_.voted_values_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProposalLedgerResponse::CopyFrom(const ProposalLedgerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.ProposalLedgerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProposalLedgerResponse::IsInitialized() const {
  return true;
}

void ProposalLedgerResponse::InternalSwap(ProposalLedgerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ledger_keys_.InternalSwap(&other->_impl_.ledger_keys_);
  _impl_.ledger_values_.InternalSwap(&other->_impl_.ledger_values_);
  _impl_.proposal_keys_.InternalSwap(&other->_impl_.proposal_keys_);
  _impl_.proposal_values_.InternalSwap(&other->_impl_.proposal_values_);
  _impl_.wallets_keys_.InternalSwap(&other->_impl_.wallets_keys_);
  _impl_.wallets_values_.InternalSwap(&other->_impl_.wallets_values_);
  _impl_.temp_keys_.InternalSwap(&other->_impl_.temp_keys_);
  _impl_.temp_values_.InternalSwap(&other->_impl_.temp_values_);
  _impl_.voted_keys_.InternalSwap(&other->_impl_.voted_keys_);
  _impl_.voted_values_.InternalSwap(&other->_impl_.voted_values_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProposalLedgerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[1]);
}

// ===================================================================

class BlockRequest::_Internal {
 public:
};

BlockRequest::BlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.BlockRequest)
}
BlockRequest::BlockRequest(const BlockRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_){}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.encoded_ = from._impl_.encoded_;
  clear_has_payload();
  switch (from.payload_case()) {
    case kBlockHeight: {
      _this->_internal_set_block_height(from._internal_block_height());
      break;
    }
    case kBlockHash: {
      _this->_internal_set_block_hash(from._internal_block_hash());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.BlockRequest)
}

inline void BlockRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_){false}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

BlockRequest::~BlockRequest() {
  // @@protoc_insertion_point(destructor:zera_api.BlockRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload()) {
    clear_payload();
  }
}

void BlockRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockRequest::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:zera_api.BlockRequest)
  switch (payload_case()) {
    case kBlockHeight: {
      // No need to clear
      break;
    }
    case kBlockHash: {
      _impl_.payload_.block_hash_.Destroy();
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void BlockRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.BlockRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.encoded_ = false;
  clear_payload();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 block_height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string block_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_block_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.BlockRequest.block_hash"));
        } else
          goto handle_unusual;
        continue;
      // bool encoded = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.encoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.BlockRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 block_height = 1;
  if (_internal_has_block_height()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_block_height(), target);
  }

  // string block_hash = 2;
  if (_internal_has_block_hash()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_block_hash().data(), static_cast<int>(this->_internal_block_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.BlockRequest.block_hash");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_block_hash(), target);
  }

  // bool encoded = 3;
  if (this->_internal_encoded() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_encoded(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.BlockRequest)
  return target;
}

size_t BlockRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.BlockRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool encoded = 3;
  if (this->_internal_encoded() != 0) {
    total_size += 1 + 1;
  }

  switch (payload_case()) {
    // uint64 block_height = 1;
    case kBlockHeight: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_block_height());
      break;
    }
    // string block_hash = 2;
    case kBlockHash: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_block_hash());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockRequest::GetClassData() const { return &_class_data_; }


void BlockRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockRequest*>(&to_msg);
  auto& from = static_cast<const BlockRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.BlockRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_encoded() != 0) {
    _this->_internal_set_encoded(from._internal_encoded());
  }
  switch (from.payload_case()) {
    case kBlockHeight: {
      _this->_internal_set_block_height(from._internal_block_height());
      break;
    }
    case kBlockHash: {
      _this->_internal_set_block_hash(from._internal_block_hash());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockRequest::CopyFrom(const BlockRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.BlockRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockRequest::IsInitialized() const {
  return true;
}

void BlockRequest::InternalSwap(BlockRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.encoded_, other->_impl_.encoded_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[2]);
}

// ===================================================================

class BlockResponse::_Internal {
 public:
  static const ::zera_validator::Block& block(const BlockResponse* msg);
};

const ::zera_validator::Block&
BlockResponse::_Internal::block(const BlockResponse* msg) {
  return *msg->_impl_.block_;
}
void BlockResponse::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
BlockResponse::BlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.BlockResponse)
}
BlockResponse::BlockResponse(const BlockResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_block()) {
    _this->_impl_.block_ = new ::zera_validator::Block(*from._impl_.block_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.BlockResponse)
}

inline void BlockResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BlockResponse::~BlockResponse() {
  // @@protoc_insertion_point(destructor:zera_api.BlockResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.block_;
}

void BlockResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.BlockResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_validator.Block block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.BlockResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_validator.Block block = 1;
  if (this->_internal_has_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::block(this),
        _Internal::block(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.BlockResponse)
  return target;
}

size_t BlockResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.BlockResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .zera_validator.Block block = 1;
  if (this->_internal_has_block()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.block_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockResponse::GetClassData() const { return &_class_data_; }


void BlockResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockResponse*>(&to_msg);
  auto& from = static_cast<const BlockResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.BlockResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_block()) {
    _this->_internal_mutable_block()->::zera_validator::Block::MergeFrom(
        from._internal_block());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockResponse::CopyFrom(const BlockResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.BlockResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockResponse::IsInitialized() const {
  return true;
}

void BlockResponse::InternalSwap(BlockResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.block_, other->_impl_.block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[3]);
}

// ===================================================================

class NonceRequest::_Internal {
 public:
};

NonceRequest::NonceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.NonceRequest)
}
NonceRequest::NonceRequest(const NonceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NonceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.wallet_address_){}
    , decltype(_impl_.encoded_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_wallet_address().empty()) {
    _this->_impl_.wallet_address_.Set(from._internal_wallet_address(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.encoded_ = from._impl_.encoded_;
  // @@protoc_insertion_point(copy_constructor:zera_api.NonceRequest)
}

inline void NonceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.wallet_address_){}
    , decltype(_impl_.encoded_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NonceRequest::~NonceRequest() {
  // @@protoc_insertion_point(destructor:zera_api.NonceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NonceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wallet_address_.Destroy();
}

void NonceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NonceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.NonceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wallet_address_.ClearToEmpty();
  _impl_.encoded_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NonceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes wallet_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_wallet_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool encoded = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.encoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NonceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.NonceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_wallet_address(), target);
  }

  // bool encoded = 3;
  if (this->_internal_encoded() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_encoded(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.NonceRequest)
  return target;
}

size_t NonceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.NonceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_wallet_address());
  }

  // bool encoded = 3;
  if (this->_internal_encoded() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NonceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NonceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NonceRequest::GetClassData() const { return &_class_data_; }


void NonceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NonceRequest*>(&to_msg);
  auto& from = static_cast<const NonceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.NonceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_wallet_address().empty()) {
    _this->_internal_set_wallet_address(from._internal_wallet_address());
  }
  if (from._internal_encoded() != 0) {
    _this->_internal_set_encoded(from._internal_encoded());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NonceRequest::CopyFrom(const NonceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.NonceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NonceRequest::IsInitialized() const {
  return true;
}

void NonceRequest::InternalSwap(NonceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wallet_address_, lhs_arena,
      &other->_impl_.wallet_address_, rhs_arena
  );
  swap(_impl_.encoded_, other->_impl_.encoded_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NonceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[4]);
}

// ===================================================================

class NonceResponse::_Internal {
 public:
};

NonceResponse::NonceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.NonceResponse)
}
NonceResponse::NonceResponse(const NonceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NonceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nonce_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.nonce_ = from._impl_.nonce_;
  // @@protoc_insertion_point(copy_constructor:zera_api.NonceResponse)
}

inline void NonceResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nonce_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NonceResponse::~NonceResponse() {
  // @@protoc_insertion_point(destructor:zera_api.NonceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NonceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NonceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NonceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.NonceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nonce_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NonceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 nonce = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NonceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.NonceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_nonce(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.NonceResponse)
  return target;
}

size_t NonceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.NonceResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nonce());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NonceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NonceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NonceResponse::GetClassData() const { return &_class_data_; }


void NonceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NonceResponse*>(&to_msg);
  auto& from = static_cast<const NonceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.NonceResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NonceResponse::CopyFrom(const NonceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.NonceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NonceResponse::IsInitialized() const {
  return true;
}

void NonceResponse::InternalSwap(NonceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.nonce_, other->_impl_.nonce_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NonceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[5]);
}

// ===================================================================

class BalanceRequest::_Internal {
 public:
};

BalanceRequest::BalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.BalanceRequest)
}
BalanceRequest::BalanceRequest(const BalanceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BalanceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.wallet_address_){}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.encoded_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_wallet_address().empty()) {
    _this->_impl_.wallet_address_.Set(from._internal_wallet_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.encoded_ = from._impl_.encoded_;
  // @@protoc_insertion_point(copy_constructor:zera_api.BalanceRequest)
}

inline void BalanceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.wallet_address_){}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.encoded_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BalanceRequest::~BalanceRequest() {
  // @@protoc_insertion_point(destructor:zera_api.BalanceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BalanceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wallet_address_.Destroy();
  _impl_.contract_id_.Destroy();
}

void BalanceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BalanceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.BalanceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wallet_address_.ClearToEmpty();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.encoded_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BalanceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes wallet_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_wallet_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.BalanceRequest.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // bool encoded = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.encoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BalanceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.BalanceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_wallet_address(), target);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.BalanceRequest.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // bool encoded = 3;
  if (this->_internal_encoded() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_encoded(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.BalanceRequest)
  return target;
}

size_t BalanceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.BalanceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_wallet_address());
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // bool encoded = 3;
  if (this->_internal_encoded() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BalanceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BalanceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BalanceRequest::GetClassData() const { return &_class_data_; }


void BalanceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BalanceRequest*>(&to_msg);
  auto& from = static_cast<const BalanceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.BalanceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_wallet_address().empty()) {
    _this->_internal_set_wallet_address(from._internal_wallet_address());
  }
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (from._internal_encoded() != 0) {
    _this->_internal_set_encoded(from._internal_encoded());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BalanceRequest::CopyFrom(const BalanceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.BalanceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BalanceRequest::IsInitialized() const {
  return true;
}

void BalanceRequest::InternalSwap(BalanceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wallet_address_, lhs_arena,
      &other->_impl_.wallet_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  swap(_impl_.encoded_, other->_impl_.encoded_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BalanceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[6]);
}

// ===================================================================

class BalanceResponse::_Internal {
 public:
};

BalanceResponse::BalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.BalanceResponse)
}
BalanceResponse::BalanceResponse(const BalanceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BalanceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.balance_){}
    , decltype(_impl_.denomination_){}
    , decltype(_impl_.rate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.balance_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_balance().empty()) {
    _this->_impl_.balance_.Set(from._internal_balance(), 
      _this->GetArenaForAllocation());
  }
  _impl_.denomination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.denomination_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denomination().empty()) {
    _this->_impl_.denomination_.Set(from._internal_denomination(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rate().empty()) {
    _this->_impl_.rate_.Set(from._internal_rate(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.BalanceResponse)
}

inline void BalanceResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.balance_){}
    , decltype(_impl_.denomination_){}
    , decltype(_impl_.rate_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.balance_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.denomination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.denomination_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BalanceResponse::~BalanceResponse() {
  // @@protoc_insertion_point(destructor:zera_api.BalanceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BalanceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.balance_.Destroy();
  _impl_.denomination_.Destroy();
  _impl_.rate_.Destroy();
}

void BalanceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BalanceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.BalanceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.balance_.ClearToEmpty();
  _impl_.denomination_.ClearToEmpty();
  _impl_.rate_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BalanceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string balance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.BalanceResponse.balance"));
        } else
          goto handle_unusual;
        continue;
      // string denomination = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_denomination();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.BalanceResponse.denomination"));
        } else
          goto handle_unusual;
        continue;
      // string rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.BalanceResponse.rate"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BalanceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.BalanceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string balance = 1;
  if (!this->_internal_balance().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_balance().data(), static_cast<int>(this->_internal_balance().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.BalanceResponse.balance");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_balance(), target);
  }

  // string denomination = 2;
  if (!this->_internal_denomination().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_denomination().data(), static_cast<int>(this->_internal_denomination().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.BalanceResponse.denomination");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_denomination(), target);
  }

  // string rate = 3;
  if (!this->_internal_rate().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_rate().data(), static_cast<int>(this->_internal_rate().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.BalanceResponse.rate");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.BalanceResponse)
  return target;
}

size_t BalanceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.BalanceResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string balance = 1;
  if (!this->_internal_balance().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_balance());
  }

  // string denomination = 2;
  if (!this->_internal_denomination().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_denomination());
  }

  // string rate = 3;
  if (!this->_internal_rate().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_rate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BalanceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BalanceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BalanceResponse::GetClassData() const { return &_class_data_; }


void BalanceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BalanceResponse*>(&to_msg);
  auto& from = static_cast<const BalanceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.BalanceResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_balance().empty()) {
    _this->_internal_set_balance(from._internal_balance());
  }
  if (!from._internal_denomination().empty()) {
    _this->_internal_set_denomination(from._internal_denomination());
  }
  if (!from._internal_rate().empty()) {
    _this->_internal_set_rate(from._internal_rate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BalanceResponse::CopyFrom(const BalanceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.BalanceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BalanceResponse::IsInitialized() const {
  return true;
}

void BalanceResponse::InternalSwap(BalanceResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.balance_, lhs_arena,
      &other->_impl_.balance_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.denomination_, lhs_arena,
      &other->_impl_.denomination_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rate_, lhs_arena,
      &other->_impl_.rate_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata BalanceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[7]);
}

// ===================================================================

class ContractFeeRequest::_Internal {
 public:
};

ContractFeeRequest::ContractFeeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.ContractFeeRequest)
}
ContractFeeRequest::ContractFeeRequest(const ContractFeeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContractFeeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.ContractFeeRequest)
}

inline void ContractFeeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContractFeeRequest::~ContractFeeRequest() {
  // @@protoc_insertion_point(destructor:zera_api.ContractFeeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractFeeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
}

void ContractFeeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContractFeeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.ContractFeeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractFeeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.ContractFeeRequest.contract_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractFeeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.ContractFeeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ContractFeeRequest.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.ContractFeeRequest)
  return target;
}

size_t ContractFeeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.ContractFeeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractFeeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContractFeeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractFeeRequest::GetClassData() const { return &_class_data_; }


void ContractFeeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContractFeeRequest*>(&to_msg);
  auto& from = static_cast<const ContractFeeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.ContractFeeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractFeeRequest::CopyFrom(const ContractFeeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.ContractFeeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractFeeRequest::IsInitialized() const {
  return true;
}

void ContractFeeRequest::InternalSwap(ContractFeeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractFeeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[8]);
}

// ===================================================================

class ContractFeeResponse::_Internal {
 public:
};

ContractFeeResponse::ContractFeeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.ContractFeeResponse)
}
ContractFeeResponse::ContractFeeResponse(const ContractFeeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContractFeeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.allowed_fee_instrument_){from._impl_.allowed_fee_instrument_}
    , decltype(_impl_.fee_){}
    , decltype(_impl_.contract_fee_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee().empty()) {
    _this->_impl_.fee_.Set(from._internal_fee(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.contract_fee_type_ = from._impl_.contract_fee_type_;
  // @@protoc_insertion_point(copy_constructor:zera_api.ContractFeeResponse)
}

inline void ContractFeeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.allowed_fee_instrument_){arena}
    , decltype(_impl_.fee_){}
    , decltype(_impl_.contract_fee_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContractFeeResponse::~ContractFeeResponse() {
  // @@protoc_insertion_point(destructor:zera_api.ContractFeeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractFeeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allowed_fee_instrument_.~RepeatedPtrField();
  _impl_.fee_.Destroy();
}

void ContractFeeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContractFeeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.ContractFeeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowed_fee_instrument_.Clear();
  _impl_.fee_.ClearToEmpty();
  _impl_.contract_fee_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractFeeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_contract_fee_type(static_cast<::zera_txn::CONTRACT_FEE_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string allowed_fee_instrument = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allowed_fee_instrument();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.ContractFeeResponse.allowed_fee_instrument"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string fee = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.ContractFeeResponse.fee"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractFeeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.ContractFeeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 1;
  if (this->_internal_contract_fee_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_contract_fee_type(), target);
  }

  // repeated string allowed_fee_instrument = 2;
  for (int i = 0, n = this->_internal_allowed_fee_instrument_size(); i < n; i++) {
    const auto& s = this->_internal_allowed_fee_instrument(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ContractFeeResponse.allowed_fee_instrument");
    target = stream->WriteString(2, s, target);
  }

  // string fee = 3;
  if (!this->_internal_fee().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fee().data(), static_cast<int>(this->_internal_fee().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ContractFeeResponse.fee");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_fee(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.ContractFeeResponse)
  return target;
}

size_t ContractFeeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.ContractFeeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string allowed_fee_instrument = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.allowed_fee_instrument_.size());
  for (int i = 0, n = _impl_.allowed_fee_instrument_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.allowed_fee_instrument_.Get(i));
  }

  // string fee = 3;
  if (!this->_internal_fee().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fee());
  }

  // .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 1;
  if (this->_internal_contract_fee_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_contract_fee_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractFeeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContractFeeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractFeeResponse::GetClassData() const { return &_class_data_; }


void ContractFeeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContractFeeResponse*>(&to_msg);
  auto& from = static_cast<const ContractFeeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.ContractFeeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allowed_fee_instrument_.MergeFrom(from._impl_.allowed_fee_instrument_);
  if (!from._internal_fee().empty()) {
    _this->_internal_set_fee(from._internal_fee());
  }
  if (from._internal_contract_fee_type() != 0) {
    _this->_internal_set_contract_fee_type(from._internal_contract_fee_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractFeeResponse::CopyFrom(const ContractFeeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.ContractFeeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractFeeResponse::IsInitialized() const {
  return true;
}

void ContractFeeResponse::InternalSwap(ContractFeeResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.allowed_fee_instrument_.InternalSwap(&other->_impl_.allowed_fee_instrument_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fee_, lhs_arena,
      &other->_impl_.fee_, rhs_arena
  );
  swap(_impl_.contract_fee_type_, other->_impl_.contract_fee_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractFeeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[9]);
}

// ===================================================================

class BaseFeeRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<BaseFeeRequest>()._impl_._has_bits_);
  static const ::zera_txn::PublicKey& public_key(const BaseFeeRequest* msg);
  static void set_has_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::zera_txn::PublicKey&
BaseFeeRequest::_Internal::public_key(const BaseFeeRequest* msg) {
  return *msg->_impl_.public_key_;
}
void BaseFeeRequest::clear_public_key() {
  if (_impl_.public_key_ != nullptr) _impl_.public_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
BaseFeeRequest::BaseFeeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.BaseFeeRequest)
}
BaseFeeRequest::BaseFeeRequest(const BaseFeeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BaseFeeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.txn_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_ = new ::zera_txn::PublicKey(*from._impl_.public_key_);
  }
  _this->_impl_.txn_type_ = from._impl_.txn_type_;
  // @@protoc_insertion_point(copy_constructor:zera_api.BaseFeeRequest)
}

inline void BaseFeeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.txn_type_){0}
  };
}

BaseFeeRequest::~BaseFeeRequest() {
  // @@protoc_insertion_point(destructor:zera_api.BaseFeeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BaseFeeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.public_key_;
}

void BaseFeeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BaseFeeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.BaseFeeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.public_key_ != nullptr);
    _impl_.public_key_->Clear();
  }
  _impl_.txn_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BaseFeeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .zera_txn.PublicKey public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.TRANSACTION_TYPE txn_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_txn_type(static_cast<::zera_txn::TRANSACTION_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseFeeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.BaseFeeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .zera_txn.PublicKey public_key = 1;
  if (_internal_has_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.TRANSACTION_TYPE txn_type = 2;
  if (this->_internal_txn_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_txn_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.BaseFeeRequest)
  return target;
}

size_t BaseFeeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.BaseFeeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .zera_txn.PublicKey public_key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.public_key_);
  }

  // .zera_txn.TRANSACTION_TYPE txn_type = 2;
  if (this->_internal_txn_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_txn_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BaseFeeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BaseFeeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BaseFeeRequest::GetClassData() const { return &_class_data_; }


void BaseFeeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BaseFeeRequest*>(&to_msg);
  auto& from = static_cast<const BaseFeeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.BaseFeeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_public_key()) {
    _this->_internal_mutable_public_key()->::zera_txn::PublicKey::MergeFrom(
        from._internal_public_key());
  }
  if (from._internal_txn_type() != 0) {
    _this->_internal_set_txn_type(from._internal_txn_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BaseFeeRequest::CopyFrom(const BaseFeeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.BaseFeeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseFeeRequest::IsInitialized() const {
  return true;
}

void BaseFeeRequest::InternalSwap(BaseFeeRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseFeeRequest, _impl_.txn_type_)
      + sizeof(BaseFeeRequest::_impl_.txn_type_)
      - PROTOBUF_FIELD_OFFSET(BaseFeeRequest, _impl_.public_key_)>(
          reinterpret_cast<char*>(&_impl_.public_key_),
          reinterpret_cast<char*>(&other->_impl_.public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BaseFeeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[10]);
}

// ===================================================================

class BaseFeeResponse::_Internal {
 public:
};

BaseFeeResponse::BaseFeeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.BaseFeeResponse)
}
BaseFeeResponse::BaseFeeResponse(const BaseFeeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BaseFeeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_fee_){}
    , decltype(_impl_.byte_fee_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key_fee().empty()) {
    _this->_impl_.key_fee_.Set(from._internal_key_fee(), 
      _this->GetArenaForAllocation());
  }
  _impl_.byte_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.byte_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_byte_fee().empty()) {
    _this->_impl_.byte_fee_.Set(from._internal_byte_fee(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.BaseFeeResponse)
}

inline void BaseFeeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_fee_){}
    , decltype(_impl_.byte_fee_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.byte_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.byte_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BaseFeeResponse::~BaseFeeResponse() {
  // @@protoc_insertion_point(destructor:zera_api.BaseFeeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BaseFeeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_fee_.Destroy();
  _impl_.byte_fee_.Destroy();
}

void BaseFeeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BaseFeeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.BaseFeeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_fee_.ClearToEmpty();
  _impl_.byte_fee_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BaseFeeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key_fee = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.BaseFeeResponse.key_fee"));
        } else
          goto handle_unusual;
        continue;
      // string byte_fee = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_byte_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.BaseFeeResponse.byte_fee"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseFeeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.BaseFeeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key_fee = 1;
  if (!this->_internal_key_fee().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key_fee().data(), static_cast<int>(this->_internal_key_fee().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.BaseFeeResponse.key_fee");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key_fee(), target);
  }

  // string byte_fee = 2;
  if (!this->_internal_byte_fee().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_byte_fee().data(), static_cast<int>(this->_internal_byte_fee().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.BaseFeeResponse.byte_fee");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_byte_fee(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.BaseFeeResponse)
  return target;
}

size_t BaseFeeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.BaseFeeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key_fee = 1;
  if (!this->_internal_key_fee().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key_fee());
  }

  // string byte_fee = 2;
  if (!this->_internal_byte_fee().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_byte_fee());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BaseFeeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BaseFeeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BaseFeeResponse::GetClassData() const { return &_class_data_; }


void BaseFeeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BaseFeeResponse*>(&to_msg);
  auto& from = static_cast<const BaseFeeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.BaseFeeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key_fee().empty()) {
    _this->_internal_set_key_fee(from._internal_key_fee());
  }
  if (!from._internal_byte_fee().empty()) {
    _this->_internal_set_byte_fee(from._internal_byte_fee());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BaseFeeResponse::CopyFrom(const BaseFeeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.BaseFeeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseFeeResponse::IsInitialized() const {
  return true;
}

void BaseFeeResponse::InternalSwap(BaseFeeResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_fee_, lhs_arena,
      &other->_impl_.key_fee_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.byte_fee_, lhs_arena,
      &other->_impl_.byte_fee_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata BaseFeeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[11]);
}

// ===================================================================

class TokenFeeInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TokenFeeInfo>()._impl_._has_bits_);
  static const ::zera_txn::ContractFees& contract_fees(const TokenFeeInfo* msg);
  static void set_has_contract_fees(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::zera_txn::ContractFees&
TokenFeeInfo::_Internal::contract_fees(const TokenFeeInfo* msg) {
  return *msg->_impl_.contract_fees_;
}
void TokenFeeInfo::clear_contract_fees() {
  if (_impl_.contract_fees_ != nullptr) _impl_.contract_fees_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TokenFeeInfo::TokenFeeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.TokenFeeInfo)
}
TokenFeeInfo::TokenFeeInfo(const TokenFeeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenFeeInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.rate_){}
    , decltype(_impl_.denomination_){}
    , decltype(_impl_.contract_fees_){nullptr}
    , decltype(_impl_.authorized_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rate().empty()) {
    _this->_impl_.rate_.Set(from._internal_rate(), 
      _this->GetArenaForAllocation());
  }
  _impl_.denomination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.denomination_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denomination().empty()) {
    _this->_impl_.denomination_.Set(from._internal_denomination(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_contract_fees()) {
    _this->_impl_.contract_fees_ = new ::zera_txn::ContractFees(*from._impl_.contract_fees_);
  }
  _this->_impl_.authorized_ = from._impl_.authorized_;
  // @@protoc_insertion_point(copy_constructor:zera_api.TokenFeeInfo)
}

inline void TokenFeeInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.rate_){}
    , decltype(_impl_.denomination_){}
    , decltype(_impl_.contract_fees_){nullptr}
    , decltype(_impl_.authorized_){false}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.denomination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.denomination_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TokenFeeInfo::~TokenFeeInfo() {
  // @@protoc_insertion_point(destructor:zera_api.TokenFeeInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenFeeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.rate_.Destroy();
  _impl_.denomination_.Destroy();
  if (this != internal_default_instance()) delete _impl_.contract_fees_;
}

void TokenFeeInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenFeeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.TokenFeeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.rate_.ClearToEmpty();
  _impl_.denomination_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.contract_fees_ != nullptr);
    _impl_.contract_fees_->Clear();
  }
  _impl_.authorized_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenFeeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.TokenFeeInfo.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string rate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.TokenFeeInfo.rate"));
        } else
          goto handle_unusual;
        continue;
      // bool authorized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.authorized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string denomination = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_denomination();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.TokenFeeInfo.denomination"));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.ContractFees contract_fees = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract_fees(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenFeeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.TokenFeeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.TokenFeeInfo.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // string rate = 2;
  if (!this->_internal_rate().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_rate().data(), static_cast<int>(this->_internal_rate().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.TokenFeeInfo.rate");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_rate(), target);
  }

  // bool authorized = 3;
  if (this->_internal_authorized() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_authorized(), target);
  }

  // string denomination = 4;
  if (!this->_internal_denomination().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_denomination().data(), static_cast<int>(this->_internal_denomination().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.TokenFeeInfo.denomination");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_denomination(), target);
  }

  // optional .zera_txn.ContractFees contract_fees = 5;
  if (_internal_has_contract_fees()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::contract_fees(this),
        _Internal::contract_fees(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.TokenFeeInfo)
  return target;
}

size_t TokenFeeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.TokenFeeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string rate = 2;
  if (!this->_internal_rate().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_rate());
  }

  // string denomination = 4;
  if (!this->_internal_denomination().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_denomination());
  }

  // optional .zera_txn.ContractFees contract_fees = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.contract_fees_);
  }

  // bool authorized = 3;
  if (this->_internal_authorized() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenFeeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenFeeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenFeeInfo::GetClassData() const { return &_class_data_; }


void TokenFeeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenFeeInfo*>(&to_msg);
  auto& from = static_cast<const TokenFeeInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.TokenFeeInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_rate().empty()) {
    _this->_internal_set_rate(from._internal_rate());
  }
  if (!from._internal_denomination().empty()) {
    _this->_internal_set_denomination(from._internal_denomination());
  }
  if (from._internal_has_contract_fees()) {
    _this->_internal_mutable_contract_fees()->::zera_txn::ContractFees::MergeFrom(
        from._internal_contract_fees());
  }
  if (from._internal_authorized() != 0) {
    _this->_internal_set_authorized(from._internal_authorized());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenFeeInfo::CopyFrom(const TokenFeeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.TokenFeeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenFeeInfo::IsInitialized() const {
  return true;
}

void TokenFeeInfo::InternalSwap(TokenFeeInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rate_, lhs_arena,
      &other->_impl_.rate_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.denomination_, lhs_arena,
      &other->_impl_.denomination_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TokenFeeInfo, _impl_.authorized_)
      + sizeof(TokenFeeInfo::_impl_.authorized_)
      - PROTOBUF_FIELD_OFFSET(TokenFeeInfo, _impl_.contract_fees_)>(
          reinterpret_cast<char*>(&_impl_.contract_fees_),
          reinterpret_cast<char*>(&other->_impl_.contract_fees_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenFeeInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[12]);
}

// ===================================================================

class TokenFeeInfoRequest::_Internal {
 public:
};

TokenFeeInfoRequest::TokenFeeInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.TokenFeeInfoRequest)
}
TokenFeeInfoRequest::TokenFeeInfoRequest(const TokenFeeInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenFeeInfoRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_ids_){from._impl_.contract_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_api.TokenFeeInfoRequest)
}

inline void TokenFeeInfoRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TokenFeeInfoRequest::~TokenFeeInfoRequest() {
  // @@protoc_insertion_point(destructor:zera_api.TokenFeeInfoRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenFeeInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_ids_.~RepeatedPtrField();
}

void TokenFeeInfoRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenFeeInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.TokenFeeInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenFeeInfoRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string contract_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_contract_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.TokenFeeInfoRequest.contract_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenFeeInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.TokenFeeInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string contract_ids = 1;
  for (int i = 0, n = this->_internal_contract_ids_size(); i < n; i++) {
    const auto& s = this->_internal_contract_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.TokenFeeInfoRequest.contract_ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.TokenFeeInfoRequest)
  return target;
}

size_t TokenFeeInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.TokenFeeInfoRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string contract_ids = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.contract_ids_.size());
  for (int i = 0, n = _impl_.contract_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.contract_ids_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenFeeInfoRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenFeeInfoRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenFeeInfoRequest::GetClassData() const { return &_class_data_; }


void TokenFeeInfoRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenFeeInfoRequest*>(&to_msg);
  auto& from = static_cast<const TokenFeeInfoRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.TokenFeeInfoRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.contract_ids_.MergeFrom(from._impl_.contract_ids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenFeeInfoRequest::CopyFrom(const TokenFeeInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.TokenFeeInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenFeeInfoRequest::IsInitialized() const {
  return true;
}

void TokenFeeInfoRequest::InternalSwap(TokenFeeInfoRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.contract_ids_.InternalSwap(&other->_impl_.contract_ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenFeeInfoRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[13]);
}

// ===================================================================

class TokenFeeInfoResponse::_Internal {
 public:
};

TokenFeeInfoResponse::TokenFeeInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.TokenFeeInfoResponse)
}
TokenFeeInfoResponse::TokenFeeInfoResponse(const TokenFeeInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenFeeInfoResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tokens_){from._impl_.tokens_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_api.TokenFeeInfoResponse)
}

inline void TokenFeeInfoResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tokens_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TokenFeeInfoResponse::~TokenFeeInfoResponse() {
  // @@protoc_insertion_point(destructor:zera_api.TokenFeeInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenFeeInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tokens_.~RepeatedPtrField();
}

void TokenFeeInfoResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenFeeInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.TokenFeeInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tokens_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenFeeInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .zera_api.TokenFeeInfo tokens = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenFeeInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.TokenFeeInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .zera_api.TokenFeeInfo tokens = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tokens_size()); i < n; i++) {
    const auto& repfield = this->_internal_tokens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.TokenFeeInfoResponse)
  return target;
}

size_t TokenFeeInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.TokenFeeInfoResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_api.TokenFeeInfo tokens = 1;
  total_size += 1UL * this->_internal_tokens_size();
  for (const auto& msg : this->_impl_.tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenFeeInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenFeeInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenFeeInfoResponse::GetClassData() const { return &_class_data_; }


void TokenFeeInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenFeeInfoResponse*>(&to_msg);
  auto& from = static_cast<const TokenFeeInfoResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.TokenFeeInfoResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tokens_.MergeFrom(from._impl_.tokens_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenFeeInfoResponse::CopyFrom(const TokenFeeInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.TokenFeeInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenFeeInfoResponse::IsInitialized() const {
  return true;
}

void TokenFeeInfoResponse::InternalSwap(TokenFeeInfoResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenFeeInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[14]);
}

// ===================================================================

class Item::_Internal {
 public:
};

Item::Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.Item)
}
Item::Item(const Item& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Item* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.item_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_item_id().empty()) {
    _this->_impl_.item_id_.Set(from._internal_item_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.Item)
}

inline void Item::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.item_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Item::~Item() {
  // @@protoc_insertion_point(destructor:zera_api.Item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Item::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.item_id_.Destroy();
}

void Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Item::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.Item)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.item_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.Item.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_item_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.Item.item_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Item::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.Item)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.Item.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // string item_id = 2;
  if (!this->_internal_item_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_item_id().data(), static_cast<int>(this->_internal_item_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.Item.item_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.Item)
  return target;
}

size_t Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.Item)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string item_id = 2;
  if (!this->_internal_item_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_item_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Item::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Item::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Item::GetClassData() const { return &_class_data_; }


void Item::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Item*>(&to_msg);
  auto& from = static_cast<const Item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.Item)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_item_id().empty()) {
    _this->_internal_set_item_id(from._internal_item_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Item::CopyFrom(const Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item::IsInitialized() const {
  return true;
}

void Item::InternalSwap(Item* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.item_id_, lhs_arena,
      &other->_impl_.item_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[15]);
}

// ===================================================================

class ItemRequest::_Internal {
 public:
};

ItemRequest::ItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.ItemRequest)
}
ItemRequest::ItemRequest(const ItemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.wallet_address_){}
    , decltype(_impl_.encoded_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_wallet_address().empty()) {
    _this->_impl_.wallet_address_.Set(from._internal_wallet_address(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.encoded_ = from._impl_.encoded_;
  // @@protoc_insertion_point(copy_constructor:zera_api.ItemRequest)
}

inline void ItemRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.wallet_address_){}
    , decltype(_impl_.encoded_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ItemRequest::~ItemRequest() {
  // @@protoc_insertion_point(destructor:zera_api.ItemRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wallet_address_.Destroy();
}

void ItemRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.ItemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wallet_address_.ClearToEmpty();
  _impl_.encoded_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes wallet_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_wallet_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool encoded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.encoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.ItemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_wallet_address(), target);
  }

  // bool encoded = 2;
  if (this->_internal_encoded() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_encoded(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.ItemRequest)
  return target;
}

size_t ItemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.ItemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_wallet_address());
  }

  // bool encoded = 2;
  if (this->_internal_encoded() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemRequest::GetClassData() const { return &_class_data_; }


void ItemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemRequest*>(&to_msg);
  auto& from = static_cast<const ItemRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.ItemRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_wallet_address().empty()) {
    _this->_internal_set_wallet_address(from._internal_wallet_address());
  }
  if (from._internal_encoded() != 0) {
    _this->_internal_set_encoded(from._internal_encoded());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemRequest::CopyFrom(const ItemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.ItemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemRequest::IsInitialized() const {
  return true;
}

void ItemRequest::InternalSwap(ItemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wallet_address_, lhs_arena,
      &other->_impl_.wallet_address_, rhs_arena
  );
  swap(_impl_.encoded_, other->_impl_.encoded_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[16]);
}

// ===================================================================

class ItemResponse::_Internal {
 public:
};

ItemResponse::ItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.ItemResponse)
}
ItemResponse::ItemResponse(const ItemResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_api.ItemResponse)
}

inline void ItemResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ItemResponse::~ItemResponse() {
  // @@protoc_insertion_point(destructor:zera_api.ItemResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void ItemResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.ItemResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .zera_api.Item items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.ItemResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .zera_api.Item items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.ItemResponse)
  return target;
}

size_t ItemResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.ItemResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_api.Item items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemResponse::GetClassData() const { return &_class_data_; }


void ItemResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemResponse*>(&to_msg);
  auto& from = static_cast<const ItemResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.ItemResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemResponse::CopyFrom(const ItemResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.ItemResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemResponse::IsInitialized() const {
  return true;
}

void ItemResponse::InternalSwap(ItemResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[17]);
}

// ===================================================================

class DenominationRequest::_Internal {
 public:
};

DenominationRequest::DenominationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.DenominationRequest)
}
DenominationRequest::DenominationRequest(const DenominationRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DenominationRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.DenominationRequest)
}

inline void DenominationRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DenominationRequest::~DenominationRequest() {
  // @@protoc_insertion_point(destructor:zera_api.DenominationRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DenominationRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
}

void DenominationRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DenominationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.DenominationRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DenominationRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.DenominationRequest.contract_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DenominationRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.DenominationRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.DenominationRequest.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.DenominationRequest)
  return target;
}

size_t DenominationRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.DenominationRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DenominationRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DenominationRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DenominationRequest::GetClassData() const { return &_class_data_; }


void DenominationRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DenominationRequest*>(&to_msg);
  auto& from = static_cast<const DenominationRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.DenominationRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DenominationRequest::CopyFrom(const DenominationRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.DenominationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenominationRequest::IsInitialized() const {
  return true;
}

void DenominationRequest::InternalSwap(DenominationRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DenominationRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[18]);
}

// ===================================================================

class DenominationResponse::_Internal {
 public:
};

DenominationResponse::DenominationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.DenominationResponse)
}
DenominationResponse::DenominationResponse(const DenominationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DenominationResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.denomination_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.denomination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.denomination_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denomination().empty()) {
    _this->_impl_.denomination_.Set(from._internal_denomination(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.DenominationResponse)
}

inline void DenominationResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.denomination_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.denomination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.denomination_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DenominationResponse::~DenominationResponse() {
  // @@protoc_insertion_point(destructor:zera_api.DenominationResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DenominationResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.denomination_.Destroy();
}

void DenominationResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DenominationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.DenominationResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.denomination_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DenominationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string denomination = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_denomination();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.DenominationResponse.denomination"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DenominationResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.DenominationResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string denomination = 1;
  if (!this->_internal_denomination().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_denomination().data(), static_cast<int>(this->_internal_denomination().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.DenominationResponse.denomination");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_denomination(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.DenominationResponse)
  return target;
}

size_t DenominationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.DenominationResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string denomination = 1;
  if (!this->_internal_denomination().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_denomination());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DenominationResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DenominationResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DenominationResponse::GetClassData() const { return &_class_data_; }


void DenominationResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DenominationResponse*>(&to_msg);
  auto& from = static_cast<const DenominationResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.DenominationResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_denomination().empty()) {
    _this->_internal_set_denomination(from._internal_denomination());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DenominationResponse::CopyFrom(const DenominationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.DenominationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenominationResponse::IsInitialized() const {
  return true;
}

void DenominationResponse::InternalSwap(DenominationResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.denomination_, lhs_arena,
      &other->_impl_.denomination_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DenominationResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[19]);
}

// ===================================================================

class DatabaseRequest::_Internal {
 public:
};

DatabaseRequest::DatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.DatabaseRequest)
}
DatabaseRequest::DatabaseRequest(const DatabaseRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DatabaseRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:zera_api.DatabaseRequest)
}

inline void DatabaseRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DatabaseRequest::~DatabaseRequest() {
  // @@protoc_insertion_point(destructor:zera_api.DatabaseRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DatabaseRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void DatabaseRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DatabaseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.DatabaseRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DatabaseRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_api.DATABASE_TYPE type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::zera_api::DATABASE_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // string key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.DatabaseRequest.key"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DatabaseRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.DatabaseRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_api.DATABASE_TYPE type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // string key = 2;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.DatabaseRequest.key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.DatabaseRequest)
  return target;
}

size_t DatabaseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.DatabaseRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // .zera_api.DATABASE_TYPE type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DatabaseRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DatabaseRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DatabaseRequest::GetClassData() const { return &_class_data_; }


void DatabaseRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DatabaseRequest*>(&to_msg);
  auto& from = static_cast<const DatabaseRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.DatabaseRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DatabaseRequest::CopyFrom(const DatabaseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.DatabaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatabaseRequest::IsInitialized() const {
  return true;
}

void DatabaseRequest::InternalSwap(DatabaseRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DatabaseRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[20]);
}

// ===================================================================

class DatabaseResponse::_Internal {
 public:
};

DatabaseResponse::DatabaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.DatabaseResponse)
}
DatabaseResponse::DatabaseResponse(const DatabaseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DatabaseResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.DatabaseResponse)
}

inline void DatabaseResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DatabaseResponse::~DatabaseResponse() {
  // @@protoc_insertion_point(destructor:zera_api.DatabaseResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DatabaseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void DatabaseResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DatabaseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.DatabaseResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DatabaseResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.DatabaseResponse.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DatabaseResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.DatabaseResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string value = 1;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.DatabaseResponse.value");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.DatabaseResponse)
  return target;
}

size_t DatabaseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.DatabaseResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string value = 1;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DatabaseResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DatabaseResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DatabaseResponse::GetClassData() const { return &_class_data_; }


void DatabaseResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DatabaseResponse*>(&to_msg);
  auto& from = static_cast<const DatabaseResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.DatabaseResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DatabaseResponse::CopyFrom(const DatabaseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.DatabaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatabaseResponse::IsInitialized() const {
  return true;
}

void DatabaseResponse::InternalSwap(DatabaseResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DatabaseResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[21]);
}

// ===================================================================

class ActivityRequest::_Internal {
 public:
  static const ::zera_txn::PublicKey& public_key(const ActivityRequest* msg);
};

const ::zera_txn::PublicKey&
ActivityRequest::_Internal::public_key(const ActivityRequest* msg) {
  return *msg->_impl_.public_key_;
}
void ActivityRequest::clear_public_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
}
ActivityRequest::ActivityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.ActivityRequest)
}
ActivityRequest::ActivityRequest(const ActivityRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActivityRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.smart_contract_id_){}
    , decltype(_impl_.host_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.instance_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.nonce_){}
    , decltype(_impl_.subscribe_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.smart_contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_smart_contract_id().empty()) {
    _this->_impl_.smart_contract_id_.Set(from._internal_smart_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host().empty()) {
    _this->_impl_.host_.Set(from._internal_host(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature().empty()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_ = new ::zera_txn::PublicKey(*from._impl_.public_key_);
  }
  ::memcpy(&_impl_.instance_, &from._impl_.instance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.subscribe_) -
    reinterpret_cast<char*>(&_impl_.instance_)) + sizeof(_impl_.subscribe_));
  // @@protoc_insertion_point(copy_constructor:zera_api.ActivityRequest)
}

inline void ActivityRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.smart_contract_id_){}
    , decltype(_impl_.host_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.instance_){uint64_t{0u}}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.port_){0}
    , decltype(_impl_.nonce_){uint64_t{0u}}
    , decltype(_impl_.subscribe_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.smart_contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActivityRequest::~ActivityRequest() {
  // @@protoc_insertion_point(destructor:zera_api.ActivityRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActivityRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.smart_contract_id_.Destroy();
  _impl_.host_.Destroy();
  _impl_.signature_.Destroy();
  if (this != internal_default_instance()) delete _impl_.public_key_;
}

void ActivityRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActivityRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.ActivityRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.smart_contract_id_.ClearToEmpty();
  _impl_.host_.ClearToEmpty();
  _impl_.signature_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
  ::memset(&_impl_.instance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.subscribe_) -
      reinterpret_cast<char*>(&_impl_.instance_)) + sizeof(_impl_.subscribe_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActivityRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string smart_contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_smart_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.ActivityRequest.smart_contract_id"));
        } else
          goto handle_unusual;
        continue;
      // uint64 instance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.instance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_api.CONFIRMATION_LEVEL level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::zera_api::CONFIRMATION_LEVEL>(val));
        } else
          goto handle_unusual;
        continue;
      // string host = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.ActivityRequest.host"));
        } else
          goto handle_unusual;
        continue;
      // int32 port = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool subscribe = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.subscribe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.PublicKey public_key = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 nonce = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivityRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.ActivityRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string smart_contract_id = 1;
  if (!this->_internal_smart_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_smart_contract_id().data(), static_cast<int>(this->_internal_smart_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ActivityRequest.smart_contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_smart_contract_id(), target);
  }

  // uint64 instance = 2;
  if (this->_internal_instance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_instance(), target);
  }

  // .zera_api.CONFIRMATION_LEVEL level = 3;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_level(), target);
  }

  // string host = 4;
  if (!this->_internal_host().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host().data(), static_cast<int>(this->_internal_host().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.ActivityRequest.host");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_host(), target);
  }

  // int32 port = 5;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_port(), target);
  }

  // bool subscribe = 6;
  if (this->_internal_subscribe() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_subscribe(), target);
  }

  // .zera_txn.PublicKey public_key = 7;
  if (this->_internal_has_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  // bytes signature = 8;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_signature(), target);
  }

  // uint64 nonce = 9;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_nonce(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.ActivityRequest)
  return target;
}

size_t ActivityRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.ActivityRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string smart_contract_id = 1;
  if (!this->_internal_smart_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_smart_contract_id());
  }

  // string host = 4;
  if (!this->_internal_host().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host());
  }

  // bytes signature = 8;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  // .zera_txn.PublicKey public_key = 7;
  if (this->_internal_has_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.public_key_);
  }

  // uint64 instance = 2;
  if (this->_internal_instance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instance());
  }

  // .zera_api.CONFIRMATION_LEVEL level = 3;
  if (this->_internal_level() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // int32 port = 5;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  // uint64 nonce = 9;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nonce());
  }

  // bool subscribe = 6;
  if (this->_internal_subscribe() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActivityRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActivityRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActivityRequest::GetClassData() const { return &_class_data_; }


void ActivityRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActivityRequest*>(&to_msg);
  auto& from = static_cast<const ActivityRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.ActivityRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_smart_contract_id().empty()) {
    _this->_internal_set_smart_contract_id(from._internal_smart_contract_id());
  }
  if (!from._internal_host().empty()) {
    _this->_internal_set_host(from._internal_host());
  }
  if (!from._internal_signature().empty()) {
    _this->_internal_set_signature(from._internal_signature());
  }
  if (from._internal_has_public_key()) {
    _this->_internal_mutable_public_key()->::zera_txn::PublicKey::MergeFrom(
        from._internal_public_key());
  }
  if (from._internal_instance() != 0) {
    _this->_internal_set_instance(from._internal_instance());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  if (from._internal_subscribe() != 0) {
    _this->_internal_set_subscribe(from._internal_subscribe());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActivityRequest::CopyFrom(const ActivityRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.ActivityRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivityRequest::IsInitialized() const {
  return true;
}

void ActivityRequest::InternalSwap(ActivityRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.smart_contract_id_, lhs_arena,
      &other->_impl_.smart_contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_, lhs_arena,
      &other->_impl_.host_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActivityRequest, _impl_.subscribe_)
      + sizeof(ActivityRequest::_impl_.subscribe_)
      - PROTOBUF_FIELD_OFFSET(ActivityRequest, _impl_.public_key_)>(
          reinterpret_cast<char*>(&_impl_.public_key_),
          reinterpret_cast<char*>(&other->_impl_.public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ActivityRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[22]);
}

// ===================================================================

class SmartContractEventsResponse::_Internal {
 public:
  static const ::zera_txn::PublicKey& caller(const SmartContractEventsResponse* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const SmartContractEventsResponse* msg);
  static const ::zera_txn::PublicKey& public_key(const SmartContractEventsResponse* msg);
};

const ::zera_txn::PublicKey&
SmartContractEventsResponse::_Internal::caller(const SmartContractEventsResponse* msg) {
  return *msg->_impl_.caller_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
SmartContractEventsResponse::_Internal::timestamp(const SmartContractEventsResponse* msg) {
  return *msg->_impl_.timestamp_;
}
const ::zera_txn::PublicKey&
SmartContractEventsResponse::_Internal::public_key(const SmartContractEventsResponse* msg) {
  return *msg->_impl_.public_key_;
}
void SmartContractEventsResponse::clear_caller() {
  if (GetArenaForAllocation() == nullptr && _impl_.caller_ != nullptr) {
    delete _impl_.caller_;
  }
  _impl_.caller_ = nullptr;
}
void SmartContractEventsResponse::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
void SmartContractEventsResponse::clear_public_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
}
SmartContractEventsResponse::SmartContractEventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.SmartContractEventsResponse)
}
SmartContractEventsResponse::SmartContractEventsResponse(const SmartContractEventsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SmartContractEventsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.smart_contract_){}
    , decltype(_impl_.storage_fee_){}
    , decltype(_impl_.event_data_){}
    , decltype(_impl_.function_){}
    , decltype(_impl_.block_hash_){}
    , decltype(_impl_.txn_hash_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.caller_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.instance_){}
    , decltype(_impl_.gas_used_){}
    , decltype(_impl_.gas_approved_){}
    , decltype(_impl_.block_height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.smart_contract_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_smart_contract().empty()) {
    _this->_impl_.smart_contract_.Set(from._internal_smart_contract(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storage_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storage_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_storage_fee().empty()) {
    _this->_impl_.storage_fee_.Set(from._internal_storage_fee(), 
      _this->GetArenaForAllocation());
  }
  _impl_.event_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_event_data().empty()) {
    _this->_impl_.event_data_.Set(from._internal_event_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_function().empty()) {
    _this->_impl_.function_.Set(from._internal_function(), 
      _this->GetArenaForAllocation());
  }
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block_hash().empty()) {
    _this->_impl_.block_hash_.Set(from._internal_block_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_txn_hash().empty()) {
    _this->_impl_.txn_hash_.Set(from._internal_txn_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature().empty()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_caller()) {
    _this->_impl_.caller_ = new ::zera_txn::PublicKey(*from._impl_.caller_);
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_ = new ::zera_txn::PublicKey(*from._impl_.public_key_);
  }
  ::memcpy(&_impl_.instance_, &from._impl_.instance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.block_height_) -
    reinterpret_cast<char*>(&_impl_.instance_)) + sizeof(_impl_.block_height_));
  // @@protoc_insertion_point(copy_constructor:zera_api.SmartContractEventsResponse)
}

inline void SmartContractEventsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.smart_contract_){}
    , decltype(_impl_.storage_fee_){}
    , decltype(_impl_.event_data_){}
    , decltype(_impl_.function_){}
    , decltype(_impl_.block_hash_){}
    , decltype(_impl_.txn_hash_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.caller_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.instance_){uint64_t{0u}}
    , decltype(_impl_.gas_used_){uint64_t{0u}}
    , decltype(_impl_.gas_approved_){uint64_t{0u}}
    , decltype(_impl_.block_height_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.smart_contract_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storage_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storage_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.event_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SmartContractEventsResponse::~SmartContractEventsResponse() {
  // @@protoc_insertion_point(destructor:zera_api.SmartContractEventsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmartContractEventsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.smart_contract_.Destroy();
  _impl_.storage_fee_.Destroy();
  _impl_.event_data_.Destroy();
  _impl_.function_.Destroy();
  _impl_.block_hash_.Destroy();
  _impl_.txn_hash_.Destroy();
  _impl_.signature_.Destroy();
  if (this != internal_default_instance()) delete _impl_.caller_;
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (this != internal_default_instance()) delete _impl_.public_key_;
}

void SmartContractEventsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmartContractEventsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.SmartContractEventsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.smart_contract_.ClearToEmpty();
  _impl_.storage_fee_.ClearToEmpty();
  _impl_.event_data_.ClearToEmpty();
  _impl_.function_.ClearToEmpty();
  _impl_.block_hash_.ClearToEmpty();
  _impl_.txn_hash_.ClearToEmpty();
  _impl_.signature_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.caller_ != nullptr) {
    delete _impl_.caller_;
  }
  _impl_.caller_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
  ::memset(&_impl_.instance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.block_height_) -
      reinterpret_cast<char*>(&_impl_.instance_)) + sizeof(_impl_.block_height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SmartContractEventsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string smart_contract = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_smart_contract();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.SmartContractEventsResponse.smart_contract"));
        } else
          goto handle_unusual;
        continue;
      // uint64 instance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.instance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 gas_used = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.gas_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 gas_approved = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.gas_approved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string storage_fee = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_storage_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.SmartContractEventsResponse.storage_fee"));
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.PublicKey caller = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_caller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes event_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_event_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string function = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_function();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.SmartContractEventsResponse.function"));
        } else
          goto handle_unusual;
        continue;
      // uint64 block_height = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.block_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string block_hash = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_block_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.SmartContractEventsResponse.block_hash"));
        } else
          goto handle_unusual;
        continue;
      // string txn_hash = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_txn_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.SmartContractEventsResponse.txn_hash"));
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.PublicKey public_key = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartContractEventsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.SmartContractEventsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string smart_contract = 1;
  if (!this->_internal_smart_contract().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_smart_contract().data(), static_cast<int>(this->_internal_smart_contract().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.SmartContractEventsResponse.smart_contract");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_smart_contract(), target);
  }

  // uint64 instance = 2;
  if (this->_internal_instance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_instance(), target);
  }

  // uint64 gas_used = 3;
  if (this->_internal_gas_used() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_gas_used(), target);
  }

  // uint64 gas_approved = 4;
  if (this->_internal_gas_approved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_gas_approved(), target);
  }

  // string storage_fee = 5;
  if (!this->_internal_storage_fee().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_storage_fee().data(), static_cast<int>(this->_internal_storage_fee().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.SmartContractEventsResponse.storage_fee");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_storage_fee(), target);
  }

  // .zera_txn.PublicKey caller = 6;
  if (this->_internal_has_caller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::caller(this),
        _Internal::caller(this).GetCachedSize(), target, stream);
  }

  // bytes event_data = 7;
  if (!this->_internal_event_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_event_data(), target);
  }

  // string function = 8;
  if (!this->_internal_function().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_function().data(), static_cast<int>(this->_internal_function().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.SmartContractEventsResponse.function");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_function(), target);
  }

  // uint64 block_height = 9;
  if (this->_internal_block_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_block_height(), target);
  }

  // .google.protobuf.Timestamp timestamp = 10;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // string block_hash = 11;
  if (!this->_internal_block_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_block_hash().data(), static_cast<int>(this->_internal_block_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.SmartContractEventsResponse.block_hash");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_block_hash(), target);
  }

  // string txn_hash = 12;
  if (!this->_internal_txn_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_txn_hash().data(), static_cast<int>(this->_internal_txn_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.SmartContractEventsResponse.txn_hash");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_txn_hash(), target);
  }

  // .zera_txn.PublicKey public_key = 13;
  if (this->_internal_has_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  // bytes signature = 14;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.SmartContractEventsResponse)
  return target;
}

size_t SmartContractEventsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.SmartContractEventsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string smart_contract = 1;
  if (!this->_internal_smart_contract().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_smart_contract());
  }

  // string storage_fee = 5;
  if (!this->_internal_storage_fee().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_storage_fee());
  }

  // bytes event_data = 7;
  if (!this->_internal_event_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_event_data());
  }

  // string function = 8;
  if (!this->_internal_function().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_function());
  }

  // string block_hash = 11;
  if (!this->_internal_block_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_block_hash());
  }

  // string txn_hash = 12;
  if (!this->_internal_txn_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_txn_hash());
  }

  // bytes signature = 14;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  // .zera_txn.PublicKey caller = 6;
  if (this->_internal_has_caller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.caller_);
  }

  // .google.protobuf.Timestamp timestamp = 10;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // .zera_txn.PublicKey public_key = 13;
  if (this->_internal_has_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.public_key_);
  }

  // uint64 instance = 2;
  if (this->_internal_instance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instance());
  }

  // uint64 gas_used = 3;
  if (this->_internal_gas_used() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gas_used());
  }

  // uint64 gas_approved = 4;
  if (this->_internal_gas_approved() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gas_approved());
  }

  // uint64 block_height = 9;
  if (this->_internal_block_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_block_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SmartContractEventsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SmartContractEventsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SmartContractEventsResponse::GetClassData() const { return &_class_data_; }


void SmartContractEventsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SmartContractEventsResponse*>(&to_msg);
  auto& from = static_cast<const SmartContractEventsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.SmartContractEventsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_smart_contract().empty()) {
    _this->_internal_set_smart_contract(from._internal_smart_contract());
  }
  if (!from._internal_storage_fee().empty()) {
    _this->_internal_set_storage_fee(from._internal_storage_fee());
  }
  if (!from._internal_event_data().empty()) {
    _this->_internal_set_event_data(from._internal_event_data());
  }
  if (!from._internal_function().empty()) {
    _this->_internal_set_function(from._internal_function());
  }
  if (!from._internal_block_hash().empty()) {
    _this->_internal_set_block_hash(from._internal_block_hash());
  }
  if (!from._internal_txn_hash().empty()) {
    _this->_internal_set_txn_hash(from._internal_txn_hash());
  }
  if (!from._internal_signature().empty()) {
    _this->_internal_set_signature(from._internal_signature());
  }
  if (from._internal_has_caller()) {
    _this->_internal_mutable_caller()->::zera_txn::PublicKey::MergeFrom(
        from._internal_caller());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_has_public_key()) {
    _this->_internal_mutable_public_key()->::zera_txn::PublicKey::MergeFrom(
        from._internal_public_key());
  }
  if (from._internal_instance() != 0) {
    _this->_internal_set_instance(from._internal_instance());
  }
  if (from._internal_gas_used() != 0) {
    _this->_internal_set_gas_used(from._internal_gas_used());
  }
  if (from._internal_gas_approved() != 0) {
    _this->_internal_set_gas_approved(from._internal_gas_approved());
  }
  if (from._internal_block_height() != 0) {
    _this->_internal_set_block_height(from._internal_block_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SmartContractEventsResponse::CopyFrom(const SmartContractEventsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.SmartContractEventsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartContractEventsResponse::IsInitialized() const {
  return true;
}

void SmartContractEventsResponse::InternalSwap(SmartContractEventsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.smart_contract_, lhs_arena,
      &other->_impl_.smart_contract_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storage_fee_, lhs_arena,
      &other->_impl_.storage_fee_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.event_data_, lhs_arena,
      &other->_impl_.event_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.function_, lhs_arena,
      &other->_impl_.function_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_hash_, lhs_arena,
      &other->_impl_.block_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.txn_hash_, lhs_arena,
      &other->_impl_.txn_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SmartContractEventsResponse, _impl_.block_height_)
      + sizeof(SmartContractEventsResponse::_impl_.block_height_)
      - PROTOBUF_FIELD_OFFSET(SmartContractEventsResponse, _impl_.caller_)>(
          reinterpret_cast<char*>(&_impl_.caller_),
          reinterpret_cast<char*>(&other->_impl_.caller_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SmartContractEventsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[23]);
}

// ===================================================================

SmartContractSubscription_SubscibersEntry_DoNotUse::SmartContractSubscription_SubscibersEntry_DoNotUse() {}
SmartContractSubscription_SubscibersEntry_DoNotUse::SmartContractSubscription_SubscibersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SmartContractSubscription_SubscibersEntry_DoNotUse::MergeFrom(const SmartContractSubscription_SubscibersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SmartContractSubscription_SubscibersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[24]);
}

// ===================================================================

class SmartContractSubscription::_Internal {
 public:
};

SmartContractSubscription::SmartContractSubscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &SmartContractSubscription::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:zera_api.SmartContractSubscription)
}
SmartContractSubscription::SmartContractSubscription(const SmartContractSubscription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SmartContractSubscription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.subscibers_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.subscibers_.MergeFrom(from._impl_.subscibers_);
  // @@protoc_insertion_point(copy_constructor:zera_api.SmartContractSubscription)
}

inline void SmartContractSubscription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.subscibers_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SmartContractSubscription::~SmartContractSubscription() {
  // @@protoc_insertion_point(destructor:zera_api.SmartContractSubscription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void SmartContractSubscription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subscibers_.Destruct();
  _impl_.subscibers_.~MapField();
}

void SmartContractSubscription::ArenaDtor(void* object) {
  SmartContractSubscription* _this = reinterpret_cast< SmartContractSubscription* >(object);
  _this->_impl_.subscibers_.Destruct();
}
void SmartContractSubscription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmartContractSubscription::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.SmartContractSubscription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subscibers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SmartContractSubscription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .zera_api.Subscriber> subscibers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.subscibers_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartContractSubscription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.SmartContractSubscription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .zera_api.Subscriber> subscibers = 1;
  if (!this->_internal_subscibers().empty()) {
    using MapType = ::_pb::Map<std::string, ::zera_api::Subscriber>;
    using WireHelper = SmartContractSubscription_SubscibersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_subscibers();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "zera_api.SmartContractSubscription.SubscibersEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.SmartContractSubscription)
  return target;
}

size_t SmartContractSubscription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.SmartContractSubscription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .zera_api.Subscriber> subscibers = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_subscibers_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::zera_api::Subscriber >::const_iterator
      it = this->_internal_subscibers().begin();
      it != this->_internal_subscibers().end(); ++it) {
    total_size += SmartContractSubscription_SubscibersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SmartContractSubscription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SmartContractSubscription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SmartContractSubscription::GetClassData() const { return &_class_data_; }


void SmartContractSubscription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SmartContractSubscription*>(&to_msg);
  auto& from = static_cast<const SmartContractSubscription&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.SmartContractSubscription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subscibers_.MergeFrom(from._impl_.subscibers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SmartContractSubscription::CopyFrom(const SmartContractSubscription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.SmartContractSubscription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartContractSubscription::IsInitialized() const {
  return true;
}

void SmartContractSubscription::InternalSwap(SmartContractSubscription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.subscibers_.InternalSwap(&other->_impl_.subscibers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SmartContractSubscription::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[25]);
}

// ===================================================================

class Subscriber::_Internal {
 public:
};

Subscriber::Subscriber(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.Subscriber)
}
Subscriber::Subscriber(const Subscriber& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Subscriber* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host().empty()) {
    _this->_impl_.host_.Set(from._internal_host(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.port_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.port_));
  // @@protoc_insertion_point(copy_constructor:zera_api.Subscriber)
}

inline void Subscriber::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_){}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.port_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Subscriber::~Subscriber() {
  // @@protoc_insertion_point(destructor:zera_api.Subscriber)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Subscriber::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.host_.Destroy();
}

void Subscriber::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Subscriber::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.Subscriber)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.host_.ClearToEmpty();
  ::memset(&_impl_.level_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.port_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.port_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Subscriber::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_api.CONFIRMATION_LEVEL level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::zera_api::CONFIRMATION_LEVEL>(val));
        } else
          goto handle_unusual;
        continue;
      // string host = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_api.Subscriber.host"));
        } else
          goto handle_unusual;
        continue;
      // int32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Subscriber::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.Subscriber)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_api.CONFIRMATION_LEVEL level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_level(), target);
  }

  // string host = 2;
  if (!this->_internal_host().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host().data(), static_cast<int>(this->_internal_host().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.Subscriber.host");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_host(), target);
  }

  // int32 port = 3;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.Subscriber)
  return target;
}

size_t Subscriber::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.Subscriber)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string host = 2;
  if (!this->_internal_host().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host());
  }

  // .zera_api.CONFIRMATION_LEVEL level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // int32 port = 3;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Subscriber::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Subscriber::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Subscriber::GetClassData() const { return &_class_data_; }


void Subscriber::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Subscriber*>(&to_msg);
  auto& from = static_cast<const Subscriber&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.Subscriber)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_host().empty()) {
    _this->_internal_set_host(from._internal_host());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Subscriber::CopyFrom(const Subscriber& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.Subscriber)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Subscriber::IsInitialized() const {
  return true;
}

void Subscriber::InternalSwap(Subscriber* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_, lhs_arena,
      &other->_impl_.host_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Subscriber, _impl_.port_)
      + sizeof(Subscriber::_impl_.port_)
      - PROTOBUF_FIELD_OFFSET(Subscriber, _impl_.level_)>(
          reinterpret_cast<char*>(&_impl_.level_),
          reinterpret_cast<char*>(&other->_impl_.level_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Subscriber::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[26]);
}

// ===================================================================

class WalletChange::_Internal {
 public:
};

WalletChange::WalletChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_api.WalletChange)
}
WalletChange::WalletChange(const WalletChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WalletChange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_ids_){from._impl_.contract_ids_}
    , decltype(_impl_.old_balances_){from._impl_.old_balances_}
    , decltype(_impl_.new_balances_){from._impl_.new_balances_}
    , decltype(_impl_.wallet_address_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_wallet_address().empty()) {
    _this->_impl_.wallet_address_.Set(from._internal_wallet_address(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_api.WalletChange)
}

inline void WalletChange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_ids_){arena}
    , decltype(_impl_.old_balances_){arena}
    , decltype(_impl_.new_balances_){arena}
    , decltype(_impl_.wallet_address_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WalletChange::~WalletChange() {
  // @@protoc_insertion_point(destructor:zera_api.WalletChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WalletChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_ids_.~RepeatedPtrField();
  _impl_.old_balances_.~RepeatedPtrField();
  _impl_.new_balances_.~RepeatedPtrField();
  _impl_.wallet_address_.Destroy();
}

void WalletChange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WalletChange::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_api.WalletChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_ids_.Clear();
  _impl_.old_balances_.Clear();
  _impl_.new_balances_.Clear();
  _impl_.wallet_address_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WalletChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes wallet_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_wallet_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string contract_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_contract_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.WalletChange.contract_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string old_balances = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_old_balances();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.WalletChange.old_balances"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string new_balances = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_new_balances();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_api.WalletChange.new_balances"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WalletChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_api.WalletChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_wallet_address(), target);
  }

  // repeated string contract_ids = 2;
  for (int i = 0, n = this->_internal_contract_ids_size(); i < n; i++) {
    const auto& s = this->_internal_contract_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.WalletChange.contract_ids");
    target = stream->WriteString(2, s, target);
  }

  // repeated string old_balances = 3;
  for (int i = 0, n = this->_internal_old_balances_size(); i < n; i++) {
    const auto& s = this->_internal_old_balances(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.WalletChange.old_balances");
    target = stream->WriteString(3, s, target);
  }

  // repeated string new_balances = 4;
  for (int i = 0, n = this->_internal_new_balances_size(); i < n; i++) {
    const auto& s = this->_internal_new_balances(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_api.WalletChange.new_balances");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_api.WalletChange)
  return target;
}

size_t WalletChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_api.WalletChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string contract_ids = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.contract_ids_.size());
  for (int i = 0, n = _impl_.contract_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.contract_ids_.Get(i));
  }

  // repeated string old_balances = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.old_balances_.size());
  for (int i = 0, n = _impl_.old_balances_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.old_balances_.Get(i));
  }

  // repeated string new_balances = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.new_balances_.size());
  for (int i = 0, n = _impl_.new_balances_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.new_balances_.Get(i));
  }

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_wallet_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WalletChange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WalletChange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WalletChange::GetClassData() const { return &_class_data_; }


void WalletChange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WalletChange*>(&to_msg);
  auto& from = static_cast<const WalletChange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_api.WalletChange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.contract_ids_.MergeFrom(from._impl_.contract_ids_);
  _this->_impl_.old_balances_.MergeFrom(from._impl_.old_balances_);
  _this->_impl_.new_balances_.MergeFrom(from._impl_.new_balances_);
  if (!from._internal_wallet_address().empty()) {
    _this->_internal_set_wallet_address(from._internal_wallet_address());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WalletChange::CopyFrom(const WalletChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_api.WalletChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WalletChange::IsInitialized() const {
  return true;
}

void WalletChange::InternalSwap(WalletChange* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.contract_ids_.InternalSwap(&other->_impl_.contract_ids_);
  _impl_.old_balances_.InternalSwap(&other->_impl_.old_balances_);
  _impl_.new_balances_.InternalSwap(&other->_impl_.new_balances_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wallet_address_, lhs_arena,
      &other->_impl_.wallet_address_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WalletChange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_zera_5fapi_2eproto_getter, &descriptor_table_zera_5fapi_2eproto_once,
      file_level_metadata_zera_5fapi_2eproto[27]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace zera_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::zera_api::ProposalLedgerRequest*
Arena::CreateMaybeMessage< ::zera_api::ProposalLedgerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::ProposalLedgerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::ProposalLedgerResponse*
Arena::CreateMaybeMessage< ::zera_api::ProposalLedgerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::ProposalLedgerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::BlockRequest*
Arena::CreateMaybeMessage< ::zera_api::BlockRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::BlockRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::BlockResponse*
Arena::CreateMaybeMessage< ::zera_api::BlockResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::BlockResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::NonceRequest*
Arena::CreateMaybeMessage< ::zera_api::NonceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::NonceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::NonceResponse*
Arena::CreateMaybeMessage< ::zera_api::NonceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::NonceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::BalanceRequest*
Arena::CreateMaybeMessage< ::zera_api::BalanceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::BalanceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::BalanceResponse*
Arena::CreateMaybeMessage< ::zera_api::BalanceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::BalanceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::ContractFeeRequest*
Arena::CreateMaybeMessage< ::zera_api::ContractFeeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::ContractFeeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::ContractFeeResponse*
Arena::CreateMaybeMessage< ::zera_api::ContractFeeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::ContractFeeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::BaseFeeRequest*
Arena::CreateMaybeMessage< ::zera_api::BaseFeeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::BaseFeeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::BaseFeeResponse*
Arena::CreateMaybeMessage< ::zera_api::BaseFeeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::BaseFeeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::TokenFeeInfo*
Arena::CreateMaybeMessage< ::zera_api::TokenFeeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::TokenFeeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::TokenFeeInfoRequest*
Arena::CreateMaybeMessage< ::zera_api::TokenFeeInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::TokenFeeInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::TokenFeeInfoResponse*
Arena::CreateMaybeMessage< ::zera_api::TokenFeeInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::TokenFeeInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::Item*
Arena::CreateMaybeMessage< ::zera_api::Item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::Item >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::ItemRequest*
Arena::CreateMaybeMessage< ::zera_api::ItemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::ItemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::ItemResponse*
Arena::CreateMaybeMessage< ::zera_api::ItemResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::ItemResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::DenominationRequest*
Arena::CreateMaybeMessage< ::zera_api::DenominationRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::DenominationRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::DenominationResponse*
Arena::CreateMaybeMessage< ::zera_api::DenominationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::DenominationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::DatabaseRequest*
Arena::CreateMaybeMessage< ::zera_api::DatabaseRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::DatabaseRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::DatabaseResponse*
Arena::CreateMaybeMessage< ::zera_api::DatabaseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::DatabaseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::ActivityRequest*
Arena::CreateMaybeMessage< ::zera_api::ActivityRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::ActivityRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::SmartContractEventsResponse*
Arena::CreateMaybeMessage< ::zera_api::SmartContractEventsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::SmartContractEventsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::SmartContractSubscription_SubscibersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::SmartContractSubscription*
Arena::CreateMaybeMessage< ::zera_api::SmartContractSubscription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::SmartContractSubscription >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::Subscriber*
Arena::CreateMaybeMessage< ::zera_api::Subscriber >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::Subscriber >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_api::WalletChange*
Arena::CreateMaybeMessage< ::zera_api::WalletChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_api::WalletChange >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
