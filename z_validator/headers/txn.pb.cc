// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: txn.proto

#include "txn.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace zera_txn {
PROTOBUF_CONSTEXPR DelegateContract::DelegateContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.priority_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DelegateContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelegateContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelegateContractDefaultTypeInternal() {}
  union {
    DelegateContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelegateContractDefaultTypeInternal _DelegateContract_default_instance_;
PROTOBUF_CONSTEXPR DelegatedTXN::DelegatedTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.delegate_votes_)*/{}
  , /*decltype(_impl_.delegate_fees_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DelegatedTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelegatedTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelegatedTXNDefaultTypeInternal() {}
  union {
    DelegatedTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelegatedTXNDefaultTypeInternal _DelegatedTXN_default_instance_;
PROTOBUF_CONSTEXPR DelegateVote::DelegateVote(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contracts_)*/{}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DelegateVoteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelegateVoteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelegateVoteDefaultTypeInternal() {}
  union {
    DelegateVote _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelegateVoteDefaultTypeInternal _DelegateVote_default_instance_;
PROTOBUF_CONSTEXPR DelegateFees::DelegateFees(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.auth_amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DelegateFeesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelegateFeesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelegateFeesDefaultTypeInternal() {}
  union {
    DelegateFees _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelegateFeesDefaultTypeInternal _DelegateFees_default_instance_;
PROTOBUF_CONSTEXPR Compliance::Compliance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.compliance_level_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ComplianceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComplianceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComplianceDefaultTypeInternal() {}
  union {
    Compliance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComplianceDefaultTypeInternal _Compliance_default_instance_;
PROTOBUF_CONSTEXPR TokenCompliance::TokenCompliance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.compliance_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenComplianceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenComplianceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenComplianceDefaultTypeInternal() {}
  union {
    TokenCompliance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenComplianceDefaultTypeInternal _TokenCompliance_default_instance_;
PROTOBUF_CONSTEXPR ExpenseRatio::ExpenseRatio(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.day_)*/0u
  , /*decltype(_impl_.month_)*/0u
  , /*decltype(_impl_.percent_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpenseRatioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpenseRatioDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpenseRatioDefaultTypeInternal() {}
  union {
    ExpenseRatio _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpenseRatioDefaultTypeInternal _ExpenseRatio_default_instance_;
PROTOBUF_CONSTEXPR KeyValuePair::KeyValuePair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyValuePairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyValuePairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyValuePairDefaultTypeInternal() {}
  union {
    KeyValuePair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
PROTOBUF_CONSTEXPR ByteMultiplier::ByteMultiplier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.multiplier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ByteMultiplierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ByteMultiplierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ByteMultiplierDefaultTypeInternal() {}
  union {
    ByteMultiplier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ByteMultiplierDefaultTypeInternal _ByteMultiplier_default_instance_;
PROTOBUF_CONSTEXPR FoundationTXN::FoundationTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.restricted_symbols_)*/{}
  , /*decltype(_impl_.byte_multiplier_)*/{}
  , /*decltype(_impl_.fee_iso4217_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr} {}
struct FoundationTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FoundationTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FoundationTXNDefaultTypeInternal() {}
  union {
    FoundationTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FoundationTXNDefaultTypeInternal _FoundationTXN_default_instance_;
PROTOBUF_CONSTEXPR RevokeTXN::RevokeTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.item_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RevokeTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RevokeTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RevokeTXNDefaultTypeInternal() {}
  union {
    RevokeTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RevokeTXNDefaultTypeInternal _RevokeTXN_default_instance_;
PROTOBUF_CONSTEXPR FastQuorumTXN::FastQuorumTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proposal_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FastQuorumTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FastQuorumTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FastQuorumTXNDefaultTypeInternal() {}
  union {
    FastQuorumTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FastQuorumTXNDefaultTypeInternal _FastQuorumTXN_default_instance_;
PROTOBUF_CONSTEXPR Governance::Governance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.voting_instrument_)*/{}
  , /*decltype(_impl_.allowed_proposal_instrument_)*/{}
  , /*decltype(_impl_.stage_length_)*/{}
  , /*decltype(_impl_.start_timestamp_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.regular_quorum_)*/0u
  , /*decltype(_impl_.fast_quorum_)*/0u
  , /*decltype(_impl_.threshold_)*/0u
  , /*decltype(_impl_.chicken_dinner_)*/false
  , /*decltype(_impl_.allow_multi_)*/false
  , /*decltype(_impl_.voting_period_)*/0u
  , /*decltype(_impl_.proposal_period_)*/0
  , /*decltype(_impl_.max_approved_)*/0u} {}
struct GovernanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GovernanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GovernanceDefaultTypeInternal() {}
  union {
    Governance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GovernanceDefaultTypeInternal _Governance_default_instance_;
PROTOBUF_CONSTEXPR Stage::Stage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.length_)*/0u
  , /*decltype(_impl_.period_)*/0
  , /*decltype(_impl_.break__)*/false
  , /*decltype(_impl_.max_approved_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StageDefaultTypeInternal() {}
  union {
    Stage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StageDefaultTypeInternal _Stage_default_instance_;
PROTOBUF_CONSTEXPR CoinDenomination::CoinDenomination(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.denomination_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CoinDenominationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoinDenominationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoinDenominationDefaultTypeInternal() {}
  union {
    CoinDenomination _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoinDenominationDefaultTypeInternal _CoinDenomination_default_instance_;
PROTOBUF_CONSTEXPR ContractFees::ContractFees(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allowed_fee_instrument_)*/{}
  , /*decltype(_impl_.fee_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fee_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.burn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.validator_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fee_type_)*/0} {}
struct ContractFeesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractFeesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractFeesDefaultTypeInternal() {}
  union {
    ContractFees _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractFeesDefaultTypeInternal _ContractFees_default_instance_;
PROTOBUF_CONSTEXPR ItemContractFees::ItemContractFees(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allowed_fee_instrument_)*/{}
  , /*decltype(_impl_.fee_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fee_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.burn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.validator_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ItemContractFeesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemContractFeesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemContractFeesDefaultTypeInternal() {}
  union {
    ItemContractFees _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemContractFeesDefaultTypeInternal _ItemContractFees_default_instance_;
PROTOBUF_CONSTEXPR RestrictedKey::RestrictedKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.public_key_)*/nullptr
  , /*decltype(_impl_.time_delay_)*/int64_t{0}
  , /*decltype(_impl_.global_)*/false
  , /*decltype(_impl_.update_contract_)*/false
  , /*decltype(_impl_.transfer_)*/false
  , /*decltype(_impl_.quash_)*/false
  , /*decltype(_impl_.mint_)*/false
  , /*decltype(_impl_.vote_)*/false
  , /*decltype(_impl_.propose_)*/false
  , /*decltype(_impl_.compliance_)*/false
  , /*decltype(_impl_.expense_ratio_)*/false
  , /*decltype(_impl_.cur_equiv_)*/false
  , /*decltype(_impl_.revoke_)*/false
  , /*decltype(_impl_.key_weight_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RestrictedKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RestrictedKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RestrictedKeyDefaultTypeInternal() {}
  union {
    RestrictedKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RestrictedKeyDefaultTypeInternal _RestrictedKey_default_instance_;
PROTOBUF_CONSTEXPR ExpenseRatioTXN::ExpenseRatioTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.addresses_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.output_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpenseRatioTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpenseRatioTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpenseRatioTXNDefaultTypeInternal() {}
  union {
    ExpenseRatioTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpenseRatioTXNDefaultTypeInternal _ExpenseRatioTXN_default_instance_;
PROTOBUF_CONSTEXPR PreMintWallet::PreMintWallet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PreMintWalletDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PreMintWalletDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PreMintWalletDefaultTypeInternal() {}
  union {
    PreMintWallet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PreMintWalletDefaultTypeInternal _PreMintWallet_default_instance_;
PROTOBUF_CONSTEXPR Transfer::Transfer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fee_amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fee_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_fee_amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_fee_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.memo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TransferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransferDefaultTypeInternal() {}
  union {
    Transfer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransferDefaultTypeInternal _Transfer_default_instance_;
PROTOBUF_CONSTEXPR BurnSBTTXN::BurnSBTTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.item_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BurnSBTTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BurnSBTTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BurnSBTTXNDefaultTypeInternal() {}
  union {
    BurnSBTTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BurnSBTTXNDefaultTypeInternal _BurnSBTTXN_default_instance_;
PROTOBUF_CONSTEXPR BaseTXN::BaseTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fee_amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fee_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.memo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.interface_fee_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.interface_fee_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.interface_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.public_key_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.nonce_)*/uint64_t{0u}
  , /*decltype(_impl_.safe_send_)*/false} {}
struct BaseTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BaseTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BaseTXNDefaultTypeInternal() {}
  union {
    BaseTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BaseTXNDefaultTypeInternal _BaseTXN_default_instance_;
PROTOBUF_CONSTEXPR PublicKey::PublicKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.single_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.smart_contract_auth_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.governance_auth_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.multi_)*/nullptr} {}
struct PublicKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PublicKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PublicKeyDefaultTypeInternal() {}
  union {
    PublicKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicKeyDefaultTypeInternal _PublicKey_default_instance_;
PROTOBUF_CONSTEXPR GovernanceAuth::GovernanceAuth(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.auth_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.proposal_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GovernanceAuthDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GovernanceAuthDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GovernanceAuthDefaultTypeInternal() {}
  union {
    GovernanceAuth _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GovernanceAuthDefaultTypeInternal _GovernanceAuth_default_instance_;
PROTOBUF_CONSTEXPR MultiKey::MultiKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.public_keys_)*/{}
  , /*decltype(_impl_.signatures_)*/{}
  , /*decltype(_impl_.multi_patterns_)*/{}
  , /*decltype(_impl_.hash_tokens_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MultiKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MultiKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MultiKeyDefaultTypeInternal() {}
  union {
    MultiKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MultiKeyDefaultTypeInternal _MultiKey_default_instance_;
PROTOBUF_CONSTEXPR MultiPatterns::MultiPatterns(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.class__)*/{}
  , /*decltype(_impl_._class__cached_byte_size_)*/{0}
  , /*decltype(_impl_.required_)*/{}
  , /*decltype(_impl_._required_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MultiPatternsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MultiPatternsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MultiPatternsDefaultTypeInternal() {}
  union {
    MultiPatterns _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MultiPatternsDefaultTypeInternal _MultiPatterns_default_instance_;
PROTOBUF_CONSTEXPR SelfCurrencyEquiv::SelfCurrencyEquiv(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cur_equiv_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SelfCurrencyEquivDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelfCurrencyEquivDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelfCurrencyEquivDefaultTypeInternal() {}
  union {
    SelfCurrencyEquiv _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelfCurrencyEquivDefaultTypeInternal _SelfCurrencyEquiv_default_instance_;
PROTOBUF_CONSTEXPR AuthorizedCurrencyEquiv::AuthorizedCurrencyEquiv(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cur_equiv_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthorizedCurrencyEquivDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthorizedCurrencyEquivDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthorizedCurrencyEquivDefaultTypeInternal() {}
  union {
    AuthorizedCurrencyEquiv _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthorizedCurrencyEquivDefaultTypeInternal _AuthorizedCurrencyEquiv_default_instance_;
PROTOBUF_CONSTEXPR CurrencyEquiv::CurrencyEquiv(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_stake_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorized_)*/false} {}
struct CurrencyEquivDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurrencyEquivDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurrencyEquivDefaultTypeInternal() {}
  union {
    CurrencyEquiv _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurrencyEquivDefaultTypeInternal _CurrencyEquiv_default_instance_;
PROTOBUF_CONSTEXPR ExpenseRatioResult::ExpenseRatioResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wallets_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpenseRatioResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpenseRatioResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpenseRatioResultDefaultTypeInternal() {}
  union {
    ExpenseRatioResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpenseRatioResultDefaultTypeInternal _ExpenseRatioResult_default_instance_;
PROTOBUF_CONSTEXPR ComplianceAssign::ComplianceAssign(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.expiry_)*/nullptr
  , /*decltype(_impl_.compliance_level_)*/0u
  , /*decltype(_impl_.assign_revoke_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ComplianceAssignDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComplianceAssignDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComplianceAssignDefaultTypeInternal() {}
  union {
    ComplianceAssign _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComplianceAssignDefaultTypeInternal _ComplianceAssign_default_instance_;
PROTOBUF_CONSTEXPR ComplianceTXN::ComplianceTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.compliance_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ComplianceTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComplianceTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComplianceTXNDefaultTypeInternal() {}
  union {
    ComplianceTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComplianceTXNDefaultTypeInternal _ComplianceTXN_default_instance_;
PROTOBUF_CONSTEXPR Wallets::Wallets(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WalletsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WalletsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WalletsDefaultTypeInternal() {}
  union {
    Wallets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WalletsDefaultTypeInternal _Wallets_default_instance_;
PROTOBUF_CONSTEXPR QuashTXN::QuashTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuashTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuashTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuashTXNDefaultTypeInternal() {}
  union {
    QuashTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuashTXNDefaultTypeInternal _QuashTXN_default_instance_;
PROTOBUF_CONSTEXPR QuashResult::QuashResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.public_keys_)*/{}
  , /*decltype(_impl_.txn_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuashResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuashResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuashResultDefaultTypeInternal() {}
  union {
    QuashResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuashResultDefaultTypeInternal _QuashResult_default_instance_;
PROTOBUF_CONSTEXPR CoinTXN::CoinTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.input_transfers_)*/{}
  , /*decltype(_impl_.output_transfers_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fee_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fee_amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.auth_)*/nullptr} {}
struct CoinTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoinTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoinTXNDefaultTypeInternal() {}
  union {
    CoinTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoinTXNDefaultTypeInternal _CoinTXN_default_instance_;
PROTOBUF_CONSTEXPR TransferAuthentication::TransferAuthentication(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.public_key_)*/{}
  , /*decltype(_impl_.signature_)*/{}
  , /*decltype(_impl_.nonce_)*/{}
  , /*decltype(_impl_._nonce_cached_byte_size_)*/{0}
  , /*decltype(_impl_.allowance_address_)*/{}
  , /*decltype(_impl_.allowance_nonce_)*/{}
  , /*decltype(_impl_._allowance_nonce_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransferAuthenticationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransferAuthenticationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransferAuthenticationDefaultTypeInternal() {}
  union {
    TransferAuthentication _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransferAuthenticationDefaultTypeInternal _TransferAuthentication_default_instance_;
PROTOBUF_CONSTEXPR InputTransfers::InputTransfers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.index_)*/uint64_t{0u}
  , /*decltype(_impl_.fee_percent_)*/0u
  , /*decltype(_impl_.contract_fee_percent_)*/0u} {}
struct InputTransfersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InputTransfersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InputTransfersDefaultTypeInternal() {}
  union {
    InputTransfers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InputTransfersDefaultTypeInternal _InputTransfers_default_instance_;
PROTOBUF_CONSTEXPR OutputTransfers::OutputTransfers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.wallet_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.memo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct OutputTransfersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OutputTransfersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OutputTransfersDefaultTypeInternal() {}
  union {
    OutputTransfers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutputTransfersDefaultTypeInternal _OutputTransfers_default_instance_;
PROTOBUF_CONSTEXPR MintTXN::MintTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MintTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MintTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MintTXNDefaultTypeInternal() {}
  union {
    MintTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MintTXNDefaultTypeInternal _MintTXN_default_instance_;
PROTOBUF_CONSTEXPR NFTTXN::NFTTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.item_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fee_amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fee_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr} {}
struct NFTTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NFTTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NFTTXNDefaultTypeInternal() {}
  union {
    NFTTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NFTTXNDefaultTypeInternal _NFTTXN_default_instance_;
PROTOBUF_CONSTEXPR ItemizedMintTXN::ItemizedMintTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parameters_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.item_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.voting_weight_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.contract_fees_)*/nullptr
  , /*decltype(_impl_.expiry_)*/uint64_t{0u}
  , /*decltype(_impl_.valid_from_)*/uint64_t{0u}} {}
struct ItemizedMintTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemizedMintTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemizedMintTXNDefaultTypeInternal() {}
  union {
    ItemizedMintTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemizedMintTXNDefaultTypeInternal _ItemizedMintTXN_default_instance_;
PROTOBUF_CONSTEXPR ContractUpdateTXN::ContractUpdateTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.restricted_keys_)*/{}
  , /*decltype(_impl_.custom_parameters_)*/{}
  , /*decltype(_impl_.expense_ratio_)*/{}
  , /*decltype(_impl_.token_compliance_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.governance_)*/nullptr
  , /*decltype(_impl_.contract_fees_)*/nullptr
  , /*decltype(_impl_.contract_version_)*/uint64_t{0u}
  , /*decltype(_impl_.kyc_status_)*/false
  , /*decltype(_impl_.immutable_kyc_status_)*/false
  , /*decltype(_impl_.quash_threshold_)*/0u} {}
struct ContractUpdateTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractUpdateTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractUpdateTXNDefaultTypeInternal() {}
  union {
    ContractUpdateTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractUpdateTXNDefaultTypeInternal _ContractUpdateTXN_default_instance_;
PROTOBUF_CONSTEXPR InstrumentContract::InstrumentContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.restricted_keys_)*/{}
  , /*decltype(_impl_.premint_wallets_)*/{}
  , /*decltype(_impl_.custom_parameters_)*/{}
  , /*decltype(_impl_.expense_ratio_)*/{}
  , /*decltype(_impl_.token_compliance_)*/{}
  , /*decltype(_impl_.max_supply_release_)*/{}
  , /*decltype(_impl_.symbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_supply_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cur_equiv_start_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.governance_)*/nullptr
  , /*decltype(_impl_.contract_fees_)*/nullptr
  , /*decltype(_impl_.coin_denomination_)*/nullptr
  , /*decltype(_impl_.contract_version_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.quash_threshold_)*/0u
  , /*decltype(_impl_.update_contract_fees_)*/false
  , /*decltype(_impl_.update_expense_ratio_)*/false
  , /*decltype(_impl_.kyc_status_)*/false
  , /*decltype(_impl_.immutable_kyc_status_)*/false} {}
struct InstrumentContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstrumentContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstrumentContractDefaultTypeInternal() {}
  union {
    InstrumentContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstrumentContractDefaultTypeInternal _InstrumentContract_default_instance_;
PROTOBUF_CONSTEXPR MaxSupplyRelease::MaxSupplyRelease(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.release_date_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MaxSupplyReleaseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MaxSupplyReleaseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MaxSupplyReleaseDefaultTypeInternal() {}
  union {
    MaxSupplyRelease _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MaxSupplyReleaseDefaultTypeInternal _MaxSupplyRelease_default_instance_;
PROTOBUF_CONSTEXPR GovernanceVote::GovernanceVote(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.proposal_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.support_)*/false
  , /*decltype(_impl_.support_option_)*/0u} {}
struct GovernanceVoteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GovernanceVoteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GovernanceVoteDefaultTypeInternal() {}
  union {
    GovernanceVote _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GovernanceVoteDefaultTypeInternal _GovernanceVote_default_instance_;
PROTOBUF_CONSTEXPR GovernanceProposal::GovernanceProposal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.options_)*/{}
  , /*decltype(_impl_.governance_txn_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.synopsis_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.start_timestamp_)*/nullptr
  , /*decltype(_impl_.end_timestamp_)*/nullptr} {}
struct GovernanceProposalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GovernanceProposalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GovernanceProposalDefaultTypeInternal() {}
  union {
    GovernanceProposal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GovernanceProposalDefaultTypeInternal _GovernanceProposal_default_instance_;
PROTOBUF_CONSTEXPR GovernanceTXN::GovernanceTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.serialized_txn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GovernanceTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GovernanceTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GovernanceTXNDefaultTypeInternal() {}
  union {
    GovernanceTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GovernanceTXNDefaultTypeInternal _GovernanceTXN_default_instance_;
PROTOBUF_CONSTEXPR SmartContractTXN::SmartContractTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.functions_)*/{}
  , /*decltype(_impl_.binary_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.smart_contract_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.language_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SmartContractTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartContractTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartContractTXNDefaultTypeInternal() {}
  union {
    SmartContractTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartContractTXNDefaultTypeInternal _SmartContractTXN_default_instance_;
PROTOBUF_CONSTEXPR Parameters::Parameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParametersDefaultTypeInternal() {}
  union {
    Parameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParametersDefaultTypeInternal _Parameters_default_instance_;
PROTOBUF_CONSTEXPR SmartContractExecuteTXN::SmartContractExecuteTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parameters_)*/{}
  , /*decltype(_impl_.smart_contract_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.function_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.instance_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SmartContractExecuteTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartContractExecuteTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartContractExecuteTXNDefaultTypeInternal() {}
  union {
    SmartContractExecuteTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartContractExecuteTXNDefaultTypeInternal _SmartContractExecuteTXN_default_instance_;
PROTOBUF_CONSTEXPR SmartContractInstantiateTXN::SmartContractInstantiateTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parameters_)*/{}
  , /*decltype(_impl_.smart_contract_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.instance_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SmartContractInstantiateTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartContractInstantiateTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartContractInstantiateTXNDefaultTypeInternal() {}
  union {
    SmartContractInstantiateTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartContractInstantiateTXNDefaultTypeInternal _SmartContractInstantiateTXN_default_instance_;
PROTOBUF_CONSTEXPR Validator::Validator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.staked_contract_ids_)*/{}
  , /*decltype(_impl_.host_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.validator_port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.public_key_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.benchmark_)*/uint64_t{0u}
  , /*decltype(_impl_.lite_)*/false
  , /*decltype(_impl_.online_)*/false
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.last_heartbeat_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ValidatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValidatorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValidatorDefaultTypeInternal() {}
  union {
    Validator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValidatorDefaultTypeInternal _Validator_default_instance_;
PROTOBUF_CONSTEXPR ValidatorRegistration::ValidatorRegistration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.generated_signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.validator_)*/nullptr
  , /*decltype(_impl_.generated_public_key_)*/nullptr
  , /*decltype(_impl_.register__)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ValidatorRegistrationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValidatorRegistrationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValidatorRegistrationDefaultTypeInternal() {}
  union {
    ValidatorRegistration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValidatorRegistrationDefaultTypeInternal _ValidatorRegistration_default_instance_;
PROTOBUF_CONSTEXPR ValidatorHeartbeat::ValidatorHeartbeat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.online_)*/false
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ValidatorHeartbeatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValidatorHeartbeatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValidatorHeartbeatDefaultTypeInternal() {}
  union {
    ValidatorHeartbeat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValidatorHeartbeatDefaultTypeInternal _ValidatorHeartbeat_default_instance_;
PROTOBUF_CONSTEXPR SmartContractParameter::SmartContractParameter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.type_)*/0} {}
struct SmartContractParameterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartContractParameterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartContractParameterDefaultTypeInternal() {}
  union {
    SmartContractParameter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartContractParameterDefaultTypeInternal _SmartContractParameter_default_instance_;
PROTOBUF_CONSTEXPR Votes::Votes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.votes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VotesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VotesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VotesDefaultTypeInternal() {}
  union {
    Votes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VotesDefaultTypeInternal _Votes_default_instance_;
PROTOBUF_CONSTEXPR VotePair::VotePair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VotePairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VotePairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VotePairDefaultTypeInternal() {}
  union {
    VotePair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VotePairDefaultTypeInternal _VotePair_default_instance_;
PROTOBUF_CONSTEXPR RequiredVersion::RequiredVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.version_)*/{}
  , /*decltype(_impl_._version_cached_byte_size_)*/{0}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequiredVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequiredVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequiredVersionDefaultTypeInternal() {}
  union {
    RequiredVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequiredVersionDefaultTypeInternal _RequiredVersion_default_instance_;
PROTOBUF_CONSTEXPR ProposalResult::ProposalResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.option_cur_equiv_)*/{}
  , /*decltype(_impl_.option_votes_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.proposal_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.support_cur_equiv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.against_cur_equiv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.support_votes_)*/nullptr
  , /*decltype(_impl_.against_votes_)*/nullptr
  , /*decltype(_impl_.stage_)*/0u
  , /*decltype(_impl_.passed_)*/false
  , /*decltype(_impl_.final_stage_)*/false
  , /*decltype(_impl_.fast_quorum_)*/false
  , /*decltype(_impl_.proposal_cut_)*/false} {}
struct ProposalResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProposalResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProposalResultDefaultTypeInternal() {}
  union {
    ProposalResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProposalResultDefaultTypeInternal _ProposalResult_default_instance_;
PROTOBUF_CONSTEXPR AllowanceTXN::AllowanceTXN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.wallet_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allowed_currency_equivalent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allowed_amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.start_time_)*/nullptr
  , /*decltype(_impl_.period_months_)*/0u
  , /*decltype(_impl_.period_seconds_)*/0u
  , /*decltype(_impl_.authorize_)*/false} {}
struct AllowanceTXNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllowanceTXNDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllowanceTXNDefaultTypeInternal() {}
  union {
    AllowanceTXN _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllowanceTXNDefaultTypeInternal _AllowanceTXN_default_instance_;
PROTOBUF_CONSTEXPR TXNS::TXNS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.coin_txns_)*/{}
  , /*decltype(_impl_.mint_txns_)*/{}
  , /*decltype(_impl_.item_mint_txns_)*/{}
  , /*decltype(_impl_.contract_txns_)*/{}
  , /*decltype(_impl_.governance_votes_)*/{}
  , /*decltype(_impl_.governance_proposals_)*/{}
  , /*decltype(_impl_.smart_contracts_)*/{}
  , /*decltype(_impl_.smart_contract_executes_)*/{}
  , /*decltype(_impl_.self_cur_equivs_)*/{}
  , /*decltype(_impl_.auth_cur_equivs_)*/{}
  , /*decltype(_impl_.expense_ratios_)*/{}
  , /*decltype(_impl_.txn_fees_and_status_)*/{}
  , /*decltype(_impl_.token_fees_)*/{}
  , /*decltype(_impl_.nft_txns_)*/{}
  , /*decltype(_impl_.contract_update_txns_)*/{}
  , /*decltype(_impl_.validator_registration_txns_)*/{}
  , /*decltype(_impl_.validator_heartbeat_txns_)*/{}
  , /*decltype(_impl_.proposal_result_txns_)*/{}
  , /*decltype(_impl_.expense_ratio_result_txns_)*/{}
  , /*decltype(_impl_.foundation_txns_)*/{}
  , /*decltype(_impl_.delegated_voting_txns_)*/{}
  , /*decltype(_impl_.quash_txns_)*/{}
  , /*decltype(_impl_.fast_quorum_txns_)*/{}
  , /*decltype(_impl_.quash_results_)*/{}
  , /*decltype(_impl_.revoke_txns_)*/{}
  , /*decltype(_impl_.compliance_txns_)*/{}
  , /*decltype(_impl_.burn_sbt_txns_)*/{}
  , /*decltype(_impl_.smart_contract_instantiate_txns_)*/{}
  , /*decltype(_impl_.allowance_txns_)*/{}
  , /*decltype(_impl_.required_version_txn_)*/nullptr} {}
struct TXNSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TXNSDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TXNSDefaultTypeInternal() {}
  union {
    TXNS _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TXNSDefaultTypeInternal _TXNS_default_instance_;
PROTOBUF_CONSTEXPR Token::Token(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenDefaultTypeInternal() {}
  union {
    Token _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenDefaultTypeInternal _Token_default_instance_;
PROTOBUF_CONSTEXPR TokenFees::TokenFees(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tokens_)*/{}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenFeesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenFeesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenFeesDefaultTypeInternal() {}
  union {
    TokenFees _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenFeesDefaultTypeInternal _TokenFees_default_instance_;
PROTOBUF_CONSTEXPR DelegatedData::DelegatedData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fee_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DelegatedDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelegatedDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelegatedDataDefaultTypeInternal() {}
  union {
    DelegatedData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelegatedDataDefaultTypeInternal _DelegatedData_default_instance_;
PROTOBUF_CONSTEXPR TXNStatusFees::TXNStatusFees(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.smart_contract_result_)*/{}
  , /*decltype(_impl_.misc_)*/{}
  , /*decltype(_impl_.delegated_data_)*/{}
  , /*decltype(_impl_.txn_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_fees_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_fees_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contract_contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.native_function_fees_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.interface_fee_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.interface_fee_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.smart_contract_)*/false
  , /*decltype(_impl_.gas_)*/uint64_t{0u}} {}
struct TXNStatusFeesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TXNStatusFeesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TXNStatusFeesDefaultTypeInternal() {}
  union {
    TXNStatusFees _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TXNStatusFeesDefaultTypeInternal _TXNStatusFees_default_instance_;
PROTOBUF_CONSTEXPR ProposalContract::ProposalContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proposal_ids_)*/{}
  , /*decltype(_impl_.contract_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stage_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProposalContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProposalContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProposalContractDefaultTypeInternal() {}
  union {
    ProposalContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProposalContractDefaultTypeInternal _ProposalContract_default_instance_;
PROTOBUF_CONSTEXPR TXNWrapper::TXNWrapper(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.proposal_ids_)*/{}
  , /*decltype(_impl_.proposal_contracts_)*/{}
  , /*decltype(_impl_.txn_type_)*/0
  , /*decltype(_impl_.smart_contract_txn_)*/false
  , /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TXNWrapperDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TXNWrapperDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TXNWrapperDefaultTypeInternal() {}
  union {
    TXNWrapper _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TXNWrapperDefaultTypeInternal _TXNWrapper_default_instance_;
}  // namespace zera_txn
static ::_pb::Metadata file_level_metadata_txn_2eproto[69];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_txn_2eproto[8];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_txn_2eproto = nullptr;

const uint32_t TableStruct_txn_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateContract, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateContract, _impl_.contract_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegatedTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegatedTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegatedTXN, _impl_.delegate_votes_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegatedTXN, _impl_.delegate_fees_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateVote, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateVote, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateVote, _impl_.contracts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateFees, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateFees, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegateFees, _impl_.auth_amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Compliance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Compliance, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Compliance, _impl_.compliance_level_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TokenCompliance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TokenCompliance, _impl_.compliance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatio, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatio, _impl_.day_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatio, _impl_.month_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatio, _impl_.percent_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::KeyValuePair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::KeyValuePair, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::KeyValuePair, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ByteMultiplier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ByteMultiplier, _impl_.txn_type_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ByteMultiplier, _impl_.multiplier_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::FoundationTXN, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::FoundationTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::FoundationTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::FoundationTXN, _impl_.restricted_symbols_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::FoundationTXN, _impl_.byte_multiplier_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::FoundationTXN, _impl_.fee_iso4217_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::RevokeTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::RevokeTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RevokeTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RevokeTXN, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RevokeTXN, _impl_.item_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::FastQuorumTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::FastQuorumTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::FastQuorumTXN, _impl_.proposal_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.regular_quorum_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.fast_quorum_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.voting_instrument_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.threshold_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.chicken_dinner_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.allow_multi_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.voting_period_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.allowed_proposal_instrument_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.proposal_period_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.stage_length_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.start_timestamp_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Governance, _impl_.max_approved_),
  ~0u,
  ~0u,
  1,
  ~0u,
  ~0u,
  2,
  ~0u,
  3,
  ~0u,
  4,
  ~0u,
  0,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Stage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Stage, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Stage, _impl_.period_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Stage, _impl_.break__),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Stage, _impl_.max_approved_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinDenomination, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinDenomination, _impl_.denomination_name_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinDenomination, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractFees, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractFees, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractFees, _impl_.fee_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractFees, _impl_.fee_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractFees, _impl_.burn_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractFees, _impl_.validator_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractFees, _impl_.allowed_fee_instrument_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractFees, _impl_.contract_fee_type_),
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemContractFees, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemContractFees, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemContractFees, _impl_.fee_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemContractFees, _impl_.fee_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemContractFees, _impl_.burn_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemContractFees, _impl_.validator_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemContractFees, _impl_.allowed_fee_instrument_),
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.time_delay_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.global_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.update_contract_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.transfer_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.quash_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.mint_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.vote_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.propose_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.compliance_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.expense_ratio_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.cur_equiv_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.revoke_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RestrictedKey, _impl_.key_weight_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioTXN, _impl_.addresses_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioTXN, _impl_.output_address_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::PreMintWallet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::PreMintWallet, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::PreMintWallet, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_.contract_fee_amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_.contract_fee_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_.base_fee_amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_.base_fee_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Transfer, _impl_.memo_),
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::BurnSBTTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::BurnSBTTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BurnSBTTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BurnSBTTXN, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.fee_amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.fee_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.memo_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.safe_send_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.nonce_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.interface_fee_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.interface_fee_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::BaseTXN, _impl_.interface_address_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  2,
  6,
  ~0u,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::zera_txn::PublicKey, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::PublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::PublicKey, _impl_.single_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::PublicKey, _impl_.multi_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::PublicKey, _impl_.smart_contract_auth_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::PublicKey, _impl_.governance_auth_),
  ~0u,
  ~0u,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceAuth, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceAuth, _impl_.auth_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceAuth, _impl_.proposal_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::MultiKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::MultiKey, _impl_.public_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::MultiKey, _impl_.signatures_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::MultiKey, _impl_.multi_patterns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::MultiKey, _impl_.hash_tokens_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::MultiPatterns, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::MultiPatterns, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::zera_txn::MultiPatterns, _impl_.required_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SelfCurrencyEquiv, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SelfCurrencyEquiv, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SelfCurrencyEquiv, _impl_.cur_equiv_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::AuthorizedCurrencyEquiv, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::AuthorizedCurrencyEquiv, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AuthorizedCurrencyEquiv, _impl_.cur_equiv_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CurrencyEquiv, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CurrencyEquiv, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::CurrencyEquiv, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CurrencyEquiv, _impl_.rate_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CurrencyEquiv, _impl_.authorized_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CurrencyEquiv, _impl_.max_stake_),
  ~0u,
  ~0u,
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioResult, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioResult, _impl_.wallets_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioResult, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ExpenseRatioResult, _impl_.recipient_address_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceAssign, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceAssign, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceAssign, _impl_.compliance_level_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceAssign, _impl_.assign_revoke_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceAssign, _impl_.expiry_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ComplianceTXN, _impl_.compliance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Wallets, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Wallets, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Wallets, _impl_.amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::QuashTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::QuashTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::QuashTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::QuashTXN, _impl_.txn_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::QuashResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::QuashResult, _impl_.txn_hash_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::QuashResult, _impl_.public_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _impl_.auth_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _impl_.input_transfers_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _impl_.output_transfers_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _impl_.contract_fee_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::CoinTXN, _impl_.contract_fee_amount_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TransferAuthentication, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TransferAuthentication, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TransferAuthentication, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TransferAuthentication, _impl_.nonce_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TransferAuthentication, _impl_.allowance_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TransferAuthentication, _impl_.allowance_nonce_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InputTransfers, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InputTransfers, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::InputTransfers, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InputTransfers, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InputTransfers, _impl_.fee_percent_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InputTransfers, _impl_.contract_fee_percent_),
  ~0u,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::zera_txn::OutputTransfers, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::OutputTransfers, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::OutputTransfers, _impl_.wallet_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::OutputTransfers, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::OutputTransfers, _impl_.memo_),
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::MintTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::MintTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::MintTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::MintTXN, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::MintTXN, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::NFTTXN, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::NFTTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::NFTTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::NFTTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::NFTTXN, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::NFTTXN, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::NFTTXN, _impl_.contract_fee_amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::NFTTXN, _impl_.contract_fee_id_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.voting_weight_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.parameters_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.expiry_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.contract_fees_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ItemizedMintTXN, _impl_.valid_from_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.contract_version_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.governance_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.restricted_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.contract_fees_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.custom_parameters_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.expense_ratio_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.token_compliance_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.kyc_status_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.immutable_kyc_status_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ContractUpdateTXN, _impl_.quash_threshold_),
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,
  2,
  ~0u,
  ~0u,
  ~0u,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.contract_version_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.symbol_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.governance_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.restricted_keys_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.max_supply_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.contract_fees_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.premint_wallets_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.coin_denomination_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.custom_parameters_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.expense_ratio_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.update_contract_fees_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.update_expense_ratio_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.quash_threshold_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.token_compliance_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.kyc_status_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.immutable_kyc_status_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.cur_equiv_start_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::InstrumentContract, _impl_.max_supply_release_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  2,
  ~0u,
  0,
  3,
  ~0u,
  4,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  5,
  ~0u,
  ~0u,
  ~0u,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::MaxSupplyRelease, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::MaxSupplyRelease, _impl_.release_date_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::MaxSupplyRelease, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceVote, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceVote, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceVote, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceVote, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceVote, _impl_.proposal_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceVote, _impl_.support_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceVote, _impl_.support_option_),
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.synopsis_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.options_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.start_timestamp_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.end_timestamp_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceProposal, _impl_.governance_txn_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceTXN, _impl_.txn_type_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceTXN, _impl_.serialized_txn_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::GovernanceTXN, _impl_.txn_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractTXN, _impl_.smart_contract_name_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractTXN, _impl_.binary_code_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractTXN, _impl_.source_code_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractTXN, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractTXN, _impl_.functions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Parameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Parameters, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Parameters, _impl_.type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractExecuteTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractExecuteTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractExecuteTXN, _impl_.smart_contract_name_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractExecuteTXN, _impl_.instance_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractExecuteTXN, _impl_.function_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractExecuteTXN, _impl_.parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractInstantiateTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractInstantiateTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractInstantiateTXN, _impl_.smart_contract_name_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractInstantiateTXN, _impl_.instance_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractInstantiateTXN, _impl_.parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.host_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.client_port_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.validator_port_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.staked_contract_ids_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.benchmark_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.lite_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.online_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Validator, _impl_.last_heartbeat_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorRegistration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorRegistration, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorRegistration, _impl_.validator_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorRegistration, _impl_.register__),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorRegistration, _impl_.generated_public_key_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorRegistration, _impl_.generated_signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorHeartbeat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorHeartbeat, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorHeartbeat, _impl_.online_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ValidatorHeartbeat, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractParameter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractParameter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractParameter, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractParameter, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::SmartContractParameter, _impl_.value_),
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Votes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Votes, _impl_.votes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::VotePair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::VotePair, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::VotePair, _impl_.amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::RequiredVersion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::RequiredVersion, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::RequiredVersion, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.proposal_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.support_cur_equiv_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.against_cur_equiv_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.option_cur_equiv_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.support_votes_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.against_votes_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.option_votes_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.passed_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.final_stage_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.stage_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.fast_quorum_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalResult, _impl_.proposal_cut_),
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,
  2,
  3,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.wallet_address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.allowed_currency_equivalent_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.allowed_amount_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.period_months_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.period_seconds_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::AllowanceTXN, _impl_.authorize_),
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  2,
  3,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.coin_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.mint_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.item_mint_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.contract_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.governance_votes_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.governance_proposals_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.smart_contracts_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.smart_contract_executes_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.self_cur_equivs_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.auth_cur_equivs_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.expense_ratios_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.txn_fees_and_status_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.token_fees_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.nft_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.contract_update_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.validator_registration_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.validator_heartbeat_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.proposal_result_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.expense_ratio_result_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.foundation_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.delegated_voting_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.quash_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.fast_quorum_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.quash_results_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.revoke_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.compliance_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.burn_sbt_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.smart_contract_instantiate_txns_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.required_version_txn_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNS, _impl_.allowance_txns_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Token, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::Token, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::Token, _impl_.amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TokenFees, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TokenFees, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TokenFees, _impl_.tokens_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegatedData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegatedData, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::DelegatedData, _impl_.fee_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.txn_hash_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.base_fees_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.base_contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.contract_fees_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.contract_contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.smart_contract_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.smart_contract_result_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.misc_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.native_function_fees_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.gas_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.delegated_data_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.interface_fee_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNStatusFees, _impl_.interface_fee_id_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  2,
  5,
  ~0u,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalContract, _impl_.contract_id_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalContract, _impl_.proposal_ids_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::ProposalContract, _impl_.stage_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNWrapper, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNWrapper, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNWrapper, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNWrapper, _impl_.txn_type_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNWrapper, _impl_.proposal_ids_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNWrapper, _impl_.proposal_contracts_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNWrapper, _impl_.smart_contract_txn_),
  PROTOBUF_FIELD_OFFSET(::zera_txn::TXNWrapper, _impl_.payload_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::zera_txn::DelegateContract)},
  { 8, -1, -1, sizeof(::zera_txn::DelegatedTXN)},
  { 17, -1, -1, sizeof(::zera_txn::DelegateVote)},
  { 25, -1, -1, sizeof(::zera_txn::DelegateFees)},
  { 33, -1, -1, sizeof(::zera_txn::Compliance)},
  { 41, -1, -1, sizeof(::zera_txn::TokenCompliance)},
  { 48, -1, -1, sizeof(::zera_txn::ExpenseRatio)},
  { 57, -1, -1, sizeof(::zera_txn::KeyValuePair)},
  { 65, -1, -1, sizeof(::zera_txn::ByteMultiplier)},
  { 73, 83, -1, sizeof(::zera_txn::FoundationTXN)},
  { 87, -1, -1, sizeof(::zera_txn::RevokeTXN)},
  { 97, -1, -1, sizeof(::zera_txn::FastQuorumTXN)},
  { 105, 124, -1, sizeof(::zera_txn::Governance)},
  { 137, -1, -1, sizeof(::zera_txn::Stage)},
  { 147, -1, -1, sizeof(::zera_txn::CoinDenomination)},
  { 155, 167, -1, sizeof(::zera_txn::ContractFees)},
  { 173, 184, -1, sizeof(::zera_txn::ItemContractFees)},
  { 189, -1, -1, sizeof(::zera_txn::RestrictedKey)},
  { 209, -1, -1, sizeof(::zera_txn::ExpenseRatioTXN)},
  { 219, -1, -1, sizeof(::zera_txn::PreMintWallet)},
  { 227, 241, -1, sizeof(::zera_txn::Transfer)},
  { 249, -1, -1, sizeof(::zera_txn::BurnSBTTXN)},
  { 258, 276, -1, sizeof(::zera_txn::BaseTXN)},
  { 288, 298, -1, sizeof(::zera_txn::PublicKey)},
  { 302, -1, -1, sizeof(::zera_txn::GovernanceAuth)},
  { 310, -1, -1, sizeof(::zera_txn::MultiKey)},
  { 320, -1, -1, sizeof(::zera_txn::MultiPatterns)},
  { 328, -1, -1, sizeof(::zera_txn::SelfCurrencyEquiv)},
  { 336, -1, -1, sizeof(::zera_txn::AuthorizedCurrencyEquiv)},
  { 344, 354, -1, sizeof(::zera_txn::CurrencyEquiv)},
  { 358, -1, -1, sizeof(::zera_txn::ExpenseRatioResult)},
  { 368, -1, -1, sizeof(::zera_txn::ComplianceAssign)},
  { 378, -1, -1, sizeof(::zera_txn::ComplianceTXN)},
  { 387, -1, -1, sizeof(::zera_txn::Wallets)},
  { 395, -1, -1, sizeof(::zera_txn::QuashTXN)},
  { 404, -1, -1, sizeof(::zera_txn::QuashResult)},
  { 412, 425, -1, sizeof(::zera_txn::CoinTXN)},
  { 432, -1, -1, sizeof(::zera_txn::TransferAuthentication)},
  { 443, 453, -1, sizeof(::zera_txn::InputTransfers)},
  { 457, 466, -1, sizeof(::zera_txn::OutputTransfers)},
  { 469, -1, -1, sizeof(::zera_txn::MintTXN)},
  { 479, 491, -1, sizeof(::zera_txn::NFTTXN)},
  { 497, 512, -1, sizeof(::zera_txn::ItemizedMintTXN)},
  { 521, 540, -1, sizeof(::zera_txn::ContractUpdateTXN)},
  { 553, 581, -1, sizeof(::zera_txn::InstrumentContract)},
  { 603, -1, -1, sizeof(::zera_txn::MaxSupplyRelease)},
  { 611, 622, -1, sizeof(::zera_txn::GovernanceVote)},
  { 627, 642, -1, sizeof(::zera_txn::GovernanceProposal)},
  { 651, -1, -1, sizeof(::zera_txn::GovernanceTXN)},
  { 660, -1, -1, sizeof(::zera_txn::SmartContractTXN)},
  { 672, -1, -1, sizeof(::zera_txn::Parameters)},
  { 680, -1, -1, sizeof(::zera_txn::SmartContractExecuteTXN)},
  { 691, -1, -1, sizeof(::zera_txn::SmartContractInstantiateTXN)},
  { 701, -1, -1, sizeof(::zera_txn::Validator)},
  { 718, -1, -1, sizeof(::zera_txn::ValidatorRegistration)},
  { 729, -1, -1, sizeof(::zera_txn::ValidatorHeartbeat)},
  { 738, 747, -1, sizeof(::zera_txn::SmartContractParameter)},
  { 750, -1, -1, sizeof(::zera_txn::Votes)},
  { 757, -1, -1, sizeof(::zera_txn::VotePair)},
  { 765, -1, -1, sizeof(::zera_txn::RequiredVersion)},
  { 773, 793, -1, sizeof(::zera_txn::ProposalResult)},
  { 807, 822, -1, sizeof(::zera_txn::AllowanceTXN)},
  { 831, 867, -1, sizeof(::zera_txn::TXNS)},
  { 897, -1, -1, sizeof(::zera_txn::Token)},
  { 905, -1, -1, sizeof(::zera_txn::TokenFees)},
  { 913, -1, -1, sizeof(::zera_txn::DelegatedData)},
  { 921, 941, -1, sizeof(::zera_txn::TXNStatusFees)},
  { 955, -1, -1, sizeof(::zera_txn::ProposalContract)},
  { 964, 1001, -1, sizeof(::zera_txn::TXNWrapper)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::zera_txn::_DelegateContract_default_instance_._instance,
  &::zera_txn::_DelegatedTXN_default_instance_._instance,
  &::zera_txn::_DelegateVote_default_instance_._instance,
  &::zera_txn::_DelegateFees_default_instance_._instance,
  &::zera_txn::_Compliance_default_instance_._instance,
  &::zera_txn::_TokenCompliance_default_instance_._instance,
  &::zera_txn::_ExpenseRatio_default_instance_._instance,
  &::zera_txn::_KeyValuePair_default_instance_._instance,
  &::zera_txn::_ByteMultiplier_default_instance_._instance,
  &::zera_txn::_FoundationTXN_default_instance_._instance,
  &::zera_txn::_RevokeTXN_default_instance_._instance,
  &::zera_txn::_FastQuorumTXN_default_instance_._instance,
  &::zera_txn::_Governance_default_instance_._instance,
  &::zera_txn::_Stage_default_instance_._instance,
  &::zera_txn::_CoinDenomination_default_instance_._instance,
  &::zera_txn::_ContractFees_default_instance_._instance,
  &::zera_txn::_ItemContractFees_default_instance_._instance,
  &::zera_txn::_RestrictedKey_default_instance_._instance,
  &::zera_txn::_ExpenseRatioTXN_default_instance_._instance,
  &::zera_txn::_PreMintWallet_default_instance_._instance,
  &::zera_txn::_Transfer_default_instance_._instance,
  &::zera_txn::_BurnSBTTXN_default_instance_._instance,
  &::zera_txn::_BaseTXN_default_instance_._instance,
  &::zera_txn::_PublicKey_default_instance_._instance,
  &::zera_txn::_GovernanceAuth_default_instance_._instance,
  &::zera_txn::_MultiKey_default_instance_._instance,
  &::zera_txn::_MultiPatterns_default_instance_._instance,
  &::zera_txn::_SelfCurrencyEquiv_default_instance_._instance,
  &::zera_txn::_AuthorizedCurrencyEquiv_default_instance_._instance,
  &::zera_txn::_CurrencyEquiv_default_instance_._instance,
  &::zera_txn::_ExpenseRatioResult_default_instance_._instance,
  &::zera_txn::_ComplianceAssign_default_instance_._instance,
  &::zera_txn::_ComplianceTXN_default_instance_._instance,
  &::zera_txn::_Wallets_default_instance_._instance,
  &::zera_txn::_QuashTXN_default_instance_._instance,
  &::zera_txn::_QuashResult_default_instance_._instance,
  &::zera_txn::_CoinTXN_default_instance_._instance,
  &::zera_txn::_TransferAuthentication_default_instance_._instance,
  &::zera_txn::_InputTransfers_default_instance_._instance,
  &::zera_txn::_OutputTransfers_default_instance_._instance,
  &::zera_txn::_MintTXN_default_instance_._instance,
  &::zera_txn::_NFTTXN_default_instance_._instance,
  &::zera_txn::_ItemizedMintTXN_default_instance_._instance,
  &::zera_txn::_ContractUpdateTXN_default_instance_._instance,
  &::zera_txn::_InstrumentContract_default_instance_._instance,
  &::zera_txn::_MaxSupplyRelease_default_instance_._instance,
  &::zera_txn::_GovernanceVote_default_instance_._instance,
  &::zera_txn::_GovernanceProposal_default_instance_._instance,
  &::zera_txn::_GovernanceTXN_default_instance_._instance,
  &::zera_txn::_SmartContractTXN_default_instance_._instance,
  &::zera_txn::_Parameters_default_instance_._instance,
  &::zera_txn::_SmartContractExecuteTXN_default_instance_._instance,
  &::zera_txn::_SmartContractInstantiateTXN_default_instance_._instance,
  &::zera_txn::_Validator_default_instance_._instance,
  &::zera_txn::_ValidatorRegistration_default_instance_._instance,
  &::zera_txn::_ValidatorHeartbeat_default_instance_._instance,
  &::zera_txn::_SmartContractParameter_default_instance_._instance,
  &::zera_txn::_Votes_default_instance_._instance,
  &::zera_txn::_VotePair_default_instance_._instance,
  &::zera_txn::_RequiredVersion_default_instance_._instance,
  &::zera_txn::_ProposalResult_default_instance_._instance,
  &::zera_txn::_AllowanceTXN_default_instance_._instance,
  &::zera_txn::_TXNS_default_instance_._instance,
  &::zera_txn::_Token_default_instance_._instance,
  &::zera_txn::_TokenFees_default_instance_._instance,
  &::zera_txn::_DelegatedData_default_instance_._instance,
  &::zera_txn::_TXNStatusFees_default_instance_._instance,
  &::zera_txn::_ProposalContract_default_instance_._instance,
  &::zera_txn::_TXNWrapper_default_instance_._instance,
};

const char descriptor_table_protodef_txn_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ttxn.proto\022\010zera_txn\032\037google/protobuf/t"
  "imestamp.proto\032\033google/protobuf/empty.pr"
  "oto\"9\n\020DelegateContract\022\020\n\010priority\030\001 \001("
  "\005\022\023\n\013contract_id\030\002 \001(\t\"\216\001\n\014DelegatedTXN\022"
  "\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022.\n\016dele"
  "gate_votes\030\002 \003(\0132\026.zera_txn.DelegateVote"
  "\022-\n\rdelegate_fees\030\003 \003(\0132\026.zera_txn.Deleg"
  "ateFees\"N\n\014DelegateVote\022\017\n\007address\030\001 \001(\014"
  "\022-\n\tcontracts\030\002 \003(\0132\032.zera_txn.DelegateC"
  "ontract\"8\n\014DelegateFees\022\023\n\013contract_id\030\001"
  " \001(\t\022\023\n\013auth_amount\030\002 \001(\t\";\n\nCompliance\022"
  "\023\n\013contract_id\030\001 \001(\t\022\030\n\020compliance_level"
  "\030\002 \001(\r\";\n\017TokenCompliance\022(\n\ncompliance\030"
  "\001 \003(\0132\024.zera_txn.Compliance\";\n\014ExpenseRa"
  "tio\022\013\n\003day\030\001 \001(\r\022\r\n\005month\030\002 \001(\r\022\017\n\007perce"
  "nt\030\003 \001(\r\"*\n\014KeyValuePair\022\013\n\003key\030\001 \001(\t\022\r\n"
  "\005value\030\002 \001(\t\"R\n\016ByteMultiplier\022,\n\010txn_ty"
  "pe\030\001 \001(\0162\032.zera_txn.TRANSACTION_TYPE\022\022\n\n"
  "multiplier\030\002 \001(\t\"\251\001\n\rFoundationTXN\022\037\n\004ba"
  "se\030\001 \001(\0132\021.zera_txn.BaseTXN\022\032\n\022restricte"
  "d_symbols\030\002 \003(\t\0221\n\017byte_multiplier\030\003 \003(\013"
  "2\030.zera_txn.ByteMultiplier\022\030\n\013fee_ISO421"
  "7\030\004 \001(\tH\000\210\001\001B\016\n\014_fee_ISO4217\"m\n\tRevokeTX"
  "N\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\023\n\013co"
  "ntract_id\030\002 \001(\t\022\031\n\021recipient_address\030\003 \001"
  "(\014\022\017\n\007item_id\030\004 \001(\t\"E\n\rFastQuorumTXN\022\037\n\004"
  "base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\023\n\013proposa"
  "l_id\030\002 \001(\014\"\253\004\n\nGovernance\022\'\n\004type\030\001 \001(\0162"
  "\031.zera_txn.GOVERNANCE_TYPE\022\026\n\016regular_qu"
  "orum\030\002 \001(\r\022\030\n\013fast_quorum\030\003 \001(\rH\000\210\001\001\022\031\n\021"
  "voting_instrument\030\004 \003(\t\022\021\n\tthreshold\030\005 \001"
  "(\r\022\033\n\016chicken_dinner\030\006 \001(\010H\001\210\001\001\022\023\n\013allow"
  "_multi\030\007 \001(\010\022\032\n\rvoting_period\030\010 \001(\rH\002\210\001\001"
  "\022#\n\033allowed_proposal_instrument\030\t \003(\t\0227\n"
  "\017proposal_period\030\n \001(\0162\031.zera_txn.PROPOS"
  "AL_PERIODH\003\210\001\001\022%\n\014stage_length\030\013 \003(\0132\017.z"
  "era_txn.Stage\0228\n\017start_timestamp\030\014 \001(\0132\032"
  ".google.protobuf.TimestampH\004\210\001\001\022\031\n\014max_a"
  "pproved\030\r \001(\rH\005\210\001\001B\016\n\014_fast_quorumB\021\n\017_c"
  "hicken_dinnerB\020\n\016_voting_periodB\022\n\020_prop"
  "osal_periodB\022\n\020_start_timestampB\017\n\r_max_"
  "approved\"g\n\005Stage\022\016\n\006length\030\001 \001(\r\022)\n\006per"
  "iod\030\002 \001(\0162\031.zera_txn.PROPOSAL_PERIOD\022\r\n\005"
  "break\030\003 \001(\010\022\024\n\014max_approved\030\004 \001(\r\"=\n\020Coi"
  "nDenomination\022\031\n\021denomination_name\030\005 \001(\t"
  "\022\016\n\006amount\030\006 \001(\t\"\276\001\n\014ContractFees\022\013\n\003fee"
  "\030\001 \001(\t\022\030\n\013fee_address\030\002 \001(\014H\000\210\001\001\022\014\n\004burn"
  "\030\003 \001(\t\022\021\n\tvalidator\030\004 \001(\t\022\036\n\026allowed_fee"
  "_instrument\030\005 \003(\t\0226\n\021contract_fee_type\030\006"
  " \001(\0162\033.zera_txn.CONTRACT_FEE_TYPEB\016\n\014_fe"
  "e_address\"\212\001\n\020ItemContractFees\022\013\n\003fee\030\001 "
  "\001(\t\022\030\n\013fee_address\030\002 \001(\014H\000\210\001\001\022\014\n\004burn\030\003 "
  "\001(\t\022\021\n\tvalidator\030\004 \001(\t\022\036\n\026allowed_fee_in"
  "strument\030\005 \003(\tB\016\n\014_fee_address\"\245\002\n\rRestr"
  "ictedKey\022\'\n\npublic_key\030\001 \001(\0132\023.zera_txn."
  "PublicKey\022\022\n\ntime_delay\030\002 \001(\003\022\016\n\006global\030"
  "\003 \001(\010\022\027\n\017update_contract\030\004 \001(\010\022\020\n\010transf"
  "er\030\005 \001(\010\022\r\n\005quash\030\006 \001(\010\022\014\n\004mint\030\007 \001(\010\022\014\n"
  "\004vote\030\010 \001(\010\022\017\n\007propose\030\t \001(\010\022\022\n\ncomplian"
  "ce\030\n \001(\010\022\025\n\rexpense_ratio\030\013 \001(\010\022\021\n\tcur_e"
  "quiv\030\014 \001(\010\022\016\n\006revoke\030\r \001(\010\022\022\n\nkey_weight"
  "\030\016 \001(\r\"r\n\017ExpenseRatioTXN\022\037\n\004base\030\001 \001(\0132"
  "\021.zera_txn.BaseTXN\022\023\n\013contract_id\030\002 \001(\t\022"
  "\021\n\taddresses\030\003 \003(\014\022\026\n\016output_address\030\004 \001"
  "(\014\"0\n\rPreMintWallet\022\017\n\007address\030\001 \001(\014\022\016\n\006"
  "amount\030\002 \001(\t\"\200\002\n\010Transfer\022\031\n\021recipient_a"
  "ddress\030\001 \001(\014\022\016\n\006amount\030\002 \001(\t\022\023\n\013contract"
  "_id\030\003 \001(\t\022 \n\023contract_fee_amount\030\004 \001(\tH\000"
  "\210\001\001\022\034\n\017contract_fee_id\030\005 \001(\tH\001\210\001\001\022\027\n\017bas"
  "e_fee_amount\030\006 \001(\t\022\023\n\013base_fee_id\030\007 \001(\t\022"
  "\021\n\004memo\030\010 \001(\tH\002\210\001\001B\026\n\024_contract_fee_amou"
  "ntB\022\n\020_contract_fee_idB\007\n\005_memo\"S\n\nBurnS"
  "BTTXN\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\023"
  "\n\013contract_id\030\002 \001(\t\022\017\n\007item_id\030\003 \001(\t\"\260\003\n"
  "\007BaseTXN\022\'\n\npublic_key\030\001 \001(\0132\023.zera_txn."
  "PublicKey\022-\n\ttimestamp\030\003 \001(\0132\032.google.pr"
  "otobuf.Timestamp\022\022\n\nfee_amount\030\004 \001(\t\022\016\n\006"
  "fee_id\030\005 \001(\t\022\026\n\tsignature\030\006 \001(\014H\000\210\001\001\022\021\n\004"
  "hash\030\007 \001(\014H\001\210\001\001\022\021\n\004memo\030\010 \001(\tH\002\210\001\001\022\026\n\tsa"
  "fe_send\030\t \001(\010H\003\210\001\001\022\r\n\005nonce\030\n \001(\004\022\032\n\rint"
  "erface_fee\030\013 \001(\tH\004\210\001\001\022\035\n\020interface_fee_i"
  "d\030\014 \001(\tH\005\210\001\001\022\036\n\021interface_address\030\r \001(\tH"
  "\006\210\001\001B\014\n\n_signatureB\007\n\005_hashB\007\n\005_memoB\014\n\n"
  "_safe_sendB\020\n\016_interface_feeB\023\n\021_interfa"
  "ce_fee_idB\024\n\022_interface_address\"\252\001\n\tPubl"
  "icKey\022\016\n\006single\030\001 \001(\014\022!\n\005multi\030\002 \001(\0132\022.z"
  "era_txn.MultiKey\022 \n\023smart_contract_auth\030"
  "\003 \001(\014H\000\210\001\001\022\034\n\017governance_auth\030\004 \001(\014H\001\210\001\001"
  "B\026\n\024_smart_contract_authB\022\n\020_governance_"
  "auth\"3\n\016GovernanceAuth\022\014\n\004auth\030\001 \001(\014\022\023\n\013"
  "proposal_id\030\002 \001(\014\"y\n\010MultiKey\022\023\n\013public_"
  "keys\030\001 \003(\014\022\022\n\nsignatures\030\002 \003(\014\022/\n\016multi_"
  "patterns\030\003 \003(\0132\027.zera_txn.MultiPatterns\022"
  "\023\n\013hash_tokens\030\004 \003(\t\"0\n\rMultiPatterns\022\r\n"
  "\005class\030\001 \003(\r\022\020\n\010required\030\002 \003(\r\"`\n\021SelfCu"
  "rrencyEquiv\022\037\n\004base\030\001 \001(\0132\021.zera_txn.Bas"
  "eTXN\022*\n\tcur_equiv\030\002 \003(\0132\027.zera_txn.Curre"
  "ncyEquiv\"f\n\027AuthorizedCurrencyEquiv\022\037\n\004b"
  "ase\030\001 \001(\0132\021.zera_txn.BaseTXN\022*\n\tcur_equi"
  "v\030\002 \003(\0132\027.zera_txn.CurrencyEquiv\"\200\001\n\rCur"
  "rencyEquiv\022\023\n\013contract_id\030\001 \001(\t\022\014\n\004rate\030"
  "\002 \001(\t\022\027\n\nauthorized\030\003 \001(\010H\000\210\001\001\022\026\n\tmax_st"
  "ake\030\004 \001(\tH\001\210\001\001B\r\n\013_authorizedB\014\n\n_max_st"
  "ake\"v\n\022ExpenseRatioResult\022\023\n\013contract_id"
  "\030\001 \001(\t\022\"\n\007wallets\030\002 \003(\0132\021.zera_txn.Walle"
  "ts\022\014\n\004hash\030\003 \001(\014\022\031\n\021recipient_address\030\004 "
  "\001(\014\"\212\001\n\020ComplianceAssign\022\031\n\021recipient_ad"
  "dress\030\001 \001(\014\022\030\n\020compliance_level\030\002 \001(\r\022\025\n"
  "\rassign_revoke\030\003 \001(\010\022*\n\006expiry\030\004 \001(\0132\032.g"
  "oogle.protobuf.Timestamp\"u\n\rComplianceTX"
  "N\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\023\n\013co"
  "ntract_id\030\002 \001(\t\022.\n\ncompliance\030\003 \003(\0132\032.ze"
  "ra_txn.ComplianceAssign\"*\n\007Wallets\022\017\n\007ad"
  "dress\030\001 \001(\014\022\016\n\006amount\030\002 \001(\t\"R\n\010QuashTXN\022"
  "\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\023\n\013cont"
  "ract_id\030\002 \001(\t\022\020\n\010txn_hash\030\003 \001(\014\"I\n\013Quash"
  "Result\022\020\n\010txn_hash\030\001 \001(\014\022(\n\013public_keys\030"
  "\002 \003(\0132\023.zera_txn.PublicKey\"\303\002\n\007CoinTXN\022\037"
  "\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\023\n\013contr"
  "act_id\030\002 \001(\t\022.\n\004auth\030\003 \001(\0132 .zera_txn.Tr"
  "ansferAuthentication\0221\n\017input_transfers\030"
  "\004 \003(\0132\030.zera_txn.InputTransfers\0223\n\020outpu"
  "t_transfers\030\005 \003(\0132\031.zera_txn.OutputTrans"
  "fers\022\034\n\017contract_fee_id\030\006 \001(\tH\000\210\001\001\022 \n\023co"
  "ntract_fee_amount\030\007 \001(\tH\001\210\001\001B\022\n\020_contrac"
  "t_fee_idB\026\n\024_contract_fee_amount\"\227\001\n\026Tra"
  "nsferAuthentication\022\'\n\npublic_key\030\001 \003(\0132"
  "\023.zera_txn.PublicKey\022\021\n\tsignature\030\002 \003(\014\022"
  "\r\n\005nonce\030\003 \003(\004\022\031\n\021allowance_address\030\004 \003("
  "\014\022\027\n\017allowance_nonce\030\005 \003(\004\"\200\001\n\016InputTran"
  "sfers\022\r\n\005index\030\001 \001(\004\022\016\n\006amount\030\002 \001(\t\022\023\n\013"
  "fee_percent\030\003 \001(\r\022!\n\024contract_fee_percen"
  "t\030\004 \001(\rH\000\210\001\001B\027\n\025_contract_fee_percent\"U\n"
  "\017OutputTransfers\022\026\n\016wallet_address\030\001 \001(\014"
  "\022\016\n\006amount\030\002 \001(\t\022\021\n\004memo\030\003 \001(\tH\000\210\001\001B\007\n\005_"
  "memo\"j\n\007MintTXN\022\037\n\004base\030\001 \001(\0132\021.zera_txn"
  ".BaseTXN\022\023\n\013contract_id\030\002 \001(\t\022\016\n\006amount\030"
  "\003 \001(\t\022\031\n\021recipient_address\030\004 \001(\014\"\326\001\n\006NFT"
  "TXN\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\023\n\013"
  "contract_id\030\002 \001(\t\022\017\n\007item_id\030\003 \001(\t\022\031\n\021re"
  "cipient_address\030\004 \001(\014\022 \n\023contract_fee_am"
  "ount\030\005 \001(\tH\000\210\001\001\022\034\n\017contract_fee_id\030\006 \001(\t"
  "H\001\210\001\001B\026\n\024_contract_fee_amountB\022\n\020_contra"
  "ct_fee_id\"\337\002\n\017ItemizedMintTXN\022\037\n\004base\030\001 "
  "\001(\0132\021.zera_txn.BaseTXN\022\023\n\013contract_id\030\002 "
  "\001(\t\022\017\n\007item_id\030\003 \001(\t\022\031\n\021recipient_addres"
  "s\030\004 \001(\014\022\032\n\rvoting_weight\030\005 \001(\tH\000\210\001\001\022*\n\np"
  "arameters\030\006 \003(\0132\026.zera_txn.KeyValuePair\022"
  "\023\n\006expiry\030\007 \001(\004H\001\210\001\001\0226\n\rcontract_fees\030\010 "
  "\001(\0132\032.zera_txn.ItemContractFeesH\002\210\001\001\022\027\n\n"
  "valid_from\030\t \001(\004H\003\210\001\001B\020\n\016_voting_weightB"
  "\t\n\007_expiryB\020\n\016_contract_feesB\r\n\013_valid_f"
  "rom\"\342\004\n\021ContractUpdateTXN\022\037\n\004base\030\001 \001(\0132"
  "\021.zera_txn.BaseTXN\022\023\n\013contract_id\030\002 \001(\t\022"
  "\030\n\020contract_version\030\003 \001(\004\022\021\n\004name\030\004 \001(\tH"
  "\000\210\001\001\022-\n\ngovernance\030\005 \001(\0132\024.zera_txn.Gove"
  "rnanceH\001\210\001\001\0220\n\017restricted_keys\030\006 \003(\0132\027.z"
  "era_txn.RestrictedKey\0222\n\rcontract_fees\030\007"
  " \001(\0132\026.zera_txn.ContractFeesH\002\210\001\001\0221\n\021cus"
  "tom_parameters\030\010 \003(\0132\026.zera_txn.KeyValue"
  "Pair\022-\n\rexpense_ratio\030\t \003(\0132\026.zera_txn.E"
  "xpenseRatio\0223\n\020token_compliance\030\n \003(\0132\031."
  "zera_txn.TokenCompliance\022\027\n\nkyc_status\030\013"
  " \001(\010H\003\210\001\001\022!\n\024immutable_kyc_status\030\014 \001(\010H"
  "\004\210\001\001\022\034\n\017quash_threshold\030\r \001(\rH\005\210\001\001B\007\n\005_n"
  "ameB\r\n\013_governanceB\020\n\016_contract_feesB\r\n\013"
  "_kyc_statusB\027\n\025_immutable_kyc_statusB\022\n\020"
  "_quash_threshold\"\254\007\n\022InstrumentContract\022"
  "\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\030\n\020cont"
  "ract_version\030\002 \001(\004\022\016\n\006symbol\030\003 \001(\t\022\014\n\004na"
  "me\030\004 \001(\t\022-\n\ngovernance\030\005 \001(\0132\024.zera_txn."
  "GovernanceH\000\210\001\001\0220\n\017restricted_keys\030\006 \003(\013"
  "2\027.zera_txn.RestrictedKey\022\027\n\nmax_supply\030"
  "\007 \001(\tH\001\210\001\001\0222\n\rcontract_fees\030\010 \001(\0132\026.zera"
  "_txn.ContractFeesH\002\210\001\001\0220\n\017premint_wallet"
  "s\030\t \003(\0132\027.zera_txn.PreMintWallet\022:\n\021coin"
  "_denomination\030\n \001(\0132\032.zera_txn.CoinDenom"
  "inationH\003\210\001\001\0221\n\021custom_parameters\030\013 \003(\0132"
  "\026.zera_txn.KeyValuePair\022\023\n\013contract_id\030\014"
  " \001(\t\022-\n\rexpense_ratio\030\r \003(\0132\026.zera_txn.E"
  "xpenseRatio\022%\n\004type\030\016 \001(\0162\027.zera_txn.CON"
  "TRACT_TYPE\022\034\n\024update_contract_fees\030\017 \001(\010"
  "\022\034\n\024update_expense_ratio\030\020 \001(\010\022\034\n\017quash_"
  "threshold\030\021 \001(\rH\004\210\001\001\0223\n\020token_compliance"
  "\030\022 \003(\0132\031.zera_txn.TokenCompliance\022\022\n\nkyc"
  "_status\030\023 \001(\010\022\034\n\024immutable_kyc_status\030\024 "
  "\001(\010\022\034\n\017cur_equiv_start\030\025 \001(\tH\005\210\001\001\0226\n\022max"
  "_supply_release\030\026 \003(\0132\032.zera_txn.MaxSupp"
  "lyReleaseB\r\n\013_governanceB\r\n\013_max_supplyB"
  "\020\n\016_contract_feesB\024\n\022_coin_denominationB"
  "\022\n\020_quash_thresholdB\022\n\020_cur_equiv_start\""
  "T\n\020MaxSupplyRelease\0220\n\014release_date\030\001 \001("
  "\0132\032.google.protobuf.Timestamp\022\016\n\006amount\030"
  "\002 \001(\t\"\255\001\n\016GovernanceVote\022\037\n\004base\030\001 \001(\0132\021"
  ".zera_txn.BaseTXN\022\023\n\013contract_id\030\002 \001(\t\022\023"
  "\n\013proposal_id\030\003 \001(\014\022\024\n\007support\030\004 \001(\010H\000\210\001"
  "\001\022\033\n\016support_option\030\005 \001(\rH\001\210\001\001B\n\n\010_suppo"
  "rtB\021\n\017_support_option\"\323\002\n\022GovernanceProp"
  "osal\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\023\n"
  "\013contract_id\030\002 \001(\t\022\r\n\005title\030\003 \001(\t\022\020\n\010syn"
  "opsis\030\004 \001(\t\022\014\n\004body\030\005 \001(\t\022\017\n\007options\030\006 \003"
  "(\t\0228\n\017start_timestamp\030\007 \001(\0132\032.google.pro"
  "tobuf.TimestampH\000\210\001\001\0226\n\rend_timestamp\030\010 "
  "\001(\0132\032.google.protobuf.TimestampH\001\210\001\001\022/\n\016"
  "governance_txn\030\t \003(\0132\027.zera_txn.Governan"
  "ceTXNB\022\n\020_start_timestampB\020\n\016_end_timest"
  "amp\"g\n\rGovernanceTXN\022,\n\010txn_type\030\001 \001(\0162\032"
  ".zera_txn.TRANSACTION_TYPE\022\026\n\016serialized"
  "_txn\030\002 \001(\014\022\020\n\010txn_hash\030\003 \001(\014\"\263\001\n\020SmartCo"
  "ntractTXN\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseT"
  "XN\022\033\n\023smart_contract_name\030\004 \001(\t\022\023\n\013binar"
  "y_code\030\002 \001(\014\022\023\n\013source_code\030\007 \001(\014\022$\n\010lan"
  "guage\030\003 \001(\0162\022.zera_txn.LANGUAGE\022\021\n\tfunct"
  "ions\030\005 \003(\t\")\n\nParameters\022\r\n\005value\030\001 \001(\014\022"
  "\014\n\004type\030\002 \001(\t\"\245\001\n\027SmartContractExecuteTX"
  "N\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\033\n\023sm"
  "art_contract_name\030\002 \001(\t\022\020\n\010instance\030\003 \001("
  "\r\022\020\n\010function\030\004 \001(\t\022(\n\nparameters\030\005 \003(\0132"
  "\024.zera_txn.Parameters\"\227\001\n\033SmartContractI"
  "nstantiateTXN\022\037\n\004base\030\001 \001(\0132\021.zera_txn.B"
  "aseTXN\022\033\n\023smart_contract_name\030\002 \001(\t\022\020\n\010i"
  "nstance\030\003 \001(\r\022(\n\nparameters\030\004 \003(\0132\024.zera"
  "_txn.Parameters\"\225\002\n\tValidator\022\'\n\npublic_"
  "key\030\001 \001(\0132\023.zera_txn.PublicKey\022\014\n\004host\030\002"
  " \001(\t\022\023\n\013client_port\030\003 \001(\t\022\026\n\016validator_p"
  "ort\030\004 \001(\t\022\033\n\023staked_contract_ids\030\005 \003(\t\022\021"
  "\n\tbenchmark\030\006 \001(\004\022-\n\ttimestamp\030\007 \001(\0132\032.g"
  "oogle.protobuf.Timestamp\022\014\n\004lite\030\010 \001(\010\022\016"
  "\n\006online\030\t \001(\010\022\017\n\007version\030\n \001(\r\022\026\n\016last_"
  "heartbeat\030\013 \001(\004\"\302\001\n\025ValidatorRegistratio"
  "n\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022&\n\tva"
  "lidator\030\002 \001(\0132\023.zera_txn.Validator\022\020\n\010re"
  "gister\030\003 \001(\010\0221\n\024generated_public_key\030\004 \001"
  "(\0132\023.zera_txn.PublicKey\022\033\n\023generated_sig"
  "nature\030\005 \001(\014\"V\n\022ValidatorHeartbeat\022\037\n\004ba"
  "se\030\001 \001(\0132\021.zera_txn.BaseTXN\022\016\n\006online\030\002 "
  "\001(\010\022\017\n\007version\030\003 \001(\r\"l\n\026SmartContractPar"
  "ameter\022\r\n\005index\030\001 \001(\r\022%\n\004type\030\002 \001(\0162\027.ze"
  "ra_txn.VARIABLE_TYPE\022\022\n\005value\030\003 \001(\tH\000\210\001\001"
  "B\010\n\006_value\"*\n\005Votes\022!\n\005votes\030\001 \003(\0132\022.zer"
  "a_txn.VotePair\"/\n\010VotePair\022\023\n\013contract_i"
  "d\030\001 \001(\t\022\016\n\006amount\030\002 \001(\t\"C\n\017RequiredVersi"
  "on\022\037\n\004base\030\001 \001(\0132\021.zera_txn.BaseTXN\022\017\n\007v"
  "ersion\030\002 \003(\r\"\373\003\n\016ProposalResult\022\037\n\004base\030"
  "\001 \001(\0132\021.zera_txn.BaseTXN\022\023\n\013contract_id\030"
  "\002 \001(\t\022\023\n\013proposal_id\030\003 \001(\014\022\036\n\021support_cu"
  "r_equiv\030\004 \001(\tH\000\210\001\001\022\036\n\021against_cur_equiv\030"
  "\005 \001(\tH\001\210\001\001\022\030\n\020option_cur_equiv\030\006 \003(\t\022+\n\r"
  "support_votes\030\007 \001(\0132\017.zera_txn.VotesH\002\210\001"
  "\001\022+\n\ragainst_votes\030\010 \001(\0132\017.zera_txn.Vote"
  "sH\003\210\001\001\022%\n\014option_votes\030\t \003(\0132\017.zera_txn."
  "Votes\022\016\n\006passed\030\n \001(\010\022\023\n\013final_stage\030\013 \001"
  "(\010\022\r\n\005stage\030\014 \001(\r\022\023\n\013fast_quorum\030\r \001(\010\022\031"
  "\n\014proposal_cut\030\016 \001(\010H\004\210\001\001B\024\n\022_support_cu"
  "r_equivB\024\n\022_against_cur_equivB\020\n\016_suppor"
  "t_votesB\020\n\016_against_votesB\017\n\r_proposal_c"
  "ut\"\367\002\n\014AllowanceTXN\022\037\n\004base\030\001 \001(\0132\021.zera"
  "_txn.BaseTXN\022\023\n\013contract_id\030\002 \001(\t\022\026\n\016wal"
  "let_address\030\003 \001(\014\022(\n\033allowed_currency_eq"
  "uivalent\030\004 \001(\tH\000\210\001\001\022\033\n\016allowed_amount\030\005 "
  "\001(\tH\001\210\001\001\022\032\n\rperiod_months\030\006 \001(\rH\002\210\001\001\022\033\n\016"
  "period_seconds\030\007 \001(\rH\003\210\001\001\022.\n\nstart_time\030"
  "\t \001(\0132\032.google.protobuf.Timestamp\022\021\n\taut"
  "horize\030\n \001(\010B\036\n\034_allowed_currency_equiva"
  "lentB\021\n\017_allowed_amountB\020\n\016_period_month"
  "sB\021\n\017_period_seconds\"\327\014\n\004TXNS\022$\n\tcoin_tx"
  "ns\030\001 \003(\0132\021.zera_txn.CoinTXN\022$\n\tmint_txns"
  "\030\002 \003(\0132\021.zera_txn.MintTXN\0221\n\016item_mint_t"
  "xns\030\003 \003(\0132\031.zera_txn.ItemizedMintTXN\0223\n\r"
  "contract_txns\030\004 \003(\0132\034.zera_txn.Instrumen"
  "tContract\0222\n\020governance_votes\030\005 \003(\0132\030.ze"
  "ra_txn.GovernanceVote\022:\n\024governance_prop"
  "osals\030\006 \003(\0132\034.zera_txn.GovernanceProposa"
  "l\0223\n\017smart_contracts\030\007 \003(\0132\032.zera_txn.Sm"
  "artContractTXN\022B\n\027smart_contract_execute"
  "s\030\010 \003(\0132!.zera_txn.SmartContractExecuteT"
  "XN\0224\n\017self_cur_equivs\030\t \003(\0132\033.zera_txn.S"
  "elfCurrencyEquiv\022:\n\017auth_cur_equivs\030\n \003("
  "\0132!.zera_txn.AuthorizedCurrencyEquiv\0221\n\016"
  "expense_ratios\030\013 \003(\0132\031.zera_txn.ExpenseR"
  "atioTXN\0224\n\023txn_fees_and_status\030\014 \003(\0132\027.z"
  "era_txn.TXNStatusFees\022\'\n\ntoken_fees\030\r \003("
  "\0132\023.zera_txn.TokenFees\022\"\n\010nft_txns\030\016 \003(\013"
  "2\020.zera_txn.NFTTXN\0229\n\024contract_update_tx"
  "ns\030\017 \003(\0132\033.zera_txn.ContractUpdateTXN\022D\n"
  "\033validator_registration_txns\030\020 \003(\0132\037.zer"
  "a_txn.ValidatorRegistration\022>\n\030validator"
  "_heartbeat_txns\030\021 \003(\0132\034.zera_txn.Validat"
  "orHeartbeat\0226\n\024proposal_result_txns\030\022 \003("
  "\0132\030.zera_txn.ProposalResult\022\?\n\031expense_r"
  "atio_result_txns\030\023 \003(\0132\034.zera_txn.Expens"
  "eRatioResult\0220\n\017foundation_txns\030\024 \003(\0132\027."
  "zera_txn.FoundationTXN\0225\n\025delegated_voti"
  "ng_txns\030\025 \003(\0132\026.zera_txn.DelegatedTXN\022&\n"
  "\nquash_txns\030\026 \003(\0132\022.zera_txn.QuashTXN\0221\n"
  "\020fast_quorum_txns\030\027 \003(\0132\027.zera_txn.FastQ"
  "uorumTXN\022,\n\rquash_results\030\030 \003(\0132\025.zera_t"
  "xn.QuashResult\022(\n\013revoke_txns\030\031 \003(\0132\023.ze"
  "ra_txn.RevokeTXN\0220\n\017compliance_txns\030\032 \003("
  "\0132\027.zera_txn.ComplianceTXN\022+\n\rburn_sbt_t"
  "xns\030\033 \003(\0132\024.zera_txn.BurnSBTTXN\022N\n\037smart"
  "_contract_instantiate_txns\030\034 \003(\0132%.zera_"
  "txn.SmartContractInstantiateTXN\022<\n\024requi"
  "red_version_txn\030\035 \001(\0132\031.zera_txn.Require"
  "dVersionH\000\210\001\001\022.\n\016allowance_txns\030\036 \003(\0132\026."
  "zera_txn.AllowanceTXNB\027\n\025_required_versi"
  "on_txn\",\n\005Token\022\023\n\013contract_id\030\001 \001(\t\022\016\n\006"
  "amount\030\002 \001(\t\"=\n\tTokenFees\022\017\n\007address\030\001 \001"
  "(\014\022\037\n\006tokens\030\002 \003(\0132\017.zera_txn.Token\">\n\rD"
  "elegatedData\022\017\n\007address\030\001 \001(\014\022\034\n\003fee\030\002 \001"
  "(\0132\017.zera_txn.Token\"\214\004\n\rTXNStatusFees\022\020\n"
  "\010txn_hash\030\001 \001(\014\022$\n\006status\030\002 \001(\0162\024.zera_t"
  "xn.TXN_STATUS\022\021\n\tbase_fees\030\003 \001(\t\022\030\n\020base"
  "_contract_id\030\004 \001(\t\022\032\n\rcontract_fees\030\005 \001("
  "\tH\000\210\001\001\022!\n\024contract_contract_id\030\006 \001(\tH\001\210\001"
  "\001\022\026\n\016smart_contract\030\t \001(\010\022\035\n\025smart_contr"
  "act_result\030\n \003(\014\022\014\n\004misc\030\013 \003(\t\022!\n\024native"
  "_function_fees\030\014 \001(\tH\002\210\001\001\022\020\n\003gas\030\r \001(\004H\003"
  "\210\001\001\022/\n\016delegated_data\030\016 \003(\0132\027.zera_txn.D"
  "elegatedData\022\032\n\rinterface_fee\030\017 \001(\tH\004\210\001\001"
  "\022\035\n\020interface_fee_id\030\020 \001(\tH\005\210\001\001B\020\n\016_cont"
  "ract_feesB\027\n\025_contract_contract_idB\027\n\025_n"
  "ative_function_feesB\006\n\004_gasB\020\n\016_interfac"
  "e_feeB\023\n\021_interface_fee_id\"L\n\020ProposalCo"
  "ntract\022\023\n\013contract_id\030\001 \001(\t\022\024\n\014proposal_"
  "ids\030\002 \003(\014\022\r\n\005stage\030\003 \001(\r\"\264\014\n\nTXNWrapper\022"
  "%\n\010coin_txn\030\001 \001(\0132\021.zera_txn.CoinTXNH\000\022%"
  "\n\010mint_txn\030\002 \001(\0132\021.zera_txn.MintTXNH\000\0222\n"
  "\ritem_mint_txn\030\003 \001(\0132\031.zera_txn.Itemized"
  "MintTXNH\000\0224\n\014contract_txn\030\004 \001(\0132\034.zera_t"
  "xn.InstrumentContractH\000\0223\n\017governance_vo"
  "te\030\005 \001(\0132\030.zera_txn.GovernanceVoteH\000\022;\n\023"
  "governance_proposal\030\006 \001(\0132\034.zera_txn.Gov"
  "ernanceProposalH\000\0224\n\016smart_contract\030\007 \001("
  "\0132\032.zera_txn.SmartContractTXNH\000\022C\n\026smart"
  "_contract_execute\030\010 \001(\0132!.zera_txn.Smart"
  "ContractExecuteTXNH\000\0226\n\017self_cur_equivs\030"
  "\t \001(\0132\033.zera_txn.SelfCurrencyEquivH\000\022<\n\017"
  "auth_cur_equivs\030\n \001(\0132!.zera_txn.Authori"
  "zedCurrencyEquivH\000\0223\n\016expense_ratios\030\013 \001"
  "(\0132\031.zera_txn.ExpenseRatioTXNH\000\022#\n\007nft_t"
  "xn\030\014 \001(\0132\020.zera_txn.NFTTXNH\000\022:\n\023contract"
  "_update_txn\030\r \001(\0132\033.zera_txn.ContractUpd"
  "ateTXNH\000\022E\n\032validator_registration_txn\030\016"
  " \001(\0132\037.zera_txn.ValidatorRegistrationH\000\022"
  "\?\n\027validator_heartbeat_txn\030\017 \001(\0132\034.zera_"
  "txn.ValidatorHeartbeatH\000\0221\n\016foundation_t"
  "xn\030\020 \001(\0132\027.zera_txn.FoundationTXNH\000\0226\n\024d"
  "elegated_voting_txn\030\021 \001(\0132\026.zera_txn.Del"
  "egatedTXNH\000\022\'\n\tquash_txn\030\022 \001(\0132\022.zera_tx"
  "n.QuashTXNH\000\0222\n\017fast_quorum_txn\030\023 \001(\0132\027."
  "zera_txn.FastQuorumTXNH\000\022)\n\nrevoke_txn\030\024"
  " \001(\0132\023.zera_txn.RevokeTXNH\000\0221\n\016complianc"
  "e_txn\030\025 \001(\0132\027.zera_txn.ComplianceTXNH\000\022\035"
  "\n\023proposal_result_txn\030\026 \001(\010H\000\022,\n\014burn_sb"
  "t_txn\030\027 \001(\0132\024.zera_txn.BurnSBTTXNH\000\0229\n\024r"
  "equired_version_txn\030\030 \001(\0132\031.zera_txn.Req"
  "uiredVersionH\000\022O\n\036smart_contract_instant"
  "iate_txn\030\031 \001(\0132%.zera_txn.SmartContractI"
  "nstantiateTXNH\000\022/\n\rallowance_txn\030\036 \001(\0132\026"
  ".zera_txn.AllowanceTXNH\000\022,\n\010txn_type\030\032 \001"
  "(\0162\032.zera_txn.TRANSACTION_TYPE\022\024\n\014propos"
  "al_ids\030\033 \003(\014\0226\n\022proposal_contracts\030\034 \003(\013"
  "2\032.zera_txn.ProposalContract\022\037\n\022smart_co"
  "ntract_txn\030\035 \001(\010H\001\210\001\001B\t\n\007payloadB\025\n\023_sma"
  "rt_contract_txn*\274\010\n\nTXN_STATUS\022\006\n\002OK\020\000\022\026"
  "\n\022INVALID_PARAMETERS\020\001\022\027\n\023INSUFFICIENT_A"
  "MOUNT\020\002\022\036\n\032INSUFFICIENT_CONTRACT_FEES\020\003\022"
  " \n\034AUTHORIZED_INSUFFICIENT_FEES\020\004\022)\n%AUT"
  "HORIZED_INSUFFICIENT_CONTRACT_FEES\020\005\022\024\n\020"
  "INVALID_CONTRACT\020\006\022\024\n\020INVALID_AUTH_KEY\020\007"
  "\022\032\n\026INVALID_WALLET_ADDRESS\020\010\022\035\n\031INVALID_"
  "MULTI_TRANSACTION\020\t\022\037\n\033INVALID_CONTRACT_"
  "PARAMETERS\020\n\022\033\n\027INVALID_CONTRACT_FEE_ID\020"
  "\013\022\023\n\017INVALID_UINT256\020\014\022\027\n\023EXCEEDED_MAX_S"
  "UPPLY\020\r\022\017\n\013INVALID_NFT\020\016\022\021\n\rNFT_OWNERSHI"
  "P\020\017\022\025\n\021VALIDATOR_ADDRESS\020\020\022\036\n\032CONTRACT_H"
  "AS_NO_GOVERNANCE\020\021\022\027\n\023INVALID_BASE_FEE_I"
  "D\020\022\022\033\n\027EXPENSE_RATIO_DUPLICATE\020\023\022\025\n\021REST"
  "RICTED_SYMBOL\020\024\022\027\n\023INVALID_PROPOSAL_ID\020\025"
  "\022!\n\035PROPOSAL_NOT_IN_VOTING_PERIOD\020\026\022\032\n\026T"
  "IME_DELAY_INITIALIZED\020\027\022\024\n\020INVALID_TXN_H"
  "ASH\020\030\022\024\n\020INVALID_TXN_TYPE\020\031\022\026\n\022TIME_DELA"
  "Y_EXPIRED\020\032\022\026\n\022DUPLICATE_AUTH_KEY\020\033\022\026\n\022K"
  "EY_WEIGHT_TOO_LOW\020\034\022\020\n\014INVALID_ITEM\020\035\022\024\n"
  "\020INVALID_PROPOSAL\020\036\022&\n\"PROPOSAL_DOES_NOT"
  "_BELONG_TO_SENDER\020\037\022\023\n\017INVALID_ADDRESS\020 "
  "\022\033\n\027NO_CHANGE_TO_COMPLIANCE\020!\022\033\n\027COMPLIA"
  "NCE_CHECK_FAILED\020\"\022\025\n\021INVALID_SAFE_SEND\020"
  "#\022\024\n\020INVALID_TXN_DATA\020$\022\"\n\036DUPLICATE_SMA"
  "RT_CONTRACT_NONCE\020%\022\032\n\026INVALID_SMART_CON"
  "TRACT\020&\022\016\n\nFAULTY_TXN\020\'\022\016\n\nOUT_OF_GAS\020(\022"
  "\025\n\021INVALID_ALLOWANCE\020)*\201\005\n\020TRANSACTION_T"
  "YPE\022\r\n\tCOIN_TYPE\020\000\022\023\n\017FOUNDATION_TYPE\020\002\022"
  "\r\n\tMINT_TYPE\020\001\022\022\n\016ITEM_MINT_TYPE\020\003\022\025\n\021CO"
  "NTRACT_TXN_TYPE\020\004\022\r\n\tVOTE_TYPE\020\005\022\021\n\rPROP"
  "OSAL_TYPE\020\006\022\027\n\023SMART_CONTRACT_TYPE\020\007\022\037\n\033"
  "SMART_CONTRACT_EXECUTE_TYPE\020\010\022\034\n\030SELF_CU"
  "RRENCY_EQUIV_TYPE\020\t\022\"\n\036AUTHORIZED_CURREN"
  "CY_EQUIV_TYPE\020\n\022\026\n\022EXPENSE_RATIO_TYPE\020\013\022"
  "\014\n\010NFT_TYPE\020\014\022\030\n\024UPDATE_CONTRACT_TYPE\020\r\022"
  "\037\n\033VALIDATOR_REGISTRATION_TYPE\020\016\022\034\n\030VALI"
  "DATOR_HEARTBEAT_TYPE\020\017\022\030\n\024PROPOSAL_RESUL"
  "T_TYPE\020\020\022\031\n\025DELEGATED_VOTING_TYPE\020\021\022\017\n\013R"
  "EVOKE_TYPE\020\022\022\016\n\nQUASH_TYPE\020\023\022\024\n\020FAST_QUO"
  "RUM_TYPE\020\024\022\023\n\017COMPLIANCE_TYPE\020\025\022\021\n\rSBT_B"
  "URN_TYPE\020\026\022\024\n\020REQUIRED_VERSION\020\027\022#\n\037SMAR"
  "T_CONTRACT_INSTANTIATE_TYPE\020\030\022\017\n\013UKNOWN_"
  "TYPE\020\031\022\022\n\016ALLOWANCE_TYPE\020\032*4\n\010LANGUAGE\022\014"
  "\n\010COMPILED\020\000\022\n\n\006PYTHON\020\001\022\016\n\nJAVASCRIPT\020\002"
  "*\'\n\017PROPOSAL_PERIOD\022\010\n\004DAYS\020\000\022\n\n\006MONTHS\020"
  "\001*R\n\rVARIABLE_TYPE\022\007\n\003INT\020\000\022\t\n\005SHORT\020\001\022\010"
  "\n\004LONG\020\002\022\r\n\tLONG_LONG\020\003\022\010\n\004BOOL\020\004\022\n\n\006STR"
  "ING\020\005*L\n\021CONTRACT_FEE_TYPE\022\t\n\005FIXED\020\000\022\022\n"
  "\016CUR_EQUIVALENT\020\001\022\016\n\nPERCENTAGE\020\002\022\010\n\004NON"
  "E\020\003*Q\n\017GOVERNANCE_TYPE\022\n\n\006STAGED\020\000\022\t\n\005CY"
  "CLE\020\001\022\r\n\tSTAGGERED\020\002\022\014\n\010ADAPTIVE\020\003\022\n\n\006RE"
  "MOVE\020\004*,\n\rCONTRACT_TYPE\022\t\n\005TOKEN\020\000\022\007\n\003NF"
  "T\020\001\022\007\n\003SBT\020\0022\241\013\n\nTXNService\0221\n\004Coin\022\021.ze"
  "ra_txn.CoinTXN\032\026.google.protobuf.Empty\0221"
  "\n\004Mint\022\021.zera_txn.MintTXN\032\026.google.proto"
  "buf.Empty\022=\n\010ItemMint\022\031.zera_txn.Itemize"
  "dMintTXN\032\026.google.protobuf.Empty\022@\n\010Cont"
  "ract\022\034.zera_txn.InstrumentContract\032\026.goo"
  "gle.protobuf.Empty\022F\n\016GovernProposal\022\034.z"
  "era_txn.GovernanceProposal\032\026.google.prot"
  "obuf.Empty\022>\n\nGovernVote\022\030.zera_txn.Gove"
  "rnanceVote\032\026.google.protobuf.Empty\022C\n\rSm"
  "artContract\022\032.zera_txn.SmartContractTXN\032"
  "\026.google.protobuf.Empty\022Q\n\024SmartContract"
  "Execute\022!.zera_txn.SmartContractExecuteT"
  "XN\032\026.google.protobuf.Empty\022Y\n\030SmartContr"
  "actInstantiate\022%.zera_txn.SmartContractI"
  "nstantiateTXN\032\026.google.protobuf.Empty\022D\n"
  "\rCurrencyEquiv\022\033.zera_txn.SelfCurrencyEq"
  "uiv\032\026.google.protobuf.Empty\022N\n\021AuthCurre"
  "ncyEquiv\022!.zera_txn.AuthorizedCurrencyEq"
  "uiv\032\026.google.protobuf.Empty\022A\n\014ExpenseRa"
  "tio\022\031.zera_txn.ExpenseRatioTXN\032\026.google."
  "protobuf.Empty\022/\n\003NFT\022\020.zera_txn.NFTTXN\032"
  "\026.google.protobuf.Empty\022E\n\016ContractUpdat"
  "e\022\033.zera_txn.ContractUpdateTXN\032\026.google."
  "protobuf.Empty\022=\n\nFoundation\022\027.zera_txn."
  "FoundationTXN\032\026.google.protobuf.Empty\022A\n"
  "\017DelegatedVoting\022\026.zera_txn.DelegatedTXN"
  "\032\026.google.protobuf.Empty\0223\n\005Quash\022\022.zera"
  "_txn.QuashTXN\032\026.google.protobuf.Empty\022=\n"
  "\nFastQuorum\022\027.zera_txn.FastQuorumTXN\032\026.g"
  "oogle.protobuf.Empty\0225\n\006Revoke\022\023.zera_tx"
  "n.RevokeTXN\032\026.google.protobuf.Empty\022=\n\nC"
  "ompliance\022\027.zera_txn.ComplianceTXN\032\026.goo"
  "gle.protobuf.Empty\0227\n\007BurnSBT\022\024.zera_txn"
  ".BurnSBTTXN\032\026.google.protobuf.Empty\022;\n\tA"
  "llowance\022\026.zera_txn.AllowanceTXN\032\026.googl"
  "e.protobuf.EmptyB\002H\001b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_txn_2eproto_deps[2] = {
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::_pbi::once_flag descriptor_table_txn_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_txn_2eproto = {
    false, false, 18188, descriptor_table_protodef_txn_2eproto,
    "txn.proto",
    &descriptor_table_txn_2eproto_once, descriptor_table_txn_2eproto_deps, 2, 69,
    schemas, file_default_instances, TableStruct_txn_2eproto::offsets,
    file_level_metadata_txn_2eproto, file_level_enum_descriptors_txn_2eproto,
    file_level_service_descriptors_txn_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_txn_2eproto_getter() {
  return &descriptor_table_txn_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_txn_2eproto(&descriptor_table_txn_2eproto);
namespace zera_txn {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TXN_STATUS_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_txn_2eproto);
  return file_level_enum_descriptors_txn_2eproto[0];
}
bool TXN_STATUS_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TRANSACTION_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_txn_2eproto);
  return file_level_enum_descriptors_txn_2eproto[1];
}
bool TRANSACTION_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LANGUAGE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_txn_2eproto);
  return file_level_enum_descriptors_txn_2eproto[2];
}
bool LANGUAGE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PROPOSAL_PERIOD_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_txn_2eproto);
  return file_level_enum_descriptors_txn_2eproto[3];
}
bool PROPOSAL_PERIOD_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VARIABLE_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_txn_2eproto);
  return file_level_enum_descriptors_txn_2eproto[4];
}
bool VARIABLE_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CONTRACT_FEE_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_txn_2eproto);
  return file_level_enum_descriptors_txn_2eproto[5];
}
bool CONTRACT_FEE_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GOVERNANCE_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_txn_2eproto);
  return file_level_enum_descriptors_txn_2eproto[6];
}
bool GOVERNANCE_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CONTRACT_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_txn_2eproto);
  return file_level_enum_descriptors_txn_2eproto[7];
}
bool CONTRACT_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class DelegateContract::_Internal {
 public:
};

DelegateContract::DelegateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.DelegateContract)
}
DelegateContract::DelegateContract(const DelegateContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DelegateContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.priority_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.priority_ = from._impl_.priority_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.DelegateContract)
}

inline void DelegateContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.priority_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DelegateContract::~DelegateContract() {
  // @@protoc_insertion_point(destructor:zera_txn.DelegateContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelegateContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
}

void DelegateContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DelegateContract::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.DelegateContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.priority_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DelegateContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 priority = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.DelegateContract.contract_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelegateContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.DelegateContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 priority = 1;
  if (this->_internal_priority() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_priority(), target);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.DelegateContract.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.DelegateContract)
  return target;
}

size_t DelegateContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.DelegateContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // int32 priority = 1;
  if (this->_internal_priority() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_priority());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DelegateContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DelegateContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DelegateContract::GetClassData() const { return &_class_data_; }


void DelegateContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DelegateContract*>(&to_msg);
  auto& from = static_cast<const DelegateContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.DelegateContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (from._internal_priority() != 0) {
    _this->_internal_set_priority(from._internal_priority());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DelegateContract::CopyFrom(const DelegateContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.DelegateContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelegateContract::IsInitialized() const {
  return true;
}

void DelegateContract::InternalSwap(DelegateContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  swap(_impl_.priority_, other->_impl_.priority_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DelegateContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[0]);
}

// ===================================================================

class DelegatedTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const DelegatedTXN* msg);
};

const ::zera_txn::BaseTXN&
DelegatedTXN::_Internal::base(const DelegatedTXN* msg) {
  return *msg->_impl_.base_;
}
DelegatedTXN::DelegatedTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.DelegatedTXN)
}
DelegatedTXN::DelegatedTXN(const DelegatedTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DelegatedTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.delegate_votes_){from._impl_.delegate_votes_}
    , decltype(_impl_.delegate_fees_){from._impl_.delegate_fees_}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.DelegatedTXN)
}

inline void DelegatedTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.delegate_votes_){arena}
    , decltype(_impl_.delegate_fees_){arena}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DelegatedTXN::~DelegatedTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.DelegatedTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelegatedTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.delegate_votes_.~RepeatedPtrField();
  _impl_.delegate_fees_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void DelegatedTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DelegatedTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.DelegatedTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.delegate_votes_.Clear();
  _impl_.delegate_fees_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DelegatedTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.DelegateVote delegate_votes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_delegate_votes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.DelegateFees delegate_fees = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_delegate_fees(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelegatedTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.DelegatedTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.DelegateVote delegate_votes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_delegate_votes_size()); i < n; i++) {
    const auto& repfield = this->_internal_delegate_votes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.DelegateFees delegate_fees = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_delegate_fees_size()); i < n; i++) {
    const auto& repfield = this->_internal_delegate_fees(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.DelegatedTXN)
  return target;
}

size_t DelegatedTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.DelegatedTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.DelegateVote delegate_votes = 2;
  total_size += 1UL * this->_internal_delegate_votes_size();
  for (const auto& msg : this->_impl_.delegate_votes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.DelegateFees delegate_fees = 3;
  total_size += 1UL * this->_internal_delegate_fees_size();
  for (const auto& msg : this->_impl_.delegate_fees_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DelegatedTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DelegatedTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DelegatedTXN::GetClassData() const { return &_class_data_; }


void DelegatedTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DelegatedTXN*>(&to_msg);
  auto& from = static_cast<const DelegatedTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.DelegatedTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.delegate_votes_.MergeFrom(from._impl_.delegate_votes_);
  _this->_impl_.delegate_fees_.MergeFrom(from._impl_.delegate_fees_);
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DelegatedTXN::CopyFrom(const DelegatedTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.DelegatedTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelegatedTXN::IsInitialized() const {
  return true;
}

void DelegatedTXN::InternalSwap(DelegatedTXN* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.delegate_votes_.InternalSwap(&other->_impl_.delegate_votes_);
  _impl_.delegate_fees_.InternalSwap(&other->_impl_.delegate_fees_);
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DelegatedTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[1]);
}

// ===================================================================

class DelegateVote::_Internal {
 public:
};

DelegateVote::DelegateVote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.DelegateVote)
}
DelegateVote::DelegateVote(const DelegateVote& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DelegateVote* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contracts_){from._impl_.contracts_}
    , decltype(_impl_.address_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.DelegateVote)
}

inline void DelegateVote::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contracts_){arena}
    , decltype(_impl_.address_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DelegateVote::~DelegateVote() {
  // @@protoc_insertion_point(destructor:zera_txn.DelegateVote)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelegateVote::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contracts_.~RepeatedPtrField();
  _impl_.address_.Destroy();
}

void DelegateVote::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DelegateVote::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.DelegateVote)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contracts_.Clear();
  _impl_.address_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DelegateVote::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.DelegateContract contracts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contracts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelegateVote::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.DelegateVote)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_address(), target);
  }

  // repeated .zera_txn.DelegateContract contracts = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contracts_size()); i < n; i++) {
    const auto& repfield = this->_internal_contracts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.DelegateVote)
  return target;
}

size_t DelegateVote::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.DelegateVote)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.DelegateContract contracts = 2;
  total_size += 1UL * this->_internal_contracts_size();
  for (const auto& msg : this->_impl_.contracts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DelegateVote::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DelegateVote::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DelegateVote::GetClassData() const { return &_class_data_; }


void DelegateVote::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DelegateVote*>(&to_msg);
  auto& from = static_cast<const DelegateVote&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.DelegateVote)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.contracts_.MergeFrom(from._impl_.contracts_);
  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DelegateVote::CopyFrom(const DelegateVote& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.DelegateVote)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelegateVote::IsInitialized() const {
  return true;
}

void DelegateVote::InternalSwap(DelegateVote* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.contracts_.InternalSwap(&other->_impl_.contracts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DelegateVote::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[2]);
}

// ===================================================================

class DelegateFees::_Internal {
 public:
};

DelegateFees::DelegateFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.DelegateFees)
}
DelegateFees::DelegateFees(const DelegateFees& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DelegateFees* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.auth_amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.auth_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_auth_amount().empty()) {
    _this->_impl_.auth_amount_.Set(from._internal_auth_amount(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.DelegateFees)
}

inline void DelegateFees::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.auth_amount_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DelegateFees::~DelegateFees() {
  // @@protoc_insertion_point(destructor:zera_txn.DelegateFees)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelegateFees::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.auth_amount_.Destroy();
}

void DelegateFees::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DelegateFees::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.DelegateFees)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.auth_amount_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DelegateFees::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.DelegateFees.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string auth_amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_auth_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.DelegateFees.auth_amount"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelegateFees::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.DelegateFees)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.DelegateFees.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // string auth_amount = 2;
  if (!this->_internal_auth_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_auth_amount().data(), static_cast<int>(this->_internal_auth_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.DelegateFees.auth_amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_auth_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.DelegateFees)
  return target;
}

size_t DelegateFees::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.DelegateFees)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string auth_amount = 2;
  if (!this->_internal_auth_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_auth_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DelegateFees::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DelegateFees::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DelegateFees::GetClassData() const { return &_class_data_; }


void DelegateFees::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DelegateFees*>(&to_msg);
  auto& from = static_cast<const DelegateFees&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.DelegateFees)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_auth_amount().empty()) {
    _this->_internal_set_auth_amount(from._internal_auth_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DelegateFees::CopyFrom(const DelegateFees& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.DelegateFees)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelegateFees::IsInitialized() const {
  return true;
}

void DelegateFees::InternalSwap(DelegateFees* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_amount_, lhs_arena,
      &other->_impl_.auth_amount_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DelegateFees::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[3]);
}

// ===================================================================

class Compliance::_Internal {
 public:
};

Compliance::Compliance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Compliance)
}
Compliance::Compliance(const Compliance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Compliance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.compliance_level_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.compliance_level_ = from._impl_.compliance_level_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.Compliance)
}

inline void Compliance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.compliance_level_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Compliance::~Compliance() {
  // @@protoc_insertion_point(destructor:zera_txn.Compliance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Compliance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
}

void Compliance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Compliance::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Compliance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.compliance_level_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Compliance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Compliance.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // uint32 compliance_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.compliance_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Compliance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Compliance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Compliance.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // uint32 compliance_level = 2;
  if (this->_internal_compliance_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_compliance_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Compliance)
  return target;
}

size_t Compliance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Compliance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // uint32 compliance_level = 2;
  if (this->_internal_compliance_level() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_compliance_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Compliance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Compliance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Compliance::GetClassData() const { return &_class_data_; }


void Compliance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Compliance*>(&to_msg);
  auto& from = static_cast<const Compliance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Compliance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (from._internal_compliance_level() != 0) {
    _this->_internal_set_compliance_level(from._internal_compliance_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Compliance::CopyFrom(const Compliance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Compliance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Compliance::IsInitialized() const {
  return true;
}

void Compliance::InternalSwap(Compliance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  swap(_impl_.compliance_level_, other->_impl_.compliance_level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Compliance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[4]);
}

// ===================================================================

class TokenCompliance::_Internal {
 public:
};

TokenCompliance::TokenCompliance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.TokenCompliance)
}
TokenCompliance::TokenCompliance(const TokenCompliance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenCompliance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.compliance_){from._impl_.compliance_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_txn.TokenCompliance)
}

inline void TokenCompliance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.compliance_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TokenCompliance::~TokenCompliance() {
  // @@protoc_insertion_point(destructor:zera_txn.TokenCompliance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenCompliance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.compliance_.~RepeatedPtrField();
}

void TokenCompliance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenCompliance::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.TokenCompliance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.compliance_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenCompliance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .zera_txn.Compliance compliance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_compliance(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenCompliance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.TokenCompliance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .zera_txn.Compliance compliance = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_compliance_size()); i < n; i++) {
    const auto& repfield = this->_internal_compliance(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.TokenCompliance)
  return target;
}

size_t TokenCompliance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.TokenCompliance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.Compliance compliance = 1;
  total_size += 1UL * this->_internal_compliance_size();
  for (const auto& msg : this->_impl_.compliance_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenCompliance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenCompliance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenCompliance::GetClassData() const { return &_class_data_; }


void TokenCompliance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenCompliance*>(&to_msg);
  auto& from = static_cast<const TokenCompliance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.TokenCompliance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.compliance_.MergeFrom(from._impl_.compliance_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenCompliance::CopyFrom(const TokenCompliance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.TokenCompliance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenCompliance::IsInitialized() const {
  return true;
}

void TokenCompliance::InternalSwap(TokenCompliance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.compliance_.InternalSwap(&other->_impl_.compliance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenCompliance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[5]);
}

// ===================================================================

class ExpenseRatio::_Internal {
 public:
};

ExpenseRatio::ExpenseRatio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ExpenseRatio)
}
ExpenseRatio::ExpenseRatio(const ExpenseRatio& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpenseRatio* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.day_){}
    , decltype(_impl_.month_){}
    , decltype(_impl_.percent_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.day_, &from._impl_.day_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.percent_) -
    reinterpret_cast<char*>(&_impl_.day_)) + sizeof(_impl_.percent_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.ExpenseRatio)
}

inline void ExpenseRatio::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.day_){0u}
    , decltype(_impl_.month_){0u}
    , decltype(_impl_.percent_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ExpenseRatio::~ExpenseRatio() {
  // @@protoc_insertion_point(destructor:zera_txn.ExpenseRatio)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpenseRatio::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExpenseRatio::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpenseRatio::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ExpenseRatio)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.day_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.percent_) -
      reinterpret_cast<char*>(&_impl_.day_)) + sizeof(_impl_.percent_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpenseRatio::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 day = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 month = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 percent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.percent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpenseRatio::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ExpenseRatio)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 day = 1;
  if (this->_internal_day() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_day(), target);
  }

  // uint32 month = 2;
  if (this->_internal_month() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_month(), target);
  }

  // uint32 percent = 3;
  if (this->_internal_percent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_percent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ExpenseRatio)
  return target;
}

size_t ExpenseRatio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ExpenseRatio)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 day = 1;
  if (this->_internal_day() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_day());
  }

  // uint32 month = 2;
  if (this->_internal_month() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_month());
  }

  // uint32 percent = 3;
  if (this->_internal_percent() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_percent());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpenseRatio::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpenseRatio::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpenseRatio::GetClassData() const { return &_class_data_; }


void ExpenseRatio::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpenseRatio*>(&to_msg);
  auto& from = static_cast<const ExpenseRatio&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ExpenseRatio)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_day() != 0) {
    _this->_internal_set_day(from._internal_day());
  }
  if (from._internal_month() != 0) {
    _this->_internal_set_month(from._internal_month());
  }
  if (from._internal_percent() != 0) {
    _this->_internal_set_percent(from._internal_percent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpenseRatio::CopyFrom(const ExpenseRatio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ExpenseRatio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpenseRatio::IsInitialized() const {
  return true;
}

void ExpenseRatio::InternalSwap(ExpenseRatio* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExpenseRatio, _impl_.percent_)
      + sizeof(ExpenseRatio::_impl_.percent_)
      - PROTOBUF_FIELD_OFFSET(ExpenseRatio, _impl_.day_)>(
          reinterpret_cast<char*>(&_impl_.day_),
          reinterpret_cast<char*>(&other->_impl_.day_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpenseRatio::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[6]);
}

// ===================================================================

class KeyValuePair::_Internal {
 public:
};

KeyValuePair::KeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.KeyValuePair)
}
KeyValuePair::KeyValuePair(const KeyValuePair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyValuePair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.KeyValuePair)
}

inline void KeyValuePair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyValuePair::~KeyValuePair() {
  // @@protoc_insertion_point(destructor:zera_txn.KeyValuePair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyValuePair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
}

void KeyValuePair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyValuePair::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.KeyValuePair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyValuePair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.KeyValuePair.key"));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.KeyValuePair.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyValuePair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.KeyValuePair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.KeyValuePair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.KeyValuePair.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.KeyValuePair)
  return target;
}

size_t KeyValuePair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.KeyValuePair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyValuePair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyValuePair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyValuePair::GetClassData() const { return &_class_data_; }


void KeyValuePair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyValuePair*>(&to_msg);
  auto& from = static_cast<const KeyValuePair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.KeyValuePair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyValuePair::CopyFrom(const KeyValuePair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.KeyValuePair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyValuePair::IsInitialized() const {
  return true;
}

void KeyValuePair::InternalSwap(KeyValuePair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyValuePair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[7]);
}

// ===================================================================

class ByteMultiplier::_Internal {
 public:
};

ByteMultiplier::ByteMultiplier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ByteMultiplier)
}
ByteMultiplier::ByteMultiplier(const ByteMultiplier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ByteMultiplier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.multiplier_){}
    , decltype(_impl_.txn_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.multiplier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_multiplier().empty()) {
    _this->_impl_.multiplier_.Set(from._internal_multiplier(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.txn_type_ = from._impl_.txn_type_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.ByteMultiplier)
}

inline void ByteMultiplier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.multiplier_){}
    , decltype(_impl_.txn_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.multiplier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ByteMultiplier::~ByteMultiplier() {
  // @@protoc_insertion_point(destructor:zera_txn.ByteMultiplier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ByteMultiplier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.multiplier_.Destroy();
}

void ByteMultiplier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ByteMultiplier::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ByteMultiplier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.multiplier_.ClearToEmpty();
  _impl_.txn_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ByteMultiplier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.TRANSACTION_TYPE txn_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_txn_type(static_cast<::zera_txn::TRANSACTION_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // string multiplier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_multiplier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ByteMultiplier.multiplier"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ByteMultiplier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ByteMultiplier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.TRANSACTION_TYPE txn_type = 1;
  if (this->_internal_txn_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_txn_type(), target);
  }

  // string multiplier = 2;
  if (!this->_internal_multiplier().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_multiplier().data(), static_cast<int>(this->_internal_multiplier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ByteMultiplier.multiplier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_multiplier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ByteMultiplier)
  return target;
}

size_t ByteMultiplier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ByteMultiplier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string multiplier = 2;
  if (!this->_internal_multiplier().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_multiplier());
  }

  // .zera_txn.TRANSACTION_TYPE txn_type = 1;
  if (this->_internal_txn_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_txn_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ByteMultiplier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ByteMultiplier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ByteMultiplier::GetClassData() const { return &_class_data_; }


void ByteMultiplier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ByteMultiplier*>(&to_msg);
  auto& from = static_cast<const ByteMultiplier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ByteMultiplier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_multiplier().empty()) {
    _this->_internal_set_multiplier(from._internal_multiplier());
  }
  if (from._internal_txn_type() != 0) {
    _this->_internal_set_txn_type(from._internal_txn_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ByteMultiplier::CopyFrom(const ByteMultiplier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ByteMultiplier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ByteMultiplier::IsInitialized() const {
  return true;
}

void ByteMultiplier::InternalSwap(ByteMultiplier* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.multiplier_, lhs_arena,
      &other->_impl_.multiplier_, rhs_arena
  );
  swap(_impl_.txn_type_, other->_impl_.txn_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ByteMultiplier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[8]);
}

// ===================================================================

class FoundationTXN::_Internal {
 public:
  using HasBits = decltype(std::declval<FoundationTXN>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const FoundationTXN* msg);
  static void set_has_fee_iso4217(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::zera_txn::BaseTXN&
FoundationTXN::_Internal::base(const FoundationTXN* msg) {
  return *msg->_impl_.base_;
}
FoundationTXN::FoundationTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.FoundationTXN)
}
FoundationTXN::FoundationTXN(const FoundationTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FoundationTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.restricted_symbols_){from._impl_.restricted_symbols_}
    , decltype(_impl_.byte_multiplier_){from._impl_.byte_multiplier_}
    , decltype(_impl_.fee_iso4217_){}
    , decltype(_impl_.base_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fee_iso4217_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_iso4217_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fee_iso4217()) {
    _this->_impl_.fee_iso4217_.Set(from._internal_fee_iso4217(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.FoundationTXN)
}

inline void FoundationTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.restricted_symbols_){arena}
    , decltype(_impl_.byte_multiplier_){arena}
    , decltype(_impl_.fee_iso4217_){}
    , decltype(_impl_.base_){nullptr}
  };
  _impl_.fee_iso4217_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_iso4217_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FoundationTXN::~FoundationTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.FoundationTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FoundationTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.restricted_symbols_.~RepeatedPtrField();
  _impl_.byte_multiplier_.~RepeatedPtrField();
  _impl_.fee_iso4217_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void FoundationTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FoundationTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.FoundationTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.restricted_symbols_.Clear();
  _impl_.byte_multiplier_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.fee_iso4217_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FoundationTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string restricted_symbols = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_restricted_symbols();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.FoundationTXN.restricted_symbols"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ByteMultiplier byte_multiplier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_byte_multiplier(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string fee_ISO4217 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fee_iso4217();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.FoundationTXN.fee_ISO4217"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FoundationTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.FoundationTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // repeated string restricted_symbols = 2;
  for (int i = 0, n = this->_internal_restricted_symbols_size(); i < n; i++) {
    const auto& s = this->_internal_restricted_symbols(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.FoundationTXN.restricted_symbols");
    target = stream->WriteString(2, s, target);
  }

  // repeated .zera_txn.ByteMultiplier byte_multiplier = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_byte_multiplier_size()); i < n; i++) {
    const auto& repfield = this->_internal_byte_multiplier(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string fee_ISO4217 = 4;
  if (_internal_has_fee_iso4217()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fee_iso4217().data(), static_cast<int>(this->_internal_fee_iso4217().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.FoundationTXN.fee_ISO4217");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_fee_iso4217(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.FoundationTXN)
  return target;
}

size_t FoundationTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.FoundationTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string restricted_symbols = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.restricted_symbols_.size());
  for (int i = 0, n = _impl_.restricted_symbols_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.restricted_symbols_.Get(i));
  }

  // repeated .zera_txn.ByteMultiplier byte_multiplier = 3;
  total_size += 1UL * this->_internal_byte_multiplier_size();
  for (const auto& msg : this->_impl_.byte_multiplier_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string fee_ISO4217 = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fee_iso4217());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FoundationTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FoundationTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FoundationTXN::GetClassData() const { return &_class_data_; }


void FoundationTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FoundationTXN*>(&to_msg);
  auto& from = static_cast<const FoundationTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.FoundationTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.restricted_symbols_.MergeFrom(from._impl_.restricted_symbols_);
  _this->_impl_.byte_multiplier_.MergeFrom(from._impl_.byte_multiplier_);
  if (from._internal_has_fee_iso4217()) {
    _this->_internal_set_fee_iso4217(from._internal_fee_iso4217());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FoundationTXN::CopyFrom(const FoundationTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.FoundationTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FoundationTXN::IsInitialized() const {
  return true;
}

void FoundationTXN::InternalSwap(FoundationTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.restricted_symbols_.InternalSwap(&other->_impl_.restricted_symbols_);
  _impl_.byte_multiplier_.InternalSwap(&other->_impl_.byte_multiplier_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fee_iso4217_, lhs_arena,
      &other->_impl_.fee_iso4217_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FoundationTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[9]);
}

// ===================================================================

class RevokeTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const RevokeTXN* msg);
};

const ::zera_txn::BaseTXN&
RevokeTXN::_Internal::base(const RevokeTXN* msg) {
  return *msg->_impl_.base_;
}
RevokeTXN::RevokeTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.RevokeTXN)
}
RevokeTXN::RevokeTXN(const RevokeTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RevokeTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_item_id().empty()) {
    _this->_impl_.item_id_.Set(from._internal_item_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.RevokeTXN)
}

inline void RevokeTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RevokeTXN::~RevokeTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.RevokeTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RevokeTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.recipient_address_.Destroy();
  _impl_.item_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void RevokeTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RevokeTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.RevokeTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.recipient_address_.ClearToEmpty();
  _impl_.item_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RevokeTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.RevokeTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // bytes recipient_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string item_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_item_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.RevokeTXN.item_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RevokeTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.RevokeTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.RevokeTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // bytes recipient_address = 3;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_recipient_address(), target);
  }

  // string item_id = 4;
  if (!this->_internal_item_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_item_id().data(), static_cast<int>(this->_internal_item_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.RevokeTXN.item_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.RevokeTXN)
  return target;
}

size_t RevokeTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.RevokeTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // bytes recipient_address = 3;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  // string item_id = 4;
  if (!this->_internal_item_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_item_id());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RevokeTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RevokeTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RevokeTXN::GetClassData() const { return &_class_data_; }


void RevokeTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RevokeTXN*>(&to_msg);
  auto& from = static_cast<const RevokeTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.RevokeTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  if (!from._internal_item_id().empty()) {
    _this->_internal_set_item_id(from._internal_item_id());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RevokeTXN::CopyFrom(const RevokeTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.RevokeTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RevokeTXN::IsInitialized() const {
  return true;
}

void RevokeTXN::InternalSwap(RevokeTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.item_id_, lhs_arena,
      &other->_impl_.item_id_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RevokeTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[10]);
}

// ===================================================================

class FastQuorumTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const FastQuorumTXN* msg);
};

const ::zera_txn::BaseTXN&
FastQuorumTXN::_Internal::base(const FastQuorumTXN* msg) {
  return *msg->_impl_.base_;
}
FastQuorumTXN::FastQuorumTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.FastQuorumTXN)
}
FastQuorumTXN::FastQuorumTXN(const FastQuorumTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FastQuorumTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proposal_id_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.proposal_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_proposal_id().empty()) {
    _this->_impl_.proposal_id_.Set(from._internal_proposal_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.FastQuorumTXN)
}

inline void FastQuorumTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.proposal_id_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.proposal_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FastQuorumTXN::~FastQuorumTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.FastQuorumTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FastQuorumTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.proposal_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void FastQuorumTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FastQuorumTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.FastQuorumTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.proposal_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FastQuorumTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes proposal_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_proposal_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastQuorumTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.FastQuorumTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // bytes proposal_id = 2;
  if (!this->_internal_proposal_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_proposal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.FastQuorumTXN)
  return target;
}

size_t FastQuorumTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.FastQuorumTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes proposal_id = 2;
  if (!this->_internal_proposal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_proposal_id());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FastQuorumTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FastQuorumTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FastQuorumTXN::GetClassData() const { return &_class_data_; }


void FastQuorumTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FastQuorumTXN*>(&to_msg);
  auto& from = static_cast<const FastQuorumTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.FastQuorumTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_proposal_id().empty()) {
    _this->_internal_set_proposal_id(from._internal_proposal_id());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FastQuorumTXN::CopyFrom(const FastQuorumTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.FastQuorumTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastQuorumTXN::IsInitialized() const {
  return true;
}

void FastQuorumTXN::InternalSwap(FastQuorumTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.proposal_id_, lhs_arena,
      &other->_impl_.proposal_id_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FastQuorumTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[11]);
}

// ===================================================================

class Governance::_Internal {
 public:
  using HasBits = decltype(std::declval<Governance>()._impl_._has_bits_);
  static void set_has_fast_quorum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chicken_dinner(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_voting_period(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_proposal_period(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_timestamp(const Governance* msg);
  static void set_has_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_approved(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Governance::_Internal::start_timestamp(const Governance* msg) {
  return *msg->_impl_.start_timestamp_;
}
void Governance::clear_start_timestamp() {
  if (_impl_.start_timestamp_ != nullptr) _impl_.start_timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Governance::Governance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Governance)
}
Governance::Governance(const Governance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Governance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.voting_instrument_){from._impl_.voting_instrument_}
    , decltype(_impl_.allowed_proposal_instrument_){from._impl_.allowed_proposal_instrument_}
    , decltype(_impl_.stage_length_){from._impl_.stage_length_}
    , decltype(_impl_.start_timestamp_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.regular_quorum_){}
    , decltype(_impl_.fast_quorum_){}
    , decltype(_impl_.threshold_){}
    , decltype(_impl_.chicken_dinner_){}
    , decltype(_impl_.allow_multi_){}
    , decltype(_impl_.voting_period_){}
    , decltype(_impl_.proposal_period_){}
    , decltype(_impl_.max_approved_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start_timestamp()) {
    _this->_impl_.start_timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.start_timestamp_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_approved_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.max_approved_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.Governance)
}

inline void Governance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.voting_instrument_){arena}
    , decltype(_impl_.allowed_proposal_instrument_){arena}
    , decltype(_impl_.stage_length_){arena}
    , decltype(_impl_.start_timestamp_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.regular_quorum_){0u}
    , decltype(_impl_.fast_quorum_){0u}
    , decltype(_impl_.threshold_){0u}
    , decltype(_impl_.chicken_dinner_){false}
    , decltype(_impl_.allow_multi_){false}
    , decltype(_impl_.voting_period_){0u}
    , decltype(_impl_.proposal_period_){0}
    , decltype(_impl_.max_approved_){0u}
  };
}

Governance::~Governance() {
  // @@protoc_insertion_point(destructor:zera_txn.Governance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Governance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.voting_instrument_.~RepeatedPtrField();
  _impl_.allowed_proposal_instrument_.~RepeatedPtrField();
  _impl_.stage_length_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.start_timestamp_;
}

void Governance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Governance::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Governance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.voting_instrument_.Clear();
  _impl_.allowed_proposal_instrument_.Clear();
  _impl_.stage_length_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.start_timestamp_ != nullptr);
    _impl_.start_timestamp_->Clear();
  }
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.regular_quorum_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.regular_quorum_));
  _impl_.fast_quorum_ = 0u;
  _impl_.threshold_ = 0u;
  _impl_.chicken_dinner_ = false;
  _impl_.allow_multi_ = false;
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.voting_period_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_approved_) -
        reinterpret_cast<char*>(&_impl_.voting_period_)) + sizeof(_impl_.max_approved_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Governance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.GOVERNANCE_TYPE type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::zera_txn::GOVERNANCE_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 regular_quorum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.regular_quorum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fast_quorum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fast_quorum(&has_bits);
          _impl_.fast_quorum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string voting_instrument = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_voting_instrument();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Governance.voting_instrument"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 threshold = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool chicken_dinner = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_chicken_dinner(&has_bits);
          _impl_.chicken_dinner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_multi = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.allow_multi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 voting_period = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_voting_period(&has_bits);
          _impl_.voting_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string allowed_proposal_instrument = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allowed_proposal_instrument();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Governance.allowed_proposal_instrument"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.PROPOSAL_PERIOD proposal_period = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_proposal_period(static_cast<::zera_txn::PROPOSAL_PERIOD>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.Stage stage_length = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stage_length(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp start_timestamp = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_approved = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_max_approved(&has_bits);
          _impl_.max_approved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Governance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Governance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.GOVERNANCE_TYPE type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // uint32 regular_quorum = 2;
  if (this->_internal_regular_quorum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_regular_quorum(), target);
  }

  // optional uint32 fast_quorum = 3;
  if (_internal_has_fast_quorum()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_fast_quorum(), target);
  }

  // repeated string voting_instrument = 4;
  for (int i = 0, n = this->_internal_voting_instrument_size(); i < n; i++) {
    const auto& s = this->_internal_voting_instrument(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Governance.voting_instrument");
    target = stream->WriteString(4, s, target);
  }

  // uint32 threshold = 5;
  if (this->_internal_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_threshold(), target);
  }

  // optional bool chicken_dinner = 6;
  if (_internal_has_chicken_dinner()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_chicken_dinner(), target);
  }

  // bool allow_multi = 7;
  if (this->_internal_allow_multi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_allow_multi(), target);
  }

  // optional uint32 voting_period = 8;
  if (_internal_has_voting_period()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_voting_period(), target);
  }

  // repeated string allowed_proposal_instrument = 9;
  for (int i = 0, n = this->_internal_allowed_proposal_instrument_size(); i < n; i++) {
    const auto& s = this->_internal_allowed_proposal_instrument(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Governance.allowed_proposal_instrument");
    target = stream->WriteString(9, s, target);
  }

  // optional .zera_txn.PROPOSAL_PERIOD proposal_period = 10;
  if (_internal_has_proposal_period()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_proposal_period(), target);
  }

  // repeated .zera_txn.Stage stage_length = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stage_length_size()); i < n; i++) {
    const auto& repfield = this->_internal_stage_length(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp start_timestamp = 12;
  if (_internal_has_start_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::start_timestamp(this),
        _Internal::start_timestamp(this).GetCachedSize(), target, stream);
  }

  // optional uint32 max_approved = 13;
  if (_internal_has_max_approved()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_max_approved(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Governance)
  return target;
}

size_t Governance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Governance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string voting_instrument = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.voting_instrument_.size());
  for (int i = 0, n = _impl_.voting_instrument_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.voting_instrument_.Get(i));
  }

  // repeated string allowed_proposal_instrument = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.allowed_proposal_instrument_.size());
  for (int i = 0, n = _impl_.allowed_proposal_instrument_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.allowed_proposal_instrument_.Get(i));
  }

  // repeated .zera_txn.Stage stage_length = 11;
  total_size += 1UL * this->_internal_stage_length_size();
  for (const auto& msg : this->_impl_.stage_length_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .google.protobuf.Timestamp start_timestamp = 12;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_timestamp_);
  }

  // .zera_txn.GOVERNANCE_TYPE type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 regular_quorum = 2;
  if (this->_internal_regular_quorum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_regular_quorum());
  }

  // optional uint32 fast_quorum = 3;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fast_quorum());
  }

  // uint32 threshold = 5;
  if (this->_internal_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_threshold());
  }

  // optional bool chicken_dinner = 6;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  // bool allow_multi = 7;
  if (this->_internal_allow_multi() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x00000038u) {
    // optional uint32 voting_period = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_voting_period());
    }

    // optional .zera_txn.PROPOSAL_PERIOD proposal_period = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_proposal_period());
    }

    // optional uint32 max_approved = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_approved());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Governance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Governance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Governance::GetClassData() const { return &_class_data_; }


void Governance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Governance*>(&to_msg);
  auto& from = static_cast<const Governance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Governance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.voting_instrument_.MergeFrom(from._impl_.voting_instrument_);
  _this->_impl_.allowed_proposal_instrument_.MergeFrom(from._impl_.allowed_proposal_instrument_);
  _this->_impl_.stage_length_.MergeFrom(from._impl_.stage_length_);
  if (from._internal_has_start_timestamp()) {
    _this->_internal_mutable_start_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_start_timestamp());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_regular_quorum() != 0) {
    _this->_internal_set_regular_quorum(from._internal_regular_quorum());
  }
  if (from._internal_has_fast_quorum()) {
    _this->_internal_set_fast_quorum(from._internal_fast_quorum());
  }
  if (from._internal_threshold() != 0) {
    _this->_internal_set_threshold(from._internal_threshold());
  }
  if (from._internal_has_chicken_dinner()) {
    _this->_internal_set_chicken_dinner(from._internal_chicken_dinner());
  }
  if (from._internal_allow_multi() != 0) {
    _this->_internal_set_allow_multi(from._internal_allow_multi());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000038u) {
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.voting_period_ = from._impl_.voting_period_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.proposal_period_ = from._impl_.proposal_period_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.max_approved_ = from._impl_.max_approved_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Governance::CopyFrom(const Governance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Governance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Governance::IsInitialized() const {
  return true;
}

void Governance::InternalSwap(Governance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.voting_instrument_.InternalSwap(&other->_impl_.voting_instrument_);
  _impl_.allowed_proposal_instrument_.InternalSwap(&other->_impl_.allowed_proposal_instrument_);
  _impl_.stage_length_.InternalSwap(&other->_impl_.stage_length_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Governance, _impl_.max_approved_)
      + sizeof(Governance::_impl_.max_approved_)
      - PROTOBUF_FIELD_OFFSET(Governance, _impl_.start_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.start_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.start_timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Governance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[12]);
}

// ===================================================================

class Stage::_Internal {
 public:
};

Stage::Stage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Stage)
}
Stage::Stage(const Stage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Stage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.length_){}
    , decltype(_impl_.period_){}
    , decltype(_impl_.break__){}
    , decltype(_impl_.max_approved_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.length_, &from._impl_.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_approved_) -
    reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.max_approved_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.Stage)
}

inline void Stage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.length_){0u}
    , decltype(_impl_.period_){0}
    , decltype(_impl_.break__){false}
    , decltype(_impl_.max_approved_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Stage::~Stage() {
  // @@protoc_insertion_point(destructor:zera_txn.Stage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Stage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Stage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Stage::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Stage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_approved_) -
      reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.max_approved_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.PROPOSAL_PERIOD period = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_period(static_cast<::zera_txn::PROPOSAL_PERIOD>(val));
        } else
          goto handle_unusual;
        continue;
      // bool break = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.break__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_approved = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.max_approved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Stage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Stage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 length = 1;
  if (this->_internal_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_length(), target);
  }

  // .zera_txn.PROPOSAL_PERIOD period = 2;
  if (this->_internal_period() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_period(), target);
  }

  // bool break = 3;
  if (this->_internal_break_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_break_(), target);
  }

  // uint32 max_approved = 4;
  if (this->_internal_max_approved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_max_approved(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Stage)
  return target;
}

size_t Stage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Stage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 length = 1;
  if (this->_internal_length() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
  }

  // .zera_txn.PROPOSAL_PERIOD period = 2;
  if (this->_internal_period() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_period());
  }

  // bool break = 3;
  if (this->_internal_break_() != 0) {
    total_size += 1 + 1;
  }

  // uint32 max_approved = 4;
  if (this->_internal_max_approved() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_approved());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Stage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stage::GetClassData() const { return &_class_data_; }


void Stage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Stage*>(&to_msg);
  auto& from = static_cast<const Stage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Stage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_length() != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  if (from._internal_period() != 0) {
    _this->_internal_set_period(from._internal_period());
  }
  if (from._internal_break_() != 0) {
    _this->_internal_set_break_(from._internal_break_());
  }
  if (from._internal_max_approved() != 0) {
    _this->_internal_set_max_approved(from._internal_max_approved());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stage::CopyFrom(const Stage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Stage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stage::IsInitialized() const {
  return true;
}

void Stage::InternalSwap(Stage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Stage, _impl_.max_approved_)
      + sizeof(Stage::_impl_.max_approved_)
      - PROTOBUF_FIELD_OFFSET(Stage, _impl_.length_)>(
          reinterpret_cast<char*>(&_impl_.length_),
          reinterpret_cast<char*>(&other->_impl_.length_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Stage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[13]);
}

// ===================================================================

class CoinDenomination::_Internal {
 public:
};

CoinDenomination::CoinDenomination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.CoinDenomination)
}
CoinDenomination::CoinDenomination(const CoinDenomination& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CoinDenomination* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.denomination_name_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.denomination_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.denomination_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denomination_name().empty()) {
    _this->_impl_.denomination_name_.Set(from._internal_denomination_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.CoinDenomination)
}

inline void CoinDenomination::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.denomination_name_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.denomination_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.denomination_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CoinDenomination::~CoinDenomination() {
  // @@protoc_insertion_point(destructor:zera_txn.CoinDenomination)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoinDenomination::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.denomination_name_.Destroy();
  _impl_.amount_.Destroy();
}

void CoinDenomination::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CoinDenomination::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.CoinDenomination)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.denomination_name_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoinDenomination::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string denomination_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_denomination_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.CoinDenomination.denomination_name"));
        } else
          goto handle_unusual;
        continue;
      // string amount = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.CoinDenomination.amount"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoinDenomination::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.CoinDenomination)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string denomination_name = 5;
  if (!this->_internal_denomination_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_denomination_name().data(), static_cast<int>(this->_internal_denomination_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.CoinDenomination.denomination_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_denomination_name(), target);
  }

  // string amount = 6;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.CoinDenomination.amount");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.CoinDenomination)
  return target;
}

size_t CoinDenomination::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.CoinDenomination)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string denomination_name = 5;
  if (!this->_internal_denomination_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_denomination_name());
  }

  // string amount = 6;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoinDenomination::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CoinDenomination::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoinDenomination::GetClassData() const { return &_class_data_; }


void CoinDenomination::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CoinDenomination*>(&to_msg);
  auto& from = static_cast<const CoinDenomination&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.CoinDenomination)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_denomination_name().empty()) {
    _this->_internal_set_denomination_name(from._internal_denomination_name());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoinDenomination::CopyFrom(const CoinDenomination& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.CoinDenomination)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoinDenomination::IsInitialized() const {
  return true;
}

void CoinDenomination::InternalSwap(CoinDenomination* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.denomination_name_, lhs_arena,
      &other->_impl_.denomination_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CoinDenomination::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[14]);
}

// ===================================================================

class ContractFees::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractFees>()._impl_._has_bits_);
  static void set_has_fee_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContractFees::ContractFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ContractFees)
}
ContractFees::ContractFees(const ContractFees& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContractFees* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_fee_instrument_){from._impl_.allowed_fee_instrument_}
    , decltype(_impl_.fee_){}
    , decltype(_impl_.fee_address_){}
    , decltype(_impl_.burn_){}
    , decltype(_impl_.validator_){}
    , decltype(_impl_.contract_fee_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee().empty()) {
    _this->_impl_.fee_.Set(from._internal_fee(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fee_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fee_address()) {
    _this->_impl_.fee_address_.Set(from._internal_fee_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.burn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.burn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_burn().empty()) {
    _this->_impl_.burn_.Set(from._internal_burn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.validator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validator_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_validator().empty()) {
    _this->_impl_.validator_.Set(from._internal_validator(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.contract_fee_type_ = from._impl_.contract_fee_type_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.ContractFees)
}

inline void ContractFees::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_fee_instrument_){arena}
    , decltype(_impl_.fee_){}
    , decltype(_impl_.fee_address_){}
    , decltype(_impl_.burn_){}
    , decltype(_impl_.validator_){}
    , decltype(_impl_.contract_fee_type_){0}
  };
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.burn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.burn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.validator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validator_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContractFees::~ContractFees() {
  // @@protoc_insertion_point(destructor:zera_txn.ContractFees)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractFees::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allowed_fee_instrument_.~RepeatedPtrField();
  _impl_.fee_.Destroy();
  _impl_.fee_address_.Destroy();
  _impl_.burn_.Destroy();
  _impl_.validator_.Destroy();
}

void ContractFees::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContractFees::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ContractFees)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowed_fee_instrument_.Clear();
  _impl_.fee_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.fee_address_.ClearNonDefaultToEmpty();
  }
  _impl_.burn_.ClearToEmpty();
  _impl_.validator_.ClearToEmpty();
  _impl_.contract_fee_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractFees::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string fee = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ContractFees.fee"));
        } else
          goto handle_unusual;
        continue;
      // optional bytes fee_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fee_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string burn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_burn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ContractFees.burn"));
        } else
          goto handle_unusual;
        continue;
      // string validator = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_validator();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ContractFees.validator"));
        } else
          goto handle_unusual;
        continue;
      // repeated string allowed_fee_instrument = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allowed_fee_instrument();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ContractFees.allowed_fee_instrument"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_contract_fee_type(static_cast<::zera_txn::CONTRACT_FEE_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractFees::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ContractFees)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string fee = 1;
  if (!this->_internal_fee().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fee().data(), static_cast<int>(this->_internal_fee().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ContractFees.fee");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_fee(), target);
  }

  // optional bytes fee_address = 2;
  if (_internal_has_fee_address()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fee_address(), target);
  }

  // string burn = 3;
  if (!this->_internal_burn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_burn().data(), static_cast<int>(this->_internal_burn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ContractFees.burn");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_burn(), target);
  }

  // string validator = 4;
  if (!this->_internal_validator().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_validator().data(), static_cast<int>(this->_internal_validator().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ContractFees.validator");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_validator(), target);
  }

  // repeated string allowed_fee_instrument = 5;
  for (int i = 0, n = this->_internal_allowed_fee_instrument_size(); i < n; i++) {
    const auto& s = this->_internal_allowed_fee_instrument(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ContractFees.allowed_fee_instrument");
    target = stream->WriteString(5, s, target);
  }

  // .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 6;
  if (this->_internal_contract_fee_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_contract_fee_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ContractFees)
  return target;
}

size_t ContractFees::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ContractFees)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string allowed_fee_instrument = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.allowed_fee_instrument_.size());
  for (int i = 0, n = _impl_.allowed_fee_instrument_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.allowed_fee_instrument_.Get(i));
  }

  // string fee = 1;
  if (!this->_internal_fee().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fee());
  }

  // optional bytes fee_address = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_fee_address());
  }

  // string burn = 3;
  if (!this->_internal_burn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_burn());
  }

  // string validator = 4;
  if (!this->_internal_validator().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_validator());
  }

  // .zera_txn.CONTRACT_FEE_TYPE contract_fee_type = 6;
  if (this->_internal_contract_fee_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_contract_fee_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractFees::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContractFees::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractFees::GetClassData() const { return &_class_data_; }


void ContractFees::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContractFees*>(&to_msg);
  auto& from = static_cast<const ContractFees&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ContractFees)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allowed_fee_instrument_.MergeFrom(from._impl_.allowed_fee_instrument_);
  if (!from._internal_fee().empty()) {
    _this->_internal_set_fee(from._internal_fee());
  }
  if (from._internal_has_fee_address()) {
    _this->_internal_set_fee_address(from._internal_fee_address());
  }
  if (!from._internal_burn().empty()) {
    _this->_internal_set_burn(from._internal_burn());
  }
  if (!from._internal_validator().empty()) {
    _this->_internal_set_validator(from._internal_validator());
  }
  if (from._internal_contract_fee_type() != 0) {
    _this->_internal_set_contract_fee_type(from._internal_contract_fee_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractFees::CopyFrom(const ContractFees& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ContractFees)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractFees::IsInitialized() const {
  return true;
}

void ContractFees::InternalSwap(ContractFees* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.allowed_fee_instrument_.InternalSwap(&other->_impl_.allowed_fee_instrument_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fee_, lhs_arena,
      &other->_impl_.fee_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fee_address_, lhs_arena,
      &other->_impl_.fee_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.burn_, lhs_arena,
      &other->_impl_.burn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.validator_, lhs_arena,
      &other->_impl_.validator_, rhs_arena
  );
  swap(_impl_.contract_fee_type_, other->_impl_.contract_fee_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractFees::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[15]);
}

// ===================================================================

class ItemContractFees::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemContractFees>()._impl_._has_bits_);
  static void set_has_fee_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ItemContractFees::ItemContractFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ItemContractFees)
}
ItemContractFees::ItemContractFees(const ItemContractFees& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemContractFees* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_fee_instrument_){from._impl_.allowed_fee_instrument_}
    , decltype(_impl_.fee_){}
    , decltype(_impl_.fee_address_){}
    , decltype(_impl_.burn_){}
    , decltype(_impl_.validator_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee().empty()) {
    _this->_impl_.fee_.Set(from._internal_fee(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fee_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fee_address()) {
    _this->_impl_.fee_address_.Set(from._internal_fee_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.burn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.burn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_burn().empty()) {
    _this->_impl_.burn_.Set(from._internal_burn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.validator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validator_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_validator().empty()) {
    _this->_impl_.validator_.Set(from._internal_validator(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.ItemContractFees)
}

inline void ItemContractFees::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_fee_instrument_){arena}
    , decltype(_impl_.fee_){}
    , decltype(_impl_.fee_address_){}
    , decltype(_impl_.burn_){}
    , decltype(_impl_.validator_){}
  };
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.burn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.burn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.validator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validator_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ItemContractFees::~ItemContractFees() {
  // @@protoc_insertion_point(destructor:zera_txn.ItemContractFees)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemContractFees::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allowed_fee_instrument_.~RepeatedPtrField();
  _impl_.fee_.Destroy();
  _impl_.fee_address_.Destroy();
  _impl_.burn_.Destroy();
  _impl_.validator_.Destroy();
}

void ItemContractFees::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemContractFees::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ItemContractFees)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowed_fee_instrument_.Clear();
  _impl_.fee_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.fee_address_.ClearNonDefaultToEmpty();
  }
  _impl_.burn_.ClearToEmpty();
  _impl_.validator_.ClearToEmpty();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemContractFees::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string fee = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ItemContractFees.fee"));
        } else
          goto handle_unusual;
        continue;
      // optional bytes fee_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fee_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string burn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_burn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ItemContractFees.burn"));
        } else
          goto handle_unusual;
        continue;
      // string validator = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_validator();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ItemContractFees.validator"));
        } else
          goto handle_unusual;
        continue;
      // repeated string allowed_fee_instrument = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allowed_fee_instrument();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ItemContractFees.allowed_fee_instrument"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemContractFees::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ItemContractFees)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string fee = 1;
  if (!this->_internal_fee().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fee().data(), static_cast<int>(this->_internal_fee().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ItemContractFees.fee");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_fee(), target);
  }

  // optional bytes fee_address = 2;
  if (_internal_has_fee_address()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fee_address(), target);
  }

  // string burn = 3;
  if (!this->_internal_burn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_burn().data(), static_cast<int>(this->_internal_burn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ItemContractFees.burn");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_burn(), target);
  }

  // string validator = 4;
  if (!this->_internal_validator().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_validator().data(), static_cast<int>(this->_internal_validator().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ItemContractFees.validator");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_validator(), target);
  }

  // repeated string allowed_fee_instrument = 5;
  for (int i = 0, n = this->_internal_allowed_fee_instrument_size(); i < n; i++) {
    const auto& s = this->_internal_allowed_fee_instrument(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ItemContractFees.allowed_fee_instrument");
    target = stream->WriteString(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ItemContractFees)
  return target;
}

size_t ItemContractFees::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ItemContractFees)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string allowed_fee_instrument = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.allowed_fee_instrument_.size());
  for (int i = 0, n = _impl_.allowed_fee_instrument_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.allowed_fee_instrument_.Get(i));
  }

  // string fee = 1;
  if (!this->_internal_fee().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fee());
  }

  // optional bytes fee_address = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_fee_address());
  }

  // string burn = 3;
  if (!this->_internal_burn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_burn());
  }

  // string validator = 4;
  if (!this->_internal_validator().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_validator());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemContractFees::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemContractFees::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemContractFees::GetClassData() const { return &_class_data_; }


void ItemContractFees::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemContractFees*>(&to_msg);
  auto& from = static_cast<const ItemContractFees&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ItemContractFees)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allowed_fee_instrument_.MergeFrom(from._impl_.allowed_fee_instrument_);
  if (!from._internal_fee().empty()) {
    _this->_internal_set_fee(from._internal_fee());
  }
  if (from._internal_has_fee_address()) {
    _this->_internal_set_fee_address(from._internal_fee_address());
  }
  if (!from._internal_burn().empty()) {
    _this->_internal_set_burn(from._internal_burn());
  }
  if (!from._internal_validator().empty()) {
    _this->_internal_set_validator(from._internal_validator());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemContractFees::CopyFrom(const ItemContractFees& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ItemContractFees)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemContractFees::IsInitialized() const {
  return true;
}

void ItemContractFees::InternalSwap(ItemContractFees* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.allowed_fee_instrument_.InternalSwap(&other->_impl_.allowed_fee_instrument_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fee_, lhs_arena,
      &other->_impl_.fee_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fee_address_, lhs_arena,
      &other->_impl_.fee_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.burn_, lhs_arena,
      &other->_impl_.burn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.validator_, lhs_arena,
      &other->_impl_.validator_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemContractFees::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[16]);
}

// ===================================================================

class RestrictedKey::_Internal {
 public:
  static const ::zera_txn::PublicKey& public_key(const RestrictedKey* msg);
};

const ::zera_txn::PublicKey&
RestrictedKey::_Internal::public_key(const RestrictedKey* msg) {
  return *msg->_impl_.public_key_;
}
RestrictedKey::RestrictedKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.RestrictedKey)
}
RestrictedKey::RestrictedKey(const RestrictedKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RestrictedKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.time_delay_){}
    , decltype(_impl_.global_){}
    , decltype(_impl_.update_contract_){}
    , decltype(_impl_.transfer_){}
    , decltype(_impl_.quash_){}
    , decltype(_impl_.mint_){}
    , decltype(_impl_.vote_){}
    , decltype(_impl_.propose_){}
    , decltype(_impl_.compliance_){}
    , decltype(_impl_.expense_ratio_){}
    , decltype(_impl_.cur_equiv_){}
    , decltype(_impl_.revoke_){}
    , decltype(_impl_.key_weight_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_ = new ::zera_txn::PublicKey(*from._impl_.public_key_);
  }
  ::memcpy(&_impl_.time_delay_, &from._impl_.time_delay_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.key_weight_) -
    reinterpret_cast<char*>(&_impl_.time_delay_)) + sizeof(_impl_.key_weight_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.RestrictedKey)
}

inline void RestrictedKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.time_delay_){int64_t{0}}
    , decltype(_impl_.global_){false}
    , decltype(_impl_.update_contract_){false}
    , decltype(_impl_.transfer_){false}
    , decltype(_impl_.quash_){false}
    , decltype(_impl_.mint_){false}
    , decltype(_impl_.vote_){false}
    , decltype(_impl_.propose_){false}
    , decltype(_impl_.compliance_){false}
    , decltype(_impl_.expense_ratio_){false}
    , decltype(_impl_.cur_equiv_){false}
    , decltype(_impl_.revoke_){false}
    , decltype(_impl_.key_weight_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RestrictedKey::~RestrictedKey() {
  // @@protoc_insertion_point(destructor:zera_txn.RestrictedKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RestrictedKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.public_key_;
}

void RestrictedKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RestrictedKey::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.RestrictedKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
  ::memset(&_impl_.time_delay_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.key_weight_) -
      reinterpret_cast<char*>(&_impl_.time_delay_)) + sizeof(_impl_.key_weight_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RestrictedKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.PublicKey public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 time_delay = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.time_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool global = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.global_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool update_contract = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.update_contract_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool transfer = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.transfer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool quash = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.quash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool mint = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.mint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool vote = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.vote_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool propose = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.propose_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool compliance = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.compliance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool expense_ratio = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.expense_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool cur_equiv = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.cur_equiv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool revoke = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.revoke_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 key_weight = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.key_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RestrictedKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.RestrictedKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.PublicKey public_key = 1;
  if (this->_internal_has_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  // int64 time_delay = 2;
  if (this->_internal_time_delay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_time_delay(), target);
  }

  // bool global = 3;
  if (this->_internal_global() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_global(), target);
  }

  // bool update_contract = 4;
  if (this->_internal_update_contract() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_update_contract(), target);
  }

  // bool transfer = 5;
  if (this->_internal_transfer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_transfer(), target);
  }

  // bool quash = 6;
  if (this->_internal_quash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_quash(), target);
  }

  // bool mint = 7;
  if (this->_internal_mint() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_mint(), target);
  }

  // bool vote = 8;
  if (this->_internal_vote() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_vote(), target);
  }

  // bool propose = 9;
  if (this->_internal_propose() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_propose(), target);
  }

  // bool compliance = 10;
  if (this->_internal_compliance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_compliance(), target);
  }

  // bool expense_ratio = 11;
  if (this->_internal_expense_ratio() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_expense_ratio(), target);
  }

  // bool cur_equiv = 12;
  if (this->_internal_cur_equiv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_cur_equiv(), target);
  }

  // bool revoke = 13;
  if (this->_internal_revoke() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_revoke(), target);
  }

  // uint32 key_weight = 14;
  if (this->_internal_key_weight() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_key_weight(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.RestrictedKey)
  return target;
}

size_t RestrictedKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.RestrictedKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .zera_txn.PublicKey public_key = 1;
  if (this->_internal_has_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.public_key_);
  }

  // int64 time_delay = 2;
  if (this->_internal_time_delay() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_delay());
  }

  // bool global = 3;
  if (this->_internal_global() != 0) {
    total_size += 1 + 1;
  }

  // bool update_contract = 4;
  if (this->_internal_update_contract() != 0) {
    total_size += 1 + 1;
  }

  // bool transfer = 5;
  if (this->_internal_transfer() != 0) {
    total_size += 1 + 1;
  }

  // bool quash = 6;
  if (this->_internal_quash() != 0) {
    total_size += 1 + 1;
  }

  // bool mint = 7;
  if (this->_internal_mint() != 0) {
    total_size += 1 + 1;
  }

  // bool vote = 8;
  if (this->_internal_vote() != 0) {
    total_size += 1 + 1;
  }

  // bool propose = 9;
  if (this->_internal_propose() != 0) {
    total_size += 1 + 1;
  }

  // bool compliance = 10;
  if (this->_internal_compliance() != 0) {
    total_size += 1 + 1;
  }

  // bool expense_ratio = 11;
  if (this->_internal_expense_ratio() != 0) {
    total_size += 1 + 1;
  }

  // bool cur_equiv = 12;
  if (this->_internal_cur_equiv() != 0) {
    total_size += 1 + 1;
  }

  // bool revoke = 13;
  if (this->_internal_revoke() != 0) {
    total_size += 1 + 1;
  }

  // uint32 key_weight = 14;
  if (this->_internal_key_weight() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key_weight());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RestrictedKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RestrictedKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RestrictedKey::GetClassData() const { return &_class_data_; }


void RestrictedKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RestrictedKey*>(&to_msg);
  auto& from = static_cast<const RestrictedKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.RestrictedKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_public_key()) {
    _this->_internal_mutable_public_key()->::zera_txn::PublicKey::MergeFrom(
        from._internal_public_key());
  }
  if (from._internal_time_delay() != 0) {
    _this->_internal_set_time_delay(from._internal_time_delay());
  }
  if (from._internal_global() != 0) {
    _this->_internal_set_global(from._internal_global());
  }
  if (from._internal_update_contract() != 0) {
    _this->_internal_set_update_contract(from._internal_update_contract());
  }
  if (from._internal_transfer() != 0) {
    _this->_internal_set_transfer(from._internal_transfer());
  }
  if (from._internal_quash() != 0) {
    _this->_internal_set_quash(from._internal_quash());
  }
  if (from._internal_mint() != 0) {
    _this->_internal_set_mint(from._internal_mint());
  }
  if (from._internal_vote() != 0) {
    _this->_internal_set_vote(from._internal_vote());
  }
  if (from._internal_propose() != 0) {
    _this->_internal_set_propose(from._internal_propose());
  }
  if (from._internal_compliance() != 0) {
    _this->_internal_set_compliance(from._internal_compliance());
  }
  if (from._internal_expense_ratio() != 0) {
    _this->_internal_set_expense_ratio(from._internal_expense_ratio());
  }
  if (from._internal_cur_equiv() != 0) {
    _this->_internal_set_cur_equiv(from._internal_cur_equiv());
  }
  if (from._internal_revoke() != 0) {
    _this->_internal_set_revoke(from._internal_revoke());
  }
  if (from._internal_key_weight() != 0) {
    _this->_internal_set_key_weight(from._internal_key_weight());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RestrictedKey::CopyFrom(const RestrictedKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.RestrictedKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RestrictedKey::IsInitialized() const {
  return true;
}

void RestrictedKey::InternalSwap(RestrictedKey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RestrictedKey, _impl_.key_weight_)
      + sizeof(RestrictedKey::_impl_.key_weight_)
      - PROTOBUF_FIELD_OFFSET(RestrictedKey, _impl_.public_key_)>(
          reinterpret_cast<char*>(&_impl_.public_key_),
          reinterpret_cast<char*>(&other->_impl_.public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RestrictedKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[17]);
}

// ===================================================================

class ExpenseRatioTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const ExpenseRatioTXN* msg);
};

const ::zera_txn::BaseTXN&
ExpenseRatioTXN::_Internal::base(const ExpenseRatioTXN* msg) {
  return *msg->_impl_.base_;
}
ExpenseRatioTXN::ExpenseRatioTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ExpenseRatioTXN)
}
ExpenseRatioTXN::ExpenseRatioTXN(const ExpenseRatioTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpenseRatioTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.addresses_){from._impl_.addresses_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.output_address_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.output_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_output_address().empty()) {
    _this->_impl_.output_address_.Set(from._internal_output_address(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.ExpenseRatioTXN)
}

inline void ExpenseRatioTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.addresses_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.output_address_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.output_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExpenseRatioTXN::~ExpenseRatioTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.ExpenseRatioTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpenseRatioTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.addresses_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
  _impl_.output_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void ExpenseRatioTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpenseRatioTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ExpenseRatioTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.addresses_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.output_address_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpenseRatioTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ExpenseRatioTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes addresses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_addresses();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes output_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_output_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpenseRatioTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ExpenseRatioTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ExpenseRatioTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // repeated bytes addresses = 3;
  for (int i = 0, n = this->_internal_addresses_size(); i < n; i++) {
    const auto& s = this->_internal_addresses(i);
    target = stream->WriteBytes(3, s, target);
  }

  // bytes output_address = 4;
  if (!this->_internal_output_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_output_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ExpenseRatioTXN)
  return target;
}

size_t ExpenseRatioTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ExpenseRatioTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes addresses = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.addresses_.size());
  for (int i = 0, n = _impl_.addresses_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.addresses_.Get(i));
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // bytes output_address = 4;
  if (!this->_internal_output_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_output_address());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpenseRatioTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpenseRatioTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpenseRatioTXN::GetClassData() const { return &_class_data_; }


void ExpenseRatioTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpenseRatioTXN*>(&to_msg);
  auto& from = static_cast<const ExpenseRatioTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ExpenseRatioTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.addresses_.MergeFrom(from._impl_.addresses_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_output_address().empty()) {
    _this->_internal_set_output_address(from._internal_output_address());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpenseRatioTXN::CopyFrom(const ExpenseRatioTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ExpenseRatioTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpenseRatioTXN::IsInitialized() const {
  return true;
}

void ExpenseRatioTXN::InternalSwap(ExpenseRatioTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.addresses_.InternalSwap(&other->_impl_.addresses_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.output_address_, lhs_arena,
      &other->_impl_.output_address_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpenseRatioTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[18]);
}

// ===================================================================

class PreMintWallet::_Internal {
 public:
};

PreMintWallet::PreMintWallet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.PreMintWallet)
}
PreMintWallet::PreMintWallet(const PreMintWallet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PreMintWallet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.PreMintWallet)
}

inline void PreMintWallet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PreMintWallet::~PreMintWallet() {
  // @@protoc_insertion_point(destructor:zera_txn.PreMintWallet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PreMintWallet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
  _impl_.amount_.Destroy();
}

void PreMintWallet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PreMintWallet::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.PreMintWallet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PreMintWallet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.PreMintWallet.amount"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PreMintWallet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.PreMintWallet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_address(), target);
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.PreMintWallet.amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.PreMintWallet)
  return target;
}

size_t PreMintWallet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.PreMintWallet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_address());
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PreMintWallet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PreMintWallet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PreMintWallet::GetClassData() const { return &_class_data_; }


void PreMintWallet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PreMintWallet*>(&to_msg);
  auto& from = static_cast<const PreMintWallet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.PreMintWallet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PreMintWallet::CopyFrom(const PreMintWallet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.PreMintWallet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PreMintWallet::IsInitialized() const {
  return true;
}

void PreMintWallet::InternalSwap(PreMintWallet* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PreMintWallet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[19]);
}

// ===================================================================

class Transfer::_Internal {
 public:
  using HasBits = decltype(std::declval<Transfer>()._impl_._has_bits_);
  static void set_has_contract_fee_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_contract_fee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_memo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Transfer::Transfer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Transfer)
}
Transfer::Transfer(const Transfer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Transfer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.contract_fee_amount_){}
    , decltype(_impl_.contract_fee_id_){}
    , decltype(_impl_.base_fee_amount_){}
    , decltype(_impl_.base_fee_id_){}
    , decltype(_impl_.memo_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_fee_amount()) {
    _this->_impl_.contract_fee_amount_.Set(from._internal_contract_fee_amount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_fee_id()) {
    _this->_impl_.contract_fee_id_.Set(from._internal_contract_fee_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base_fee_amount().empty()) {
    _this->_impl_.base_fee_amount_.Set(from._internal_base_fee_amount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base_fee_id().empty()) {
    _this->_impl_.base_fee_id_.Set(from._internal_base_fee_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.memo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_memo()) {
    _this->_impl_.memo_.Set(from._internal_memo(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.Transfer)
}

inline void Transfer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.contract_fee_amount_){}
    , decltype(_impl_.contract_fee_id_){}
    , decltype(_impl_.base_fee_amount_){}
    , decltype(_impl_.base_fee_id_){}
    , decltype(_impl_.memo_){}
  };
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.memo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Transfer::~Transfer() {
  // @@protoc_insertion_point(destructor:zera_txn.Transfer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Transfer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recipient_address_.Destroy();
  _impl_.amount_.Destroy();
  _impl_.contract_id_.Destroy();
  _impl_.contract_fee_amount_.Destroy();
  _impl_.contract_fee_id_.Destroy();
  _impl_.base_fee_amount_.Destroy();
  _impl_.base_fee_id_.Destroy();
  _impl_.memo_.Destroy();
}

void Transfer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Transfer::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Transfer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recipient_address_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _impl_.contract_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.contract_fee_amount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.contract_fee_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.base_fee_amount_.ClearToEmpty();
  _impl_.base_fee_id_.ClearToEmpty();
  if (cached_has_bits & 0x00000004u) {
    _impl_.memo_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Transfer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes recipient_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Transfer.amount"));
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Transfer.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string contract_fee_amount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_contract_fee_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Transfer.contract_fee_amount"));
        } else
          goto handle_unusual;
        continue;
      // optional string contract_fee_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_contract_fee_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Transfer.contract_fee_id"));
        } else
          goto handle_unusual;
        continue;
      // string base_fee_amount = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_base_fee_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Transfer.base_fee_amount"));
        } else
          goto handle_unusual;
        continue;
      // string base_fee_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_base_fee_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Transfer.base_fee_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string memo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_memo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Transfer.memo"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Transfer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Transfer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_recipient_address(), target);
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Transfer.amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_amount(), target);
  }

  // string contract_id = 3;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Transfer.contract_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_contract_id(), target);
  }

  // optional string contract_fee_amount = 4;
  if (_internal_has_contract_fee_amount()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_fee_amount().data(), static_cast<int>(this->_internal_contract_fee_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Transfer.contract_fee_amount");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_contract_fee_amount(), target);
  }

  // optional string contract_fee_id = 5;
  if (_internal_has_contract_fee_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_fee_id().data(), static_cast<int>(this->_internal_contract_fee_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Transfer.contract_fee_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_contract_fee_id(), target);
  }

  // string base_fee_amount = 6;
  if (!this->_internal_base_fee_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_base_fee_amount().data(), static_cast<int>(this->_internal_base_fee_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Transfer.base_fee_amount");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_base_fee_amount(), target);
  }

  // string base_fee_id = 7;
  if (!this->_internal_base_fee_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_base_fee_id().data(), static_cast<int>(this->_internal_base_fee_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Transfer.base_fee_id");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_base_fee_id(), target);
  }

  // optional string memo = 8;
  if (_internal_has_memo()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_memo().data(), static_cast<int>(this->_internal_memo().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Transfer.memo");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_memo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Transfer)
  return target;
}

size_t Transfer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Transfer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  // string contract_id = 3;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string contract_fee_amount = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_fee_amount());
    }

    // optional string contract_fee_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_fee_id());
    }

  }
  // string base_fee_amount = 6;
  if (!this->_internal_base_fee_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_base_fee_amount());
  }

  // string base_fee_id = 7;
  if (!this->_internal_base_fee_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_base_fee_id());
  }

  // optional string memo = 8;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_memo());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Transfer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Transfer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Transfer::GetClassData() const { return &_class_data_; }


void Transfer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Transfer*>(&to_msg);
  auto& from = static_cast<const Transfer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Transfer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_contract_fee_amount(from._internal_contract_fee_amount());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_contract_fee_id(from._internal_contract_fee_id());
    }
  }
  if (!from._internal_base_fee_amount().empty()) {
    _this->_internal_set_base_fee_amount(from._internal_base_fee_amount());
  }
  if (!from._internal_base_fee_id().empty()) {
    _this->_internal_set_base_fee_id(from._internal_base_fee_id());
  }
  if (cached_has_bits & 0x00000004u) {
    _this->_internal_set_memo(from._internal_memo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Transfer::CopyFrom(const Transfer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Transfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transfer::IsInitialized() const {
  return true;
}

void Transfer::InternalSwap(Transfer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_fee_amount_, lhs_arena,
      &other->_impl_.contract_fee_amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_fee_id_, lhs_arena,
      &other->_impl_.contract_fee_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_fee_amount_, lhs_arena,
      &other->_impl_.base_fee_amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_fee_id_, lhs_arena,
      &other->_impl_.base_fee_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.memo_, lhs_arena,
      &other->_impl_.memo_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Transfer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[20]);
}

// ===================================================================

class BurnSBTTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const BurnSBTTXN* msg);
};

const ::zera_txn::BaseTXN&
BurnSBTTXN::_Internal::base(const BurnSBTTXN* msg) {
  return *msg->_impl_.base_;
}
BurnSBTTXN::BurnSBTTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.BurnSBTTXN)
}
BurnSBTTXN::BurnSBTTXN(const BurnSBTTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BurnSBTTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_item_id().empty()) {
    _this->_impl_.item_id_.Set(from._internal_item_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.BurnSBTTXN)
}

inline void BurnSBTTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BurnSBTTXN::~BurnSBTTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.BurnSBTTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BurnSBTTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.item_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void BurnSBTTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BurnSBTTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.BurnSBTTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.item_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BurnSBTTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.BurnSBTTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_item_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.BurnSBTTXN.item_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BurnSBTTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.BurnSBTTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.BurnSBTTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // string item_id = 3;
  if (!this->_internal_item_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_item_id().data(), static_cast<int>(this->_internal_item_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.BurnSBTTXN.item_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.BurnSBTTXN)
  return target;
}

size_t BurnSBTTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.BurnSBTTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string item_id = 3;
  if (!this->_internal_item_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_item_id());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BurnSBTTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BurnSBTTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BurnSBTTXN::GetClassData() const { return &_class_data_; }


void BurnSBTTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BurnSBTTXN*>(&to_msg);
  auto& from = static_cast<const BurnSBTTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.BurnSBTTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_item_id().empty()) {
    _this->_internal_set_item_id(from._internal_item_id());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BurnSBTTXN::CopyFrom(const BurnSBTTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.BurnSBTTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BurnSBTTXN::IsInitialized() const {
  return true;
}

void BurnSBTTXN::InternalSwap(BurnSBTTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.item_id_, lhs_arena,
      &other->_impl_.item_id_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BurnSBTTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[21]);
}

// ===================================================================

class BaseTXN::_Internal {
 public:
  using HasBits = decltype(std::declval<BaseTXN>()._impl_._has_bits_);
  static const ::zera_txn::PublicKey& public_key(const BaseTXN* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const BaseTXN* msg);
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_memo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_safe_send(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_interface_fee(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_interface_fee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_interface_address(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::zera_txn::PublicKey&
BaseTXN::_Internal::public_key(const BaseTXN* msg) {
  return *msg->_impl_.public_key_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
BaseTXN::_Internal::timestamp(const BaseTXN* msg) {
  return *msg->_impl_.timestamp_;
}
void BaseTXN::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
BaseTXN::BaseTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.BaseTXN)
}
BaseTXN::BaseTXN(const BaseTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BaseTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fee_amount_){}
    , decltype(_impl_.fee_id_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.memo_){}
    , decltype(_impl_.interface_fee_){}
    , decltype(_impl_.interface_fee_id_){}
    , decltype(_impl_.interface_address_){}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.nonce_){}
    , decltype(_impl_.safe_send_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee_amount().empty()) {
    _this->_impl_.fee_amount_.Set(from._internal_fee_amount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee_id().empty()) {
    _this->_impl_.fee_id_.Set(from._internal_fee_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.memo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_memo()) {
    _this->_impl_.memo_.Set(from._internal_memo(), 
      _this->GetArenaForAllocation());
  }
  _impl_.interface_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_interface_fee()) {
    _this->_impl_.interface_fee_.Set(from._internal_interface_fee(), 
      _this->GetArenaForAllocation());
  }
  _impl_.interface_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_interface_fee_id()) {
    _this->_impl_.interface_fee_id_.Set(from._internal_interface_fee_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.interface_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_interface_address()) {
    _this->_impl_.interface_address_.Set(from._internal_interface_address(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_ = new ::zera_txn::PublicKey(*from._impl_.public_key_);
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.nonce_, &from._impl_.nonce_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.safe_send_) -
    reinterpret_cast<char*>(&_impl_.nonce_)) + sizeof(_impl_.safe_send_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.BaseTXN)
}

inline void BaseTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fee_amount_){}
    , decltype(_impl_.fee_id_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.memo_){}
    , decltype(_impl_.interface_fee_){}
    , decltype(_impl_.interface_fee_id_){}
    , decltype(_impl_.interface_address_){}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.nonce_){uint64_t{0u}}
    , decltype(_impl_.safe_send_){false}
  };
  _impl_.fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.memo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BaseTXN::~BaseTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.BaseTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BaseTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fee_amount_.Destroy();
  _impl_.fee_id_.Destroy();
  _impl_.signature_.Destroy();
  _impl_.hash_.Destroy();
  _impl_.memo_.Destroy();
  _impl_.interface_fee_.Destroy();
  _impl_.interface_fee_id_.Destroy();
  _impl_.interface_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.public_key_;
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void BaseTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BaseTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.BaseTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fee_amount_.ClearToEmpty();
  _impl_.fee_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.memo_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.interface_fee_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.interface_fee_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.interface_address_.ClearNonDefaultToEmpty();
    }
  }
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  _impl_.nonce_ = uint64_t{0u};
  _impl_.safe_send_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BaseTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.PublicKey public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string fee_amount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fee_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.BaseTXN.fee_amount"));
        } else
          goto handle_unusual;
        continue;
      // string fee_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_fee_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.BaseTXN.fee_id"));
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hash = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string memo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_memo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.BaseTXN.memo"));
        } else
          goto handle_unusual;
        continue;
      // optional bool safe_send = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_safe_send(&has_bits);
          _impl_.safe_send_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 nonce = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string interface_fee = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_interface_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.BaseTXN.interface_fee"));
        } else
          goto handle_unusual;
        continue;
      // optional string interface_fee_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_interface_fee_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.BaseTXN.interface_fee_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string interface_address = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_interface_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.BaseTXN.interface_address"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.BaseTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.PublicKey public_key = 1;
  if (this->_internal_has_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp timestamp = 3;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // string fee_amount = 4;
  if (!this->_internal_fee_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fee_amount().data(), static_cast<int>(this->_internal_fee_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.BaseTXN.fee_amount");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_fee_amount(), target);
  }

  // string fee_id = 5;
  if (!this->_internal_fee_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fee_id().data(), static_cast<int>(this->_internal_fee_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.BaseTXN.fee_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_fee_id(), target);
  }

  // optional bytes signature = 6;
  if (_internal_has_signature()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_signature(), target);
  }

  // optional bytes hash = 7;
  if (_internal_has_hash()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_hash(), target);
  }

  // optional string memo = 8;
  if (_internal_has_memo()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_memo().data(), static_cast<int>(this->_internal_memo().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.BaseTXN.memo");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_memo(), target);
  }

  // optional bool safe_send = 9;
  if (_internal_has_safe_send()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_safe_send(), target);
  }

  // uint64 nonce = 10;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_nonce(), target);
  }

  // optional string interface_fee = 11;
  if (_internal_has_interface_fee()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_interface_fee().data(), static_cast<int>(this->_internal_interface_fee().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.BaseTXN.interface_fee");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_interface_fee(), target);
  }

  // optional string interface_fee_id = 12;
  if (_internal_has_interface_fee_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_interface_fee_id().data(), static_cast<int>(this->_internal_interface_fee_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.BaseTXN.interface_fee_id");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_interface_fee_id(), target);
  }

  // optional string interface_address = 13;
  if (_internal_has_interface_address()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_interface_address().data(), static_cast<int>(this->_internal_interface_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.BaseTXN.interface_address");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_interface_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.BaseTXN)
  return target;
}

size_t BaseTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.BaseTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string fee_amount = 4;
  if (!this->_internal_fee_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fee_amount());
  }

  // string fee_id = 5;
  if (!this->_internal_fee_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fee_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes signature = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional bytes hash = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional string memo = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_memo());
    }

    // optional string interface_fee = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_interface_fee());
    }

    // optional string interface_fee_id = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_interface_fee_id());
    }

    // optional string interface_address = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_interface_address());
    }

  }
  // .zera_txn.PublicKey public_key = 1;
  if (this->_internal_has_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.public_key_);
  }

  // .google.protobuf.Timestamp timestamp = 3;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // uint64 nonce = 10;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nonce());
  }

  // optional bool safe_send = 9;
  if (cached_has_bits & 0x00000040u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BaseTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BaseTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BaseTXN::GetClassData() const { return &_class_data_; }


void BaseTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BaseTXN*>(&to_msg);
  auto& from = static_cast<const BaseTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.BaseTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_fee_amount().empty()) {
    _this->_internal_set_fee_amount(from._internal_fee_amount());
  }
  if (!from._internal_fee_id().empty()) {
    _this->_internal_set_fee_id(from._internal_fee_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_memo(from._internal_memo());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_interface_fee(from._internal_interface_fee());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_interface_fee_id(from._internal_interface_fee_id());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_interface_address(from._internal_interface_address());
    }
  }
  if (from._internal_has_public_key()) {
    _this->_internal_mutable_public_key()->::zera_txn::PublicKey::MergeFrom(
        from._internal_public_key());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  if (cached_has_bits & 0x00000040u) {
    _this->_internal_set_safe_send(from._internal_safe_send());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BaseTXN::CopyFrom(const BaseTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.BaseTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseTXN::IsInitialized() const {
  return true;
}

void BaseTXN::InternalSwap(BaseTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fee_amount_, lhs_arena,
      &other->_impl_.fee_amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fee_id_, lhs_arena,
      &other->_impl_.fee_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.memo_, lhs_arena,
      &other->_impl_.memo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_fee_, lhs_arena,
      &other->_impl_.interface_fee_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_fee_id_, lhs_arena,
      &other->_impl_.interface_fee_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_address_, lhs_arena,
      &other->_impl_.interface_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseTXN, _impl_.safe_send_)
      + sizeof(BaseTXN::_impl_.safe_send_)
      - PROTOBUF_FIELD_OFFSET(BaseTXN, _impl_.public_key_)>(
          reinterpret_cast<char*>(&_impl_.public_key_),
          reinterpret_cast<char*>(&other->_impl_.public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BaseTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[22]);
}

// ===================================================================

class PublicKey::_Internal {
 public:
  using HasBits = decltype(std::declval<PublicKey>()._impl_._has_bits_);
  static const ::zera_txn::MultiKey& multi(const PublicKey* msg);
  static void set_has_smart_contract_auth(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_governance_auth(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::zera_txn::MultiKey&
PublicKey::_Internal::multi(const PublicKey* msg) {
  return *msg->_impl_.multi_;
}
PublicKey::PublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.PublicKey)
}
PublicKey::PublicKey(const PublicKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PublicKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.single_){}
    , decltype(_impl_.smart_contract_auth_){}
    , decltype(_impl_.governance_auth_){}
    , decltype(_impl_.multi_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.single_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.single_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_single().empty()) {
    _this->_impl_.single_.Set(from._internal_single(), 
      _this->GetArenaForAllocation());
  }
  _impl_.smart_contract_auth_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_auth_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_smart_contract_auth()) {
    _this->_impl_.smart_contract_auth_.Set(from._internal_smart_contract_auth(), 
      _this->GetArenaForAllocation());
  }
  _impl_.governance_auth_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.governance_auth_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_governance_auth()) {
    _this->_impl_.governance_auth_.Set(from._internal_governance_auth(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_multi()) {
    _this->_impl_.multi_ = new ::zera_txn::MultiKey(*from._impl_.multi_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.PublicKey)
}

inline void PublicKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.single_){}
    , decltype(_impl_.smart_contract_auth_){}
    , decltype(_impl_.governance_auth_){}
    , decltype(_impl_.multi_){nullptr}
  };
  _impl_.single_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.single_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.smart_contract_auth_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_auth_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.governance_auth_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.governance_auth_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PublicKey::~PublicKey() {
  // @@protoc_insertion_point(destructor:zera_txn.PublicKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PublicKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.single_.Destroy();
  _impl_.smart_contract_auth_.Destroy();
  _impl_.governance_auth_.Destroy();
  if (this != internal_default_instance()) delete _impl_.multi_;
}

void PublicKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.PublicKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.single_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.smart_contract_auth_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.governance_auth_.ClearNonDefaultToEmpty();
    }
  }
  if (GetArenaForAllocation() == nullptr && _impl_.multi_ != nullptr) {
    delete _impl_.multi_;
  }
  _impl_.multi_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PublicKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes single = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_single();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.MultiKey multi = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_multi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes smart_contract_auth = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_smart_contract_auth();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes governance_auth = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_governance_auth();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PublicKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.PublicKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes single = 1;
  if (!this->_internal_single().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_single(), target);
  }

  // .zera_txn.MultiKey multi = 2;
  if (this->_internal_has_multi()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::multi(this),
        _Internal::multi(this).GetCachedSize(), target, stream);
  }

  // optional bytes smart_contract_auth = 3;
  if (_internal_has_smart_contract_auth()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_smart_contract_auth(), target);
  }

  // optional bytes governance_auth = 4;
  if (_internal_has_governance_auth()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_governance_auth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.PublicKey)
  return target;
}

size_t PublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.PublicKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes single = 1;
  if (!this->_internal_single().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_single());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes smart_contract_auth = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_smart_contract_auth());
    }

    // optional bytes governance_auth = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_governance_auth());
    }

  }
  // .zera_txn.MultiKey multi = 2;
  if (this->_internal_has_multi()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.multi_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PublicKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PublicKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PublicKey::GetClassData() const { return &_class_data_; }


void PublicKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PublicKey*>(&to_msg);
  auto& from = static_cast<const PublicKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.PublicKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_single().empty()) {
    _this->_internal_set_single(from._internal_single());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_smart_contract_auth(from._internal_smart_contract_auth());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_governance_auth(from._internal_governance_auth());
    }
  }
  if (from._internal_has_multi()) {
    _this->_internal_mutable_multi()->::zera_txn::MultiKey::MergeFrom(
        from._internal_multi());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PublicKey::CopyFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKey::IsInitialized() const {
  return true;
}

void PublicKey::InternalSwap(PublicKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.single_, lhs_arena,
      &other->_impl_.single_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.smart_contract_auth_, lhs_arena,
      &other->_impl_.smart_contract_auth_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.governance_auth_, lhs_arena,
      &other->_impl_.governance_auth_, rhs_arena
  );
  swap(_impl_.multi_, other->_impl_.multi_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PublicKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[23]);
}

// ===================================================================

class GovernanceAuth::_Internal {
 public:
};

GovernanceAuth::GovernanceAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.GovernanceAuth)
}
GovernanceAuth::GovernanceAuth(const GovernanceAuth& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GovernanceAuth* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.auth_){}
    , decltype(_impl_.proposal_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.auth_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_auth().empty()) {
    _this->_impl_.auth_.Set(from._internal_auth(), 
      _this->GetArenaForAllocation());
  }
  _impl_.proposal_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_proposal_id().empty()) {
    _this->_impl_.proposal_id_.Set(from._internal_proposal_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.GovernanceAuth)
}

inline void GovernanceAuth::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.auth_){}
    , decltype(_impl_.proposal_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.auth_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.proposal_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GovernanceAuth::~GovernanceAuth() {
  // @@protoc_insertion_point(destructor:zera_txn.GovernanceAuth)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GovernanceAuth::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.auth_.Destroy();
  _impl_.proposal_id_.Destroy();
}

void GovernanceAuth::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GovernanceAuth::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.GovernanceAuth)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.auth_.ClearToEmpty();
  _impl_.proposal_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GovernanceAuth::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes auth = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_auth();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes proposal_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_proposal_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GovernanceAuth::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.GovernanceAuth)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes auth = 1;
  if (!this->_internal_auth().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_auth(), target);
  }

  // bytes proposal_id = 2;
  if (!this->_internal_proposal_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_proposal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.GovernanceAuth)
  return target;
}

size_t GovernanceAuth::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.GovernanceAuth)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes auth = 1;
  if (!this->_internal_auth().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_auth());
  }

  // bytes proposal_id = 2;
  if (!this->_internal_proposal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_proposal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GovernanceAuth::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GovernanceAuth::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GovernanceAuth::GetClassData() const { return &_class_data_; }


void GovernanceAuth::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GovernanceAuth*>(&to_msg);
  auto& from = static_cast<const GovernanceAuth&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.GovernanceAuth)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_auth().empty()) {
    _this->_internal_set_auth(from._internal_auth());
  }
  if (!from._internal_proposal_id().empty()) {
    _this->_internal_set_proposal_id(from._internal_proposal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GovernanceAuth::CopyFrom(const GovernanceAuth& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.GovernanceAuth)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GovernanceAuth::IsInitialized() const {
  return true;
}

void GovernanceAuth::InternalSwap(GovernanceAuth* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_, lhs_arena,
      &other->_impl_.auth_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.proposal_id_, lhs_arena,
      &other->_impl_.proposal_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GovernanceAuth::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[24]);
}

// ===================================================================

class MultiKey::_Internal {
 public:
};

MultiKey::MultiKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.MultiKey)
}
MultiKey::MultiKey(const MultiKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MultiKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.public_keys_){from._impl_.public_keys_}
    , decltype(_impl_.signatures_){from._impl_.signatures_}
    , decltype(_impl_.multi_patterns_){from._impl_.multi_patterns_}
    , decltype(_impl_.hash_tokens_){from._impl_.hash_tokens_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_txn.MultiKey)
}

inline void MultiKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.public_keys_){arena}
    , decltype(_impl_.signatures_){arena}
    , decltype(_impl_.multi_patterns_){arena}
    , decltype(_impl_.hash_tokens_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MultiKey::~MultiKey() {
  // @@protoc_insertion_point(destructor:zera_txn.MultiKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MultiKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.public_keys_.~RepeatedPtrField();
  _impl_.signatures_.~RepeatedPtrField();
  _impl_.multi_patterns_.~RepeatedPtrField();
  _impl_.hash_tokens_.~RepeatedPtrField();
}

void MultiKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MultiKey::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.MultiKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.public_keys_.Clear();
  _impl_.signatures_.Clear();
  _impl_.multi_patterns_.Clear();
  _impl_.hash_tokens_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MultiKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes public_keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_public_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes signatures = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signatures();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.MultiPatterns multi_patterns = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_multi_patterns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string hash_tokens = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hash_tokens();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.MultiKey.hash_tokens"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MultiKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.MultiKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes public_keys = 1;
  for (int i = 0, n = this->_internal_public_keys_size(); i < n; i++) {
    const auto& s = this->_internal_public_keys(i);
    target = stream->WriteBytes(1, s, target);
  }

  // repeated bytes signatures = 2;
  for (int i = 0, n = this->_internal_signatures_size(); i < n; i++) {
    const auto& s = this->_internal_signatures(i);
    target = stream->WriteBytes(2, s, target);
  }

  // repeated .zera_txn.MultiPatterns multi_patterns = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_multi_patterns_size()); i < n; i++) {
    const auto& repfield = this->_internal_multi_patterns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string hash_tokens = 4;
  for (int i = 0, n = this->_internal_hash_tokens_size(); i < n; i++) {
    const auto& s = this->_internal_hash_tokens(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.MultiKey.hash_tokens");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.MultiKey)
  return target;
}

size_t MultiKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.MultiKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes public_keys = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.public_keys_.size());
  for (int i = 0, n = _impl_.public_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.public_keys_.Get(i));
  }

  // repeated bytes signatures = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signatures_.size());
  for (int i = 0, n = _impl_.signatures_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.signatures_.Get(i));
  }

  // repeated .zera_txn.MultiPatterns multi_patterns = 3;
  total_size += 1UL * this->_internal_multi_patterns_size();
  for (const auto& msg : this->_impl_.multi_patterns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string hash_tokens = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hash_tokens_.size());
  for (int i = 0, n = _impl_.hash_tokens_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.hash_tokens_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MultiKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MultiKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MultiKey::GetClassData() const { return &_class_data_; }


void MultiKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MultiKey*>(&to_msg);
  auto& from = static_cast<const MultiKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.MultiKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.public_keys_.MergeFrom(from._impl_.public_keys_);
  _this->_impl_.signatures_.MergeFrom(from._impl_.signatures_);
  _this->_impl_.multi_patterns_.MergeFrom(from._impl_.multi_patterns_);
  _this->_impl_.hash_tokens_.MergeFrom(from._impl_.hash_tokens_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MultiKey::CopyFrom(const MultiKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.MultiKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiKey::IsInitialized() const {
  return true;
}

void MultiKey::InternalSwap(MultiKey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.public_keys_.InternalSwap(&other->_impl_.public_keys_);
  _impl_.signatures_.InternalSwap(&other->_impl_.signatures_);
  _impl_.multi_patterns_.InternalSwap(&other->_impl_.multi_patterns_);
  _impl_.hash_tokens_.InternalSwap(&other->_impl_.hash_tokens_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MultiKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[25]);
}

// ===================================================================

class MultiPatterns::_Internal {
 public:
};

MultiPatterns::MultiPatterns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.MultiPatterns)
}
MultiPatterns::MultiPatterns(const MultiPatterns& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MultiPatterns* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){from._impl_.class__}
    , /*decltype(_impl_._class__cached_byte_size_)*/{0}
    , decltype(_impl_.required_){from._impl_.required_}
    , /*decltype(_impl_._required_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_txn.MultiPatterns)
}

inline void MultiPatterns::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){arena}
    , /*decltype(_impl_._class__cached_byte_size_)*/{0}
    , decltype(_impl_.required_){arena}
    , /*decltype(_impl_._required_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MultiPatterns::~MultiPatterns() {
  // @@protoc_insertion_point(destructor:zera_txn.MultiPatterns)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MultiPatterns::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.~RepeatedField();
  _impl_.required_.~RepeatedField();
}

void MultiPatterns::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MultiPatterns::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.MultiPatterns)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.Clear();
  _impl_.required_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MultiPatterns::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_class_(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_class_(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 required = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_required(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_required(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MultiPatterns::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.MultiPatterns)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 class = 1;
  {
    int byte_size = _impl_._class__cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_class_(), byte_size, target);
    }
  }

  // repeated uint32 required = 2;
  {
    int byte_size = _impl_._required_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_required(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.MultiPatterns)
  return target;
}

size_t MultiPatterns::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.MultiPatterns)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 class = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.class__);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._class__cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 required = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.required_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._required_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MultiPatterns::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MultiPatterns::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MultiPatterns::GetClassData() const { return &_class_data_; }


void MultiPatterns::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MultiPatterns*>(&to_msg);
  auto& from = static_cast<const MultiPatterns&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.MultiPatterns)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.class__.MergeFrom(from._impl_.class__);
  _this->_impl_.required_.MergeFrom(from._impl_.required_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MultiPatterns::CopyFrom(const MultiPatterns& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.MultiPatterns)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiPatterns::IsInitialized() const {
  return true;
}

void MultiPatterns::InternalSwap(MultiPatterns* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.class__.InternalSwap(&other->_impl_.class__);
  _impl_.required_.InternalSwap(&other->_impl_.required_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MultiPatterns::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[26]);
}

// ===================================================================

class SelfCurrencyEquiv::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const SelfCurrencyEquiv* msg);
};

const ::zera_txn::BaseTXN&
SelfCurrencyEquiv::_Internal::base(const SelfCurrencyEquiv* msg) {
  return *msg->_impl_.base_;
}
SelfCurrencyEquiv::SelfCurrencyEquiv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.SelfCurrencyEquiv)
}
SelfCurrencyEquiv::SelfCurrencyEquiv(const SelfCurrencyEquiv& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SelfCurrencyEquiv* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cur_equiv_){from._impl_.cur_equiv_}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.SelfCurrencyEquiv)
}

inline void SelfCurrencyEquiv::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cur_equiv_){arena}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SelfCurrencyEquiv::~SelfCurrencyEquiv() {
  // @@protoc_insertion_point(destructor:zera_txn.SelfCurrencyEquiv)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelfCurrencyEquiv::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cur_equiv_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void SelfCurrencyEquiv::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SelfCurrencyEquiv::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.SelfCurrencyEquiv)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cur_equiv_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelfCurrencyEquiv::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cur_equiv(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelfCurrencyEquiv::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.SelfCurrencyEquiv)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cur_equiv_size()); i < n; i++) {
    const auto& repfield = this->_internal_cur_equiv(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.SelfCurrencyEquiv)
  return target;
}

size_t SelfCurrencyEquiv::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.SelfCurrencyEquiv)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
  total_size += 1UL * this->_internal_cur_equiv_size();
  for (const auto& msg : this->_impl_.cur_equiv_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelfCurrencyEquiv::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SelfCurrencyEquiv::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelfCurrencyEquiv::GetClassData() const { return &_class_data_; }


void SelfCurrencyEquiv::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SelfCurrencyEquiv*>(&to_msg);
  auto& from = static_cast<const SelfCurrencyEquiv&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.SelfCurrencyEquiv)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cur_equiv_.MergeFrom(from._impl_.cur_equiv_);
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelfCurrencyEquiv::CopyFrom(const SelfCurrencyEquiv& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.SelfCurrencyEquiv)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelfCurrencyEquiv::IsInitialized() const {
  return true;
}

void SelfCurrencyEquiv::InternalSwap(SelfCurrencyEquiv* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cur_equiv_.InternalSwap(&other->_impl_.cur_equiv_);
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SelfCurrencyEquiv::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[27]);
}

// ===================================================================

class AuthorizedCurrencyEquiv::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const AuthorizedCurrencyEquiv* msg);
};

const ::zera_txn::BaseTXN&
AuthorizedCurrencyEquiv::_Internal::base(const AuthorizedCurrencyEquiv* msg) {
  return *msg->_impl_.base_;
}
AuthorizedCurrencyEquiv::AuthorizedCurrencyEquiv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.AuthorizedCurrencyEquiv)
}
AuthorizedCurrencyEquiv::AuthorizedCurrencyEquiv(const AuthorizedCurrencyEquiv& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthorizedCurrencyEquiv* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cur_equiv_){from._impl_.cur_equiv_}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.AuthorizedCurrencyEquiv)
}

inline void AuthorizedCurrencyEquiv::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cur_equiv_){arena}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AuthorizedCurrencyEquiv::~AuthorizedCurrencyEquiv() {
  // @@protoc_insertion_point(destructor:zera_txn.AuthorizedCurrencyEquiv)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthorizedCurrencyEquiv::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cur_equiv_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void AuthorizedCurrencyEquiv::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthorizedCurrencyEquiv::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.AuthorizedCurrencyEquiv)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cur_equiv_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthorizedCurrencyEquiv::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cur_equiv(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthorizedCurrencyEquiv::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.AuthorizedCurrencyEquiv)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cur_equiv_size()); i < n; i++) {
    const auto& repfield = this->_internal_cur_equiv(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.AuthorizedCurrencyEquiv)
  return target;
}

size_t AuthorizedCurrencyEquiv::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.AuthorizedCurrencyEquiv)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.CurrencyEquiv cur_equiv = 2;
  total_size += 1UL * this->_internal_cur_equiv_size();
  for (const auto& msg : this->_impl_.cur_equiv_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthorizedCurrencyEquiv::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthorizedCurrencyEquiv::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthorizedCurrencyEquiv::GetClassData() const { return &_class_data_; }


void AuthorizedCurrencyEquiv::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthorizedCurrencyEquiv*>(&to_msg);
  auto& from = static_cast<const AuthorizedCurrencyEquiv&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.AuthorizedCurrencyEquiv)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cur_equiv_.MergeFrom(from._impl_.cur_equiv_);
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthorizedCurrencyEquiv::CopyFrom(const AuthorizedCurrencyEquiv& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.AuthorizedCurrencyEquiv)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthorizedCurrencyEquiv::IsInitialized() const {
  return true;
}

void AuthorizedCurrencyEquiv::InternalSwap(AuthorizedCurrencyEquiv* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cur_equiv_.InternalSwap(&other->_impl_.cur_equiv_);
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthorizedCurrencyEquiv::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[28]);
}

// ===================================================================

class CurrencyEquiv::_Internal {
 public:
  using HasBits = decltype(std::declval<CurrencyEquiv>()._impl_._has_bits_);
  static void set_has_authorized(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_stake(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CurrencyEquiv::CurrencyEquiv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.CurrencyEquiv)
}
CurrencyEquiv::CurrencyEquiv(const CurrencyEquiv& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CurrencyEquiv* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.rate_){}
    , decltype(_impl_.max_stake_){}
    , decltype(_impl_.authorized_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rate().empty()) {
    _this->_impl_.rate_.Set(from._internal_rate(), 
      _this->GetArenaForAllocation());
  }
  _impl_.max_stake_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_stake_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_max_stake()) {
    _this->_impl_.max_stake_.Set(from._internal_max_stake(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.authorized_ = from._impl_.authorized_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.CurrencyEquiv)
}

inline void CurrencyEquiv::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.rate_){}
    , decltype(_impl_.max_stake_){}
    , decltype(_impl_.authorized_){false}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.max_stake_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_stake_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CurrencyEquiv::~CurrencyEquiv() {
  // @@protoc_insertion_point(destructor:zera_txn.CurrencyEquiv)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CurrencyEquiv::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.rate_.Destroy();
  _impl_.max_stake_.Destroy();
}

void CurrencyEquiv::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CurrencyEquiv::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.CurrencyEquiv)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.rate_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.max_stake_.ClearNonDefaultToEmpty();
  }
  _impl_.authorized_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CurrencyEquiv::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.CurrencyEquiv.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string rate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.CurrencyEquiv.rate"));
        } else
          goto handle_unusual;
        continue;
      // optional bool authorized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_authorized(&has_bits);
          _impl_.authorized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string max_stake = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_max_stake();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.CurrencyEquiv.max_stake"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CurrencyEquiv::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.CurrencyEquiv)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.CurrencyEquiv.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // string rate = 2;
  if (!this->_internal_rate().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_rate().data(), static_cast<int>(this->_internal_rate().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.CurrencyEquiv.rate");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_rate(), target);
  }

  // optional bool authorized = 3;
  if (_internal_has_authorized()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_authorized(), target);
  }

  // optional string max_stake = 4;
  if (_internal_has_max_stake()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_max_stake().data(), static_cast<int>(this->_internal_max_stake().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.CurrencyEquiv.max_stake");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_max_stake(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.CurrencyEquiv)
  return target;
}

size_t CurrencyEquiv::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.CurrencyEquiv)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string rate = 2;
  if (!this->_internal_rate().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_rate());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string max_stake = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_max_stake());
    }

    // optional bool authorized = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CurrencyEquiv::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CurrencyEquiv::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CurrencyEquiv::GetClassData() const { return &_class_data_; }


void CurrencyEquiv::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CurrencyEquiv*>(&to_msg);
  auto& from = static_cast<const CurrencyEquiv&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.CurrencyEquiv)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_rate().empty()) {
    _this->_internal_set_rate(from._internal_rate());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_max_stake(from._internal_max_stake());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.authorized_ = from._impl_.authorized_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CurrencyEquiv::CopyFrom(const CurrencyEquiv& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.CurrencyEquiv)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CurrencyEquiv::IsInitialized() const {
  return true;
}

void CurrencyEquiv::InternalSwap(CurrencyEquiv* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rate_, lhs_arena,
      &other->_impl_.rate_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.max_stake_, lhs_arena,
      &other->_impl_.max_stake_, rhs_arena
  );
  swap(_impl_.authorized_, other->_impl_.authorized_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CurrencyEquiv::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[29]);
}

// ===================================================================

class ExpenseRatioResult::_Internal {
 public:
};

ExpenseRatioResult::ExpenseRatioResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ExpenseRatioResult)
}
ExpenseRatioResult::ExpenseRatioResult(const ExpenseRatioResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpenseRatioResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.wallets_){from._impl_.wallets_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.recipient_address_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash().empty()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.ExpenseRatioResult)
}

inline void ExpenseRatioResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.wallets_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.recipient_address_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExpenseRatioResult::~ExpenseRatioResult() {
  // @@protoc_insertion_point(destructor:zera_txn.ExpenseRatioResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpenseRatioResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wallets_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
  _impl_.hash_.Destroy();
  _impl_.recipient_address_.Destroy();
}

void ExpenseRatioResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpenseRatioResult::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ExpenseRatioResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wallets_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.hash_.ClearToEmpty();
  _impl_.recipient_address_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpenseRatioResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ExpenseRatioResult.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.Wallets wallets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_wallets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes hash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes recipient_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpenseRatioResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ExpenseRatioResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ExpenseRatioResult.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // repeated .zera_txn.Wallets wallets = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_wallets_size()); i < n; i++) {
    const auto& repfield = this->_internal_wallets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bytes hash = 3;
  if (!this->_internal_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_hash(), target);
  }

  // bytes recipient_address = 4;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_recipient_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ExpenseRatioResult)
  return target;
}

size_t ExpenseRatioResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ExpenseRatioResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.Wallets wallets = 2;
  total_size += 1UL * this->_internal_wallets_size();
  for (const auto& msg : this->_impl_.wallets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // bytes hash = 3;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  // bytes recipient_address = 4;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpenseRatioResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpenseRatioResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpenseRatioResult::GetClassData() const { return &_class_data_; }


void ExpenseRatioResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpenseRatioResult*>(&to_msg);
  auto& from = static_cast<const ExpenseRatioResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ExpenseRatioResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.wallets_.MergeFrom(from._impl_.wallets_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_hash().empty()) {
    _this->_internal_set_hash(from._internal_hash());
  }
  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpenseRatioResult::CopyFrom(const ExpenseRatioResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ExpenseRatioResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpenseRatioResult::IsInitialized() const {
  return true;
}

void ExpenseRatioResult::InternalSwap(ExpenseRatioResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.wallets_.InternalSwap(&other->_impl_.wallets_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpenseRatioResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[30]);
}

// ===================================================================

class ComplianceAssign::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& expiry(const ComplianceAssign* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
ComplianceAssign::_Internal::expiry(const ComplianceAssign* msg) {
  return *msg->_impl_.expiry_;
}
void ComplianceAssign::clear_expiry() {
  if (GetArenaForAllocation() == nullptr && _impl_.expiry_ != nullptr) {
    delete _impl_.expiry_;
  }
  _impl_.expiry_ = nullptr;
}
ComplianceAssign::ComplianceAssign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ComplianceAssign)
}
ComplianceAssign::ComplianceAssign(const ComplianceAssign& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ComplianceAssign* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_address_){}
    , decltype(_impl_.expiry_){nullptr}
    , decltype(_impl_.compliance_level_){}
    , decltype(_impl_.assign_revoke_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_expiry()) {
    _this->_impl_.expiry_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.expiry_);
  }
  ::memcpy(&_impl_.compliance_level_, &from._impl_.compliance_level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.assign_revoke_) -
    reinterpret_cast<char*>(&_impl_.compliance_level_)) + sizeof(_impl_.assign_revoke_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.ComplianceAssign)
}

inline void ComplianceAssign::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_address_){}
    , decltype(_impl_.expiry_){nullptr}
    , decltype(_impl_.compliance_level_){0u}
    , decltype(_impl_.assign_revoke_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ComplianceAssign::~ComplianceAssign() {
  // @@protoc_insertion_point(destructor:zera_txn.ComplianceAssign)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ComplianceAssign::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recipient_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.expiry_;
}

void ComplianceAssign::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ComplianceAssign::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ComplianceAssign)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recipient_address_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.expiry_ != nullptr) {
    delete _impl_.expiry_;
  }
  _impl_.expiry_ = nullptr;
  ::memset(&_impl_.compliance_level_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.assign_revoke_) -
      reinterpret_cast<char*>(&_impl_.compliance_level_)) + sizeof(_impl_.assign_revoke_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ComplianceAssign::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes recipient_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 compliance_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.compliance_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool assign_revoke = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.assign_revoke_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp expiry = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_expiry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComplianceAssign::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ComplianceAssign)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_recipient_address(), target);
  }

  // uint32 compliance_level = 2;
  if (this->_internal_compliance_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_compliance_level(), target);
  }

  // bool assign_revoke = 3;
  if (this->_internal_assign_revoke() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_assign_revoke(), target);
  }

  // .google.protobuf.Timestamp expiry = 4;
  if (this->_internal_has_expiry()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::expiry(this),
        _Internal::expiry(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ComplianceAssign)
  return target;
}

size_t ComplianceAssign::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ComplianceAssign)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  // .google.protobuf.Timestamp expiry = 4;
  if (this->_internal_has_expiry()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expiry_);
  }

  // uint32 compliance_level = 2;
  if (this->_internal_compliance_level() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_compliance_level());
  }

  // bool assign_revoke = 3;
  if (this->_internal_assign_revoke() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ComplianceAssign::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ComplianceAssign::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ComplianceAssign::GetClassData() const { return &_class_data_; }


void ComplianceAssign::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ComplianceAssign*>(&to_msg);
  auto& from = static_cast<const ComplianceAssign&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ComplianceAssign)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  if (from._internal_has_expiry()) {
    _this->_internal_mutable_expiry()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_expiry());
  }
  if (from._internal_compliance_level() != 0) {
    _this->_internal_set_compliance_level(from._internal_compliance_level());
  }
  if (from._internal_assign_revoke() != 0) {
    _this->_internal_set_assign_revoke(from._internal_assign_revoke());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ComplianceAssign::CopyFrom(const ComplianceAssign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ComplianceAssign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComplianceAssign::IsInitialized() const {
  return true;
}

void ComplianceAssign::InternalSwap(ComplianceAssign* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ComplianceAssign, _impl_.assign_revoke_)
      + sizeof(ComplianceAssign::_impl_.assign_revoke_)
      - PROTOBUF_FIELD_OFFSET(ComplianceAssign, _impl_.expiry_)>(
          reinterpret_cast<char*>(&_impl_.expiry_),
          reinterpret_cast<char*>(&other->_impl_.expiry_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ComplianceAssign::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[31]);
}

// ===================================================================

class ComplianceTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const ComplianceTXN* msg);
};

const ::zera_txn::BaseTXN&
ComplianceTXN::_Internal::base(const ComplianceTXN* msg) {
  return *msg->_impl_.base_;
}
ComplianceTXN::ComplianceTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ComplianceTXN)
}
ComplianceTXN::ComplianceTXN(const ComplianceTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ComplianceTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.compliance_){from._impl_.compliance_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.ComplianceTXN)
}

inline void ComplianceTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.compliance_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ComplianceTXN::~ComplianceTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.ComplianceTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ComplianceTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.compliance_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void ComplianceTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ComplianceTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ComplianceTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.compliance_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ComplianceTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ComplianceTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ComplianceAssign compliance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_compliance(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComplianceTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ComplianceTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ComplianceTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // repeated .zera_txn.ComplianceAssign compliance = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_compliance_size()); i < n; i++) {
    const auto& repfield = this->_internal_compliance(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ComplianceTXN)
  return target;
}

size_t ComplianceTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ComplianceTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.ComplianceAssign compliance = 3;
  total_size += 1UL * this->_internal_compliance_size();
  for (const auto& msg : this->_impl_.compliance_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ComplianceTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ComplianceTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ComplianceTXN::GetClassData() const { return &_class_data_; }


void ComplianceTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ComplianceTXN*>(&to_msg);
  auto& from = static_cast<const ComplianceTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ComplianceTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.compliance_.MergeFrom(from._impl_.compliance_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ComplianceTXN::CopyFrom(const ComplianceTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ComplianceTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComplianceTXN::IsInitialized() const {
  return true;
}

void ComplianceTXN::InternalSwap(ComplianceTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.compliance_.InternalSwap(&other->_impl_.compliance_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ComplianceTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[32]);
}

// ===================================================================

class Wallets::_Internal {
 public:
};

Wallets::Wallets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Wallets)
}
Wallets::Wallets(const Wallets& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Wallets* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.Wallets)
}

inline void Wallets::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Wallets::~Wallets() {
  // @@protoc_insertion_point(destructor:zera_txn.Wallets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Wallets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
  _impl_.amount_.Destroy();
}

void Wallets::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Wallets::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Wallets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Wallets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Wallets.amount"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Wallets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Wallets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_address(), target);
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Wallets.amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Wallets)
  return target;
}

size_t Wallets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Wallets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_address());
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Wallets::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Wallets::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Wallets::GetClassData() const { return &_class_data_; }


void Wallets::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Wallets*>(&to_msg);
  auto& from = static_cast<const Wallets&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Wallets)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Wallets::CopyFrom(const Wallets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Wallets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Wallets::IsInitialized() const {
  return true;
}

void Wallets::InternalSwap(Wallets* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Wallets::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[33]);
}

// ===================================================================

class QuashTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const QuashTXN* msg);
};

const ::zera_txn::BaseTXN&
QuashTXN::_Internal::base(const QuashTXN* msg) {
  return *msg->_impl_.base_;
}
QuashTXN::QuashTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.QuashTXN)
}
QuashTXN::QuashTXN(const QuashTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QuashTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.txn_hash_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_txn_hash().empty()) {
    _this->_impl_.txn_hash_.Set(from._internal_txn_hash(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.QuashTXN)
}

inline void QuashTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.txn_hash_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QuashTXN::~QuashTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.QuashTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuashTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.txn_hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void QuashTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuashTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.QuashTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.txn_hash_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QuashTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.QuashTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // bytes txn_hash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_txn_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuashTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.QuashTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.QuashTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // bytes txn_hash = 3;
  if (!this->_internal_txn_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_txn_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.QuashTXN)
  return target;
}

size_t QuashTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.QuashTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // bytes txn_hash = 3;
  if (!this->_internal_txn_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_txn_hash());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QuashTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QuashTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QuashTXN::GetClassData() const { return &_class_data_; }


void QuashTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QuashTXN*>(&to_msg);
  auto& from = static_cast<const QuashTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.QuashTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_txn_hash().empty()) {
    _this->_internal_set_txn_hash(from._internal_txn_hash());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QuashTXN::CopyFrom(const QuashTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.QuashTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuashTXN::IsInitialized() const {
  return true;
}

void QuashTXN::InternalSwap(QuashTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.txn_hash_, lhs_arena,
      &other->_impl_.txn_hash_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata QuashTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[34]);
}

// ===================================================================

class QuashResult::_Internal {
 public:
};

QuashResult::QuashResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.QuashResult)
}
QuashResult::QuashResult(const QuashResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QuashResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.public_keys_){from._impl_.public_keys_}
    , decltype(_impl_.txn_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_txn_hash().empty()) {
    _this->_impl_.txn_hash_.Set(from._internal_txn_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.QuashResult)
}

inline void QuashResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.public_keys_){arena}
    , decltype(_impl_.txn_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QuashResult::~QuashResult() {
  // @@protoc_insertion_point(destructor:zera_txn.QuashResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuashResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.public_keys_.~RepeatedPtrField();
  _impl_.txn_hash_.Destroy();
}

void QuashResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuashResult::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.QuashResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.public_keys_.Clear();
  _impl_.txn_hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QuashResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes txn_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_txn_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.PublicKey public_keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_public_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuashResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.QuashResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes txn_hash = 1;
  if (!this->_internal_txn_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_txn_hash(), target);
  }

  // repeated .zera_txn.PublicKey public_keys = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_public_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_public_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.QuashResult)
  return target;
}

size_t QuashResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.QuashResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.PublicKey public_keys = 2;
  total_size += 1UL * this->_internal_public_keys_size();
  for (const auto& msg : this->_impl_.public_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes txn_hash = 1;
  if (!this->_internal_txn_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_txn_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QuashResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QuashResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QuashResult::GetClassData() const { return &_class_data_; }


void QuashResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QuashResult*>(&to_msg);
  auto& from = static_cast<const QuashResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.QuashResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.public_keys_.MergeFrom(from._impl_.public_keys_);
  if (!from._internal_txn_hash().empty()) {
    _this->_internal_set_txn_hash(from._internal_txn_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QuashResult::CopyFrom(const QuashResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.QuashResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuashResult::IsInitialized() const {
  return true;
}

void QuashResult::InternalSwap(QuashResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.public_keys_.InternalSwap(&other->_impl_.public_keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.txn_hash_, lhs_arena,
      &other->_impl_.txn_hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata QuashResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[35]);
}

// ===================================================================

class CoinTXN::_Internal {
 public:
  using HasBits = decltype(std::declval<CoinTXN>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const CoinTXN* msg);
  static const ::zera_txn::TransferAuthentication& auth(const CoinTXN* msg);
  static void set_has_contract_fee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_contract_fee_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::zera_txn::BaseTXN&
CoinTXN::_Internal::base(const CoinTXN* msg) {
  return *msg->_impl_.base_;
}
const ::zera_txn::TransferAuthentication&
CoinTXN::_Internal::auth(const CoinTXN* msg) {
  return *msg->_impl_.auth_;
}
CoinTXN::CoinTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.CoinTXN)
}
CoinTXN::CoinTXN(const CoinTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CoinTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_transfers_){from._impl_.input_transfers_}
    , decltype(_impl_.output_transfers_){from._impl_.output_transfers_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.contract_fee_id_){}
    , decltype(_impl_.contract_fee_amount_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.auth_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_fee_id()) {
    _this->_impl_.contract_fee_id_.Set(from._internal_contract_fee_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_fee_amount()) {
    _this->_impl_.contract_fee_amount_.Set(from._internal_contract_fee_amount(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  if (from._internal_has_auth()) {
    _this->_impl_.auth_ = new ::zera_txn::TransferAuthentication(*from._impl_.auth_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.CoinTXN)
}

inline void CoinTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_transfers_){arena}
    , decltype(_impl_.output_transfers_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.contract_fee_id_){}
    , decltype(_impl_.contract_fee_amount_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.auth_){nullptr}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CoinTXN::~CoinTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.CoinTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoinTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_transfers_.~RepeatedPtrField();
  _impl_.output_transfers_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
  _impl_.contract_fee_id_.Destroy();
  _impl_.contract_fee_amount_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.auth_;
}

void CoinTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CoinTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.CoinTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_transfers_.Clear();
  _impl_.output_transfers_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.contract_fee_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.contract_fee_amount_.ClearNonDefaultToEmpty();
    }
  }
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.auth_ != nullptr) {
    delete _impl_.auth_;
  }
  _impl_.auth_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoinTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.CoinTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.TransferAuthentication auth = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_auth(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.InputTransfers input_transfers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input_transfers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.OutputTransfers output_transfers = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_output_transfers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string contract_fee_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_contract_fee_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.CoinTXN.contract_fee_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string contract_fee_amount = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_contract_fee_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.CoinTXN.contract_fee_amount"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoinTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.CoinTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.CoinTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // .zera_txn.TransferAuthentication auth = 3;
  if (this->_internal_has_auth()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::auth(this),
        _Internal::auth(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.InputTransfers input_transfers = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_transfers_size()); i < n; i++) {
    const auto& repfield = this->_internal_input_transfers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.OutputTransfers output_transfers = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_output_transfers_size()); i < n; i++) {
    const auto& repfield = this->_internal_output_transfers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string contract_fee_id = 6;
  if (_internal_has_contract_fee_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_fee_id().data(), static_cast<int>(this->_internal_contract_fee_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.CoinTXN.contract_fee_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_contract_fee_id(), target);
  }

  // optional string contract_fee_amount = 7;
  if (_internal_has_contract_fee_amount()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_fee_amount().data(), static_cast<int>(this->_internal_contract_fee_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.CoinTXN.contract_fee_amount");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_contract_fee_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.CoinTXN)
  return target;
}

size_t CoinTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.CoinTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.InputTransfers input_transfers = 4;
  total_size += 1UL * this->_internal_input_transfers_size();
  for (const auto& msg : this->_impl_.input_transfers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.OutputTransfers output_transfers = 5;
  total_size += 1UL * this->_internal_output_transfers_size();
  for (const auto& msg : this->_impl_.output_transfers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string contract_fee_id = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_fee_id());
    }

    // optional string contract_fee_amount = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_fee_amount());
    }

  }
  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // .zera_txn.TransferAuthentication auth = 3;
  if (this->_internal_has_auth()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.auth_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoinTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CoinTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoinTXN::GetClassData() const { return &_class_data_; }


void CoinTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CoinTXN*>(&to_msg);
  auto& from = static_cast<const CoinTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.CoinTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_transfers_.MergeFrom(from._impl_.input_transfers_);
  _this->_impl_.output_transfers_.MergeFrom(from._impl_.output_transfers_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_contract_fee_id(from._internal_contract_fee_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_contract_fee_amount(from._internal_contract_fee_amount());
    }
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  if (from._internal_has_auth()) {
    _this->_internal_mutable_auth()->::zera_txn::TransferAuthentication::MergeFrom(
        from._internal_auth());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoinTXN::CopyFrom(const CoinTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.CoinTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoinTXN::IsInitialized() const {
  return true;
}

void CoinTXN::InternalSwap(CoinTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.input_transfers_.InternalSwap(&other->_impl_.input_transfers_);
  _impl_.output_transfers_.InternalSwap(&other->_impl_.output_transfers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_fee_id_, lhs_arena,
      &other->_impl_.contract_fee_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_fee_amount_, lhs_arena,
      &other->_impl_.contract_fee_amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CoinTXN, _impl_.auth_)
      + sizeof(CoinTXN::_impl_.auth_)
      - PROTOBUF_FIELD_OFFSET(CoinTXN, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CoinTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[36]);
}

// ===================================================================

class TransferAuthentication::_Internal {
 public:
};

TransferAuthentication::TransferAuthentication(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.TransferAuthentication)
}
TransferAuthentication::TransferAuthentication(const TransferAuthentication& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransferAuthentication* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.public_key_){from._impl_.public_key_}
    , decltype(_impl_.signature_){from._impl_.signature_}
    , decltype(_impl_.nonce_){from._impl_.nonce_}
    , /*decltype(_impl_._nonce_cached_byte_size_)*/{0}
    , decltype(_impl_.allowance_address_){from._impl_.allowance_address_}
    , decltype(_impl_.allowance_nonce_){from._impl_.allowance_nonce_}
    , /*decltype(_impl_._allowance_nonce_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_txn.TransferAuthentication)
}

inline void TransferAuthentication::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.public_key_){arena}
    , decltype(_impl_.signature_){arena}
    , decltype(_impl_.nonce_){arena}
    , /*decltype(_impl_._nonce_cached_byte_size_)*/{0}
    , decltype(_impl_.allowance_address_){arena}
    , decltype(_impl_.allowance_nonce_){arena}
    , /*decltype(_impl_._allowance_nonce_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TransferAuthentication::~TransferAuthentication() {
  // @@protoc_insertion_point(destructor:zera_txn.TransferAuthentication)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransferAuthentication::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.public_key_.~RepeatedPtrField();
  _impl_.signature_.~RepeatedPtrField();
  _impl_.nonce_.~RepeatedField();
  _impl_.allowance_address_.~RepeatedPtrField();
  _impl_.allowance_nonce_.~RepeatedField();
}

void TransferAuthentication::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransferAuthentication::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.TransferAuthentication)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.public_key_.Clear();
  _impl_.signature_.Clear();
  _impl_.nonce_.Clear();
  _impl_.allowance_address_.Clear();
  _impl_.allowance_nonce_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransferAuthentication::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .zera_txn.PublicKey public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_public_key(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signature();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 nonce = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_nonce(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_nonce(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes allowance_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allowance_address();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 allowance_nonce = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_allowance_nonce(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_allowance_nonce(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransferAuthentication::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.TransferAuthentication)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .zera_txn.PublicKey public_key = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_public_key_size()); i < n; i++) {
    const auto& repfield = this->_internal_public_key(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated bytes signature = 2;
  for (int i = 0, n = this->_internal_signature_size(); i < n; i++) {
    const auto& s = this->_internal_signature(i);
    target = stream->WriteBytes(2, s, target);
  }

  // repeated uint64 nonce = 3;
  {
    int byte_size = _impl_._nonce_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          3, _internal_nonce(), byte_size, target);
    }
  }

  // repeated bytes allowance_address = 4;
  for (int i = 0, n = this->_internal_allowance_address_size(); i < n; i++) {
    const auto& s = this->_internal_allowance_address(i);
    target = stream->WriteBytes(4, s, target);
  }

  // repeated uint64 allowance_nonce = 5;
  {
    int byte_size = _impl_._allowance_nonce_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          5, _internal_allowance_nonce(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.TransferAuthentication)
  return target;
}

size_t TransferAuthentication::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.TransferAuthentication)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.PublicKey public_key = 1;
  total_size += 1UL * this->_internal_public_key_size();
  for (const auto& msg : this->_impl_.public_key_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bytes signature = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signature_.size());
  for (int i = 0, n = _impl_.signature_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.signature_.Get(i));
  }

  // repeated uint64 nonce = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.nonce_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._nonce_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bytes allowance_address = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.allowance_address_.size());
  for (int i = 0, n = _impl_.allowance_address_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.allowance_address_.Get(i));
  }

  // repeated uint64 allowance_nonce = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.allowance_nonce_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._allowance_nonce_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransferAuthentication::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransferAuthentication::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransferAuthentication::GetClassData() const { return &_class_data_; }


void TransferAuthentication::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransferAuthentication*>(&to_msg);
  auto& from = static_cast<const TransferAuthentication&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.TransferAuthentication)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.public_key_.MergeFrom(from._impl_.public_key_);
  _this->_impl_.signature_.MergeFrom(from._impl_.signature_);
  _this->_impl_.nonce_.MergeFrom(from._impl_.nonce_);
  _this->_impl_.allowance_address_.MergeFrom(from._impl_.allowance_address_);
  _this->_impl_.allowance_nonce_.MergeFrom(from._impl_.allowance_nonce_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransferAuthentication::CopyFrom(const TransferAuthentication& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.TransferAuthentication)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransferAuthentication::IsInitialized() const {
  return true;
}

void TransferAuthentication::InternalSwap(TransferAuthentication* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.public_key_.InternalSwap(&other->_impl_.public_key_);
  _impl_.signature_.InternalSwap(&other->_impl_.signature_);
  _impl_.nonce_.InternalSwap(&other->_impl_.nonce_);
  _impl_.allowance_address_.InternalSwap(&other->_impl_.allowance_address_);
  _impl_.allowance_nonce_.InternalSwap(&other->_impl_.allowance_nonce_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransferAuthentication::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[37]);
}

// ===================================================================

class InputTransfers::_Internal {
 public:
  using HasBits = decltype(std::declval<InputTransfers>()._impl_._has_bits_);
  static void set_has_contract_fee_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

InputTransfers::InputTransfers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.InputTransfers)
}
InputTransfers::InputTransfers(const InputTransfers& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InputTransfers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.fee_percent_){}
    , decltype(_impl_.contract_fee_percent_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.contract_fee_percent_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.contract_fee_percent_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.InputTransfers)
}

inline void InputTransfers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.index_){uint64_t{0u}}
    , decltype(_impl_.fee_percent_){0u}
    , decltype(_impl_.contract_fee_percent_){0u}
  };
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InputTransfers::~InputTransfers() {
  // @@protoc_insertion_point(destructor:zera_txn.InputTransfers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InputTransfers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.amount_.Destroy();
}

void InputTransfers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InputTransfers::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.InputTransfers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.amount_.ClearToEmpty();
  ::memset(&_impl_.index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.fee_percent_) -
      reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.fee_percent_));
  _impl_.contract_fee_percent_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InputTransfers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.InputTransfers.amount"));
        } else
          goto handle_unusual;
        continue;
      // uint32 fee_percent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.fee_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 contract_fee_percent = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_contract_fee_percent(&has_bits);
          _impl_.contract_fee_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InputTransfers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.InputTransfers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_index(), target);
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.InputTransfers.amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_amount(), target);
  }

  // uint32 fee_percent = 3;
  if (this->_internal_fee_percent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_fee_percent(), target);
  }

  // optional uint32 contract_fee_percent = 4;
  if (_internal_has_contract_fee_percent()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_contract_fee_percent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.InputTransfers)
  return target;
}

size_t InputTransfers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.InputTransfers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  // uint64 index = 1;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
  }

  // uint32 fee_percent = 3;
  if (this->_internal_fee_percent() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fee_percent());
  }

  // optional uint32 contract_fee_percent = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_contract_fee_percent());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InputTransfers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InputTransfers::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InputTransfers::GetClassData() const { return &_class_data_; }


void InputTransfers::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InputTransfers*>(&to_msg);
  auto& from = static_cast<const InputTransfers&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.InputTransfers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  if (from._internal_fee_percent() != 0) {
    _this->_internal_set_fee_percent(from._internal_fee_percent());
  }
  if (from._internal_has_contract_fee_percent()) {
    _this->_internal_set_contract_fee_percent(from._internal_contract_fee_percent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InputTransfers::CopyFrom(const InputTransfers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.InputTransfers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputTransfers::IsInitialized() const {
  return true;
}

void InputTransfers::InternalSwap(InputTransfers* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InputTransfers, _impl_.contract_fee_percent_)
      + sizeof(InputTransfers::_impl_.contract_fee_percent_)
      - PROTOBUF_FIELD_OFFSET(InputTransfers, _impl_.index_)>(
          reinterpret_cast<char*>(&_impl_.index_),
          reinterpret_cast<char*>(&other->_impl_.index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InputTransfers::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[38]);
}

// ===================================================================

class OutputTransfers::_Internal {
 public:
  using HasBits = decltype(std::declval<OutputTransfers>()._impl_._has_bits_);
  static void set_has_memo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OutputTransfers::OutputTransfers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.OutputTransfers)
}
OutputTransfers::OutputTransfers(const OutputTransfers& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OutputTransfers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wallet_address_){}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.memo_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_wallet_address().empty()) {
    _this->_impl_.wallet_address_.Set(from._internal_wallet_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.memo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_memo()) {
    _this->_impl_.memo_.Set(from._internal_memo(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.OutputTransfers)
}

inline void OutputTransfers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wallet_address_){}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.memo_){}
  };
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.memo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OutputTransfers::~OutputTransfers() {
  // @@protoc_insertion_point(destructor:zera_txn.OutputTransfers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OutputTransfers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wallet_address_.Destroy();
  _impl_.amount_.Destroy();
  _impl_.memo_.Destroy();
}

void OutputTransfers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OutputTransfers::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.OutputTransfers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wallet_address_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.memo_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OutputTransfers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes wallet_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_wallet_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.OutputTransfers.amount"));
        } else
          goto handle_unusual;
        continue;
      // optional string memo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_memo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.OutputTransfers.memo"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OutputTransfers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.OutputTransfers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_wallet_address(), target);
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.OutputTransfers.amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_amount(), target);
  }

  // optional string memo = 3;
  if (_internal_has_memo()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_memo().data(), static_cast<int>(this->_internal_memo().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.OutputTransfers.memo");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_memo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.OutputTransfers)
  return target;
}

size_t OutputTransfers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.OutputTransfers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes wallet_address = 1;
  if (!this->_internal_wallet_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_wallet_address());
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  // optional string memo = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_memo());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OutputTransfers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OutputTransfers::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OutputTransfers::GetClassData() const { return &_class_data_; }


void OutputTransfers::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OutputTransfers*>(&to_msg);
  auto& from = static_cast<const OutputTransfers&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.OutputTransfers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_wallet_address().empty()) {
    _this->_internal_set_wallet_address(from._internal_wallet_address());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (from._internal_has_memo()) {
    _this->_internal_set_memo(from._internal_memo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OutputTransfers::CopyFrom(const OutputTransfers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.OutputTransfers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputTransfers::IsInitialized() const {
  return true;
}

void OutputTransfers::InternalSwap(OutputTransfers* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wallet_address_, lhs_arena,
      &other->_impl_.wallet_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.memo_, lhs_arena,
      &other->_impl_.memo_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata OutputTransfers::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[39]);
}

// ===================================================================

class MintTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const MintTXN* msg);
};

const ::zera_txn::BaseTXN&
MintTXN::_Internal::base(const MintTXN* msg) {
  return *msg->_impl_.base_;
}
MintTXN::MintTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.MintTXN)
}
MintTXN::MintTXN(const MintTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MintTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.MintTXN)
}

inline void MintTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MintTXN::~MintTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.MintTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MintTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.amount_.Destroy();
  _impl_.recipient_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void MintTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MintTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.MintTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _impl_.recipient_address_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MintTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.MintTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string amount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.MintTXN.amount"));
        } else
          goto handle_unusual;
        continue;
      // bytes recipient_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MintTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.MintTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.MintTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // string amount = 3;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.MintTXN.amount");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_amount(), target);
  }

  // bytes recipient_address = 4;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_recipient_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.MintTXN)
  return target;
}

size_t MintTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.MintTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string amount = 3;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  // bytes recipient_address = 4;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MintTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MintTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MintTXN::GetClassData() const { return &_class_data_; }


void MintTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MintTXN*>(&to_msg);
  auto& from = static_cast<const MintTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.MintTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MintTXN::CopyFrom(const MintTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.MintTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MintTXN::IsInitialized() const {
  return true;
}

void MintTXN::InternalSwap(MintTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MintTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[40]);
}

// ===================================================================

class NFTTXN::_Internal {
 public:
  using HasBits = decltype(std::declval<NFTTXN>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const NFTTXN* msg);
  static void set_has_contract_fee_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_contract_fee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::zera_txn::BaseTXN&
NFTTXN::_Internal::base(const NFTTXN* msg) {
  return *msg->_impl_.base_;
}
NFTTXN::NFTTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.NFTTXN)
}
NFTTXN::NFTTXN(const NFTTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NFTTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.contract_fee_amount_){}
    , decltype(_impl_.contract_fee_id_){}
    , decltype(_impl_.base_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_item_id().empty()) {
    _this->_impl_.item_id_.Set(from._internal_item_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_fee_amount()) {
    _this->_impl_.contract_fee_amount_.Set(from._internal_contract_fee_amount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_fee_id()) {
    _this->_impl_.contract_fee_id_.Set(from._internal_contract_fee_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.NFTTXN)
}

inline void NFTTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.contract_fee_amount_){}
    , decltype(_impl_.contract_fee_id_){}
    , decltype(_impl_.base_){nullptr}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_fee_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NFTTXN::~NFTTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.NFTTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NFTTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.item_id_.Destroy();
  _impl_.recipient_address_.Destroy();
  _impl_.contract_fee_amount_.Destroy();
  _impl_.contract_fee_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void NFTTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NFTTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.NFTTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.item_id_.ClearToEmpty();
  _impl_.recipient_address_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.contract_fee_amount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.contract_fee_id_.ClearNonDefaultToEmpty();
    }
  }
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NFTTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.NFTTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_item_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.NFTTXN.item_id"));
        } else
          goto handle_unusual;
        continue;
      // bytes recipient_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string contract_fee_amount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_contract_fee_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.NFTTXN.contract_fee_amount"));
        } else
          goto handle_unusual;
        continue;
      // optional string contract_fee_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_contract_fee_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.NFTTXN.contract_fee_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NFTTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.NFTTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.NFTTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // string item_id = 3;
  if (!this->_internal_item_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_item_id().data(), static_cast<int>(this->_internal_item_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.NFTTXN.item_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_item_id(), target);
  }

  // bytes recipient_address = 4;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_recipient_address(), target);
  }

  // optional string contract_fee_amount = 5;
  if (_internal_has_contract_fee_amount()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_fee_amount().data(), static_cast<int>(this->_internal_contract_fee_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.NFTTXN.contract_fee_amount");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_contract_fee_amount(), target);
  }

  // optional string contract_fee_id = 6;
  if (_internal_has_contract_fee_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_fee_id().data(), static_cast<int>(this->_internal_contract_fee_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.NFTTXN.contract_fee_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_contract_fee_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.NFTTXN)
  return target;
}

size_t NFTTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.NFTTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string item_id = 3;
  if (!this->_internal_item_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_item_id());
  }

  // bytes recipient_address = 4;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string contract_fee_amount = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_fee_amount());
    }

    // optional string contract_fee_id = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_fee_id());
    }

  }
  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NFTTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NFTTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NFTTXN::GetClassData() const { return &_class_data_; }


void NFTTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NFTTXN*>(&to_msg);
  auto& from = static_cast<const NFTTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.NFTTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_item_id().empty()) {
    _this->_internal_set_item_id(from._internal_item_id());
  }
  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_contract_fee_amount(from._internal_contract_fee_amount());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_contract_fee_id(from._internal_contract_fee_id());
    }
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NFTTXN::CopyFrom(const NFTTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.NFTTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NFTTXN::IsInitialized() const {
  return true;
}

void NFTTXN::InternalSwap(NFTTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.item_id_, lhs_arena,
      &other->_impl_.item_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_fee_amount_, lhs_arena,
      &other->_impl_.contract_fee_amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_fee_id_, lhs_arena,
      &other->_impl_.contract_fee_id_, rhs_arena
  );
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NFTTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[41]);
}

// ===================================================================

class ItemizedMintTXN::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemizedMintTXN>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const ItemizedMintTXN* msg);
  static void set_has_voting_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expiry(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::zera_txn::ItemContractFees& contract_fees(const ItemizedMintTXN* msg);
  static void set_has_contract_fees(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_valid_from(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::zera_txn::BaseTXN&
ItemizedMintTXN::_Internal::base(const ItemizedMintTXN* msg) {
  return *msg->_impl_.base_;
}
const ::zera_txn::ItemContractFees&
ItemizedMintTXN::_Internal::contract_fees(const ItemizedMintTXN* msg) {
  return *msg->_impl_.contract_fees_;
}
ItemizedMintTXN::ItemizedMintTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ItemizedMintTXN)
}
ItemizedMintTXN::ItemizedMintTXN(const ItemizedMintTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemizedMintTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parameters_){from._impl_.parameters_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.voting_weight_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.contract_fees_){nullptr}
    , decltype(_impl_.expiry_){}
    , decltype(_impl_.valid_from_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_item_id().empty()) {
    _this->_impl_.item_id_.Set(from._internal_item_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.voting_weight_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voting_weight_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_voting_weight()) {
    _this->_impl_.voting_weight_.Set(from._internal_voting_weight(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  if (from._internal_has_contract_fees()) {
    _this->_impl_.contract_fees_ = new ::zera_txn::ItemContractFees(*from._impl_.contract_fees_);
  }
  ::memcpy(&_impl_.expiry_, &from._impl_.expiry_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.valid_from_) -
    reinterpret_cast<char*>(&_impl_.expiry_)) + sizeof(_impl_.valid_from_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.ItemizedMintTXN)
}

inline void ItemizedMintTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parameters_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.recipient_address_){}
    , decltype(_impl_.voting_weight_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.contract_fees_){nullptr}
    , decltype(_impl_.expiry_){uint64_t{0u}}
    , decltype(_impl_.valid_from_){uint64_t{0u}}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.item_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.voting_weight_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voting_weight_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ItemizedMintTXN::~ItemizedMintTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.ItemizedMintTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemizedMintTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parameters_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
  _impl_.item_id_.Destroy();
  _impl_.recipient_address_.Destroy();
  _impl_.voting_weight_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.contract_fees_;
}

void ItemizedMintTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemizedMintTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ItemizedMintTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parameters_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.item_id_.ClearToEmpty();
  _impl_.recipient_address_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.voting_weight_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  if (cached_has_bits & 0x00000002u) {
    GOOGLE_DCHECK(_impl_.contract_fees_ != nullptr);
    _impl_.contract_fees_->Clear();
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.expiry_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.valid_from_) -
        reinterpret_cast<char*>(&_impl_.expiry_)) + sizeof(_impl_.valid_from_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemizedMintTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ItemizedMintTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_item_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ItemizedMintTXN.item_id"));
        } else
          goto handle_unusual;
        continue;
      // bytes recipient_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string voting_weight = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_voting_weight();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ItemizedMintTXN.voting_weight"));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.KeyValuePair parameters = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 expiry = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_expiry(&has_bits);
          _impl_.expiry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.ItemContractFees contract_fees = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract_fees(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 valid_from = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_valid_from(&has_bits);
          _impl_.valid_from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemizedMintTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ItemizedMintTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ItemizedMintTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // string item_id = 3;
  if (!this->_internal_item_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_item_id().data(), static_cast<int>(this->_internal_item_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ItemizedMintTXN.item_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_item_id(), target);
  }

  // bytes recipient_address = 4;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_recipient_address(), target);
  }

  // optional string voting_weight = 5;
  if (_internal_has_voting_weight()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_voting_weight().data(), static_cast<int>(this->_internal_voting_weight().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ItemizedMintTXN.voting_weight");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_voting_weight(), target);
  }

  // repeated .zera_txn.KeyValuePair parameters = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 expiry = 7;
  if (_internal_has_expiry()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_expiry(), target);
  }

  // optional .zera_txn.ItemContractFees contract_fees = 8;
  if (_internal_has_contract_fees()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::contract_fees(this),
        _Internal::contract_fees(this).GetCachedSize(), target, stream);
  }

  // optional uint64 valid_from = 9;
  if (_internal_has_valid_from()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_valid_from(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ItemizedMintTXN)
  return target;
}

size_t ItemizedMintTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ItemizedMintTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.KeyValuePair parameters = 6;
  total_size += 1UL * this->_internal_parameters_size();
  for (const auto& msg : this->_impl_.parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string item_id = 3;
  if (!this->_internal_item_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_item_id());
  }

  // bytes recipient_address = 4;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  // optional string voting_weight = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_voting_weight());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  if (cached_has_bits & 0x0000000eu) {
    // optional .zera_txn.ItemContractFees contract_fees = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.contract_fees_);
    }

    // optional uint64 expiry = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_expiry());
    }

    // optional uint64 valid_from = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_valid_from());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemizedMintTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemizedMintTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemizedMintTXN::GetClassData() const { return &_class_data_; }


void ItemizedMintTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemizedMintTXN*>(&to_msg);
  auto& from = static_cast<const ItemizedMintTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ItemizedMintTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_item_id().empty()) {
    _this->_internal_set_item_id(from._internal_item_id());
  }
  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  if (from._internal_has_voting_weight()) {
    _this->_internal_set_voting_weight(from._internal_voting_weight());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_contract_fees()->::zera_txn::ItemContractFees::MergeFrom(
          from._internal_contract_fees());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.expiry_ = from._impl_.expiry_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.valid_from_ = from._impl_.valid_from_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemizedMintTXN::CopyFrom(const ItemizedMintTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ItemizedMintTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemizedMintTXN::IsInitialized() const {
  return true;
}

void ItemizedMintTXN::InternalSwap(ItemizedMintTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.item_id_, lhs_arena,
      &other->_impl_.item_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.voting_weight_, lhs_arena,
      &other->_impl_.voting_weight_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemizedMintTXN, _impl_.valid_from_)
      + sizeof(ItemizedMintTXN::_impl_.valid_from_)
      - PROTOBUF_FIELD_OFFSET(ItemizedMintTXN, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemizedMintTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[42]);
}

// ===================================================================

class ContractUpdateTXN::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractUpdateTXN>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const ContractUpdateTXN* msg);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::zera_txn::Governance& governance(const ContractUpdateTXN* msg);
  static void set_has_governance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::zera_txn::ContractFees& contract_fees(const ContractUpdateTXN* msg);
  static void set_has_contract_fees(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_kyc_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_immutable_kyc_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_quash_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::zera_txn::BaseTXN&
ContractUpdateTXN::_Internal::base(const ContractUpdateTXN* msg) {
  return *msg->_impl_.base_;
}
const ::zera_txn::Governance&
ContractUpdateTXN::_Internal::governance(const ContractUpdateTXN* msg) {
  return *msg->_impl_.governance_;
}
const ::zera_txn::ContractFees&
ContractUpdateTXN::_Internal::contract_fees(const ContractUpdateTXN* msg) {
  return *msg->_impl_.contract_fees_;
}
ContractUpdateTXN::ContractUpdateTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ContractUpdateTXN)
}
ContractUpdateTXN::ContractUpdateTXN(const ContractUpdateTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContractUpdateTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.restricted_keys_){from._impl_.restricted_keys_}
    , decltype(_impl_.custom_parameters_){from._impl_.custom_parameters_}
    , decltype(_impl_.expense_ratio_){from._impl_.expense_ratio_}
    , decltype(_impl_.token_compliance_){from._impl_.token_compliance_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.governance_){nullptr}
    , decltype(_impl_.contract_fees_){nullptr}
    , decltype(_impl_.contract_version_){}
    , decltype(_impl_.kyc_status_){}
    , decltype(_impl_.immutable_kyc_status_){}
    , decltype(_impl_.quash_threshold_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  if (from._internal_has_governance()) {
    _this->_impl_.governance_ = new ::zera_txn::Governance(*from._impl_.governance_);
  }
  if (from._internal_has_contract_fees()) {
    _this->_impl_.contract_fees_ = new ::zera_txn::ContractFees(*from._impl_.contract_fees_);
  }
  ::memcpy(&_impl_.contract_version_, &from._impl_.contract_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.quash_threshold_) -
    reinterpret_cast<char*>(&_impl_.contract_version_)) + sizeof(_impl_.quash_threshold_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.ContractUpdateTXN)
}

inline void ContractUpdateTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.restricted_keys_){arena}
    , decltype(_impl_.custom_parameters_){arena}
    , decltype(_impl_.expense_ratio_){arena}
    , decltype(_impl_.token_compliance_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.governance_){nullptr}
    , decltype(_impl_.contract_fees_){nullptr}
    , decltype(_impl_.contract_version_){uint64_t{0u}}
    , decltype(_impl_.kyc_status_){false}
    , decltype(_impl_.immutable_kyc_status_){false}
    , decltype(_impl_.quash_threshold_){0u}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContractUpdateTXN::~ContractUpdateTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.ContractUpdateTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractUpdateTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.restricted_keys_.~RepeatedPtrField();
  _impl_.custom_parameters_.~RepeatedPtrField();
  _impl_.expense_ratio_.~RepeatedPtrField();
  _impl_.token_compliance_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.governance_;
  if (this != internal_default_instance()) delete _impl_.contract_fees_;
}

void ContractUpdateTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContractUpdateTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ContractUpdateTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.restricted_keys_.Clear();
  _impl_.custom_parameters_.Clear();
  _impl_.expense_ratio_.Clear();
  _impl_.token_compliance_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  if (cached_has_bits & 0x00000006u) {
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.governance_ != nullptr);
      _impl_.governance_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.contract_fees_ != nullptr);
      _impl_.contract_fees_->Clear();
    }
  }
  _impl_.contract_version_ = uint64_t{0u};
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.kyc_status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.quash_threshold_) -
        reinterpret_cast<char*>(&_impl_.kyc_status_)) + sizeof(_impl_.quash_threshold_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractUpdateTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ContractUpdateTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // uint64 contract_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.contract_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ContractUpdateTXN.name"));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.Governance governance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_governance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.RestrictedKey restricted_keys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_restricted_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.ContractFees contract_fees = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract_fees(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.KeyValuePair custom_parameters = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_custom_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ExpenseRatio expense_ratio = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_expense_ratio(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.TokenCompliance token_compliance = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_token_compliance(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool kyc_status = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_kyc_status(&has_bits);
          _impl_.kyc_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool immutable_kyc_status = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_immutable_kyc_status(&has_bits);
          _impl_.immutable_kyc_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quash_threshold = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_quash_threshold(&has_bits);
          _impl_.quash_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractUpdateTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ContractUpdateTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ContractUpdateTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // uint64 contract_version = 3;
  if (this->_internal_contract_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_contract_version(), target);
  }

  // optional string name = 4;
  if (_internal_has_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ContractUpdateTXN.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // optional .zera_txn.Governance governance = 5;
  if (_internal_has_governance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::governance(this),
        _Internal::governance(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.RestrictedKey restricted_keys = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_restricted_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_restricted_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .zera_txn.ContractFees contract_fees = 7;
  if (_internal_has_contract_fees()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::contract_fees(this),
        _Internal::contract_fees(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.KeyValuePair custom_parameters = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_custom_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_custom_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ExpenseRatio expense_ratio = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_expense_ratio_size()); i < n; i++) {
    const auto& repfield = this->_internal_expense_ratio(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.TokenCompliance token_compliance = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_token_compliance_size()); i < n; i++) {
    const auto& repfield = this->_internal_token_compliance(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool kyc_status = 11;
  if (_internal_has_kyc_status()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_kyc_status(), target);
  }

  // optional bool immutable_kyc_status = 12;
  if (_internal_has_immutable_kyc_status()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_immutable_kyc_status(), target);
  }

  // optional uint32 quash_threshold = 13;
  if (_internal_has_quash_threshold()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_quash_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ContractUpdateTXN)
  return target;
}

size_t ContractUpdateTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ContractUpdateTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.RestrictedKey restricted_keys = 6;
  total_size += 1UL * this->_internal_restricted_keys_size();
  for (const auto& msg : this->_impl_.restricted_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.KeyValuePair custom_parameters = 8;
  total_size += 1UL * this->_internal_custom_parameters_size();
  for (const auto& msg : this->_impl_.custom_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ExpenseRatio expense_ratio = 9;
  total_size += 1UL * this->_internal_expense_ratio_size();
  for (const auto& msg : this->_impl_.expense_ratio_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.TokenCompliance token_compliance = 10;
  total_size += 1UL * this->_internal_token_compliance_size();
  for (const auto& msg : this->_impl_.token_compliance_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // optional string name = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  if (cached_has_bits & 0x00000006u) {
    // optional .zera_txn.Governance governance = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.governance_);
    }

    // optional .zera_txn.ContractFees contract_fees = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.contract_fees_);
    }

  }
  // uint64 contract_version = 3;
  if (this->_internal_contract_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_contract_version());
  }

  if (cached_has_bits & 0x00000038u) {
    // optional bool kyc_status = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool immutable_kyc_status = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 quash_threshold = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quash_threshold());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractUpdateTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContractUpdateTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractUpdateTXN::GetClassData() const { return &_class_data_; }


void ContractUpdateTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContractUpdateTXN*>(&to_msg);
  auto& from = static_cast<const ContractUpdateTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ContractUpdateTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.restricted_keys_.MergeFrom(from._impl_.restricted_keys_);
  _this->_impl_.custom_parameters_.MergeFrom(from._impl_.custom_parameters_);
  _this->_impl_.expense_ratio_.MergeFrom(from._impl_.expense_ratio_);
  _this->_impl_.token_compliance_.MergeFrom(from._impl_.token_compliance_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (from._internal_has_name()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_governance()->::zera_txn::Governance::MergeFrom(
          from._internal_governance());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_contract_fees()->::zera_txn::ContractFees::MergeFrom(
          from._internal_contract_fees());
    }
  }
  if (from._internal_contract_version() != 0) {
    _this->_internal_set_contract_version(from._internal_contract_version());
  }
  if (cached_has_bits & 0x00000038u) {
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.kyc_status_ = from._impl_.kyc_status_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.immutable_kyc_status_ = from._impl_.immutable_kyc_status_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.quash_threshold_ = from._impl_.quash_threshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractUpdateTXN::CopyFrom(const ContractUpdateTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ContractUpdateTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractUpdateTXN::IsInitialized() const {
  return true;
}

void ContractUpdateTXN::InternalSwap(ContractUpdateTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.restricted_keys_.InternalSwap(&other->_impl_.restricted_keys_);
  _impl_.custom_parameters_.InternalSwap(&other->_impl_.custom_parameters_);
  _impl_.expense_ratio_.InternalSwap(&other->_impl_.expense_ratio_);
  _impl_.token_compliance_.InternalSwap(&other->_impl_.token_compliance_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractUpdateTXN, _impl_.quash_threshold_)
      + sizeof(ContractUpdateTXN::_impl_.quash_threshold_)
      - PROTOBUF_FIELD_OFFSET(ContractUpdateTXN, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractUpdateTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[43]);
}

// ===================================================================

class InstrumentContract::_Internal {
 public:
  using HasBits = decltype(std::declval<InstrumentContract>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const InstrumentContract* msg);
  static const ::zera_txn::Governance& governance(const InstrumentContract* msg);
  static void set_has_governance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_supply(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::zera_txn::ContractFees& contract_fees(const InstrumentContract* msg);
  static void set_has_contract_fees(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::zera_txn::CoinDenomination& coin_denomination(const InstrumentContract* msg);
  static void set_has_coin_denomination(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_quash_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cur_equiv_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::zera_txn::BaseTXN&
InstrumentContract::_Internal::base(const InstrumentContract* msg) {
  return *msg->_impl_.base_;
}
const ::zera_txn::Governance&
InstrumentContract::_Internal::governance(const InstrumentContract* msg) {
  return *msg->_impl_.governance_;
}
const ::zera_txn::ContractFees&
InstrumentContract::_Internal::contract_fees(const InstrumentContract* msg) {
  return *msg->_impl_.contract_fees_;
}
const ::zera_txn::CoinDenomination&
InstrumentContract::_Internal::coin_denomination(const InstrumentContract* msg) {
  return *msg->_impl_.coin_denomination_;
}
InstrumentContract::InstrumentContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.InstrumentContract)
}
InstrumentContract::InstrumentContract(const InstrumentContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstrumentContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.restricted_keys_){from._impl_.restricted_keys_}
    , decltype(_impl_.premint_wallets_){from._impl_.premint_wallets_}
    , decltype(_impl_.custom_parameters_){from._impl_.custom_parameters_}
    , decltype(_impl_.expense_ratio_){from._impl_.expense_ratio_}
    , decltype(_impl_.token_compliance_){from._impl_.token_compliance_}
    , decltype(_impl_.max_supply_release_){from._impl_.max_supply_release_}
    , decltype(_impl_.symbol_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.max_supply_){}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.cur_equiv_start_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.governance_){nullptr}
    , decltype(_impl_.contract_fees_){nullptr}
    , decltype(_impl_.coin_denomination_){nullptr}
    , decltype(_impl_.contract_version_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.quash_threshold_){}
    , decltype(_impl_.update_contract_fees_){}
    , decltype(_impl_.update_expense_ratio_){}
    , decltype(_impl_.kyc_status_){}
    , decltype(_impl_.immutable_kyc_status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol().empty()) {
    _this->_impl_.symbol_.Set(from._internal_symbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.max_supply_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_supply_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_max_supply()) {
    _this->_impl_.max_supply_.Set(from._internal_max_supply(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cur_equiv_start_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cur_equiv_start_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cur_equiv_start()) {
    _this->_impl_.cur_equiv_start_.Set(from._internal_cur_equiv_start(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  if (from._internal_has_governance()) {
    _this->_impl_.governance_ = new ::zera_txn::Governance(*from._impl_.governance_);
  }
  if (from._internal_has_contract_fees()) {
    _this->_impl_.contract_fees_ = new ::zera_txn::ContractFees(*from._impl_.contract_fees_);
  }
  if (from._internal_has_coin_denomination()) {
    _this->_impl_.coin_denomination_ = new ::zera_txn::CoinDenomination(*from._impl_.coin_denomination_);
  }
  ::memcpy(&_impl_.contract_version_, &from._impl_.contract_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.immutable_kyc_status_) -
    reinterpret_cast<char*>(&_impl_.contract_version_)) + sizeof(_impl_.immutable_kyc_status_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.InstrumentContract)
}

inline void InstrumentContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.restricted_keys_){arena}
    , decltype(_impl_.premint_wallets_){arena}
    , decltype(_impl_.custom_parameters_){arena}
    , decltype(_impl_.expense_ratio_){arena}
    , decltype(_impl_.token_compliance_){arena}
    , decltype(_impl_.max_supply_release_){arena}
    , decltype(_impl_.symbol_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.max_supply_){}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.cur_equiv_start_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.governance_){nullptr}
    , decltype(_impl_.contract_fees_){nullptr}
    , decltype(_impl_.coin_denomination_){nullptr}
    , decltype(_impl_.contract_version_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.quash_threshold_){0u}
    , decltype(_impl_.update_contract_fees_){false}
    , decltype(_impl_.update_expense_ratio_){false}
    , decltype(_impl_.kyc_status_){false}
    , decltype(_impl_.immutable_kyc_status_){false}
  };
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.max_supply_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_supply_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cur_equiv_start_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cur_equiv_start_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InstrumentContract::~InstrumentContract() {
  // @@protoc_insertion_point(destructor:zera_txn.InstrumentContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstrumentContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.restricted_keys_.~RepeatedPtrField();
  _impl_.premint_wallets_.~RepeatedPtrField();
  _impl_.custom_parameters_.~RepeatedPtrField();
  _impl_.expense_ratio_.~RepeatedPtrField();
  _impl_.token_compliance_.~RepeatedPtrField();
  _impl_.max_supply_release_.~RepeatedPtrField();
  _impl_.symbol_.Destroy();
  _impl_.name_.Destroy();
  _impl_.max_supply_.Destroy();
  _impl_.contract_id_.Destroy();
  _impl_.cur_equiv_start_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.governance_;
  if (this != internal_default_instance()) delete _impl_.contract_fees_;
  if (this != internal_default_instance()) delete _impl_.coin_denomination_;
}

void InstrumentContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstrumentContract::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.InstrumentContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.restricted_keys_.Clear();
  _impl_.premint_wallets_.Clear();
  _impl_.custom_parameters_.Clear();
  _impl_.expense_ratio_.Clear();
  _impl_.token_compliance_.Clear();
  _impl_.max_supply_release_.Clear();
  _impl_.symbol_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.max_supply_.ClearNonDefaultToEmpty();
  }
  _impl_.contract_id_.ClearToEmpty();
  if (cached_has_bits & 0x00000002u) {
    _impl_.cur_equiv_start_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  if (cached_has_bits & 0x0000001cu) {
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.governance_ != nullptr);
      _impl_.governance_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.contract_fees_ != nullptr);
      _impl_.contract_fees_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.coin_denomination_ != nullptr);
      _impl_.coin_denomination_->Clear();
    }
  }
  ::memset(&_impl_.contract_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.contract_version_)) + sizeof(_impl_.type_));
  _impl_.quash_threshold_ = 0u;
  ::memset(&_impl_.update_contract_fees_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.immutable_kyc_status_) -
      reinterpret_cast<char*>(&_impl_.update_contract_fees_)) + sizeof(_impl_.immutable_kyc_status_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstrumentContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 contract_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.contract_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string symbol = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_symbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.InstrumentContract.symbol"));
        } else
          goto handle_unusual;
        continue;
      // string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.InstrumentContract.name"));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.Governance governance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_governance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.RestrictedKey restricted_keys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_restricted_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string max_supply = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_max_supply();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.InstrumentContract.max_supply"));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.ContractFees contract_fees = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract_fees(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.PreMintWallet premint_wallets = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_premint_wallets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.CoinDenomination coin_denomination = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_coin_denomination(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.KeyValuePair custom_parameters = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_custom_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.InstrumentContract.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ExpenseRatio expense_ratio = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_expense_ratio(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.CONTRACT_TYPE type = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::zera_txn::CONTRACT_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // bool update_contract_fees = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.update_contract_fees_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool update_expense_ratio = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.update_expense_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quash_threshold = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_quash_threshold(&has_bits);
          _impl_.quash_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.TokenCompliance token_compliance = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_token_compliance(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool kyc_status = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.kyc_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool immutable_kyc_status = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.immutable_kyc_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cur_equiv_start = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_cur_equiv_start();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.InstrumentContract.cur_equiv_start"));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.MaxSupplyRelease max_supply_release = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_max_supply_release(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstrumentContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.InstrumentContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // uint64 contract_version = 2;
  if (this->_internal_contract_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_contract_version(), target);
  }

  // string symbol = 3;
  if (!this->_internal_symbol().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_symbol().data(), static_cast<int>(this->_internal_symbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.InstrumentContract.symbol");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_symbol(), target);
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.InstrumentContract.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // optional .zera_txn.Governance governance = 5;
  if (_internal_has_governance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::governance(this),
        _Internal::governance(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.RestrictedKey restricted_keys = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_restricted_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_restricted_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string max_supply = 7;
  if (_internal_has_max_supply()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_max_supply().data(), static_cast<int>(this->_internal_max_supply().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.InstrumentContract.max_supply");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_max_supply(), target);
  }

  // optional .zera_txn.ContractFees contract_fees = 8;
  if (_internal_has_contract_fees()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::contract_fees(this),
        _Internal::contract_fees(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.PreMintWallet premint_wallets = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_premint_wallets_size()); i < n; i++) {
    const auto& repfield = this->_internal_premint_wallets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .zera_txn.CoinDenomination coin_denomination = 10;
  if (_internal_has_coin_denomination()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::coin_denomination(this),
        _Internal::coin_denomination(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.KeyValuePair custom_parameters = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_custom_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_custom_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string contract_id = 12;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.InstrumentContract.contract_id");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_contract_id(), target);
  }

  // repeated .zera_txn.ExpenseRatio expense_ratio = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_expense_ratio_size()); i < n; i++) {
    const auto& repfield = this->_internal_expense_ratio(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .zera_txn.CONTRACT_TYPE type = 14;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_type(), target);
  }

  // bool update_contract_fees = 15;
  if (this->_internal_update_contract_fees() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_update_contract_fees(), target);
  }

  // bool update_expense_ratio = 16;
  if (this->_internal_update_expense_ratio() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_update_expense_ratio(), target);
  }

  // optional uint32 quash_threshold = 17;
  if (_internal_has_quash_threshold()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_quash_threshold(), target);
  }

  // repeated .zera_txn.TokenCompliance token_compliance = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_token_compliance_size()); i < n; i++) {
    const auto& repfield = this->_internal_token_compliance(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool kyc_status = 19;
  if (this->_internal_kyc_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_kyc_status(), target);
  }

  // bool immutable_kyc_status = 20;
  if (this->_internal_immutable_kyc_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_immutable_kyc_status(), target);
  }

  // optional string cur_equiv_start = 21;
  if (_internal_has_cur_equiv_start()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_cur_equiv_start().data(), static_cast<int>(this->_internal_cur_equiv_start().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.InstrumentContract.cur_equiv_start");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_cur_equiv_start(), target);
  }

  // repeated .zera_txn.MaxSupplyRelease max_supply_release = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_max_supply_release_size()); i < n; i++) {
    const auto& repfield = this->_internal_max_supply_release(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.InstrumentContract)
  return target;
}

size_t InstrumentContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.InstrumentContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.RestrictedKey restricted_keys = 6;
  total_size += 1UL * this->_internal_restricted_keys_size();
  for (const auto& msg : this->_impl_.restricted_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.PreMintWallet premint_wallets = 9;
  total_size += 1UL * this->_internal_premint_wallets_size();
  for (const auto& msg : this->_impl_.premint_wallets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.KeyValuePair custom_parameters = 11;
  total_size += 1UL * this->_internal_custom_parameters_size();
  for (const auto& msg : this->_impl_.custom_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ExpenseRatio expense_ratio = 13;
  total_size += 1UL * this->_internal_expense_ratio_size();
  for (const auto& msg : this->_impl_.expense_ratio_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.TokenCompliance token_compliance = 18;
  total_size += 2UL * this->_internal_token_compliance_size();
  for (const auto& msg : this->_impl_.token_compliance_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.MaxSupplyRelease max_supply_release = 22;
  total_size += 2UL * this->_internal_max_supply_release_size();
  for (const auto& msg : this->_impl_.max_supply_release_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string symbol = 3;
  if (!this->_internal_symbol().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_symbol());
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // optional string max_supply = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_max_supply());
  }

  // string contract_id = 12;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // optional string cur_equiv_start = 21;
  if (cached_has_bits & 0x00000002u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cur_equiv_start());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional .zera_txn.Governance governance = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.governance_);
    }

    // optional .zera_txn.ContractFees contract_fees = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.contract_fees_);
    }

    // optional .zera_txn.CoinDenomination coin_denomination = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.coin_denomination_);
    }

  }
  // uint64 contract_version = 2;
  if (this->_internal_contract_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_contract_version());
  }

  // .zera_txn.CONTRACT_TYPE type = 14;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // optional uint32 quash_threshold = 17;
  if (cached_has_bits & 0x00000020u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_quash_threshold());
  }

  // bool update_contract_fees = 15;
  if (this->_internal_update_contract_fees() != 0) {
    total_size += 1 + 1;
  }

  // bool update_expense_ratio = 16;
  if (this->_internal_update_expense_ratio() != 0) {
    total_size += 2 + 1;
  }

  // bool kyc_status = 19;
  if (this->_internal_kyc_status() != 0) {
    total_size += 2 + 1;
  }

  // bool immutable_kyc_status = 20;
  if (this->_internal_immutable_kyc_status() != 0) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstrumentContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstrumentContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstrumentContract::GetClassData() const { return &_class_data_; }


void InstrumentContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstrumentContract*>(&to_msg);
  auto& from = static_cast<const InstrumentContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.InstrumentContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.restricted_keys_.MergeFrom(from._impl_.restricted_keys_);
  _this->_impl_.premint_wallets_.MergeFrom(from._impl_.premint_wallets_);
  _this->_impl_.custom_parameters_.MergeFrom(from._impl_.custom_parameters_);
  _this->_impl_.expense_ratio_.MergeFrom(from._impl_.expense_ratio_);
  _this->_impl_.token_compliance_.MergeFrom(from._impl_.token_compliance_);
  _this->_impl_.max_supply_release_.MergeFrom(from._impl_.max_supply_release_);
  if (!from._internal_symbol().empty()) {
    _this->_internal_set_symbol(from._internal_symbol());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_max_supply()) {
    _this->_internal_set_max_supply(from._internal_max_supply());
  }
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (from._internal_has_cur_equiv_start()) {
    _this->_internal_set_cur_equiv_start(from._internal_cur_equiv_start());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_governance()->::zera_txn::Governance::MergeFrom(
          from._internal_governance());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_contract_fees()->::zera_txn::ContractFees::MergeFrom(
          from._internal_contract_fees());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_coin_denomination()->::zera_txn::CoinDenomination::MergeFrom(
          from._internal_coin_denomination());
    }
  }
  if (from._internal_contract_version() != 0) {
    _this->_internal_set_contract_version(from._internal_contract_version());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (cached_has_bits & 0x00000020u) {
    _this->_internal_set_quash_threshold(from._internal_quash_threshold());
  }
  if (from._internal_update_contract_fees() != 0) {
    _this->_internal_set_update_contract_fees(from._internal_update_contract_fees());
  }
  if (from._internal_update_expense_ratio() != 0) {
    _this->_internal_set_update_expense_ratio(from._internal_update_expense_ratio());
  }
  if (from._internal_kyc_status() != 0) {
    _this->_internal_set_kyc_status(from._internal_kyc_status());
  }
  if (from._internal_immutable_kyc_status() != 0) {
    _this->_internal_set_immutable_kyc_status(from._internal_immutable_kyc_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstrumentContract::CopyFrom(const InstrumentContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.InstrumentContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstrumentContract::IsInitialized() const {
  return true;
}

void InstrumentContract::InternalSwap(InstrumentContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.restricted_keys_.InternalSwap(&other->_impl_.restricted_keys_);
  _impl_.premint_wallets_.InternalSwap(&other->_impl_.premint_wallets_);
  _impl_.custom_parameters_.InternalSwap(&other->_impl_.custom_parameters_);
  _impl_.expense_ratio_.InternalSwap(&other->_impl_.expense_ratio_);
  _impl_.token_compliance_.InternalSwap(&other->_impl_.token_compliance_);
  _impl_.max_supply_release_.InternalSwap(&other->_impl_.max_supply_release_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.symbol_, lhs_arena,
      &other->_impl_.symbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.max_supply_, lhs_arena,
      &other->_impl_.max_supply_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cur_equiv_start_, lhs_arena,
      &other->_impl_.cur_equiv_start_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InstrumentContract, _impl_.immutable_kyc_status_)
      + sizeof(InstrumentContract::_impl_.immutable_kyc_status_)
      - PROTOBUF_FIELD_OFFSET(InstrumentContract, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InstrumentContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[44]);
}

// ===================================================================

class MaxSupplyRelease::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& release_date(const MaxSupplyRelease* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
MaxSupplyRelease::_Internal::release_date(const MaxSupplyRelease* msg) {
  return *msg->_impl_.release_date_;
}
void MaxSupplyRelease::clear_release_date() {
  if (GetArenaForAllocation() == nullptr && _impl_.release_date_ != nullptr) {
    delete _impl_.release_date_;
  }
  _impl_.release_date_ = nullptr;
}
MaxSupplyRelease::MaxSupplyRelease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.MaxSupplyRelease)
}
MaxSupplyRelease::MaxSupplyRelease(const MaxSupplyRelease& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MaxSupplyRelease* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.amount_){}
    , decltype(_impl_.release_date_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_release_date()) {
    _this->_impl_.release_date_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.release_date_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.MaxSupplyRelease)
}

inline void MaxSupplyRelease::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.amount_){}
    , decltype(_impl_.release_date_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MaxSupplyRelease::~MaxSupplyRelease() {
  // @@protoc_insertion_point(destructor:zera_txn.MaxSupplyRelease)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MaxSupplyRelease::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.amount_.Destroy();
  if (this != internal_default_instance()) delete _impl_.release_date_;
}

void MaxSupplyRelease::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MaxSupplyRelease::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.MaxSupplyRelease)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.amount_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.release_date_ != nullptr) {
    delete _impl_.release_date_;
  }
  _impl_.release_date_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MaxSupplyRelease::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Timestamp release_date = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_release_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.MaxSupplyRelease.amount"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MaxSupplyRelease::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.MaxSupplyRelease)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.Timestamp release_date = 1;
  if (this->_internal_has_release_date()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::release_date(this),
        _Internal::release_date(this).GetCachedSize(), target, stream);
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.MaxSupplyRelease.amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.MaxSupplyRelease)
  return target;
}

size_t MaxSupplyRelease::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.MaxSupplyRelease)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  // .google.protobuf.Timestamp release_date = 1;
  if (this->_internal_has_release_date()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.release_date_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MaxSupplyRelease::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MaxSupplyRelease::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MaxSupplyRelease::GetClassData() const { return &_class_data_; }


void MaxSupplyRelease::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MaxSupplyRelease*>(&to_msg);
  auto& from = static_cast<const MaxSupplyRelease&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.MaxSupplyRelease)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (from._internal_has_release_date()) {
    _this->_internal_mutable_release_date()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_release_date());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MaxSupplyRelease::CopyFrom(const MaxSupplyRelease& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.MaxSupplyRelease)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaxSupplyRelease::IsInitialized() const {
  return true;
}

void MaxSupplyRelease::InternalSwap(MaxSupplyRelease* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
  swap(_impl_.release_date_, other->_impl_.release_date_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MaxSupplyRelease::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[45]);
}

// ===================================================================

class GovernanceVote::_Internal {
 public:
  using HasBits = decltype(std::declval<GovernanceVote>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const GovernanceVote* msg);
  static void set_has_support(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_support_option(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::zera_txn::BaseTXN&
GovernanceVote::_Internal::base(const GovernanceVote* msg) {
  return *msg->_impl_.base_;
}
GovernanceVote::GovernanceVote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.GovernanceVote)
}
GovernanceVote::GovernanceVote(const GovernanceVote& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GovernanceVote* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.proposal_id_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.support_){}
    , decltype(_impl_.support_option_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.proposal_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_proposal_id().empty()) {
    _this->_impl_.proposal_id_.Set(from._internal_proposal_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  ::memcpy(&_impl_.support_, &from._impl_.support_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.support_option_) -
    reinterpret_cast<char*>(&_impl_.support_)) + sizeof(_impl_.support_option_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.GovernanceVote)
}

inline void GovernanceVote::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.proposal_id_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.support_){false}
    , decltype(_impl_.support_option_){0u}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.proposal_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GovernanceVote::~GovernanceVote() {
  // @@protoc_insertion_point(destructor:zera_txn.GovernanceVote)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GovernanceVote::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.proposal_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void GovernanceVote::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GovernanceVote::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.GovernanceVote)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.proposal_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.support_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.support_option_) -
        reinterpret_cast<char*>(&_impl_.support_)) + sizeof(_impl_.support_option_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GovernanceVote::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.GovernanceVote.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // bytes proposal_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_proposal_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool support = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_support(&has_bits);
          _impl_.support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 support_option = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_support_option(&has_bits);
          _impl_.support_option_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GovernanceVote::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.GovernanceVote)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.GovernanceVote.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // bytes proposal_id = 3;
  if (!this->_internal_proposal_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_proposal_id(), target);
  }

  // optional bool support = 4;
  if (_internal_has_support()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_support(), target);
  }

  // optional uint32 support_option = 5;
  if (_internal_has_support_option()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_support_option(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.GovernanceVote)
  return target;
}

size_t GovernanceVote::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.GovernanceVote)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // bytes proposal_id = 3;
  if (!this->_internal_proposal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_proposal_id());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool support = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional uint32 support_option = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_support_option());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GovernanceVote::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GovernanceVote::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GovernanceVote::GetClassData() const { return &_class_data_; }


void GovernanceVote::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GovernanceVote*>(&to_msg);
  auto& from = static_cast<const GovernanceVote&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.GovernanceVote)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_proposal_id().empty()) {
    _this->_internal_set_proposal_id(from._internal_proposal_id());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.support_ = from._impl_.support_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.support_option_ = from._impl_.support_option_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GovernanceVote::CopyFrom(const GovernanceVote& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.GovernanceVote)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GovernanceVote::IsInitialized() const {
  return true;
}

void GovernanceVote::InternalSwap(GovernanceVote* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.proposal_id_, lhs_arena,
      &other->_impl_.proposal_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GovernanceVote, _impl_.support_option_)
      + sizeof(GovernanceVote::_impl_.support_option_)
      - PROTOBUF_FIELD_OFFSET(GovernanceVote, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GovernanceVote::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[46]);
}

// ===================================================================

class GovernanceProposal::_Internal {
 public:
  using HasBits = decltype(std::declval<GovernanceProposal>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const GovernanceProposal* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_timestamp(const GovernanceProposal* msg);
  static void set_has_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_timestamp(const GovernanceProposal* msg);
  static void set_has_end_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::zera_txn::BaseTXN&
GovernanceProposal::_Internal::base(const GovernanceProposal* msg) {
  return *msg->_impl_.base_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
GovernanceProposal::_Internal::start_timestamp(const GovernanceProposal* msg) {
  return *msg->_impl_.start_timestamp_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
GovernanceProposal::_Internal::end_timestamp(const GovernanceProposal* msg) {
  return *msg->_impl_.end_timestamp_;
}
void GovernanceProposal::clear_start_timestamp() {
  if (_impl_.start_timestamp_ != nullptr) _impl_.start_timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void GovernanceProposal::clear_end_timestamp() {
  if (_impl_.end_timestamp_ != nullptr) _impl_.end_timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
GovernanceProposal::GovernanceProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.GovernanceProposal)
}
GovernanceProposal::GovernanceProposal(const GovernanceProposal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GovernanceProposal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.options_){from._impl_.options_}
    , decltype(_impl_.governance_txn_){from._impl_.governance_txn_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.synopsis_){}
    , decltype(_impl_.body_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.start_timestamp_){nullptr}
    , decltype(_impl_.end_timestamp_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.synopsis_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.synopsis_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_synopsis().empty()) {
    _this->_impl_.synopsis_.Set(from._internal_synopsis(), 
      _this->GetArenaForAllocation());
  }
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_body().empty()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  if (from._internal_has_start_timestamp()) {
    _this->_impl_.start_timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.start_timestamp_);
  }
  if (from._internal_has_end_timestamp()) {
    _this->_impl_.end_timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.end_timestamp_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.GovernanceProposal)
}

inline void GovernanceProposal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.options_){arena}
    , decltype(_impl_.governance_txn_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.synopsis_){}
    , decltype(_impl_.body_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.start_timestamp_){nullptr}
    , decltype(_impl_.end_timestamp_){nullptr}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.synopsis_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.synopsis_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GovernanceProposal::~GovernanceProposal() {
  // @@protoc_insertion_point(destructor:zera_txn.GovernanceProposal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GovernanceProposal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.options_.~RepeatedPtrField();
  _impl_.governance_txn_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
  _impl_.title_.Destroy();
  _impl_.synopsis_.Destroy();
  _impl_.body_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.start_timestamp_;
  if (this != internal_default_instance()) delete _impl_.end_timestamp_;
}

void GovernanceProposal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GovernanceProposal::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.GovernanceProposal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.options_.Clear();
  _impl_.governance_txn_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.title_.ClearToEmpty();
  _impl_.synopsis_.ClearToEmpty();
  _impl_.body_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.start_timestamp_ != nullptr);
      _impl_.start_timestamp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.end_timestamp_ != nullptr);
      _impl_.end_timestamp_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GovernanceProposal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.GovernanceProposal.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string title = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.GovernanceProposal.title"));
        } else
          goto handle_unusual;
        continue;
      // string synopsis = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_synopsis();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.GovernanceProposal.synopsis"));
        } else
          goto handle_unusual;
        continue;
      // string body = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.GovernanceProposal.body"));
        } else
          goto handle_unusual;
        continue;
      // repeated string options = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_options();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.GovernanceProposal.options"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp start_timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp end_timestamp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.GovernanceTXN governance_txn = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_governance_txn(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GovernanceProposal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.GovernanceProposal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.GovernanceProposal.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // string title = 3;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.GovernanceProposal.title");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_title(), target);
  }

  // string synopsis = 4;
  if (!this->_internal_synopsis().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_synopsis().data(), static_cast<int>(this->_internal_synopsis().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.GovernanceProposal.synopsis");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_synopsis(), target);
  }

  // string body = 5;
  if (!this->_internal_body().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_body().data(), static_cast<int>(this->_internal_body().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.GovernanceProposal.body");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_body(), target);
  }

  // repeated string options = 6;
  for (int i = 0, n = this->_internal_options_size(); i < n; i++) {
    const auto& s = this->_internal_options(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.GovernanceProposal.options");
    target = stream->WriteString(6, s, target);
  }

  // optional .google.protobuf.Timestamp start_timestamp = 7;
  if (_internal_has_start_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::start_timestamp(this),
        _Internal::start_timestamp(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp end_timestamp = 8;
  if (_internal_has_end_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::end_timestamp(this),
        _Internal::end_timestamp(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.GovernanceTXN governance_txn = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_governance_txn_size()); i < n; i++) {
    const auto& repfield = this->_internal_governance_txn(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.GovernanceProposal)
  return target;
}

size_t GovernanceProposal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.GovernanceProposal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string options = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.options_.size());
  for (int i = 0, n = _impl_.options_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.options_.Get(i));
  }

  // repeated .zera_txn.GovernanceTXN governance_txn = 9;
  total_size += 1UL * this->_internal_governance_txn_size();
  for (const auto& msg : this->_impl_.governance_txn_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string title = 3;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string synopsis = 4;
  if (!this->_internal_synopsis().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_synopsis());
  }

  // string body = 5;
  if (!this->_internal_body().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_body());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .google.protobuf.Timestamp start_timestamp = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_timestamp_);
    }

    // optional .google.protobuf.Timestamp end_timestamp = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_timestamp_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GovernanceProposal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GovernanceProposal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GovernanceProposal::GetClassData() const { return &_class_data_; }


void GovernanceProposal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GovernanceProposal*>(&to_msg);
  auto& from = static_cast<const GovernanceProposal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.GovernanceProposal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  _this->_impl_.governance_txn_.MergeFrom(from._impl_.governance_txn_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_synopsis().empty()) {
    _this->_internal_set_synopsis(from._internal_synopsis());
  }
  if (!from._internal_body().empty()) {
    _this->_internal_set_body(from._internal_body());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_start_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_start_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_end_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_end_timestamp());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GovernanceProposal::CopyFrom(const GovernanceProposal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.GovernanceProposal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GovernanceProposal::IsInitialized() const {
  return true;
}

void GovernanceProposal::InternalSwap(GovernanceProposal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.options_.InternalSwap(&other->_impl_.options_);
  _impl_.governance_txn_.InternalSwap(&other->_impl_.governance_txn_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.synopsis_, lhs_arena,
      &other->_impl_.synopsis_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GovernanceProposal, _impl_.end_timestamp_)
      + sizeof(GovernanceProposal::_impl_.end_timestamp_)
      - PROTOBUF_FIELD_OFFSET(GovernanceProposal, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GovernanceProposal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[47]);
}

// ===================================================================

class GovernanceTXN::_Internal {
 public:
};

GovernanceTXN::GovernanceTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.GovernanceTXN)
}
GovernanceTXN::GovernanceTXN(const GovernanceTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GovernanceTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.serialized_txn_){}
    , decltype(_impl_.txn_hash_){}
    , decltype(_impl_.txn_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.serialized_txn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_txn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serialized_txn().empty()) {
    _this->_impl_.serialized_txn_.Set(from._internal_serialized_txn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_txn_hash().empty()) {
    _this->_impl_.txn_hash_.Set(from._internal_txn_hash(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.txn_type_ = from._impl_.txn_type_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.GovernanceTXN)
}

inline void GovernanceTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.serialized_txn_){}
    , decltype(_impl_.txn_hash_){}
    , decltype(_impl_.txn_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.serialized_txn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_txn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GovernanceTXN::~GovernanceTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.GovernanceTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GovernanceTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serialized_txn_.Destroy();
  _impl_.txn_hash_.Destroy();
}

void GovernanceTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GovernanceTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.GovernanceTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.serialized_txn_.ClearToEmpty();
  _impl_.txn_hash_.ClearToEmpty();
  _impl_.txn_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GovernanceTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.TRANSACTION_TYPE txn_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_txn_type(static_cast<::zera_txn::TRANSACTION_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes serialized_txn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_serialized_txn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes txn_hash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_txn_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GovernanceTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.GovernanceTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.TRANSACTION_TYPE txn_type = 1;
  if (this->_internal_txn_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_txn_type(), target);
  }

  // bytes serialized_txn = 2;
  if (!this->_internal_serialized_txn().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_serialized_txn(), target);
  }

  // bytes txn_hash = 3;
  if (!this->_internal_txn_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_txn_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.GovernanceTXN)
  return target;
}

size_t GovernanceTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.GovernanceTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes serialized_txn = 2;
  if (!this->_internal_serialized_txn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_serialized_txn());
  }

  // bytes txn_hash = 3;
  if (!this->_internal_txn_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_txn_hash());
  }

  // .zera_txn.TRANSACTION_TYPE txn_type = 1;
  if (this->_internal_txn_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_txn_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GovernanceTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GovernanceTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GovernanceTXN::GetClassData() const { return &_class_data_; }


void GovernanceTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GovernanceTXN*>(&to_msg);
  auto& from = static_cast<const GovernanceTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.GovernanceTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_serialized_txn().empty()) {
    _this->_internal_set_serialized_txn(from._internal_serialized_txn());
  }
  if (!from._internal_txn_hash().empty()) {
    _this->_internal_set_txn_hash(from._internal_txn_hash());
  }
  if (from._internal_txn_type() != 0) {
    _this->_internal_set_txn_type(from._internal_txn_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GovernanceTXN::CopyFrom(const GovernanceTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.GovernanceTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GovernanceTXN::IsInitialized() const {
  return true;
}

void GovernanceTXN::InternalSwap(GovernanceTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serialized_txn_, lhs_arena,
      &other->_impl_.serialized_txn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.txn_hash_, lhs_arena,
      &other->_impl_.txn_hash_, rhs_arena
  );
  swap(_impl_.txn_type_, other->_impl_.txn_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GovernanceTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[48]);
}

// ===================================================================

class SmartContractTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const SmartContractTXN* msg);
};

const ::zera_txn::BaseTXN&
SmartContractTXN::_Internal::base(const SmartContractTXN* msg) {
  return *msg->_impl_.base_;
}
SmartContractTXN::SmartContractTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.SmartContractTXN)
}
SmartContractTXN::SmartContractTXN(const SmartContractTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SmartContractTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.functions_){from._impl_.functions_}
    , decltype(_impl_.binary_code_){}
    , decltype(_impl_.smart_contract_name_){}
    , decltype(_impl_.source_code_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.language_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.binary_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.binary_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_binary_code().empty()) {
    _this->_impl_.binary_code_.Set(from._internal_binary_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.smart_contract_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_smart_contract_name().empty()) {
    _this->_impl_.smart_contract_name_.Set(from._internal_smart_contract_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.source_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_code().empty()) {
    _this->_impl_.source_code_.Set(from._internal_source_code(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  _this->_impl_.language_ = from._impl_.language_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.SmartContractTXN)
}

inline void SmartContractTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.functions_){arena}
    , decltype(_impl_.binary_code_){}
    , decltype(_impl_.smart_contract_name_){}
    , decltype(_impl_.source_code_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.language_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.binary_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.binary_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.smart_contract_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SmartContractTXN::~SmartContractTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.SmartContractTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmartContractTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.functions_.~RepeatedPtrField();
  _impl_.binary_code_.Destroy();
  _impl_.smart_contract_name_.Destroy();
  _impl_.source_code_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void SmartContractTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmartContractTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.SmartContractTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.functions_.Clear();
  _impl_.binary_code_.ClearToEmpty();
  _impl_.smart_contract_name_.ClearToEmpty();
  _impl_.source_code_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _impl_.language_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SmartContractTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes binary_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_binary_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.LANGUAGE language = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_language(static_cast<::zera_txn::LANGUAGE>(val));
        } else
          goto handle_unusual;
        continue;
      // string smart_contract_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_smart_contract_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.SmartContractTXN.smart_contract_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string functions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_functions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.SmartContractTXN.functions"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes source_code = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_source_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartContractTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.SmartContractTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // bytes binary_code = 2;
  if (!this->_internal_binary_code().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_binary_code(), target);
  }

  // .zera_txn.LANGUAGE language = 3;
  if (this->_internal_language() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_language(), target);
  }

  // string smart_contract_name = 4;
  if (!this->_internal_smart_contract_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_smart_contract_name().data(), static_cast<int>(this->_internal_smart_contract_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.SmartContractTXN.smart_contract_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_smart_contract_name(), target);
  }

  // repeated string functions = 5;
  for (int i = 0, n = this->_internal_functions_size(); i < n; i++) {
    const auto& s = this->_internal_functions(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.SmartContractTXN.functions");
    target = stream->WriteString(5, s, target);
  }

  // bytes source_code = 7;
  if (!this->_internal_source_code().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_source_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.SmartContractTXN)
  return target;
}

size_t SmartContractTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.SmartContractTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string functions = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.functions_.size());
  for (int i = 0, n = _impl_.functions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.functions_.Get(i));
  }

  // bytes binary_code = 2;
  if (!this->_internal_binary_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_binary_code());
  }

  // string smart_contract_name = 4;
  if (!this->_internal_smart_contract_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_smart_contract_name());
  }

  // bytes source_code = 7;
  if (!this->_internal_source_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_source_code());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // .zera_txn.LANGUAGE language = 3;
  if (this->_internal_language() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_language());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SmartContractTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SmartContractTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SmartContractTXN::GetClassData() const { return &_class_data_; }


void SmartContractTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SmartContractTXN*>(&to_msg);
  auto& from = static_cast<const SmartContractTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.SmartContractTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.functions_.MergeFrom(from._impl_.functions_);
  if (!from._internal_binary_code().empty()) {
    _this->_internal_set_binary_code(from._internal_binary_code());
  }
  if (!from._internal_smart_contract_name().empty()) {
    _this->_internal_set_smart_contract_name(from._internal_smart_contract_name());
  }
  if (!from._internal_source_code().empty()) {
    _this->_internal_set_source_code(from._internal_source_code());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  if (from._internal_language() != 0) {
    _this->_internal_set_language(from._internal_language());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SmartContractTXN::CopyFrom(const SmartContractTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.SmartContractTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartContractTXN::IsInitialized() const {
  return true;
}

void SmartContractTXN::InternalSwap(SmartContractTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.functions_.InternalSwap(&other->_impl_.functions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.binary_code_, lhs_arena,
      &other->_impl_.binary_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.smart_contract_name_, lhs_arena,
      &other->_impl_.smart_contract_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_code_, lhs_arena,
      &other->_impl_.source_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SmartContractTXN, _impl_.language_)
      + sizeof(SmartContractTXN::_impl_.language_)
      - PROTOBUF_FIELD_OFFSET(SmartContractTXN, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SmartContractTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[49]);
}

// ===================================================================

class Parameters::_Internal {
 public:
};

Parameters::Parameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Parameters)
}
Parameters::Parameters(const Parameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Parameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.Parameters)
}

inline void Parameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Parameters::~Parameters() {
  // @@protoc_insertion_point(destructor:zera_txn.Parameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Parameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
  _impl_.type_.Destroy();
}

void Parameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Parameters::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Parameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Parameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Parameters.type"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Parameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Parameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes value = 1;
  if (!this->_internal_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_value(), target);
  }

  // string type = 2;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Parameters.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Parameters)
  return target;
}

size_t Parameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Parameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes value = 1;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  // string type = 2;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Parameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Parameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Parameters::GetClassData() const { return &_class_data_; }


void Parameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Parameters*>(&to_msg);
  auto& from = static_cast<const Parameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Parameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Parameters::CopyFrom(const Parameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Parameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Parameters::IsInitialized() const {
  return true;
}

void Parameters::InternalSwap(Parameters* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Parameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[50]);
}

// ===================================================================

class SmartContractExecuteTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const SmartContractExecuteTXN* msg);
};

const ::zera_txn::BaseTXN&
SmartContractExecuteTXN::_Internal::base(const SmartContractExecuteTXN* msg) {
  return *msg->_impl_.base_;
}
SmartContractExecuteTXN::SmartContractExecuteTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.SmartContractExecuteTXN)
}
SmartContractExecuteTXN::SmartContractExecuteTXN(const SmartContractExecuteTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SmartContractExecuteTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parameters_){from._impl_.parameters_}
    , decltype(_impl_.smart_contract_name_){}
    , decltype(_impl_.function_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.instance_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.smart_contract_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_smart_contract_name().empty()) {
    _this->_impl_.smart_contract_name_.Set(from._internal_smart_contract_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_function().empty()) {
    _this->_impl_.function_.Set(from._internal_function(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  _this->_impl_.instance_ = from._impl_.instance_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.SmartContractExecuteTXN)
}

inline void SmartContractExecuteTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parameters_){arena}
    , decltype(_impl_.smart_contract_name_){}
    , decltype(_impl_.function_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.instance_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.smart_contract_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SmartContractExecuteTXN::~SmartContractExecuteTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.SmartContractExecuteTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmartContractExecuteTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parameters_.~RepeatedPtrField();
  _impl_.smart_contract_name_.Destroy();
  _impl_.function_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void SmartContractExecuteTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmartContractExecuteTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.SmartContractExecuteTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parameters_.Clear();
  _impl_.smart_contract_name_.ClearToEmpty();
  _impl_.function_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _impl_.instance_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SmartContractExecuteTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string smart_contract_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_smart_contract_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.SmartContractExecuteTXN.smart_contract_name"));
        } else
          goto handle_unusual;
        continue;
      // uint32 instance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.instance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string function = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_function();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.SmartContractExecuteTXN.function"));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.Parameters parameters = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartContractExecuteTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.SmartContractExecuteTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string smart_contract_name = 2;
  if (!this->_internal_smart_contract_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_smart_contract_name().data(), static_cast<int>(this->_internal_smart_contract_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.SmartContractExecuteTXN.smart_contract_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_smart_contract_name(), target);
  }

  // uint32 instance = 3;
  if (this->_internal_instance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_instance(), target);
  }

  // string function = 4;
  if (!this->_internal_function().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_function().data(), static_cast<int>(this->_internal_function().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.SmartContractExecuteTXN.function");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_function(), target);
  }

  // repeated .zera_txn.Parameters parameters = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.SmartContractExecuteTXN)
  return target;
}

size_t SmartContractExecuteTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.SmartContractExecuteTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.Parameters parameters = 5;
  total_size += 1UL * this->_internal_parameters_size();
  for (const auto& msg : this->_impl_.parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string smart_contract_name = 2;
  if (!this->_internal_smart_contract_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_smart_contract_name());
  }

  // string function = 4;
  if (!this->_internal_function().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_function());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // uint32 instance = 3;
  if (this->_internal_instance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_instance());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SmartContractExecuteTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SmartContractExecuteTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SmartContractExecuteTXN::GetClassData() const { return &_class_data_; }


void SmartContractExecuteTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SmartContractExecuteTXN*>(&to_msg);
  auto& from = static_cast<const SmartContractExecuteTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.SmartContractExecuteTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  if (!from._internal_smart_contract_name().empty()) {
    _this->_internal_set_smart_contract_name(from._internal_smart_contract_name());
  }
  if (!from._internal_function().empty()) {
    _this->_internal_set_function(from._internal_function());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  if (from._internal_instance() != 0) {
    _this->_internal_set_instance(from._internal_instance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SmartContractExecuteTXN::CopyFrom(const SmartContractExecuteTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.SmartContractExecuteTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartContractExecuteTXN::IsInitialized() const {
  return true;
}

void SmartContractExecuteTXN::InternalSwap(SmartContractExecuteTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.smart_contract_name_, lhs_arena,
      &other->_impl_.smart_contract_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.function_, lhs_arena,
      &other->_impl_.function_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SmartContractExecuteTXN, _impl_.instance_)
      + sizeof(SmartContractExecuteTXN::_impl_.instance_)
      - PROTOBUF_FIELD_OFFSET(SmartContractExecuteTXN, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SmartContractExecuteTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[51]);
}

// ===================================================================

class SmartContractInstantiateTXN::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const SmartContractInstantiateTXN* msg);
};

const ::zera_txn::BaseTXN&
SmartContractInstantiateTXN::_Internal::base(const SmartContractInstantiateTXN* msg) {
  return *msg->_impl_.base_;
}
SmartContractInstantiateTXN::SmartContractInstantiateTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.SmartContractInstantiateTXN)
}
SmartContractInstantiateTXN::SmartContractInstantiateTXN(const SmartContractInstantiateTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SmartContractInstantiateTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parameters_){from._impl_.parameters_}
    , decltype(_impl_.smart_contract_name_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.instance_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.smart_contract_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_smart_contract_name().empty()) {
    _this->_impl_.smart_contract_name_.Set(from._internal_smart_contract_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  _this->_impl_.instance_ = from._impl_.instance_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.SmartContractInstantiateTXN)
}

inline void SmartContractInstantiateTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parameters_){arena}
    , decltype(_impl_.smart_contract_name_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.instance_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.smart_contract_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smart_contract_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SmartContractInstantiateTXN::~SmartContractInstantiateTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.SmartContractInstantiateTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmartContractInstantiateTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parameters_.~RepeatedPtrField();
  _impl_.smart_contract_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void SmartContractInstantiateTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmartContractInstantiateTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.SmartContractInstantiateTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parameters_.Clear();
  _impl_.smart_contract_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _impl_.instance_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SmartContractInstantiateTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string smart_contract_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_smart_contract_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.SmartContractInstantiateTXN.smart_contract_name"));
        } else
          goto handle_unusual;
        continue;
      // uint32 instance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.instance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.Parameters parameters = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartContractInstantiateTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.SmartContractInstantiateTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string smart_contract_name = 2;
  if (!this->_internal_smart_contract_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_smart_contract_name().data(), static_cast<int>(this->_internal_smart_contract_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.SmartContractInstantiateTXN.smart_contract_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_smart_contract_name(), target);
  }

  // uint32 instance = 3;
  if (this->_internal_instance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_instance(), target);
  }

  // repeated .zera_txn.Parameters parameters = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.SmartContractInstantiateTXN)
  return target;
}

size_t SmartContractInstantiateTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.SmartContractInstantiateTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.Parameters parameters = 4;
  total_size += 1UL * this->_internal_parameters_size();
  for (const auto& msg : this->_impl_.parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string smart_contract_name = 2;
  if (!this->_internal_smart_contract_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_smart_contract_name());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // uint32 instance = 3;
  if (this->_internal_instance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_instance());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SmartContractInstantiateTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SmartContractInstantiateTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SmartContractInstantiateTXN::GetClassData() const { return &_class_data_; }


void SmartContractInstantiateTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SmartContractInstantiateTXN*>(&to_msg);
  auto& from = static_cast<const SmartContractInstantiateTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.SmartContractInstantiateTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  if (!from._internal_smart_contract_name().empty()) {
    _this->_internal_set_smart_contract_name(from._internal_smart_contract_name());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  if (from._internal_instance() != 0) {
    _this->_internal_set_instance(from._internal_instance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SmartContractInstantiateTXN::CopyFrom(const SmartContractInstantiateTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.SmartContractInstantiateTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartContractInstantiateTXN::IsInitialized() const {
  return true;
}

void SmartContractInstantiateTXN::InternalSwap(SmartContractInstantiateTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.smart_contract_name_, lhs_arena,
      &other->_impl_.smart_contract_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SmartContractInstantiateTXN, _impl_.instance_)
      + sizeof(SmartContractInstantiateTXN::_impl_.instance_)
      - PROTOBUF_FIELD_OFFSET(SmartContractInstantiateTXN, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SmartContractInstantiateTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[52]);
}

// ===================================================================

class Validator::_Internal {
 public:
  static const ::zera_txn::PublicKey& public_key(const Validator* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const Validator* msg);
};

const ::zera_txn::PublicKey&
Validator::_Internal::public_key(const Validator* msg) {
  return *msg->_impl_.public_key_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Validator::_Internal::timestamp(const Validator* msg) {
  return *msg->_impl_.timestamp_;
}
void Validator::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
Validator::Validator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Validator)
}
Validator::Validator(const Validator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Validator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.staked_contract_ids_){from._impl_.staked_contract_ids_}
    , decltype(_impl_.host_){}
    , decltype(_impl_.client_port_){}
    , decltype(_impl_.validator_port_){}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.benchmark_){}
    , decltype(_impl_.lite_){}
    , decltype(_impl_.online_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.last_heartbeat_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host().empty()) {
    _this->_impl_.host_.Set(from._internal_host(), 
      _this->GetArenaForAllocation());
  }
  _impl_.client_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_client_port().empty()) {
    _this->_impl_.client_port_.Set(from._internal_client_port(), 
      _this->GetArenaForAllocation());
  }
  _impl_.validator_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validator_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_validator_port().empty()) {
    _this->_impl_.validator_port_.Set(from._internal_validator_port(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_ = new ::zera_txn::PublicKey(*from._impl_.public_key_);
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.benchmark_, &from._impl_.benchmark_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_heartbeat_) -
    reinterpret_cast<char*>(&_impl_.benchmark_)) + sizeof(_impl_.last_heartbeat_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.Validator)
}

inline void Validator::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.staked_contract_ids_){arena}
    , decltype(_impl_.host_){}
    , decltype(_impl_.client_port_){}
    , decltype(_impl_.validator_port_){}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.benchmark_){uint64_t{0u}}
    , decltype(_impl_.lite_){false}
    , decltype(_impl_.online_){false}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.last_heartbeat_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.validator_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.validator_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Validator::~Validator() {
  // @@protoc_insertion_point(destructor:zera_txn.Validator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Validator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.staked_contract_ids_.~RepeatedPtrField();
  _impl_.host_.Destroy();
  _impl_.client_port_.Destroy();
  _impl_.validator_port_.Destroy();
  if (this != internal_default_instance()) delete _impl_.public_key_;
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void Validator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Validator::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Validator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.staked_contract_ids_.Clear();
  _impl_.host_.ClearToEmpty();
  _impl_.client_port_.ClearToEmpty();
  _impl_.validator_port_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.public_key_ != nullptr) {
    delete _impl_.public_key_;
  }
  _impl_.public_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  ::memset(&_impl_.benchmark_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.last_heartbeat_) -
      reinterpret_cast<char*>(&_impl_.benchmark_)) + sizeof(_impl_.last_heartbeat_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Validator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.PublicKey public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string host = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Validator.host"));
        } else
          goto handle_unusual;
        continue;
      // string client_port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_client_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Validator.client_port"));
        } else
          goto handle_unusual;
        continue;
      // string validator_port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_validator_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Validator.validator_port"));
        } else
          goto handle_unusual;
        continue;
      // repeated string staked_contract_ids = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_staked_contract_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Validator.staked_contract_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 benchmark = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.benchmark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool lite = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.lite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool online = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.online_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 version = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 last_heartbeat = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.last_heartbeat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Validator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Validator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.PublicKey public_key = 1;
  if (this->_internal_has_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  // string host = 2;
  if (!this->_internal_host().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host().data(), static_cast<int>(this->_internal_host().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Validator.host");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_host(), target);
  }

  // string client_port = 3;
  if (!this->_internal_client_port().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_client_port().data(), static_cast<int>(this->_internal_client_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Validator.client_port");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_client_port(), target);
  }

  // string validator_port = 4;
  if (!this->_internal_validator_port().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_validator_port().data(), static_cast<int>(this->_internal_validator_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Validator.validator_port");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_validator_port(), target);
  }

  // repeated string staked_contract_ids = 5;
  for (int i = 0, n = this->_internal_staked_contract_ids_size(); i < n; i++) {
    const auto& s = this->_internal_staked_contract_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Validator.staked_contract_ids");
    target = stream->WriteString(5, s, target);
  }

  // uint64 benchmark = 6;
  if (this->_internal_benchmark() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_benchmark(), target);
  }

  // .google.protobuf.Timestamp timestamp = 7;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // bool lite = 8;
  if (this->_internal_lite() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_lite(), target);
  }

  // bool online = 9;
  if (this->_internal_online() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_online(), target);
  }

  // uint32 version = 10;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_version(), target);
  }

  // uint64 last_heartbeat = 11;
  if (this->_internal_last_heartbeat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_last_heartbeat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Validator)
  return target;
}

size_t Validator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Validator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string staked_contract_ids = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.staked_contract_ids_.size());
  for (int i = 0, n = _impl_.staked_contract_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.staked_contract_ids_.Get(i));
  }

  // string host = 2;
  if (!this->_internal_host().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host());
  }

  // string client_port = 3;
  if (!this->_internal_client_port().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_port());
  }

  // string validator_port = 4;
  if (!this->_internal_validator_port().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_validator_port());
  }

  // .zera_txn.PublicKey public_key = 1;
  if (this->_internal_has_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.public_key_);
  }

  // .google.protobuf.Timestamp timestamp = 7;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // uint64 benchmark = 6;
  if (this->_internal_benchmark() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_benchmark());
  }

  // bool lite = 8;
  if (this->_internal_lite() != 0) {
    total_size += 1 + 1;
  }

  // bool online = 9;
  if (this->_internal_online() != 0) {
    total_size += 1 + 1;
  }

  // uint32 version = 10;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  // uint64 last_heartbeat = 11;
  if (this->_internal_last_heartbeat() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_heartbeat());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Validator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Validator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Validator::GetClassData() const { return &_class_data_; }


void Validator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Validator*>(&to_msg);
  auto& from = static_cast<const Validator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Validator)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.staked_contract_ids_.MergeFrom(from._impl_.staked_contract_ids_);
  if (!from._internal_host().empty()) {
    _this->_internal_set_host(from._internal_host());
  }
  if (!from._internal_client_port().empty()) {
    _this->_internal_set_client_port(from._internal_client_port());
  }
  if (!from._internal_validator_port().empty()) {
    _this->_internal_set_validator_port(from._internal_validator_port());
  }
  if (from._internal_has_public_key()) {
    _this->_internal_mutable_public_key()->::zera_txn::PublicKey::MergeFrom(
        from._internal_public_key());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_benchmark() != 0) {
    _this->_internal_set_benchmark(from._internal_benchmark());
  }
  if (from._internal_lite() != 0) {
    _this->_internal_set_lite(from._internal_lite());
  }
  if (from._internal_online() != 0) {
    _this->_internal_set_online(from._internal_online());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_last_heartbeat() != 0) {
    _this->_internal_set_last_heartbeat(from._internal_last_heartbeat());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Validator::CopyFrom(const Validator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Validator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Validator::IsInitialized() const {
  return true;
}

void Validator::InternalSwap(Validator* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.staked_contract_ids_.InternalSwap(&other->_impl_.staked_contract_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_, lhs_arena,
      &other->_impl_.host_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_port_, lhs_arena,
      &other->_impl_.client_port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.validator_port_, lhs_arena,
      &other->_impl_.validator_port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Validator, _impl_.last_heartbeat_)
      + sizeof(Validator::_impl_.last_heartbeat_)
      - PROTOBUF_FIELD_OFFSET(Validator, _impl_.public_key_)>(
          reinterpret_cast<char*>(&_impl_.public_key_),
          reinterpret_cast<char*>(&other->_impl_.public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Validator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[53]);
}

// ===================================================================

class ValidatorRegistration::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const ValidatorRegistration* msg);
  static const ::zera_txn::Validator& validator(const ValidatorRegistration* msg);
  static const ::zera_txn::PublicKey& generated_public_key(const ValidatorRegistration* msg);
};

const ::zera_txn::BaseTXN&
ValidatorRegistration::_Internal::base(const ValidatorRegistration* msg) {
  return *msg->_impl_.base_;
}
const ::zera_txn::Validator&
ValidatorRegistration::_Internal::validator(const ValidatorRegistration* msg) {
  return *msg->_impl_.validator_;
}
const ::zera_txn::PublicKey&
ValidatorRegistration::_Internal::generated_public_key(const ValidatorRegistration* msg) {
  return *msg->_impl_.generated_public_key_;
}
ValidatorRegistration::ValidatorRegistration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ValidatorRegistration)
}
ValidatorRegistration::ValidatorRegistration(const ValidatorRegistration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ValidatorRegistration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.generated_signature_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.validator_){nullptr}
    , decltype(_impl_.generated_public_key_){nullptr}
    , decltype(_impl_.register__){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.generated_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.generated_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_generated_signature().empty()) {
    _this->_impl_.generated_signature_.Set(from._internal_generated_signature(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  if (from._internal_has_validator()) {
    _this->_impl_.validator_ = new ::zera_txn::Validator(*from._impl_.validator_);
  }
  if (from._internal_has_generated_public_key()) {
    _this->_impl_.generated_public_key_ = new ::zera_txn::PublicKey(*from._impl_.generated_public_key_);
  }
  _this->_impl_.register__ = from._impl_.register__;
  // @@protoc_insertion_point(copy_constructor:zera_txn.ValidatorRegistration)
}

inline void ValidatorRegistration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.generated_signature_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.validator_){nullptr}
    , decltype(_impl_.generated_public_key_){nullptr}
    , decltype(_impl_.register__){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.generated_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.generated_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ValidatorRegistration::~ValidatorRegistration() {
  // @@protoc_insertion_point(destructor:zera_txn.ValidatorRegistration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValidatorRegistration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.generated_signature_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.validator_;
  if (this != internal_default_instance()) delete _impl_.generated_public_key_;
}

void ValidatorRegistration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ValidatorRegistration::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ValidatorRegistration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.generated_signature_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.validator_ != nullptr) {
    delete _impl_.validator_;
  }
  _impl_.validator_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.generated_public_key_ != nullptr) {
    delete _impl_.generated_public_key_;
  }
  _impl_.generated_public_key_ = nullptr;
  _impl_.register__ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ValidatorRegistration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.Validator validator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_validator(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool register = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.register__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.PublicKey generated_public_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_generated_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes generated_signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_generated_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValidatorRegistration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ValidatorRegistration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.Validator validator = 2;
  if (this->_internal_has_validator()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::validator(this),
        _Internal::validator(this).GetCachedSize(), target, stream);
  }

  // bool register = 3;
  if (this->_internal_register_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_register_(), target);
  }

  // .zera_txn.PublicKey generated_public_key = 4;
  if (this->_internal_has_generated_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::generated_public_key(this),
        _Internal::generated_public_key(this).GetCachedSize(), target, stream);
  }

  // bytes generated_signature = 5;
  if (!this->_internal_generated_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_generated_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ValidatorRegistration)
  return target;
}

size_t ValidatorRegistration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ValidatorRegistration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes generated_signature = 5;
  if (!this->_internal_generated_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_generated_signature());
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // .zera_txn.Validator validator = 2;
  if (this->_internal_has_validator()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.validator_);
  }

  // .zera_txn.PublicKey generated_public_key = 4;
  if (this->_internal_has_generated_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.generated_public_key_);
  }

  // bool register = 3;
  if (this->_internal_register_() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ValidatorRegistration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ValidatorRegistration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ValidatorRegistration::GetClassData() const { return &_class_data_; }


void ValidatorRegistration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ValidatorRegistration*>(&to_msg);
  auto& from = static_cast<const ValidatorRegistration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ValidatorRegistration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_generated_signature().empty()) {
    _this->_internal_set_generated_signature(from._internal_generated_signature());
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  if (from._internal_has_validator()) {
    _this->_internal_mutable_validator()->::zera_txn::Validator::MergeFrom(
        from._internal_validator());
  }
  if (from._internal_has_generated_public_key()) {
    _this->_internal_mutable_generated_public_key()->::zera_txn::PublicKey::MergeFrom(
        from._internal_generated_public_key());
  }
  if (from._internal_register_() != 0) {
    _this->_internal_set_register_(from._internal_register_());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ValidatorRegistration::CopyFrom(const ValidatorRegistration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ValidatorRegistration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValidatorRegistration::IsInitialized() const {
  return true;
}

void ValidatorRegistration::InternalSwap(ValidatorRegistration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.generated_signature_, lhs_arena,
      &other->_impl_.generated_signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ValidatorRegistration, _impl_.register__)
      + sizeof(ValidatorRegistration::_impl_.register__)
      - PROTOBUF_FIELD_OFFSET(ValidatorRegistration, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ValidatorRegistration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[54]);
}

// ===================================================================

class ValidatorHeartbeat::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const ValidatorHeartbeat* msg);
};

const ::zera_txn::BaseTXN&
ValidatorHeartbeat::_Internal::base(const ValidatorHeartbeat* msg) {
  return *msg->_impl_.base_;
}
ValidatorHeartbeat::ValidatorHeartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ValidatorHeartbeat)
}
ValidatorHeartbeat::ValidatorHeartbeat(const ValidatorHeartbeat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ValidatorHeartbeat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.base_){nullptr}
    , decltype(_impl_.online_){}
    , decltype(_impl_.version_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  ::memcpy(&_impl_.online_, &from._impl_.online_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.online_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.ValidatorHeartbeat)
}

inline void ValidatorHeartbeat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.base_){nullptr}
    , decltype(_impl_.online_){false}
    , decltype(_impl_.version_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ValidatorHeartbeat::~ValidatorHeartbeat() {
  // @@protoc_insertion_point(destructor:zera_txn.ValidatorHeartbeat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValidatorHeartbeat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}

void ValidatorHeartbeat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ValidatorHeartbeat::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ValidatorHeartbeat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  ::memset(&_impl_.online_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.version_) -
      reinterpret_cast<char*>(&_impl_.online_)) + sizeof(_impl_.version_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ValidatorHeartbeat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool online = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.online_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValidatorHeartbeat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ValidatorHeartbeat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // bool online = 2;
  if (this->_internal_online() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_online(), target);
  }

  // uint32 version = 3;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ValidatorHeartbeat)
  return target;
}

size_t ValidatorHeartbeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ValidatorHeartbeat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // bool online = 2;
  if (this->_internal_online() != 0) {
    total_size += 1 + 1;
  }

  // uint32 version = 3;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ValidatorHeartbeat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ValidatorHeartbeat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ValidatorHeartbeat::GetClassData() const { return &_class_data_; }


void ValidatorHeartbeat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ValidatorHeartbeat*>(&to_msg);
  auto& from = static_cast<const ValidatorHeartbeat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ValidatorHeartbeat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  if (from._internal_online() != 0) {
    _this->_internal_set_online(from._internal_online());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ValidatorHeartbeat::CopyFrom(const ValidatorHeartbeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ValidatorHeartbeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValidatorHeartbeat::IsInitialized() const {
  return true;
}

void ValidatorHeartbeat::InternalSwap(ValidatorHeartbeat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ValidatorHeartbeat, _impl_.version_)
      + sizeof(ValidatorHeartbeat::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(ValidatorHeartbeat, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ValidatorHeartbeat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[55]);
}

// ===================================================================

class SmartContractParameter::_Internal {
 public:
  using HasBits = decltype(std::declval<SmartContractParameter>()._impl_._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SmartContractParameter::SmartContractParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.SmartContractParameter)
}
SmartContractParameter::SmartContractParameter(const SmartContractParameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SmartContractParameter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.SmartContractParameter)
}

inline void SmartContractParameter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.type_){0}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SmartContractParameter::~SmartContractParameter() {
  // @@protoc_insertion_point(destructor:zera_txn.SmartContractParameter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmartContractParameter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void SmartContractParameter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmartContractParameter::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.SmartContractParameter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.value_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.type_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SmartContractParameter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.VARIABLE_TYPE type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::zera_txn::VARIABLE_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.SmartContractParameter.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartContractParameter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.SmartContractParameter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 index = 1;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_index(), target);
  }

  // .zera_txn.VARIABLE_TYPE type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional string value = 3;
  if (_internal_has_value()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.SmartContractParameter.value");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.SmartContractParameter)
  return target;
}

size_t SmartContractParameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.SmartContractParameter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string value = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  // uint32 index = 1;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  // .zera_txn.VARIABLE_TYPE type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SmartContractParameter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SmartContractParameter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SmartContractParameter::GetClassData() const { return &_class_data_; }


void SmartContractParameter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SmartContractParameter*>(&to_msg);
  auto& from = static_cast<const SmartContractParameter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.SmartContractParameter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SmartContractParameter::CopyFrom(const SmartContractParameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.SmartContractParameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartContractParameter::IsInitialized() const {
  return true;
}

void SmartContractParameter::InternalSwap(SmartContractParameter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SmartContractParameter, _impl_.type_)
      + sizeof(SmartContractParameter::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SmartContractParameter, _impl_.index_)>(
          reinterpret_cast<char*>(&_impl_.index_),
          reinterpret_cast<char*>(&other->_impl_.index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SmartContractParameter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[56]);
}

// ===================================================================

class Votes::_Internal {
 public:
};

Votes::Votes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Votes)
}
Votes::Votes(const Votes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Votes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.votes_){from._impl_.votes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:zera_txn.Votes)
}

inline void Votes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.votes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Votes::~Votes() {
  // @@protoc_insertion_point(destructor:zera_txn.Votes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Votes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.votes_.~RepeatedPtrField();
}

void Votes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Votes::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Votes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.votes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Votes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .zera_txn.VotePair votes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_votes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Votes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Votes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .zera_txn.VotePair votes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_votes_size()); i < n; i++) {
    const auto& repfield = this->_internal_votes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Votes)
  return target;
}

size_t Votes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Votes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.VotePair votes = 1;
  total_size += 1UL * this->_internal_votes_size();
  for (const auto& msg : this->_impl_.votes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Votes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Votes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Votes::GetClassData() const { return &_class_data_; }


void Votes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Votes*>(&to_msg);
  auto& from = static_cast<const Votes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Votes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.votes_.MergeFrom(from._impl_.votes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Votes::CopyFrom(const Votes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Votes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Votes::IsInitialized() const {
  return true;
}

void Votes::InternalSwap(Votes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.votes_.InternalSwap(&other->_impl_.votes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Votes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[57]);
}

// ===================================================================

class VotePair::_Internal {
 public:
};

VotePair::VotePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.VotePair)
}
VotePair::VotePair(const VotePair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VotePair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.VotePair)
}

inline void VotePair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VotePair::~VotePair() {
  // @@protoc_insertion_point(destructor:zera_txn.VotePair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VotePair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.amount_.Destroy();
}

void VotePair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VotePair::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.VotePair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VotePair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.VotePair.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.VotePair.amount"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VotePair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.VotePair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.VotePair.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.VotePair.amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.VotePair)
  return target;
}

size_t VotePair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.VotePair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VotePair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VotePair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VotePair::GetClassData() const { return &_class_data_; }


void VotePair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VotePair*>(&to_msg);
  auto& from = static_cast<const VotePair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.VotePair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VotePair::CopyFrom(const VotePair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.VotePair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VotePair::IsInitialized() const {
  return true;
}

void VotePair::InternalSwap(VotePair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata VotePair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[58]);
}

// ===================================================================

class RequiredVersion::_Internal {
 public:
  static const ::zera_txn::BaseTXN& base(const RequiredVersion* msg);
};

const ::zera_txn::BaseTXN&
RequiredVersion::_Internal::base(const RequiredVersion* msg) {
  return *msg->_impl_.base_;
}
RequiredVersion::RequiredVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.RequiredVersion)
}
RequiredVersion::RequiredVersion(const RequiredVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequiredVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){from._impl_.version_}
    , /*decltype(_impl_._version_cached_byte_size_)*/{0}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.RequiredVersion)
}

inline void RequiredVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){arena}
    , /*decltype(_impl_._version_cached_byte_size_)*/{0}
    , decltype(_impl_.base_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RequiredVersion::~RequiredVersion() {
  // @@protoc_insertion_point(destructor:zera_txn.RequiredVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequiredVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.version_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void RequiredVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequiredVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.RequiredVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.version_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequiredVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_version(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_version(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequiredVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.RequiredVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // repeated uint32 version = 2;
  {
    int byte_size = _impl_._version_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_version(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.RequiredVersion)
  return target;
}

size_t RequiredVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.RequiredVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 version = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.version_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._version_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequiredVersion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequiredVersion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequiredVersion::GetClassData() const { return &_class_data_; }


void RequiredVersion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequiredVersion*>(&to_msg);
  auto& from = static_cast<const RequiredVersion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.RequiredVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.version_.MergeFrom(from._impl_.version_);
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequiredVersion::CopyFrom(const RequiredVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.RequiredVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequiredVersion::IsInitialized() const {
  return true;
}

void RequiredVersion::InternalSwap(RequiredVersion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.version_.InternalSwap(&other->_impl_.version_);
  swap(_impl_.base_, other->_impl_.base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequiredVersion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[59]);
}

// ===================================================================

class ProposalResult::_Internal {
 public:
  using HasBits = decltype(std::declval<ProposalResult>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const ProposalResult* msg);
  static void set_has_support_cur_equiv(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_against_cur_equiv(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::zera_txn::Votes& support_votes(const ProposalResult* msg);
  static void set_has_support_votes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::zera_txn::Votes& against_votes(const ProposalResult* msg);
  static void set_has_against_votes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_proposal_cut(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::zera_txn::BaseTXN&
ProposalResult::_Internal::base(const ProposalResult* msg) {
  return *msg->_impl_.base_;
}
const ::zera_txn::Votes&
ProposalResult::_Internal::support_votes(const ProposalResult* msg) {
  return *msg->_impl_.support_votes_;
}
const ::zera_txn::Votes&
ProposalResult::_Internal::against_votes(const ProposalResult* msg) {
  return *msg->_impl_.against_votes_;
}
ProposalResult::ProposalResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ProposalResult)
}
ProposalResult::ProposalResult(const ProposalResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProposalResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.option_cur_equiv_){from._impl_.option_cur_equiv_}
    , decltype(_impl_.option_votes_){from._impl_.option_votes_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.proposal_id_){}
    , decltype(_impl_.support_cur_equiv_){}
    , decltype(_impl_.against_cur_equiv_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.support_votes_){nullptr}
    , decltype(_impl_.against_votes_){nullptr}
    , decltype(_impl_.stage_){}
    , decltype(_impl_.passed_){}
    , decltype(_impl_.final_stage_){}
    , decltype(_impl_.fast_quorum_){}
    , decltype(_impl_.proposal_cut_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.proposal_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_proposal_id().empty()) {
    _this->_impl_.proposal_id_.Set(from._internal_proposal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.support_cur_equiv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.support_cur_equiv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_support_cur_equiv()) {
    _this->_impl_.support_cur_equiv_.Set(from._internal_support_cur_equiv(), 
      _this->GetArenaForAllocation());
  }
  _impl_.against_cur_equiv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.against_cur_equiv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_against_cur_equiv()) {
    _this->_impl_.against_cur_equiv_.Set(from._internal_against_cur_equiv(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  if (from._internal_has_support_votes()) {
    _this->_impl_.support_votes_ = new ::zera_txn::Votes(*from._impl_.support_votes_);
  }
  if (from._internal_has_against_votes()) {
    _this->_impl_.against_votes_ = new ::zera_txn::Votes(*from._impl_.against_votes_);
  }
  ::memcpy(&_impl_.stage_, &from._impl_.stage_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.proposal_cut_) -
    reinterpret_cast<char*>(&_impl_.stage_)) + sizeof(_impl_.proposal_cut_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.ProposalResult)
}

inline void ProposalResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.option_cur_equiv_){arena}
    , decltype(_impl_.option_votes_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.proposal_id_){}
    , decltype(_impl_.support_cur_equiv_){}
    , decltype(_impl_.against_cur_equiv_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.support_votes_){nullptr}
    , decltype(_impl_.against_votes_){nullptr}
    , decltype(_impl_.stage_){0u}
    , decltype(_impl_.passed_){false}
    , decltype(_impl_.final_stage_){false}
    , decltype(_impl_.fast_quorum_){false}
    , decltype(_impl_.proposal_cut_){false}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.proposal_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proposal_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.support_cur_equiv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.support_cur_equiv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.against_cur_equiv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.against_cur_equiv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProposalResult::~ProposalResult() {
  // @@protoc_insertion_point(destructor:zera_txn.ProposalResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProposalResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.option_cur_equiv_.~RepeatedPtrField();
  _impl_.option_votes_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
  _impl_.proposal_id_.Destroy();
  _impl_.support_cur_equiv_.Destroy();
  _impl_.against_cur_equiv_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.support_votes_;
  if (this != internal_default_instance()) delete _impl_.against_votes_;
}

void ProposalResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProposalResult::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ProposalResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.option_cur_equiv_.Clear();
  _impl_.option_votes_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.proposal_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.support_cur_equiv_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.against_cur_equiv_.ClearNonDefaultToEmpty();
    }
  }
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  if (cached_has_bits & 0x0000000cu) {
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.support_votes_ != nullptr);
      _impl_.support_votes_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.against_votes_ != nullptr);
      _impl_.against_votes_->Clear();
    }
  }
  ::memset(&_impl_.stage_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.fast_quorum_) -
      reinterpret_cast<char*>(&_impl_.stage_)) + sizeof(_impl_.fast_quorum_));
  _impl_.proposal_cut_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProposalResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ProposalResult.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // bytes proposal_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_proposal_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string support_cur_equiv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_support_cur_equiv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ProposalResult.support_cur_equiv"));
        } else
          goto handle_unusual;
        continue;
      // optional string against_cur_equiv = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_against_cur_equiv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ProposalResult.against_cur_equiv"));
        } else
          goto handle_unusual;
        continue;
      // repeated string option_cur_equiv = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_option_cur_equiv();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ProposalResult.option_cur_equiv"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.Votes support_votes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_support_votes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.Votes against_votes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_against_votes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.Votes option_votes = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_option_votes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool passed = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.passed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool final_stage = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.final_stage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 stage = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.stage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool fast_quorum = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.fast_quorum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool proposal_cut = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_proposal_cut(&has_bits);
          _impl_.proposal_cut_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProposalResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ProposalResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ProposalResult.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // bytes proposal_id = 3;
  if (!this->_internal_proposal_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_proposal_id(), target);
  }

  // optional string support_cur_equiv = 4;
  if (_internal_has_support_cur_equiv()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_support_cur_equiv().data(), static_cast<int>(this->_internal_support_cur_equiv().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ProposalResult.support_cur_equiv");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_support_cur_equiv(), target);
  }

  // optional string against_cur_equiv = 5;
  if (_internal_has_against_cur_equiv()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_against_cur_equiv().data(), static_cast<int>(this->_internal_against_cur_equiv().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ProposalResult.against_cur_equiv");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_against_cur_equiv(), target);
  }

  // repeated string option_cur_equiv = 6;
  for (int i = 0, n = this->_internal_option_cur_equiv_size(); i < n; i++) {
    const auto& s = this->_internal_option_cur_equiv(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ProposalResult.option_cur_equiv");
    target = stream->WriteString(6, s, target);
  }

  // optional .zera_txn.Votes support_votes = 7;
  if (_internal_has_support_votes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::support_votes(this),
        _Internal::support_votes(this).GetCachedSize(), target, stream);
  }

  // optional .zera_txn.Votes against_votes = 8;
  if (_internal_has_against_votes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::against_votes(this),
        _Internal::against_votes(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.Votes option_votes = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_option_votes_size()); i < n; i++) {
    const auto& repfield = this->_internal_option_votes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool passed = 10;
  if (this->_internal_passed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_passed(), target);
  }

  // bool final_stage = 11;
  if (this->_internal_final_stage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_final_stage(), target);
  }

  // uint32 stage = 12;
  if (this->_internal_stage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_stage(), target);
  }

  // bool fast_quorum = 13;
  if (this->_internal_fast_quorum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_fast_quorum(), target);
  }

  // optional bool proposal_cut = 14;
  if (_internal_has_proposal_cut()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_proposal_cut(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ProposalResult)
  return target;
}

size_t ProposalResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ProposalResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string option_cur_equiv = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.option_cur_equiv_.size());
  for (int i = 0, n = _impl_.option_cur_equiv_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.option_cur_equiv_.Get(i));
  }

  // repeated .zera_txn.Votes option_votes = 9;
  total_size += 1UL * this->_internal_option_votes_size();
  for (const auto& msg : this->_impl_.option_votes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // bytes proposal_id = 3;
  if (!this->_internal_proposal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_proposal_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string support_cur_equiv = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_support_cur_equiv());
    }

    // optional string against_cur_equiv = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_against_cur_equiv());
    }

  }
  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional .zera_txn.Votes support_votes = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.support_votes_);
    }

    // optional .zera_txn.Votes against_votes = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.against_votes_);
    }

  }
  // uint32 stage = 12;
  if (this->_internal_stage() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stage());
  }

  // bool passed = 10;
  if (this->_internal_passed() != 0) {
    total_size += 1 + 1;
  }

  // bool final_stage = 11;
  if (this->_internal_final_stage() != 0) {
    total_size += 1 + 1;
  }

  // bool fast_quorum = 13;
  if (this->_internal_fast_quorum() != 0) {
    total_size += 1 + 1;
  }

  // optional bool proposal_cut = 14;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProposalResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProposalResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProposalResult::GetClassData() const { return &_class_data_; }


void ProposalResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProposalResult*>(&to_msg);
  auto& from = static_cast<const ProposalResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ProposalResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.option_cur_equiv_.MergeFrom(from._impl_.option_cur_equiv_);
  _this->_impl_.option_votes_.MergeFrom(from._impl_.option_votes_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_proposal_id().empty()) {
    _this->_internal_set_proposal_id(from._internal_proposal_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_support_cur_equiv(from._internal_support_cur_equiv());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_against_cur_equiv(from._internal_against_cur_equiv());
    }
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  if (cached_has_bits & 0x0000000cu) {
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_support_votes()->::zera_txn::Votes::MergeFrom(
          from._internal_support_votes());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_against_votes()->::zera_txn::Votes::MergeFrom(
          from._internal_against_votes());
    }
  }
  if (from._internal_stage() != 0) {
    _this->_internal_set_stage(from._internal_stage());
  }
  if (from._internal_passed() != 0) {
    _this->_internal_set_passed(from._internal_passed());
  }
  if (from._internal_final_stage() != 0) {
    _this->_internal_set_final_stage(from._internal_final_stage());
  }
  if (from._internal_fast_quorum() != 0) {
    _this->_internal_set_fast_quorum(from._internal_fast_quorum());
  }
  if (cached_has_bits & 0x00000010u) {
    _this->_internal_set_proposal_cut(from._internal_proposal_cut());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProposalResult::CopyFrom(const ProposalResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ProposalResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProposalResult::IsInitialized() const {
  return true;
}

void ProposalResult::InternalSwap(ProposalResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.option_cur_equiv_.InternalSwap(&other->_impl_.option_cur_equiv_);
  _impl_.option_votes_.InternalSwap(&other->_impl_.option_votes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.proposal_id_, lhs_arena,
      &other->_impl_.proposal_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.support_cur_equiv_, lhs_arena,
      &other->_impl_.support_cur_equiv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.against_cur_equiv_, lhs_arena,
      &other->_impl_.against_cur_equiv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProposalResult, _impl_.proposal_cut_)
      + sizeof(ProposalResult::_impl_.proposal_cut_)
      - PROTOBUF_FIELD_OFFSET(ProposalResult, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProposalResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[60]);
}

// ===================================================================

class AllowanceTXN::_Internal {
 public:
  using HasBits = decltype(std::declval<AllowanceTXN>()._impl_._has_bits_);
  static const ::zera_txn::BaseTXN& base(const AllowanceTXN* msg);
  static void set_has_allowed_currency_equivalent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allowed_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_period_months(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_period_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time(const AllowanceTXN* msg);
};

const ::zera_txn::BaseTXN&
AllowanceTXN::_Internal::base(const AllowanceTXN* msg) {
  return *msg->_impl_.base_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AllowanceTXN::_Internal::start_time(const AllowanceTXN* msg) {
  return *msg->_impl_.start_time_;
}
void AllowanceTXN::clear_start_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_time_ != nullptr) {
    delete _impl_.start_time_;
  }
  _impl_.start_time_ = nullptr;
}
AllowanceTXN::AllowanceTXN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.AllowanceTXN)
}
AllowanceTXN::AllowanceTXN(const AllowanceTXN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AllowanceTXN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.wallet_address_){}
    , decltype(_impl_.allowed_currency_equivalent_){}
    , decltype(_impl_.allowed_amount_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.start_time_){nullptr}
    , decltype(_impl_.period_months_){}
    , decltype(_impl_.period_seconds_){}
    , decltype(_impl_.authorize_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_wallet_address().empty()) {
    _this->_impl_.wallet_address_.Set(from._internal_wallet_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.allowed_currency_equivalent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowed_currency_equivalent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_allowed_currency_equivalent()) {
    _this->_impl_.allowed_currency_equivalent_.Set(from._internal_allowed_currency_equivalent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.allowed_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowed_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_allowed_amount()) {
    _this->_impl_.allowed_amount_.Set(from._internal_allowed_amount(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::zera_txn::BaseTXN(*from._impl_.base_);
  }
  if (from._internal_has_start_time()) {
    _this->_impl_.start_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.start_time_);
  }
  ::memcpy(&_impl_.period_months_, &from._impl_.period_months_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.authorize_) -
    reinterpret_cast<char*>(&_impl_.period_months_)) + sizeof(_impl_.authorize_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.AllowanceTXN)
}

inline void AllowanceTXN::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.wallet_address_){}
    , decltype(_impl_.allowed_currency_equivalent_){}
    , decltype(_impl_.allowed_amount_){}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.start_time_){nullptr}
    , decltype(_impl_.period_months_){0u}
    , decltype(_impl_.period_seconds_){0u}
    , decltype(_impl_.authorize_){false}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.wallet_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wallet_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.allowed_currency_equivalent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowed_currency_equivalent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.allowed_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowed_amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AllowanceTXN::~AllowanceTXN() {
  // @@protoc_insertion_point(destructor:zera_txn.AllowanceTXN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllowanceTXN::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.wallet_address_.Destroy();
  _impl_.allowed_currency_equivalent_.Destroy();
  _impl_.allowed_amount_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.start_time_;
}

void AllowanceTXN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllowanceTXN::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.AllowanceTXN)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.wallet_address_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.allowed_currency_equivalent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.allowed_amount_.ClearNonDefaultToEmpty();
    }
  }
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.start_time_ != nullptr) {
    delete _impl_.start_time_;
  }
  _impl_.start_time_ = nullptr;
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.period_months_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.period_seconds_) -
        reinterpret_cast<char*>(&_impl_.period_months_)) + sizeof(_impl_.period_seconds_));
  }
  _impl_.authorize_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AllowanceTXN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.BaseTXN base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contract_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.AllowanceTXN.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // bytes wallet_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_wallet_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string allowed_currency_equivalent = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_allowed_currency_equivalent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.AllowanceTXN.allowed_currency_equivalent"));
        } else
          goto handle_unusual;
        continue;
      // optional string allowed_amount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_allowed_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.AllowanceTXN.allowed_amount"));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 period_months = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_period_months(&has_bits);
          _impl_.period_months_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 period_seconds = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_period_seconds(&has_bits);
          _impl_.period_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp start_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool authorize = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.authorize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllowanceTXN::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.AllowanceTXN)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.AllowanceTXN.contract_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_id(), target);
  }

  // bytes wallet_address = 3;
  if (!this->_internal_wallet_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_wallet_address(), target);
  }

  // optional string allowed_currency_equivalent = 4;
  if (_internal_has_allowed_currency_equivalent()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_allowed_currency_equivalent().data(), static_cast<int>(this->_internal_allowed_currency_equivalent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.AllowanceTXN.allowed_currency_equivalent");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_allowed_currency_equivalent(), target);
  }

  // optional string allowed_amount = 5;
  if (_internal_has_allowed_amount()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_allowed_amount().data(), static_cast<int>(this->_internal_allowed_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.AllowanceTXN.allowed_amount");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_allowed_amount(), target);
  }

  // optional uint32 period_months = 6;
  if (_internal_has_period_months()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_period_months(), target);
  }

  // optional uint32 period_seconds = 7;
  if (_internal_has_period_seconds()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_period_seconds(), target);
  }

  // .google.protobuf.Timestamp start_time = 9;
  if (this->_internal_has_start_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::start_time(this),
        _Internal::start_time(this).GetCachedSize(), target, stream);
  }

  // bool authorize = 10;
  if (this->_internal_authorize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_authorize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.AllowanceTXN)
  return target;
}

size_t AllowanceTXN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.AllowanceTXN)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 2;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // bytes wallet_address = 3;
  if (!this->_internal_wallet_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_wallet_address());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string allowed_currency_equivalent = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_allowed_currency_equivalent());
    }

    // optional string allowed_amount = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_allowed_amount());
    }

  }
  // .zera_txn.BaseTXN base = 1;
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // .google.protobuf.Timestamp start_time = 9;
  if (this->_internal_has_start_time()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_time_);
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional uint32 period_months = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_period_months());
    }

    // optional uint32 period_seconds = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_period_seconds());
    }

  }
  // bool authorize = 10;
  if (this->_internal_authorize() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllowanceTXN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AllowanceTXN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllowanceTXN::GetClassData() const { return &_class_data_; }


void AllowanceTXN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AllowanceTXN*>(&to_msg);
  auto& from = static_cast<const AllowanceTXN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.AllowanceTXN)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_wallet_address().empty()) {
    _this->_internal_set_wallet_address(from._internal_wallet_address());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_allowed_currency_equivalent(from._internal_allowed_currency_equivalent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_allowed_amount(from._internal_allowed_amount());
    }
  }
  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::zera_txn::BaseTXN::MergeFrom(
        from._internal_base());
  }
  if (from._internal_has_start_time()) {
    _this->_internal_mutable_start_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_start_time());
  }
  if (cached_has_bits & 0x0000000cu) {
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.period_months_ = from._impl_.period_months_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.period_seconds_ = from._impl_.period_seconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_authorize() != 0) {
    _this->_internal_set_authorize(from._internal_authorize());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AllowanceTXN::CopyFrom(const AllowanceTXN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.AllowanceTXN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllowanceTXN::IsInitialized() const {
  return true;
}

void AllowanceTXN::InternalSwap(AllowanceTXN* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wallet_address_, lhs_arena,
      &other->_impl_.wallet_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.allowed_currency_equivalent_, lhs_arena,
      &other->_impl_.allowed_currency_equivalent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.allowed_amount_, lhs_arena,
      &other->_impl_.allowed_amount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllowanceTXN, _impl_.authorize_)
      + sizeof(AllowanceTXN::_impl_.authorize_)
      - PROTOBUF_FIELD_OFFSET(AllowanceTXN, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AllowanceTXN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[61]);
}

// ===================================================================

class TXNS::_Internal {
 public:
  using HasBits = decltype(std::declval<TXNS>()._impl_._has_bits_);
  static const ::zera_txn::RequiredVersion& required_version_txn(const TXNS* msg);
  static void set_has_required_version_txn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::zera_txn::RequiredVersion&
TXNS::_Internal::required_version_txn(const TXNS* msg) {
  return *msg->_impl_.required_version_txn_;
}
TXNS::TXNS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.TXNS)
}
TXNS::TXNS(const TXNS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TXNS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coin_txns_){from._impl_.coin_txns_}
    , decltype(_impl_.mint_txns_){from._impl_.mint_txns_}
    , decltype(_impl_.item_mint_txns_){from._impl_.item_mint_txns_}
    , decltype(_impl_.contract_txns_){from._impl_.contract_txns_}
    , decltype(_impl_.governance_votes_){from._impl_.governance_votes_}
    , decltype(_impl_.governance_proposals_){from._impl_.governance_proposals_}
    , decltype(_impl_.smart_contracts_){from._impl_.smart_contracts_}
    , decltype(_impl_.smart_contract_executes_){from._impl_.smart_contract_executes_}
    , decltype(_impl_.self_cur_equivs_){from._impl_.self_cur_equivs_}
    , decltype(_impl_.auth_cur_equivs_){from._impl_.auth_cur_equivs_}
    , decltype(_impl_.expense_ratios_){from._impl_.expense_ratios_}
    , decltype(_impl_.txn_fees_and_status_){from._impl_.txn_fees_and_status_}
    , decltype(_impl_.token_fees_){from._impl_.token_fees_}
    , decltype(_impl_.nft_txns_){from._impl_.nft_txns_}
    , decltype(_impl_.contract_update_txns_){from._impl_.contract_update_txns_}
    , decltype(_impl_.validator_registration_txns_){from._impl_.validator_registration_txns_}
    , decltype(_impl_.validator_heartbeat_txns_){from._impl_.validator_heartbeat_txns_}
    , decltype(_impl_.proposal_result_txns_){from._impl_.proposal_result_txns_}
    , decltype(_impl_.expense_ratio_result_txns_){from._impl_.expense_ratio_result_txns_}
    , decltype(_impl_.foundation_txns_){from._impl_.foundation_txns_}
    , decltype(_impl_.delegated_voting_txns_){from._impl_.delegated_voting_txns_}
    , decltype(_impl_.quash_txns_){from._impl_.quash_txns_}
    , decltype(_impl_.fast_quorum_txns_){from._impl_.fast_quorum_txns_}
    , decltype(_impl_.quash_results_){from._impl_.quash_results_}
    , decltype(_impl_.revoke_txns_){from._impl_.revoke_txns_}
    , decltype(_impl_.compliance_txns_){from._impl_.compliance_txns_}
    , decltype(_impl_.burn_sbt_txns_){from._impl_.burn_sbt_txns_}
    , decltype(_impl_.smart_contract_instantiate_txns_){from._impl_.smart_contract_instantiate_txns_}
    , decltype(_impl_.allowance_txns_){from._impl_.allowance_txns_}
    , decltype(_impl_.required_version_txn_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_required_version_txn()) {
    _this->_impl_.required_version_txn_ = new ::zera_txn::RequiredVersion(*from._impl_.required_version_txn_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.TXNS)
}

inline void TXNS::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coin_txns_){arena}
    , decltype(_impl_.mint_txns_){arena}
    , decltype(_impl_.item_mint_txns_){arena}
    , decltype(_impl_.contract_txns_){arena}
    , decltype(_impl_.governance_votes_){arena}
    , decltype(_impl_.governance_proposals_){arena}
    , decltype(_impl_.smart_contracts_){arena}
    , decltype(_impl_.smart_contract_executes_){arena}
    , decltype(_impl_.self_cur_equivs_){arena}
    , decltype(_impl_.auth_cur_equivs_){arena}
    , decltype(_impl_.expense_ratios_){arena}
    , decltype(_impl_.txn_fees_and_status_){arena}
    , decltype(_impl_.token_fees_){arena}
    , decltype(_impl_.nft_txns_){arena}
    , decltype(_impl_.contract_update_txns_){arena}
    , decltype(_impl_.validator_registration_txns_){arena}
    , decltype(_impl_.validator_heartbeat_txns_){arena}
    , decltype(_impl_.proposal_result_txns_){arena}
    , decltype(_impl_.expense_ratio_result_txns_){arena}
    , decltype(_impl_.foundation_txns_){arena}
    , decltype(_impl_.delegated_voting_txns_){arena}
    , decltype(_impl_.quash_txns_){arena}
    , decltype(_impl_.fast_quorum_txns_){arena}
    , decltype(_impl_.quash_results_){arena}
    , decltype(_impl_.revoke_txns_){arena}
    , decltype(_impl_.compliance_txns_){arena}
    , decltype(_impl_.burn_sbt_txns_){arena}
    , decltype(_impl_.smart_contract_instantiate_txns_){arena}
    , decltype(_impl_.allowance_txns_){arena}
    , decltype(_impl_.required_version_txn_){nullptr}
  };
}

TXNS::~TXNS() {
  // @@protoc_insertion_point(destructor:zera_txn.TXNS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TXNS::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.coin_txns_.~RepeatedPtrField();
  _impl_.mint_txns_.~RepeatedPtrField();
  _impl_.item_mint_txns_.~RepeatedPtrField();
  _impl_.contract_txns_.~RepeatedPtrField();
  _impl_.governance_votes_.~RepeatedPtrField();
  _impl_.governance_proposals_.~RepeatedPtrField();
  _impl_.smart_contracts_.~RepeatedPtrField();
  _impl_.smart_contract_executes_.~RepeatedPtrField();
  _impl_.self_cur_equivs_.~RepeatedPtrField();
  _impl_.auth_cur_equivs_.~RepeatedPtrField();
  _impl_.expense_ratios_.~RepeatedPtrField();
  _impl_.txn_fees_and_status_.~RepeatedPtrField();
  _impl_.token_fees_.~RepeatedPtrField();
  _impl_.nft_txns_.~RepeatedPtrField();
  _impl_.contract_update_txns_.~RepeatedPtrField();
  _impl_.validator_registration_txns_.~RepeatedPtrField();
  _impl_.validator_heartbeat_txns_.~RepeatedPtrField();
  _impl_.proposal_result_txns_.~RepeatedPtrField();
  _impl_.expense_ratio_result_txns_.~RepeatedPtrField();
  _impl_.foundation_txns_.~RepeatedPtrField();
  _impl_.delegated_voting_txns_.~RepeatedPtrField();
  _impl_.quash_txns_.~RepeatedPtrField();
  _impl_.fast_quorum_txns_.~RepeatedPtrField();
  _impl_.quash_results_.~RepeatedPtrField();
  _impl_.revoke_txns_.~RepeatedPtrField();
  _impl_.compliance_txns_.~RepeatedPtrField();
  _impl_.burn_sbt_txns_.~RepeatedPtrField();
  _impl_.smart_contract_instantiate_txns_.~RepeatedPtrField();
  _impl_.allowance_txns_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.required_version_txn_;
}

void TXNS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TXNS::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.TXNS)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.coin_txns_.Clear();
  _impl_.mint_txns_.Clear();
  _impl_.item_mint_txns_.Clear();
  _impl_.contract_txns_.Clear();
  _impl_.governance_votes_.Clear();
  _impl_.governance_proposals_.Clear();
  _impl_.smart_contracts_.Clear();
  _impl_.smart_contract_executes_.Clear();
  _impl_.self_cur_equivs_.Clear();
  _impl_.auth_cur_equivs_.Clear();
  _impl_.expense_ratios_.Clear();
  _impl_.txn_fees_and_status_.Clear();
  _impl_.token_fees_.Clear();
  _impl_.nft_txns_.Clear();
  _impl_.contract_update_txns_.Clear();
  _impl_.validator_registration_txns_.Clear();
  _impl_.validator_heartbeat_txns_.Clear();
  _impl_.proposal_result_txns_.Clear();
  _impl_.expense_ratio_result_txns_.Clear();
  _impl_.foundation_txns_.Clear();
  _impl_.delegated_voting_txns_.Clear();
  _impl_.quash_txns_.Clear();
  _impl_.fast_quorum_txns_.Clear();
  _impl_.quash_results_.Clear();
  _impl_.revoke_txns_.Clear();
  _impl_.compliance_txns_.Clear();
  _impl_.burn_sbt_txns_.Clear();
  _impl_.smart_contract_instantiate_txns_.Clear();
  _impl_.allowance_txns_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.required_version_txn_ != nullptr);
    _impl_.required_version_txn_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TXNS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .zera_txn.CoinTXN coin_txns = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_coin_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.MintTXN mint_txns = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mint_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ItemizedMintTXN item_mint_txns = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_item_mint_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.InstrumentContract contract_txns = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contract_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.GovernanceVote governance_votes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_governance_votes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.GovernanceProposal governance_proposals = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_governance_proposals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.SmartContractTXN smart_contracts = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_smart_contracts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.SmartContractExecuteTXN smart_contract_executes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_smart_contract_executes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_self_cur_equivs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_auth_cur_equivs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ExpenseRatioTXN expense_ratios = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_expense_ratios(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.TXNStatusFees txn_fees_and_status = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_txn_fees_and_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.TokenFees token_fees = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_token_fees(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.NFTTXN nft_txns = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nft_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ContractUpdateTXN contract_update_txns = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contract_update_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ValidatorRegistration validator_registration_txns = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_validator_registration_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ValidatorHeartbeat validator_heartbeat_txns = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_validator_heartbeat_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ProposalResult proposal_result_txns = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_proposal_result_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ExpenseRatioResult expense_ratio_result_txns = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_expense_ratio_result_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.FoundationTXN foundation_txns = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_foundation_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.DelegatedTXN delegated_voting_txns = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_delegated_voting_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.QuashTXN quash_txns = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_quash_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.FastQuorumTXN fast_quorum_txns = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_fast_quorum_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.QuashResult quash_results = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_quash_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.RevokeTXN revoke_txns = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_revoke_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<202>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ComplianceTXN compliance_txns = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_compliance_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<210>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.BurnSBTTXN burn_sbt_txns = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_burn_sbt_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txns = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_smart_contract_instantiate_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<226>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .zera_txn.RequiredVersion required_version_txn = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_required_version_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.AllowanceTXN allowance_txns = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_allowance_txns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TXNS::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.TXNS)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .zera_txn.CoinTXN coin_txns = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_coin_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_coin_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.MintTXN mint_txns = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mint_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_mint_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ItemizedMintTXN item_mint_txns = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_item_mint_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_item_mint_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.InstrumentContract contract_txns = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contract_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_contract_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.GovernanceVote governance_votes = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_governance_votes_size()); i < n; i++) {
    const auto& repfield = this->_internal_governance_votes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.GovernanceProposal governance_proposals = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_governance_proposals_size()); i < n; i++) {
    const auto& repfield = this->_internal_governance_proposals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.SmartContractTXN smart_contracts = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_smart_contracts_size()); i < n; i++) {
    const auto& repfield = this->_internal_smart_contracts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.SmartContractExecuteTXN smart_contract_executes = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_smart_contract_executes_size()); i < n; i++) {
    const auto& repfield = this->_internal_smart_contract_executes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_self_cur_equivs_size()); i < n; i++) {
    const auto& repfield = this->_internal_self_cur_equivs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_auth_cur_equivs_size()); i < n; i++) {
    const auto& repfield = this->_internal_auth_cur_equivs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ExpenseRatioTXN expense_ratios = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_expense_ratios_size()); i < n; i++) {
    const auto& repfield = this->_internal_expense_ratios(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.TXNStatusFees txn_fees_and_status = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_txn_fees_and_status_size()); i < n; i++) {
    const auto& repfield = this->_internal_txn_fees_and_status(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.TokenFees token_fees = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_token_fees_size()); i < n; i++) {
    const auto& repfield = this->_internal_token_fees(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.NFTTXN nft_txns = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nft_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_nft_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ContractUpdateTXN contract_update_txns = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contract_update_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_contract_update_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ValidatorRegistration validator_registration_txns = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_validator_registration_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_validator_registration_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ValidatorHeartbeat validator_heartbeat_txns = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_validator_heartbeat_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_validator_heartbeat_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ProposalResult proposal_result_txns = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_proposal_result_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_proposal_result_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ExpenseRatioResult expense_ratio_result_txns = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_expense_ratio_result_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_expense_ratio_result_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.FoundationTXN foundation_txns = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_foundation_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_foundation_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.DelegatedTXN delegated_voting_txns = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_delegated_voting_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_delegated_voting_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.QuashTXN quash_txns = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_quash_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_quash_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.FastQuorumTXN fast_quorum_txns = 23;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fast_quorum_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_fast_quorum_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.QuashResult quash_results = 24;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_quash_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_quash_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.RevokeTXN revoke_txns = 25;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_revoke_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_revoke_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(25, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.ComplianceTXN compliance_txns = 26;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_compliance_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_compliance_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(26, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.BurnSBTTXN burn_sbt_txns = 27;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_burn_sbt_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_burn_sbt_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(27, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txns = 28;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_smart_contract_instantiate_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_smart_contract_instantiate_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .zera_txn.RequiredVersion required_version_txn = 29;
  if (_internal_has_required_version_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::required_version_txn(this),
        _Internal::required_version_txn(this).GetCachedSize(), target, stream);
  }

  // repeated .zera_txn.AllowanceTXN allowance_txns = 30;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_allowance_txns_size()); i < n; i++) {
    const auto& repfield = this->_internal_allowance_txns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.TXNS)
  return target;
}

size_t TXNS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.TXNS)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.CoinTXN coin_txns = 1;
  total_size += 1UL * this->_internal_coin_txns_size();
  for (const auto& msg : this->_impl_.coin_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.MintTXN mint_txns = 2;
  total_size += 1UL * this->_internal_mint_txns_size();
  for (const auto& msg : this->_impl_.mint_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ItemizedMintTXN item_mint_txns = 3;
  total_size += 1UL * this->_internal_item_mint_txns_size();
  for (const auto& msg : this->_impl_.item_mint_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.InstrumentContract contract_txns = 4;
  total_size += 1UL * this->_internal_contract_txns_size();
  for (const auto& msg : this->_impl_.contract_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.GovernanceVote governance_votes = 5;
  total_size += 1UL * this->_internal_governance_votes_size();
  for (const auto& msg : this->_impl_.governance_votes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.GovernanceProposal governance_proposals = 6;
  total_size += 1UL * this->_internal_governance_proposals_size();
  for (const auto& msg : this->_impl_.governance_proposals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.SmartContractTXN smart_contracts = 7;
  total_size += 1UL * this->_internal_smart_contracts_size();
  for (const auto& msg : this->_impl_.smart_contracts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.SmartContractExecuteTXN smart_contract_executes = 8;
  total_size += 1UL * this->_internal_smart_contract_executes_size();
  for (const auto& msg : this->_impl_.smart_contract_executes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
  total_size += 1UL * this->_internal_self_cur_equivs_size();
  for (const auto& msg : this->_impl_.self_cur_equivs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
  total_size += 1UL * this->_internal_auth_cur_equivs_size();
  for (const auto& msg : this->_impl_.auth_cur_equivs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ExpenseRatioTXN expense_ratios = 11;
  total_size += 1UL * this->_internal_expense_ratios_size();
  for (const auto& msg : this->_impl_.expense_ratios_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.TXNStatusFees txn_fees_and_status = 12;
  total_size += 1UL * this->_internal_txn_fees_and_status_size();
  for (const auto& msg : this->_impl_.txn_fees_and_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.TokenFees token_fees = 13;
  total_size += 1UL * this->_internal_token_fees_size();
  for (const auto& msg : this->_impl_.token_fees_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.NFTTXN nft_txns = 14;
  total_size += 1UL * this->_internal_nft_txns_size();
  for (const auto& msg : this->_impl_.nft_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ContractUpdateTXN contract_update_txns = 15;
  total_size += 1UL * this->_internal_contract_update_txns_size();
  for (const auto& msg : this->_impl_.contract_update_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ValidatorRegistration validator_registration_txns = 16;
  total_size += 2UL * this->_internal_validator_registration_txns_size();
  for (const auto& msg : this->_impl_.validator_registration_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ValidatorHeartbeat validator_heartbeat_txns = 17;
  total_size += 2UL * this->_internal_validator_heartbeat_txns_size();
  for (const auto& msg : this->_impl_.validator_heartbeat_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ProposalResult proposal_result_txns = 18;
  total_size += 2UL * this->_internal_proposal_result_txns_size();
  for (const auto& msg : this->_impl_.proposal_result_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ExpenseRatioResult expense_ratio_result_txns = 19;
  total_size += 2UL * this->_internal_expense_ratio_result_txns_size();
  for (const auto& msg : this->_impl_.expense_ratio_result_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.FoundationTXN foundation_txns = 20;
  total_size += 2UL * this->_internal_foundation_txns_size();
  for (const auto& msg : this->_impl_.foundation_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.DelegatedTXN delegated_voting_txns = 21;
  total_size += 2UL * this->_internal_delegated_voting_txns_size();
  for (const auto& msg : this->_impl_.delegated_voting_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.QuashTXN quash_txns = 22;
  total_size += 2UL * this->_internal_quash_txns_size();
  for (const auto& msg : this->_impl_.quash_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.FastQuorumTXN fast_quorum_txns = 23;
  total_size += 2UL * this->_internal_fast_quorum_txns_size();
  for (const auto& msg : this->_impl_.fast_quorum_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.QuashResult quash_results = 24;
  total_size += 2UL * this->_internal_quash_results_size();
  for (const auto& msg : this->_impl_.quash_results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.RevokeTXN revoke_txns = 25;
  total_size += 2UL * this->_internal_revoke_txns_size();
  for (const auto& msg : this->_impl_.revoke_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.ComplianceTXN compliance_txns = 26;
  total_size += 2UL * this->_internal_compliance_txns_size();
  for (const auto& msg : this->_impl_.compliance_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.BurnSBTTXN burn_sbt_txns = 27;
  total_size += 2UL * this->_internal_burn_sbt_txns_size();
  for (const auto& msg : this->_impl_.burn_sbt_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txns = 28;
  total_size += 2UL * this->_internal_smart_contract_instantiate_txns_size();
  for (const auto& msg : this->_impl_.smart_contract_instantiate_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .zera_txn.AllowanceTXN allowance_txns = 30;
  total_size += 2UL * this->_internal_allowance_txns_size();
  for (const auto& msg : this->_impl_.allowance_txns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .zera_txn.RequiredVersion required_version_txn = 29;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.required_version_txn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TXNS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TXNS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TXNS::GetClassData() const { return &_class_data_; }


void TXNS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TXNS*>(&to_msg);
  auto& from = static_cast<const TXNS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.TXNS)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.coin_txns_.MergeFrom(from._impl_.coin_txns_);
  _this->_impl_.mint_txns_.MergeFrom(from._impl_.mint_txns_);
  _this->_impl_.item_mint_txns_.MergeFrom(from._impl_.item_mint_txns_);
  _this->_impl_.contract_txns_.MergeFrom(from._impl_.contract_txns_);
  _this->_impl_.governance_votes_.MergeFrom(from._impl_.governance_votes_);
  _this->_impl_.governance_proposals_.MergeFrom(from._impl_.governance_proposals_);
  _this->_impl_.smart_contracts_.MergeFrom(from._impl_.smart_contracts_);
  _this->_impl_.smart_contract_executes_.MergeFrom(from._impl_.smart_contract_executes_);
  _this->_impl_.self_cur_equivs_.MergeFrom(from._impl_.self_cur_equivs_);
  _this->_impl_.auth_cur_equivs_.MergeFrom(from._impl_.auth_cur_equivs_);
  _this->_impl_.expense_ratios_.MergeFrom(from._impl_.expense_ratios_);
  _this->_impl_.txn_fees_and_status_.MergeFrom(from._impl_.txn_fees_and_status_);
  _this->_impl_.token_fees_.MergeFrom(from._impl_.token_fees_);
  _this->_impl_.nft_txns_.MergeFrom(from._impl_.nft_txns_);
  _this->_impl_.contract_update_txns_.MergeFrom(from._impl_.contract_update_txns_);
  _this->_impl_.validator_registration_txns_.MergeFrom(from._impl_.validator_registration_txns_);
  _this->_impl_.validator_heartbeat_txns_.MergeFrom(from._impl_.validator_heartbeat_txns_);
  _this->_impl_.proposal_result_txns_.MergeFrom(from._impl_.proposal_result_txns_);
  _this->_impl_.expense_ratio_result_txns_.MergeFrom(from._impl_.expense_ratio_result_txns_);
  _this->_impl_.foundation_txns_.MergeFrom(from._impl_.foundation_txns_);
  _this->_impl_.delegated_voting_txns_.MergeFrom(from._impl_.delegated_voting_txns_);
  _this->_impl_.quash_txns_.MergeFrom(from._impl_.quash_txns_);
  _this->_impl_.fast_quorum_txns_.MergeFrom(from._impl_.fast_quorum_txns_);
  _this->_impl_.quash_results_.MergeFrom(from._impl_.quash_results_);
  _this->_impl_.revoke_txns_.MergeFrom(from._impl_.revoke_txns_);
  _this->_impl_.compliance_txns_.MergeFrom(from._impl_.compliance_txns_);
  _this->_impl_.burn_sbt_txns_.MergeFrom(from._impl_.burn_sbt_txns_);
  _this->_impl_.smart_contract_instantiate_txns_.MergeFrom(from._impl_.smart_contract_instantiate_txns_);
  _this->_impl_.allowance_txns_.MergeFrom(from._impl_.allowance_txns_);
  if (from._internal_has_required_version_txn()) {
    _this->_internal_mutable_required_version_txn()->::zera_txn::RequiredVersion::MergeFrom(
        from._internal_required_version_txn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TXNS::CopyFrom(const TXNS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.TXNS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TXNS::IsInitialized() const {
  return true;
}

void TXNS::InternalSwap(TXNS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.coin_txns_.InternalSwap(&other->_impl_.coin_txns_);
  _impl_.mint_txns_.InternalSwap(&other->_impl_.mint_txns_);
  _impl_.item_mint_txns_.InternalSwap(&other->_impl_.item_mint_txns_);
  _impl_.contract_txns_.InternalSwap(&other->_impl_.contract_txns_);
  _impl_.governance_votes_.InternalSwap(&other->_impl_.governance_votes_);
  _impl_.governance_proposals_.InternalSwap(&other->_impl_.governance_proposals_);
  _impl_.smart_contracts_.InternalSwap(&other->_impl_.smart_contracts_);
  _impl_.smart_contract_executes_.InternalSwap(&other->_impl_.smart_contract_executes_);
  _impl_.self_cur_equivs_.InternalSwap(&other->_impl_.self_cur_equivs_);
  _impl_.auth_cur_equivs_.InternalSwap(&other->_impl_.auth_cur_equivs_);
  _impl_.expense_ratios_.InternalSwap(&other->_impl_.expense_ratios_);
  _impl_.txn_fees_and_status_.InternalSwap(&other->_impl_.txn_fees_and_status_);
  _impl_.token_fees_.InternalSwap(&other->_impl_.token_fees_);
  _impl_.nft_txns_.InternalSwap(&other->_impl_.nft_txns_);
  _impl_.contract_update_txns_.InternalSwap(&other->_impl_.contract_update_txns_);
  _impl_.validator_registration_txns_.InternalSwap(&other->_impl_.validator_registration_txns_);
  _impl_.validator_heartbeat_txns_.InternalSwap(&other->_impl_.validator_heartbeat_txns_);
  _impl_.proposal_result_txns_.InternalSwap(&other->_impl_.proposal_result_txns_);
  _impl_.expense_ratio_result_txns_.InternalSwap(&other->_impl_.expense_ratio_result_txns_);
  _impl_.foundation_txns_.InternalSwap(&other->_impl_.foundation_txns_);
  _impl_.delegated_voting_txns_.InternalSwap(&other->_impl_.delegated_voting_txns_);
  _impl_.quash_txns_.InternalSwap(&other->_impl_.quash_txns_);
  _impl_.fast_quorum_txns_.InternalSwap(&other->_impl_.fast_quorum_txns_);
  _impl_.quash_results_.InternalSwap(&other->_impl_.quash_results_);
  _impl_.revoke_txns_.InternalSwap(&other->_impl_.revoke_txns_);
  _impl_.compliance_txns_.InternalSwap(&other->_impl_.compliance_txns_);
  _impl_.burn_sbt_txns_.InternalSwap(&other->_impl_.burn_sbt_txns_);
  _impl_.smart_contract_instantiate_txns_.InternalSwap(&other->_impl_.smart_contract_instantiate_txns_);
  _impl_.allowance_txns_.InternalSwap(&other->_impl_.allowance_txns_);
  swap(_impl_.required_version_txn_, other->_impl_.required_version_txn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TXNS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[62]);
}

// ===================================================================

class Token::_Internal {
 public:
};

Token::Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.Token)
}
Token::Token(const Token& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Token* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.Token)
}

inline void Token::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contract_id_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.amount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Token::~Token() {
  // @@protoc_insertion_point(destructor:zera_txn.Token)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Token::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contract_id_.Destroy();
  _impl_.amount_.Destroy();
}

void Token::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Token::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.Token)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contract_id_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Token::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Token.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // string amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.Token.amount"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Token::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.Token)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Token.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_amount().data(), static_cast<int>(this->_internal_amount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.Token.amount");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.Token)
  return target;
}

size_t Token::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.Token)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // string amount = 2;
  if (!this->_internal_amount().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Token::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Token::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Token::GetClassData() const { return &_class_data_; }


void Token::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Token*>(&to_msg);
  auto& from = static_cast<const Token&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.Token)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Token::CopyFrom(const Token& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.Token)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Token::IsInitialized() const {
  return true;
}

void Token::InternalSwap(Token* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.amount_, lhs_arena,
      &other->_impl_.amount_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Token::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[63]);
}

// ===================================================================

class TokenFees::_Internal {
 public:
};

TokenFees::TokenFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.TokenFees)
}
TokenFees::TokenFees(const TokenFees& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenFees* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tokens_){from._impl_.tokens_}
    , decltype(_impl_.address_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.TokenFees)
}

inline void TokenFees::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tokens_){arena}
    , decltype(_impl_.address_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TokenFees::~TokenFees() {
  // @@protoc_insertion_point(destructor:zera_txn.TokenFees)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenFees::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tokens_.~RepeatedPtrField();
  _impl_.address_.Destroy();
}

void TokenFees::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenFees::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.TokenFees)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tokens_.Clear();
  _impl_.address_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenFees::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.Token tokens = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenFees::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.TokenFees)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_address(), target);
  }

  // repeated .zera_txn.Token tokens = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tokens_size()); i < n; i++) {
    const auto& repfield = this->_internal_tokens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.TokenFees)
  return target;
}

size_t TokenFees::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.TokenFees)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .zera_txn.Token tokens = 2;
  total_size += 1UL * this->_internal_tokens_size();
  for (const auto& msg : this->_impl_.tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenFees::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenFees::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenFees::GetClassData() const { return &_class_data_; }


void TokenFees::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenFees*>(&to_msg);
  auto& from = static_cast<const TokenFees&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.TokenFees)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tokens_.MergeFrom(from._impl_.tokens_);
  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenFees::CopyFrom(const TokenFees& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.TokenFees)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenFees::IsInitialized() const {
  return true;
}

void TokenFees::InternalSwap(TokenFees* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenFees::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[64]);
}

// ===================================================================

class DelegatedData::_Internal {
 public:
  static const ::zera_txn::Token& fee(const DelegatedData* msg);
};

const ::zera_txn::Token&
DelegatedData::_Internal::fee(const DelegatedData* msg) {
  return *msg->_impl_.fee_;
}
DelegatedData::DelegatedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.DelegatedData)
}
DelegatedData::DelegatedData(const DelegatedData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DelegatedData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.fee_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fee()) {
    _this->_impl_.fee_ = new ::zera_txn::Token(*from._impl_.fee_);
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.DelegatedData)
}

inline void DelegatedData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.fee_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DelegatedData::~DelegatedData() {
  // @@protoc_insertion_point(destructor:zera_txn.DelegatedData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelegatedData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fee_;
}

void DelegatedData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DelegatedData::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.DelegatedData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.fee_ != nullptr) {
    delete _impl_.fee_;
  }
  _impl_.fee_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DelegatedData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.Token fee = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fee(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelegatedData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.DelegatedData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_address(), target);
  }

  // .zera_txn.Token fee = 2;
  if (this->_internal_has_fee()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fee(this),
        _Internal::fee(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.DelegatedData)
  return target;
}

size_t DelegatedData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.DelegatedData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_address());
  }

  // .zera_txn.Token fee = 2;
  if (this->_internal_has_fee()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fee_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DelegatedData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DelegatedData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DelegatedData::GetClassData() const { return &_class_data_; }


void DelegatedData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DelegatedData*>(&to_msg);
  auto& from = static_cast<const DelegatedData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.DelegatedData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (from._internal_has_fee()) {
    _this->_internal_mutable_fee()->::zera_txn::Token::MergeFrom(
        from._internal_fee());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DelegatedData::CopyFrom(const DelegatedData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.DelegatedData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelegatedData::IsInitialized() const {
  return true;
}

void DelegatedData::InternalSwap(DelegatedData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  swap(_impl_.fee_, other->_impl_.fee_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DelegatedData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[65]);
}

// ===================================================================

class TXNStatusFees::_Internal {
 public:
  using HasBits = decltype(std::declval<TXNStatusFees>()._impl_._has_bits_);
  static void set_has_contract_fees(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_contract_contract_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_native_function_fees(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_interface_fee(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_interface_fee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

TXNStatusFees::TXNStatusFees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.TXNStatusFees)
}
TXNStatusFees::TXNStatusFees(const TXNStatusFees& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TXNStatusFees* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.smart_contract_result_){from._impl_.smart_contract_result_}
    , decltype(_impl_.misc_){from._impl_.misc_}
    , decltype(_impl_.delegated_data_){from._impl_.delegated_data_}
    , decltype(_impl_.txn_hash_){}
    , decltype(_impl_.base_fees_){}
    , decltype(_impl_.base_contract_id_){}
    , decltype(_impl_.contract_fees_){}
    , decltype(_impl_.contract_contract_id_){}
    , decltype(_impl_.native_function_fees_){}
    , decltype(_impl_.interface_fee_){}
    , decltype(_impl_.interface_fee_id_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.smart_contract_){}
    , decltype(_impl_.gas_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_txn_hash().empty()) {
    _this->_impl_.txn_hash_.Set(from._internal_txn_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_fees_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_fees_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base_fees().empty()) {
    _this->_impl_.base_fees_.Set(from._internal_base_fees(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base_contract_id().empty()) {
    _this->_impl_.base_contract_id_.Set(from._internal_base_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_fees_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fees_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_fees()) {
    _this->_impl_.contract_fees_.Set(from._internal_contract_fees(), 
      _this->GetArenaForAllocation());
  }
  _impl_.contract_contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_contract_id()) {
    _this->_impl_.contract_contract_id_.Set(from._internal_contract_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.native_function_fees_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.native_function_fees_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_native_function_fees()) {
    _this->_impl_.native_function_fees_.Set(from._internal_native_function_fees(), 
      _this->GetArenaForAllocation());
  }
  _impl_.interface_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_interface_fee()) {
    _this->_impl_.interface_fee_.Set(from._internal_interface_fee(), 
      _this->GetArenaForAllocation());
  }
  _impl_.interface_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_interface_fee_id()) {
    _this->_impl_.interface_fee_id_.Set(from._internal_interface_fee_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gas_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.gas_));
  // @@protoc_insertion_point(copy_constructor:zera_txn.TXNStatusFees)
}

inline void TXNStatusFees::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.smart_contract_result_){arena}
    , decltype(_impl_.misc_){arena}
    , decltype(_impl_.delegated_data_){arena}
    , decltype(_impl_.txn_hash_){}
    , decltype(_impl_.base_fees_){}
    , decltype(_impl_.base_contract_id_){}
    , decltype(_impl_.contract_fees_){}
    , decltype(_impl_.contract_contract_id_){}
    , decltype(_impl_.native_function_fees_){}
    , decltype(_impl_.interface_fee_){}
    , decltype(_impl_.interface_fee_id_){}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.smart_contract_){false}
    , decltype(_impl_.gas_){uint64_t{0u}}
  };
  _impl_.txn_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_fees_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_fees_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_fees_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_fees_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.native_function_fees_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.native_function_fees_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_fee_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_fee_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_fee_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TXNStatusFees::~TXNStatusFees() {
  // @@protoc_insertion_point(destructor:zera_txn.TXNStatusFees)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TXNStatusFees::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.smart_contract_result_.~RepeatedPtrField();
  _impl_.misc_.~RepeatedPtrField();
  _impl_.delegated_data_.~RepeatedPtrField();
  _impl_.txn_hash_.Destroy();
  _impl_.base_fees_.Destroy();
  _impl_.base_contract_id_.Destroy();
  _impl_.contract_fees_.Destroy();
  _impl_.contract_contract_id_.Destroy();
  _impl_.native_function_fees_.Destroy();
  _impl_.interface_fee_.Destroy();
  _impl_.interface_fee_id_.Destroy();
}

void TXNStatusFees::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TXNStatusFees::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.TXNStatusFees)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.smart_contract_result_.Clear();
  _impl_.misc_.Clear();
  _impl_.delegated_data_.Clear();
  _impl_.txn_hash_.ClearToEmpty();
  _impl_.base_fees_.ClearToEmpty();
  _impl_.base_contract_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.contract_fees_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.contract_contract_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.native_function_fees_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.interface_fee_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.interface_fee_id_.ClearNonDefaultToEmpty();
    }
  }
  ::memset(&_impl_.status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.smart_contract_) -
      reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.smart_contract_));
  _impl_.gas_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TXNStatusFees::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes txn_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_txn_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.TXN_STATUS status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::zera_txn::TXN_STATUS>(val));
        } else
          goto handle_unusual;
        continue;
      // string base_fees = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_base_fees();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.TXNStatusFees.base_fees"));
        } else
          goto handle_unusual;
        continue;
      // string base_contract_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_base_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.TXNStatusFees.base_contract_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string contract_fees = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_contract_fees();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.TXNStatusFees.contract_fees"));
        } else
          goto handle_unusual;
        continue;
      // optional string contract_contract_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_contract_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.TXNStatusFees.contract_contract_id"));
        } else
          goto handle_unusual;
        continue;
      // bool smart_contract = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.smart_contract_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes smart_contract_result = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_smart_contract_result();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string misc = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_misc();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "zera_txn.TXNStatusFees.misc"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string native_function_fees = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_native_function_fees();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.TXNStatusFees.native_function_fees"));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gas = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_gas(&has_bits);
          _impl_.gas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.DelegatedData delegated_data = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_delegated_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string interface_fee = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_interface_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.TXNStatusFees.interface_fee"));
        } else
          goto handle_unusual;
        continue;
      // optional string interface_fee_id = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_interface_fee_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.TXNStatusFees.interface_fee_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TXNStatusFees::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.TXNStatusFees)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes txn_hash = 1;
  if (!this->_internal_txn_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_txn_hash(), target);
  }

  // .zera_txn.TXN_STATUS status = 2;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // string base_fees = 3;
  if (!this->_internal_base_fees().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_base_fees().data(), static_cast<int>(this->_internal_base_fees().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.TXNStatusFees.base_fees");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_base_fees(), target);
  }

  // string base_contract_id = 4;
  if (!this->_internal_base_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_base_contract_id().data(), static_cast<int>(this->_internal_base_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.TXNStatusFees.base_contract_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_base_contract_id(), target);
  }

  // optional string contract_fees = 5;
  if (_internal_has_contract_fees()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_fees().data(), static_cast<int>(this->_internal_contract_fees().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.TXNStatusFees.contract_fees");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_contract_fees(), target);
  }

  // optional string contract_contract_id = 6;
  if (_internal_has_contract_contract_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_contract_id().data(), static_cast<int>(this->_internal_contract_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.TXNStatusFees.contract_contract_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_contract_contract_id(), target);
  }

  // bool smart_contract = 9;
  if (this->_internal_smart_contract() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_smart_contract(), target);
  }

  // repeated bytes smart_contract_result = 10;
  for (int i = 0, n = this->_internal_smart_contract_result_size(); i < n; i++) {
    const auto& s = this->_internal_smart_contract_result(i);
    target = stream->WriteBytes(10, s, target);
  }

  // repeated string misc = 11;
  for (int i = 0, n = this->_internal_misc_size(); i < n; i++) {
    const auto& s = this->_internal_misc(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.TXNStatusFees.misc");
    target = stream->WriteString(11, s, target);
  }

  // optional string native_function_fees = 12;
  if (_internal_has_native_function_fees()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_native_function_fees().data(), static_cast<int>(this->_internal_native_function_fees().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.TXNStatusFees.native_function_fees");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_native_function_fees(), target);
  }

  // optional uint64 gas = 13;
  if (_internal_has_gas()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_gas(), target);
  }

  // repeated .zera_txn.DelegatedData delegated_data = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_delegated_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_delegated_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string interface_fee = 15;
  if (_internal_has_interface_fee()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_interface_fee().data(), static_cast<int>(this->_internal_interface_fee().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.TXNStatusFees.interface_fee");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_interface_fee(), target);
  }

  // optional string interface_fee_id = 16;
  if (_internal_has_interface_fee_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_interface_fee_id().data(), static_cast<int>(this->_internal_interface_fee_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.TXNStatusFees.interface_fee_id");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_interface_fee_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.TXNStatusFees)
  return target;
}

size_t TXNStatusFees::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.TXNStatusFees)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes smart_contract_result = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.smart_contract_result_.size());
  for (int i = 0, n = _impl_.smart_contract_result_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.smart_contract_result_.Get(i));
  }

  // repeated string misc = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.misc_.size());
  for (int i = 0, n = _impl_.misc_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.misc_.Get(i));
  }

  // repeated .zera_txn.DelegatedData delegated_data = 14;
  total_size += 1UL * this->_internal_delegated_data_size();
  for (const auto& msg : this->_impl_.delegated_data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes txn_hash = 1;
  if (!this->_internal_txn_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_txn_hash());
  }

  // string base_fees = 3;
  if (!this->_internal_base_fees().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_base_fees());
  }

  // string base_contract_id = 4;
  if (!this->_internal_base_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_base_contract_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string contract_fees = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_fees());
    }

    // optional string contract_contract_id = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_contract_id());
    }

    // optional string native_function_fees = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_native_function_fees());
    }

    // optional string interface_fee = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_interface_fee());
    }

    // optional string interface_fee_id = 16;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_interface_fee_id());
    }

  }
  // .zera_txn.TXN_STATUS status = 2;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // bool smart_contract = 9;
  if (this->_internal_smart_contract() != 0) {
    total_size += 1 + 1;
  }

  // optional uint64 gas = 13;
  if (cached_has_bits & 0x00000020u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gas());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TXNStatusFees::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TXNStatusFees::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TXNStatusFees::GetClassData() const { return &_class_data_; }


void TXNStatusFees::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TXNStatusFees*>(&to_msg);
  auto& from = static_cast<const TXNStatusFees&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.TXNStatusFees)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.smart_contract_result_.MergeFrom(from._impl_.smart_contract_result_);
  _this->_impl_.misc_.MergeFrom(from._impl_.misc_);
  _this->_impl_.delegated_data_.MergeFrom(from._impl_.delegated_data_);
  if (!from._internal_txn_hash().empty()) {
    _this->_internal_set_txn_hash(from._internal_txn_hash());
  }
  if (!from._internal_base_fees().empty()) {
    _this->_internal_set_base_fees(from._internal_base_fees());
  }
  if (!from._internal_base_contract_id().empty()) {
    _this->_internal_set_base_contract_id(from._internal_base_contract_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_contract_fees(from._internal_contract_fees());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_contract_contract_id(from._internal_contract_contract_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_native_function_fees(from._internal_native_function_fees());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_interface_fee(from._internal_interface_fee());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_interface_fee_id(from._internal_interface_fee_id());
    }
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_smart_contract() != 0) {
    _this->_internal_set_smart_contract(from._internal_smart_contract());
  }
  if (cached_has_bits & 0x00000020u) {
    _this->_internal_set_gas(from._internal_gas());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TXNStatusFees::CopyFrom(const TXNStatusFees& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.TXNStatusFees)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TXNStatusFees::IsInitialized() const {
  return true;
}

void TXNStatusFees::InternalSwap(TXNStatusFees* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.smart_contract_result_.InternalSwap(&other->_impl_.smart_contract_result_);
  _impl_.misc_.InternalSwap(&other->_impl_.misc_);
  _impl_.delegated_data_.InternalSwap(&other->_impl_.delegated_data_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.txn_hash_, lhs_arena,
      &other->_impl_.txn_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_fees_, lhs_arena,
      &other->_impl_.base_fees_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_contract_id_, lhs_arena,
      &other->_impl_.base_contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_fees_, lhs_arena,
      &other->_impl_.contract_fees_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_contract_id_, lhs_arena,
      &other->_impl_.contract_contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.native_function_fees_, lhs_arena,
      &other->_impl_.native_function_fees_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_fee_, lhs_arena,
      &other->_impl_.interface_fee_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_fee_id_, lhs_arena,
      &other->_impl_.interface_fee_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TXNStatusFees, _impl_.gas_)
      + sizeof(TXNStatusFees::_impl_.gas_)
      - PROTOBUF_FIELD_OFFSET(TXNStatusFees, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TXNStatusFees::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[66]);
}

// ===================================================================

class ProposalContract::_Internal {
 public:
};

ProposalContract::ProposalContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.ProposalContract)
}
ProposalContract::ProposalContract(const ProposalContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProposalContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proposal_ids_){from._impl_.proposal_ids_}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.stage_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.stage_ = from._impl_.stage_;
  // @@protoc_insertion_point(copy_constructor:zera_txn.ProposalContract)
}

inline void ProposalContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.proposal_ids_){arena}
    , decltype(_impl_.contract_id_){}
    , decltype(_impl_.stage_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProposalContract::~ProposalContract() {
  // @@protoc_insertion_point(destructor:zera_txn.ProposalContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProposalContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.proposal_ids_.~RepeatedPtrField();
  _impl_.contract_id_.Destroy();
}

void ProposalContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProposalContract::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.ProposalContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.proposal_ids_.Clear();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.stage_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProposalContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "zera_txn.ProposalContract.contract_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes proposal_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_proposal_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 stage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.stage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProposalContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.ProposalContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "zera_txn.ProposalContract.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // repeated bytes proposal_ids = 2;
  for (int i = 0, n = this->_internal_proposal_ids_size(); i < n; i++) {
    const auto& s = this->_internal_proposal_ids(i);
    target = stream->WriteBytes(2, s, target);
  }

  // uint32 stage = 3;
  if (this->_internal_stage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_stage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.ProposalContract)
  return target;
}

size_t ProposalContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.ProposalContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes proposal_ids = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.proposal_ids_.size());
  for (int i = 0, n = _impl_.proposal_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.proposal_ids_.Get(i));
  }

  // string contract_id = 1;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  // uint32 stage = 3;
  if (this->_internal_stage() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stage());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProposalContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProposalContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProposalContract::GetClassData() const { return &_class_data_; }


void ProposalContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProposalContract*>(&to_msg);
  auto& from = static_cast<const ProposalContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.ProposalContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.proposal_ids_.MergeFrom(from._impl_.proposal_ids_);
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (from._internal_stage() != 0) {
    _this->_internal_set_stage(from._internal_stage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProposalContract::CopyFrom(const ProposalContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.ProposalContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProposalContract::IsInitialized() const {
  return true;
}

void ProposalContract::InternalSwap(ProposalContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.proposal_ids_.InternalSwap(&other->_impl_.proposal_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contract_id_, lhs_arena,
      &other->_impl_.contract_id_, rhs_arena
  );
  swap(_impl_.stage_, other->_impl_.stage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProposalContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[67]);
}

// ===================================================================

class TXNWrapper::_Internal {
 public:
  using HasBits = decltype(std::declval<TXNWrapper>()._impl_._has_bits_);
  static const ::zera_txn::CoinTXN& coin_txn(const TXNWrapper* msg);
  static const ::zera_txn::MintTXN& mint_txn(const TXNWrapper* msg);
  static const ::zera_txn::ItemizedMintTXN& item_mint_txn(const TXNWrapper* msg);
  static const ::zera_txn::InstrumentContract& contract_txn(const TXNWrapper* msg);
  static const ::zera_txn::GovernanceVote& governance_vote(const TXNWrapper* msg);
  static const ::zera_txn::GovernanceProposal& governance_proposal(const TXNWrapper* msg);
  static const ::zera_txn::SmartContractTXN& smart_contract(const TXNWrapper* msg);
  static const ::zera_txn::SmartContractExecuteTXN& smart_contract_execute(const TXNWrapper* msg);
  static const ::zera_txn::SelfCurrencyEquiv& self_cur_equivs(const TXNWrapper* msg);
  static const ::zera_txn::AuthorizedCurrencyEquiv& auth_cur_equivs(const TXNWrapper* msg);
  static const ::zera_txn::ExpenseRatioTXN& expense_ratios(const TXNWrapper* msg);
  static const ::zera_txn::NFTTXN& nft_txn(const TXNWrapper* msg);
  static const ::zera_txn::ContractUpdateTXN& contract_update_txn(const TXNWrapper* msg);
  static const ::zera_txn::ValidatorRegistration& validator_registration_txn(const TXNWrapper* msg);
  static const ::zera_txn::ValidatorHeartbeat& validator_heartbeat_txn(const TXNWrapper* msg);
  static const ::zera_txn::FoundationTXN& foundation_txn(const TXNWrapper* msg);
  static const ::zera_txn::DelegatedTXN& delegated_voting_txn(const TXNWrapper* msg);
  static const ::zera_txn::QuashTXN& quash_txn(const TXNWrapper* msg);
  static const ::zera_txn::FastQuorumTXN& fast_quorum_txn(const TXNWrapper* msg);
  static const ::zera_txn::RevokeTXN& revoke_txn(const TXNWrapper* msg);
  static const ::zera_txn::ComplianceTXN& compliance_txn(const TXNWrapper* msg);
  static const ::zera_txn::BurnSBTTXN& burn_sbt_txn(const TXNWrapper* msg);
  static const ::zera_txn::RequiredVersion& required_version_txn(const TXNWrapper* msg);
  static const ::zera_txn::SmartContractInstantiateTXN& smart_contract_instantiate_txn(const TXNWrapper* msg);
  static const ::zera_txn::AllowanceTXN& allowance_txn(const TXNWrapper* msg);
  static void set_has_smart_contract_txn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::zera_txn::CoinTXN&
TXNWrapper::_Internal::coin_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.coin_txn_;
}
const ::zera_txn::MintTXN&
TXNWrapper::_Internal::mint_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.mint_txn_;
}
const ::zera_txn::ItemizedMintTXN&
TXNWrapper::_Internal::item_mint_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.item_mint_txn_;
}
const ::zera_txn::InstrumentContract&
TXNWrapper::_Internal::contract_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.contract_txn_;
}
const ::zera_txn::GovernanceVote&
TXNWrapper::_Internal::governance_vote(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.governance_vote_;
}
const ::zera_txn::GovernanceProposal&
TXNWrapper::_Internal::governance_proposal(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.governance_proposal_;
}
const ::zera_txn::SmartContractTXN&
TXNWrapper::_Internal::smart_contract(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.smart_contract_;
}
const ::zera_txn::SmartContractExecuteTXN&
TXNWrapper::_Internal::smart_contract_execute(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.smart_contract_execute_;
}
const ::zera_txn::SelfCurrencyEquiv&
TXNWrapper::_Internal::self_cur_equivs(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.self_cur_equivs_;
}
const ::zera_txn::AuthorizedCurrencyEquiv&
TXNWrapper::_Internal::auth_cur_equivs(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.auth_cur_equivs_;
}
const ::zera_txn::ExpenseRatioTXN&
TXNWrapper::_Internal::expense_ratios(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.expense_ratios_;
}
const ::zera_txn::NFTTXN&
TXNWrapper::_Internal::nft_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.nft_txn_;
}
const ::zera_txn::ContractUpdateTXN&
TXNWrapper::_Internal::contract_update_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.contract_update_txn_;
}
const ::zera_txn::ValidatorRegistration&
TXNWrapper::_Internal::validator_registration_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.validator_registration_txn_;
}
const ::zera_txn::ValidatorHeartbeat&
TXNWrapper::_Internal::validator_heartbeat_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.validator_heartbeat_txn_;
}
const ::zera_txn::FoundationTXN&
TXNWrapper::_Internal::foundation_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.foundation_txn_;
}
const ::zera_txn::DelegatedTXN&
TXNWrapper::_Internal::delegated_voting_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.delegated_voting_txn_;
}
const ::zera_txn::QuashTXN&
TXNWrapper::_Internal::quash_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.quash_txn_;
}
const ::zera_txn::FastQuorumTXN&
TXNWrapper::_Internal::fast_quorum_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.fast_quorum_txn_;
}
const ::zera_txn::RevokeTXN&
TXNWrapper::_Internal::revoke_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.revoke_txn_;
}
const ::zera_txn::ComplianceTXN&
TXNWrapper::_Internal::compliance_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.compliance_txn_;
}
const ::zera_txn::BurnSBTTXN&
TXNWrapper::_Internal::burn_sbt_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.burn_sbt_txn_;
}
const ::zera_txn::RequiredVersion&
TXNWrapper::_Internal::required_version_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.required_version_txn_;
}
const ::zera_txn::SmartContractInstantiateTXN&
TXNWrapper::_Internal::smart_contract_instantiate_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.smart_contract_instantiate_txn_;
}
const ::zera_txn::AllowanceTXN&
TXNWrapper::_Internal::allowance_txn(const TXNWrapper* msg) {
  return *msg->_impl_.payload_.allowance_txn_;
}
void TXNWrapper::set_allocated_coin_txn(::zera_txn::CoinTXN* coin_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (coin_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coin_txn);
    if (message_arena != submessage_arena) {
      coin_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coin_txn, submessage_arena);
    }
    set_has_coin_txn();
    _impl_.payload_.coin_txn_ = coin_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.coin_txn)
}
void TXNWrapper::set_allocated_mint_txn(::zera_txn::MintTXN* mint_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (mint_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mint_txn);
    if (message_arena != submessage_arena) {
      mint_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mint_txn, submessage_arena);
    }
    set_has_mint_txn();
    _impl_.payload_.mint_txn_ = mint_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.mint_txn)
}
void TXNWrapper::set_allocated_item_mint_txn(::zera_txn::ItemizedMintTXN* item_mint_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (item_mint_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item_mint_txn);
    if (message_arena != submessage_arena) {
      item_mint_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_mint_txn, submessage_arena);
    }
    set_has_item_mint_txn();
    _impl_.payload_.item_mint_txn_ = item_mint_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.item_mint_txn)
}
void TXNWrapper::set_allocated_contract_txn(::zera_txn::InstrumentContract* contract_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (contract_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract_txn);
    if (message_arena != submessage_arena) {
      contract_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_txn, submessage_arena);
    }
    set_has_contract_txn();
    _impl_.payload_.contract_txn_ = contract_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.contract_txn)
}
void TXNWrapper::set_allocated_governance_vote(::zera_txn::GovernanceVote* governance_vote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (governance_vote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(governance_vote);
    if (message_arena != submessage_arena) {
      governance_vote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, governance_vote, submessage_arena);
    }
    set_has_governance_vote();
    _impl_.payload_.governance_vote_ = governance_vote;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.governance_vote)
}
void TXNWrapper::set_allocated_governance_proposal(::zera_txn::GovernanceProposal* governance_proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (governance_proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(governance_proposal);
    if (message_arena != submessage_arena) {
      governance_proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, governance_proposal, submessage_arena);
    }
    set_has_governance_proposal();
    _impl_.payload_.governance_proposal_ = governance_proposal;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.governance_proposal)
}
void TXNWrapper::set_allocated_smart_contract(::zera_txn::SmartContractTXN* smart_contract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (smart_contract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(smart_contract);
    if (message_arena != submessage_arena) {
      smart_contract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smart_contract, submessage_arena);
    }
    set_has_smart_contract();
    _impl_.payload_.smart_contract_ = smart_contract;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.smart_contract)
}
void TXNWrapper::set_allocated_smart_contract_execute(::zera_txn::SmartContractExecuteTXN* smart_contract_execute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (smart_contract_execute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(smart_contract_execute);
    if (message_arena != submessage_arena) {
      smart_contract_execute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smart_contract_execute, submessage_arena);
    }
    set_has_smart_contract_execute();
    _impl_.payload_.smart_contract_execute_ = smart_contract_execute;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.smart_contract_execute)
}
void TXNWrapper::set_allocated_self_cur_equivs(::zera_txn::SelfCurrencyEquiv* self_cur_equivs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (self_cur_equivs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(self_cur_equivs);
    if (message_arena != submessage_arena) {
      self_cur_equivs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self_cur_equivs, submessage_arena);
    }
    set_has_self_cur_equivs();
    _impl_.payload_.self_cur_equivs_ = self_cur_equivs;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.self_cur_equivs)
}
void TXNWrapper::set_allocated_auth_cur_equivs(::zera_txn::AuthorizedCurrencyEquiv* auth_cur_equivs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (auth_cur_equivs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth_cur_equivs);
    if (message_arena != submessage_arena) {
      auth_cur_equivs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth_cur_equivs, submessage_arena);
    }
    set_has_auth_cur_equivs();
    _impl_.payload_.auth_cur_equivs_ = auth_cur_equivs;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.auth_cur_equivs)
}
void TXNWrapper::set_allocated_expense_ratios(::zera_txn::ExpenseRatioTXN* expense_ratios) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (expense_ratios) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expense_ratios);
    if (message_arena != submessage_arena) {
      expense_ratios = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expense_ratios, submessage_arena);
    }
    set_has_expense_ratios();
    _impl_.payload_.expense_ratios_ = expense_ratios;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.expense_ratios)
}
void TXNWrapper::set_allocated_nft_txn(::zera_txn::NFTTXN* nft_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (nft_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nft_txn);
    if (message_arena != submessage_arena) {
      nft_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nft_txn, submessage_arena);
    }
    set_has_nft_txn();
    _impl_.payload_.nft_txn_ = nft_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.nft_txn)
}
void TXNWrapper::set_allocated_contract_update_txn(::zera_txn::ContractUpdateTXN* contract_update_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (contract_update_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract_update_txn);
    if (message_arena != submessage_arena) {
      contract_update_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_update_txn, submessage_arena);
    }
    set_has_contract_update_txn();
    _impl_.payload_.contract_update_txn_ = contract_update_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.contract_update_txn)
}
void TXNWrapper::set_allocated_validator_registration_txn(::zera_txn::ValidatorRegistration* validator_registration_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (validator_registration_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(validator_registration_txn);
    if (message_arena != submessage_arena) {
      validator_registration_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator_registration_txn, submessage_arena);
    }
    set_has_validator_registration_txn();
    _impl_.payload_.validator_registration_txn_ = validator_registration_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.validator_registration_txn)
}
void TXNWrapper::set_allocated_validator_heartbeat_txn(::zera_txn::ValidatorHeartbeat* validator_heartbeat_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (validator_heartbeat_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(validator_heartbeat_txn);
    if (message_arena != submessage_arena) {
      validator_heartbeat_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator_heartbeat_txn, submessage_arena);
    }
    set_has_validator_heartbeat_txn();
    _impl_.payload_.validator_heartbeat_txn_ = validator_heartbeat_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.validator_heartbeat_txn)
}
void TXNWrapper::set_allocated_foundation_txn(::zera_txn::FoundationTXN* foundation_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (foundation_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(foundation_txn);
    if (message_arena != submessage_arena) {
      foundation_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foundation_txn, submessage_arena);
    }
    set_has_foundation_txn();
    _impl_.payload_.foundation_txn_ = foundation_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.foundation_txn)
}
void TXNWrapper::set_allocated_delegated_voting_txn(::zera_txn::DelegatedTXN* delegated_voting_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (delegated_voting_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delegated_voting_txn);
    if (message_arena != submessage_arena) {
      delegated_voting_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delegated_voting_txn, submessage_arena);
    }
    set_has_delegated_voting_txn();
    _impl_.payload_.delegated_voting_txn_ = delegated_voting_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.delegated_voting_txn)
}
void TXNWrapper::set_allocated_quash_txn(::zera_txn::QuashTXN* quash_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (quash_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quash_txn);
    if (message_arena != submessage_arena) {
      quash_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quash_txn, submessage_arena);
    }
    set_has_quash_txn();
    _impl_.payload_.quash_txn_ = quash_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.quash_txn)
}
void TXNWrapper::set_allocated_fast_quorum_txn(::zera_txn::FastQuorumTXN* fast_quorum_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (fast_quorum_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fast_quorum_txn);
    if (message_arena != submessage_arena) {
      fast_quorum_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fast_quorum_txn, submessage_arena);
    }
    set_has_fast_quorum_txn();
    _impl_.payload_.fast_quorum_txn_ = fast_quorum_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.fast_quorum_txn)
}
void TXNWrapper::set_allocated_revoke_txn(::zera_txn::RevokeTXN* revoke_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (revoke_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(revoke_txn);
    if (message_arena != submessage_arena) {
      revoke_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, revoke_txn, submessage_arena);
    }
    set_has_revoke_txn();
    _impl_.payload_.revoke_txn_ = revoke_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.revoke_txn)
}
void TXNWrapper::set_allocated_compliance_txn(::zera_txn::ComplianceTXN* compliance_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (compliance_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compliance_txn);
    if (message_arena != submessage_arena) {
      compliance_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compliance_txn, submessage_arena);
    }
    set_has_compliance_txn();
    _impl_.payload_.compliance_txn_ = compliance_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.compliance_txn)
}
void TXNWrapper::set_allocated_burn_sbt_txn(::zera_txn::BurnSBTTXN* burn_sbt_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (burn_sbt_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(burn_sbt_txn);
    if (message_arena != submessage_arena) {
      burn_sbt_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, burn_sbt_txn, submessage_arena);
    }
    set_has_burn_sbt_txn();
    _impl_.payload_.burn_sbt_txn_ = burn_sbt_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.burn_sbt_txn)
}
void TXNWrapper::set_allocated_required_version_txn(::zera_txn::RequiredVersion* required_version_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (required_version_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(required_version_txn);
    if (message_arena != submessage_arena) {
      required_version_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, required_version_txn, submessage_arena);
    }
    set_has_required_version_txn();
    _impl_.payload_.required_version_txn_ = required_version_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.required_version_txn)
}
void TXNWrapper::set_allocated_smart_contract_instantiate_txn(::zera_txn::SmartContractInstantiateTXN* smart_contract_instantiate_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (smart_contract_instantiate_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(smart_contract_instantiate_txn);
    if (message_arena != submessage_arena) {
      smart_contract_instantiate_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smart_contract_instantiate_txn, submessage_arena);
    }
    set_has_smart_contract_instantiate_txn();
    _impl_.payload_.smart_contract_instantiate_txn_ = smart_contract_instantiate_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.smart_contract_instantiate_txn)
}
void TXNWrapper::set_allocated_allowance_txn(::zera_txn::AllowanceTXN* allowance_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (allowance_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allowance_txn);
    if (message_arena != submessage_arena) {
      allowance_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allowance_txn, submessage_arena);
    }
    set_has_allowance_txn();
    _impl_.payload_.allowance_txn_ = allowance_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:zera_txn.TXNWrapper.allowance_txn)
}
TXNWrapper::TXNWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:zera_txn.TXNWrapper)
}
TXNWrapper::TXNWrapper(const TXNWrapper& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TXNWrapper* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.proposal_ids_){from._impl_.proposal_ids_}
    , decltype(_impl_.proposal_contracts_){from._impl_.proposal_contracts_}
    , decltype(_impl_.txn_type_){}
    , decltype(_impl_.smart_contract_txn_){}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.txn_type_, &from._impl_.txn_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.smart_contract_txn_) -
    reinterpret_cast<char*>(&_impl_.txn_type_)) + sizeof(_impl_.smart_contract_txn_));
  clear_has_payload();
  switch (from.payload_case()) {
    case kCoinTxn: {
      _this->_internal_mutable_coin_txn()->::zera_txn::CoinTXN::MergeFrom(
          from._internal_coin_txn());
      break;
    }
    case kMintTxn: {
      _this->_internal_mutable_mint_txn()->::zera_txn::MintTXN::MergeFrom(
          from._internal_mint_txn());
      break;
    }
    case kItemMintTxn: {
      _this->_internal_mutable_item_mint_txn()->::zera_txn::ItemizedMintTXN::MergeFrom(
          from._internal_item_mint_txn());
      break;
    }
    case kContractTxn: {
      _this->_internal_mutable_contract_txn()->::zera_txn::InstrumentContract::MergeFrom(
          from._internal_contract_txn());
      break;
    }
    case kGovernanceVote: {
      _this->_internal_mutable_governance_vote()->::zera_txn::GovernanceVote::MergeFrom(
          from._internal_governance_vote());
      break;
    }
    case kGovernanceProposal: {
      _this->_internal_mutable_governance_proposal()->::zera_txn::GovernanceProposal::MergeFrom(
          from._internal_governance_proposal());
      break;
    }
    case kSmartContract: {
      _this->_internal_mutable_smart_contract()->::zera_txn::SmartContractTXN::MergeFrom(
          from._internal_smart_contract());
      break;
    }
    case kSmartContractExecute: {
      _this->_internal_mutable_smart_contract_execute()->::zera_txn::SmartContractExecuteTXN::MergeFrom(
          from._internal_smart_contract_execute());
      break;
    }
    case kSelfCurEquivs: {
      _this->_internal_mutable_self_cur_equivs()->::zera_txn::SelfCurrencyEquiv::MergeFrom(
          from._internal_self_cur_equivs());
      break;
    }
    case kAuthCurEquivs: {
      _this->_internal_mutable_auth_cur_equivs()->::zera_txn::AuthorizedCurrencyEquiv::MergeFrom(
          from._internal_auth_cur_equivs());
      break;
    }
    case kExpenseRatios: {
      _this->_internal_mutable_expense_ratios()->::zera_txn::ExpenseRatioTXN::MergeFrom(
          from._internal_expense_ratios());
      break;
    }
    case kNftTxn: {
      _this->_internal_mutable_nft_txn()->::zera_txn::NFTTXN::MergeFrom(
          from._internal_nft_txn());
      break;
    }
    case kContractUpdateTxn: {
      _this->_internal_mutable_contract_update_txn()->::zera_txn::ContractUpdateTXN::MergeFrom(
          from._internal_contract_update_txn());
      break;
    }
    case kValidatorRegistrationTxn: {
      _this->_internal_mutable_validator_registration_txn()->::zera_txn::ValidatorRegistration::MergeFrom(
          from._internal_validator_registration_txn());
      break;
    }
    case kValidatorHeartbeatTxn: {
      _this->_internal_mutable_validator_heartbeat_txn()->::zera_txn::ValidatorHeartbeat::MergeFrom(
          from._internal_validator_heartbeat_txn());
      break;
    }
    case kFoundationTxn: {
      _this->_internal_mutable_foundation_txn()->::zera_txn::FoundationTXN::MergeFrom(
          from._internal_foundation_txn());
      break;
    }
    case kDelegatedVotingTxn: {
      _this->_internal_mutable_delegated_voting_txn()->::zera_txn::DelegatedTXN::MergeFrom(
          from._internal_delegated_voting_txn());
      break;
    }
    case kQuashTxn: {
      _this->_internal_mutable_quash_txn()->::zera_txn::QuashTXN::MergeFrom(
          from._internal_quash_txn());
      break;
    }
    case kFastQuorumTxn: {
      _this->_internal_mutable_fast_quorum_txn()->::zera_txn::FastQuorumTXN::MergeFrom(
          from._internal_fast_quorum_txn());
      break;
    }
    case kRevokeTxn: {
      _this->_internal_mutable_revoke_txn()->::zera_txn::RevokeTXN::MergeFrom(
          from._internal_revoke_txn());
      break;
    }
    case kComplianceTxn: {
      _this->_internal_mutable_compliance_txn()->::zera_txn::ComplianceTXN::MergeFrom(
          from._internal_compliance_txn());
      break;
    }
    case kProposalResultTxn: {
      _this->_internal_set_proposal_result_txn(from._internal_proposal_result_txn());
      break;
    }
    case kBurnSbtTxn: {
      _this->_internal_mutable_burn_sbt_txn()->::zera_txn::BurnSBTTXN::MergeFrom(
          from._internal_burn_sbt_txn());
      break;
    }
    case kRequiredVersionTxn: {
      _this->_internal_mutable_required_version_txn()->::zera_txn::RequiredVersion::MergeFrom(
          from._internal_required_version_txn());
      break;
    }
    case kSmartContractInstantiateTxn: {
      _this->_internal_mutable_smart_contract_instantiate_txn()->::zera_txn::SmartContractInstantiateTXN::MergeFrom(
          from._internal_smart_contract_instantiate_txn());
      break;
    }
    case kAllowanceTxn: {
      _this->_internal_mutable_allowance_txn()->::zera_txn::AllowanceTXN::MergeFrom(
          from._internal_allowance_txn());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:zera_txn.TXNWrapper)
}

inline void TXNWrapper::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.proposal_ids_){arena}
    , decltype(_impl_.proposal_contracts_){arena}
    , decltype(_impl_.txn_type_){0}
    , decltype(_impl_.smart_contract_txn_){false}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

TXNWrapper::~TXNWrapper() {
  // @@protoc_insertion_point(destructor:zera_txn.TXNWrapper)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TXNWrapper::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.proposal_ids_.~RepeatedPtrField();
  _impl_.proposal_contracts_.~RepeatedPtrField();
  if (has_payload()) {
    clear_payload();
  }
}

void TXNWrapper::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TXNWrapper::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:zera_txn.TXNWrapper)
  switch (payload_case()) {
    case kCoinTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.coin_txn_;
      }
      break;
    }
    case kMintTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.mint_txn_;
      }
      break;
    }
    case kItemMintTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.item_mint_txn_;
      }
      break;
    }
    case kContractTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.contract_txn_;
      }
      break;
    }
    case kGovernanceVote: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.governance_vote_;
      }
      break;
    }
    case kGovernanceProposal: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.governance_proposal_;
      }
      break;
    }
    case kSmartContract: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.smart_contract_;
      }
      break;
    }
    case kSmartContractExecute: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.smart_contract_execute_;
      }
      break;
    }
    case kSelfCurEquivs: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.self_cur_equivs_;
      }
      break;
    }
    case kAuthCurEquivs: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.auth_cur_equivs_;
      }
      break;
    }
    case kExpenseRatios: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.expense_ratios_;
      }
      break;
    }
    case kNftTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.nft_txn_;
      }
      break;
    }
    case kContractUpdateTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.contract_update_txn_;
      }
      break;
    }
    case kValidatorRegistrationTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.validator_registration_txn_;
      }
      break;
    }
    case kValidatorHeartbeatTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.validator_heartbeat_txn_;
      }
      break;
    }
    case kFoundationTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.foundation_txn_;
      }
      break;
    }
    case kDelegatedVotingTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.delegated_voting_txn_;
      }
      break;
    }
    case kQuashTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.quash_txn_;
      }
      break;
    }
    case kFastQuorumTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.fast_quorum_txn_;
      }
      break;
    }
    case kRevokeTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.revoke_txn_;
      }
      break;
    }
    case kComplianceTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.compliance_txn_;
      }
      break;
    }
    case kProposalResultTxn: {
      // No need to clear
      break;
    }
    case kBurnSbtTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.burn_sbt_txn_;
      }
      break;
    }
    case kRequiredVersionTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.required_version_txn_;
      }
      break;
    }
    case kSmartContractInstantiateTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.smart_contract_instantiate_txn_;
      }
      break;
    }
    case kAllowanceTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.allowance_txn_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void TXNWrapper::Clear() {
// @@protoc_insertion_point(message_clear_start:zera_txn.TXNWrapper)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.proposal_ids_.Clear();
  _impl_.proposal_contracts_.Clear();
  _impl_.txn_type_ = 0;
  _impl_.smart_contract_txn_ = false;
  clear_payload();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TXNWrapper::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .zera_txn.CoinTXN coin_txn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_coin_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.MintTXN mint_txn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mint_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.ItemizedMintTXN item_mint_txn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_item_mint_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.InstrumentContract contract_txn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.GovernanceVote governance_vote = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_governance_vote(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.GovernanceProposal governance_proposal = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_governance_proposal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.SmartContractTXN smart_contract = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_smart_contract(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.SmartContractExecuteTXN smart_contract_execute = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_smart_contract_execute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_self_cur_equivs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_auth_cur_equivs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.ExpenseRatioTXN expense_ratios = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_expense_ratios(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.NFTTXN nft_txn = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_nft_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.ContractUpdateTXN contract_update_txn = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract_update_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.ValidatorRegistration validator_registration_txn = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_validator_registration_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.ValidatorHeartbeat validator_heartbeat_txn = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_validator_heartbeat_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.FoundationTXN foundation_txn = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_foundation_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.DelegatedTXN delegated_voting_txn = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_delegated_voting_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.QuashTXN quash_txn = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_quash_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.FastQuorumTXN fast_quorum_txn = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_fast_quorum_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.RevokeTXN revoke_txn = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_revoke_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.ComplianceTXN compliance_txn = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_compliance_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool proposal_result_txn = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _internal_set_proposal_result_txn(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.BurnSBTTXN burn_sbt_txn = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_burn_sbt_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.RequiredVersion required_version_txn = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_required_version_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txn = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_smart_contract_instantiate_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.TRANSACTION_TYPE txn_type = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_txn_type(static_cast<::zera_txn::TRANSACTION_TYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes proposal_ids = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_proposal_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .zera_txn.ProposalContract proposal_contracts = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_proposal_contracts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<226>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool smart_contract_txn = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_smart_contract_txn(&has_bits);
          _impl_.smart_contract_txn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .zera_txn.AllowanceTXN allowance_txn = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_allowance_txn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TXNWrapper::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zera_txn.TXNWrapper)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .zera_txn.CoinTXN coin_txn = 1;
  if (_internal_has_coin_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::coin_txn(this),
        _Internal::coin_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.MintTXN mint_txn = 2;
  if (_internal_has_mint_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::mint_txn(this),
        _Internal::mint_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.ItemizedMintTXN item_mint_txn = 3;
  if (_internal_has_item_mint_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::item_mint_txn(this),
        _Internal::item_mint_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.InstrumentContract contract_txn = 4;
  if (_internal_has_contract_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::contract_txn(this),
        _Internal::contract_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.GovernanceVote governance_vote = 5;
  if (_internal_has_governance_vote()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::governance_vote(this),
        _Internal::governance_vote(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.GovernanceProposal governance_proposal = 6;
  if (_internal_has_governance_proposal()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::governance_proposal(this),
        _Internal::governance_proposal(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.SmartContractTXN smart_contract = 7;
  if (_internal_has_smart_contract()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::smart_contract(this),
        _Internal::smart_contract(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.SmartContractExecuteTXN smart_contract_execute = 8;
  if (_internal_has_smart_contract_execute()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::smart_contract_execute(this),
        _Internal::smart_contract_execute(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
  if (_internal_has_self_cur_equivs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::self_cur_equivs(this),
        _Internal::self_cur_equivs(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
  if (_internal_has_auth_cur_equivs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::auth_cur_equivs(this),
        _Internal::auth_cur_equivs(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.ExpenseRatioTXN expense_ratios = 11;
  if (_internal_has_expense_ratios()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::expense_ratios(this),
        _Internal::expense_ratios(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.NFTTXN nft_txn = 12;
  if (_internal_has_nft_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::nft_txn(this),
        _Internal::nft_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.ContractUpdateTXN contract_update_txn = 13;
  if (_internal_has_contract_update_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::contract_update_txn(this),
        _Internal::contract_update_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.ValidatorRegistration validator_registration_txn = 14;
  if (_internal_has_validator_registration_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::validator_registration_txn(this),
        _Internal::validator_registration_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.ValidatorHeartbeat validator_heartbeat_txn = 15;
  if (_internal_has_validator_heartbeat_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::validator_heartbeat_txn(this),
        _Internal::validator_heartbeat_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.FoundationTXN foundation_txn = 16;
  if (_internal_has_foundation_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::foundation_txn(this),
        _Internal::foundation_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.DelegatedTXN delegated_voting_txn = 17;
  if (_internal_has_delegated_voting_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::delegated_voting_txn(this),
        _Internal::delegated_voting_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.QuashTXN quash_txn = 18;
  if (_internal_has_quash_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::quash_txn(this),
        _Internal::quash_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.FastQuorumTXN fast_quorum_txn = 19;
  if (_internal_has_fast_quorum_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::fast_quorum_txn(this),
        _Internal::fast_quorum_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.RevokeTXN revoke_txn = 20;
  if (_internal_has_revoke_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::revoke_txn(this),
        _Internal::revoke_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.ComplianceTXN compliance_txn = 21;
  if (_internal_has_compliance_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::compliance_txn(this),
        _Internal::compliance_txn(this).GetCachedSize(), target, stream);
  }

  // bool proposal_result_txn = 22;
  if (_internal_has_proposal_result_txn()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_proposal_result_txn(), target);
  }

  // .zera_txn.BurnSBTTXN burn_sbt_txn = 23;
  if (_internal_has_burn_sbt_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::burn_sbt_txn(this),
        _Internal::burn_sbt_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.RequiredVersion required_version_txn = 24;
  if (_internal_has_required_version_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::required_version_txn(this),
        _Internal::required_version_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txn = 25;
  if (_internal_has_smart_contract_instantiate_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::smart_contract_instantiate_txn(this),
        _Internal::smart_contract_instantiate_txn(this).GetCachedSize(), target, stream);
  }

  // .zera_txn.TRANSACTION_TYPE txn_type = 26;
  if (this->_internal_txn_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      26, this->_internal_txn_type(), target);
  }

  // repeated bytes proposal_ids = 27;
  for (int i = 0, n = this->_internal_proposal_ids_size(); i < n; i++) {
    const auto& s = this->_internal_proposal_ids(i);
    target = stream->WriteBytes(27, s, target);
  }

  // repeated .zera_txn.ProposalContract proposal_contracts = 28;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_proposal_contracts_size()); i < n; i++) {
    const auto& repfield = this->_internal_proposal_contracts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool smart_contract_txn = 29;
  if (_internal_has_smart_contract_txn()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_smart_contract_txn(), target);
  }

  // .zera_txn.AllowanceTXN allowance_txn = 30;
  if (_internal_has_allowance_txn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::allowance_txn(this),
        _Internal::allowance_txn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zera_txn.TXNWrapper)
  return target;
}

size_t TXNWrapper::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zera_txn.TXNWrapper)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes proposal_ids = 27;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.proposal_ids_.size());
  for (int i = 0, n = _impl_.proposal_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.proposal_ids_.Get(i));
  }

  // repeated .zera_txn.ProposalContract proposal_contracts = 28;
  total_size += 2UL * this->_internal_proposal_contracts_size();
  for (const auto& msg : this->_impl_.proposal_contracts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .zera_txn.TRANSACTION_TYPE txn_type = 26;
  if (this->_internal_txn_type() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_txn_type());
  }

  // optional bool smart_contract_txn = 29;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 + 1;
  }

  switch (payload_case()) {
    // .zera_txn.CoinTXN coin_txn = 1;
    case kCoinTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.coin_txn_);
      break;
    }
    // .zera_txn.MintTXN mint_txn = 2;
    case kMintTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.mint_txn_);
      break;
    }
    // .zera_txn.ItemizedMintTXN item_mint_txn = 3;
    case kItemMintTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.item_mint_txn_);
      break;
    }
    // .zera_txn.InstrumentContract contract_txn = 4;
    case kContractTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.contract_txn_);
      break;
    }
    // .zera_txn.GovernanceVote governance_vote = 5;
    case kGovernanceVote: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.governance_vote_);
      break;
    }
    // .zera_txn.GovernanceProposal governance_proposal = 6;
    case kGovernanceProposal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.governance_proposal_);
      break;
    }
    // .zera_txn.SmartContractTXN smart_contract = 7;
    case kSmartContract: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.smart_contract_);
      break;
    }
    // .zera_txn.SmartContractExecuteTXN smart_contract_execute = 8;
    case kSmartContractExecute: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.smart_contract_execute_);
      break;
    }
    // .zera_txn.SelfCurrencyEquiv self_cur_equivs = 9;
    case kSelfCurEquivs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.self_cur_equivs_);
      break;
    }
    // .zera_txn.AuthorizedCurrencyEquiv auth_cur_equivs = 10;
    case kAuthCurEquivs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.auth_cur_equivs_);
      break;
    }
    // .zera_txn.ExpenseRatioTXN expense_ratios = 11;
    case kExpenseRatios: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.expense_ratios_);
      break;
    }
    // .zera_txn.NFTTXN nft_txn = 12;
    case kNftTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.nft_txn_);
      break;
    }
    // .zera_txn.ContractUpdateTXN contract_update_txn = 13;
    case kContractUpdateTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.contract_update_txn_);
      break;
    }
    // .zera_txn.ValidatorRegistration validator_registration_txn = 14;
    case kValidatorRegistrationTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.validator_registration_txn_);
      break;
    }
    // .zera_txn.ValidatorHeartbeat validator_heartbeat_txn = 15;
    case kValidatorHeartbeatTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.validator_heartbeat_txn_);
      break;
    }
    // .zera_txn.FoundationTXN foundation_txn = 16;
    case kFoundationTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.foundation_txn_);
      break;
    }
    // .zera_txn.DelegatedTXN delegated_voting_txn = 17;
    case kDelegatedVotingTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.delegated_voting_txn_);
      break;
    }
    // .zera_txn.QuashTXN quash_txn = 18;
    case kQuashTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.quash_txn_);
      break;
    }
    // .zera_txn.FastQuorumTXN fast_quorum_txn = 19;
    case kFastQuorumTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.fast_quorum_txn_);
      break;
    }
    // .zera_txn.RevokeTXN revoke_txn = 20;
    case kRevokeTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.revoke_txn_);
      break;
    }
    // .zera_txn.ComplianceTXN compliance_txn = 21;
    case kComplianceTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.compliance_txn_);
      break;
    }
    // bool proposal_result_txn = 22;
    case kProposalResultTxn: {
      total_size += 2 + 1;
      break;
    }
    // .zera_txn.BurnSBTTXN burn_sbt_txn = 23;
    case kBurnSbtTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.burn_sbt_txn_);
      break;
    }
    // .zera_txn.RequiredVersion required_version_txn = 24;
    case kRequiredVersionTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.required_version_txn_);
      break;
    }
    // .zera_txn.SmartContractInstantiateTXN smart_contract_instantiate_txn = 25;
    case kSmartContractInstantiateTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.smart_contract_instantiate_txn_);
      break;
    }
    // .zera_txn.AllowanceTXN allowance_txn = 30;
    case kAllowanceTxn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.allowance_txn_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TXNWrapper::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TXNWrapper::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TXNWrapper::GetClassData() const { return &_class_data_; }


void TXNWrapper::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TXNWrapper*>(&to_msg);
  auto& from = static_cast<const TXNWrapper&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:zera_txn.TXNWrapper)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.proposal_ids_.MergeFrom(from._impl_.proposal_ids_);
  _this->_impl_.proposal_contracts_.MergeFrom(from._impl_.proposal_contracts_);
  if (from._internal_txn_type() != 0) {
    _this->_internal_set_txn_type(from._internal_txn_type());
  }
  if (from._internal_has_smart_contract_txn()) {
    _this->_internal_set_smart_contract_txn(from._internal_smart_contract_txn());
  }
  switch (from.payload_case()) {
    case kCoinTxn: {
      _this->_internal_mutable_coin_txn()->::zera_txn::CoinTXN::MergeFrom(
          from._internal_coin_txn());
      break;
    }
    case kMintTxn: {
      _this->_internal_mutable_mint_txn()->::zera_txn::MintTXN::MergeFrom(
          from._internal_mint_txn());
      break;
    }
    case kItemMintTxn: {
      _this->_internal_mutable_item_mint_txn()->::zera_txn::ItemizedMintTXN::MergeFrom(
          from._internal_item_mint_txn());
      break;
    }
    case kContractTxn: {
      _this->_internal_mutable_contract_txn()->::zera_txn::InstrumentContract::MergeFrom(
          from._internal_contract_txn());
      break;
    }
    case kGovernanceVote: {
      _this->_internal_mutable_governance_vote()->::zera_txn::GovernanceVote::MergeFrom(
          from._internal_governance_vote());
      break;
    }
    case kGovernanceProposal: {
      _this->_internal_mutable_governance_proposal()->::zera_txn::GovernanceProposal::MergeFrom(
          from._internal_governance_proposal());
      break;
    }
    case kSmartContract: {
      _this->_internal_mutable_smart_contract()->::zera_txn::SmartContractTXN::MergeFrom(
          from._internal_smart_contract());
      break;
    }
    case kSmartContractExecute: {
      _this->_internal_mutable_smart_contract_execute()->::zera_txn::SmartContractExecuteTXN::MergeFrom(
          from._internal_smart_contract_execute());
      break;
    }
    case kSelfCurEquivs: {
      _this->_internal_mutable_self_cur_equivs()->::zera_txn::SelfCurrencyEquiv::MergeFrom(
          from._internal_self_cur_equivs());
      break;
    }
    case kAuthCurEquivs: {
      _this->_internal_mutable_auth_cur_equivs()->::zera_txn::AuthorizedCurrencyEquiv::MergeFrom(
          from._internal_auth_cur_equivs());
      break;
    }
    case kExpenseRatios: {
      _this->_internal_mutable_expense_ratios()->::zera_txn::ExpenseRatioTXN::MergeFrom(
          from._internal_expense_ratios());
      break;
    }
    case kNftTxn: {
      _this->_internal_mutable_nft_txn()->::zera_txn::NFTTXN::MergeFrom(
          from._internal_nft_txn());
      break;
    }
    case kContractUpdateTxn: {
      _this->_internal_mutable_contract_update_txn()->::zera_txn::ContractUpdateTXN::MergeFrom(
          from._internal_contract_update_txn());
      break;
    }
    case kValidatorRegistrationTxn: {
      _this->_internal_mutable_validator_registration_txn()->::zera_txn::ValidatorRegistration::MergeFrom(
          from._internal_validator_registration_txn());
      break;
    }
    case kValidatorHeartbeatTxn: {
      _this->_internal_mutable_validator_heartbeat_txn()->::zera_txn::ValidatorHeartbeat::MergeFrom(
          from._internal_validator_heartbeat_txn());
      break;
    }
    case kFoundationTxn: {
      _this->_internal_mutable_foundation_txn()->::zera_txn::FoundationTXN::MergeFrom(
          from._internal_foundation_txn());
      break;
    }
    case kDelegatedVotingTxn: {
      _this->_internal_mutable_delegated_voting_txn()->::zera_txn::DelegatedTXN::MergeFrom(
          from._internal_delegated_voting_txn());
      break;
    }
    case kQuashTxn: {
      _this->_internal_mutable_quash_txn()->::zera_txn::QuashTXN::MergeFrom(
          from._internal_quash_txn());
      break;
    }
    case kFastQuorumTxn: {
      _this->_internal_mutable_fast_quorum_txn()->::zera_txn::FastQuorumTXN::MergeFrom(
          from._internal_fast_quorum_txn());
      break;
    }
    case kRevokeTxn: {
      _this->_internal_mutable_revoke_txn()->::zera_txn::RevokeTXN::MergeFrom(
          from._internal_revoke_txn());
      break;
    }
    case kComplianceTxn: {
      _this->_internal_mutable_compliance_txn()->::zera_txn::ComplianceTXN::MergeFrom(
          from._internal_compliance_txn());
      break;
    }
    case kProposalResultTxn: {
      _this->_internal_set_proposal_result_txn(from._internal_proposal_result_txn());
      break;
    }
    case kBurnSbtTxn: {
      _this->_internal_mutable_burn_sbt_txn()->::zera_txn::BurnSBTTXN::MergeFrom(
          from._internal_burn_sbt_txn());
      break;
    }
    case kRequiredVersionTxn: {
      _this->_internal_mutable_required_version_txn()->::zera_txn::RequiredVersion::MergeFrom(
          from._internal_required_version_txn());
      break;
    }
    case kSmartContractInstantiateTxn: {
      _this->_internal_mutable_smart_contract_instantiate_txn()->::zera_txn::SmartContractInstantiateTXN::MergeFrom(
          from._internal_smart_contract_instantiate_txn());
      break;
    }
    case kAllowanceTxn: {
      _this->_internal_mutable_allowance_txn()->::zera_txn::AllowanceTXN::MergeFrom(
          from._internal_allowance_txn());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TXNWrapper::CopyFrom(const TXNWrapper& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zera_txn.TXNWrapper)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TXNWrapper::IsInitialized() const {
  return true;
}

void TXNWrapper::InternalSwap(TXNWrapper* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.proposal_ids_.InternalSwap(&other->_impl_.proposal_ids_);
  _impl_.proposal_contracts_.InternalSwap(&other->_impl_.proposal_contracts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TXNWrapper, _impl_.smart_contract_txn_)
      + sizeof(TXNWrapper::_impl_.smart_contract_txn_)
      - PROTOBUF_FIELD_OFFSET(TXNWrapper, _impl_.txn_type_)>(
          reinterpret_cast<char*>(&_impl_.txn_type_),
          reinterpret_cast<char*>(&other->_impl_.txn_type_));
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TXNWrapper::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_txn_2eproto_getter, &descriptor_table_txn_2eproto_once,
      file_level_metadata_txn_2eproto[68]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace zera_txn
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::zera_txn::DelegateContract*
Arena::CreateMaybeMessage< ::zera_txn::DelegateContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::DelegateContract >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::DelegatedTXN*
Arena::CreateMaybeMessage< ::zera_txn::DelegatedTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::DelegatedTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::DelegateVote*
Arena::CreateMaybeMessage< ::zera_txn::DelegateVote >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::DelegateVote >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::DelegateFees*
Arena::CreateMaybeMessage< ::zera_txn::DelegateFees >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::DelegateFees >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Compliance*
Arena::CreateMaybeMessage< ::zera_txn::Compliance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Compliance >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::TokenCompliance*
Arena::CreateMaybeMessage< ::zera_txn::TokenCompliance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::TokenCompliance >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ExpenseRatio*
Arena::CreateMaybeMessage< ::zera_txn::ExpenseRatio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ExpenseRatio >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::KeyValuePair*
Arena::CreateMaybeMessage< ::zera_txn::KeyValuePair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::KeyValuePair >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ByteMultiplier*
Arena::CreateMaybeMessage< ::zera_txn::ByteMultiplier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ByteMultiplier >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::FoundationTXN*
Arena::CreateMaybeMessage< ::zera_txn::FoundationTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::FoundationTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::RevokeTXN*
Arena::CreateMaybeMessage< ::zera_txn::RevokeTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::RevokeTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::FastQuorumTXN*
Arena::CreateMaybeMessage< ::zera_txn::FastQuorumTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::FastQuorumTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Governance*
Arena::CreateMaybeMessage< ::zera_txn::Governance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Governance >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Stage*
Arena::CreateMaybeMessage< ::zera_txn::Stage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Stage >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::CoinDenomination*
Arena::CreateMaybeMessage< ::zera_txn::CoinDenomination >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::CoinDenomination >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ContractFees*
Arena::CreateMaybeMessage< ::zera_txn::ContractFees >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ContractFees >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ItemContractFees*
Arena::CreateMaybeMessage< ::zera_txn::ItemContractFees >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ItemContractFees >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::RestrictedKey*
Arena::CreateMaybeMessage< ::zera_txn::RestrictedKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::RestrictedKey >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ExpenseRatioTXN*
Arena::CreateMaybeMessage< ::zera_txn::ExpenseRatioTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ExpenseRatioTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::PreMintWallet*
Arena::CreateMaybeMessage< ::zera_txn::PreMintWallet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::PreMintWallet >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Transfer*
Arena::CreateMaybeMessage< ::zera_txn::Transfer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Transfer >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::BurnSBTTXN*
Arena::CreateMaybeMessage< ::zera_txn::BurnSBTTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::BurnSBTTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::BaseTXN*
Arena::CreateMaybeMessage< ::zera_txn::BaseTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::BaseTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::PublicKey*
Arena::CreateMaybeMessage< ::zera_txn::PublicKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::PublicKey >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::GovernanceAuth*
Arena::CreateMaybeMessage< ::zera_txn::GovernanceAuth >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::GovernanceAuth >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::MultiKey*
Arena::CreateMaybeMessage< ::zera_txn::MultiKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::MultiKey >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::MultiPatterns*
Arena::CreateMaybeMessage< ::zera_txn::MultiPatterns >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::MultiPatterns >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::SelfCurrencyEquiv*
Arena::CreateMaybeMessage< ::zera_txn::SelfCurrencyEquiv >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::SelfCurrencyEquiv >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::AuthorizedCurrencyEquiv*
Arena::CreateMaybeMessage< ::zera_txn::AuthorizedCurrencyEquiv >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::AuthorizedCurrencyEquiv >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::CurrencyEquiv*
Arena::CreateMaybeMessage< ::zera_txn::CurrencyEquiv >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::CurrencyEquiv >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ExpenseRatioResult*
Arena::CreateMaybeMessage< ::zera_txn::ExpenseRatioResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ExpenseRatioResult >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ComplianceAssign*
Arena::CreateMaybeMessage< ::zera_txn::ComplianceAssign >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ComplianceAssign >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ComplianceTXN*
Arena::CreateMaybeMessage< ::zera_txn::ComplianceTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ComplianceTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Wallets*
Arena::CreateMaybeMessage< ::zera_txn::Wallets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Wallets >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::QuashTXN*
Arena::CreateMaybeMessage< ::zera_txn::QuashTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::QuashTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::QuashResult*
Arena::CreateMaybeMessage< ::zera_txn::QuashResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::QuashResult >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::CoinTXN*
Arena::CreateMaybeMessage< ::zera_txn::CoinTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::CoinTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::TransferAuthentication*
Arena::CreateMaybeMessage< ::zera_txn::TransferAuthentication >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::TransferAuthentication >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::InputTransfers*
Arena::CreateMaybeMessage< ::zera_txn::InputTransfers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::InputTransfers >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::OutputTransfers*
Arena::CreateMaybeMessage< ::zera_txn::OutputTransfers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::OutputTransfers >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::MintTXN*
Arena::CreateMaybeMessage< ::zera_txn::MintTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::MintTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::NFTTXN*
Arena::CreateMaybeMessage< ::zera_txn::NFTTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::NFTTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ItemizedMintTXN*
Arena::CreateMaybeMessage< ::zera_txn::ItemizedMintTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ItemizedMintTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ContractUpdateTXN*
Arena::CreateMaybeMessage< ::zera_txn::ContractUpdateTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ContractUpdateTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::InstrumentContract*
Arena::CreateMaybeMessage< ::zera_txn::InstrumentContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::InstrumentContract >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::MaxSupplyRelease*
Arena::CreateMaybeMessage< ::zera_txn::MaxSupplyRelease >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::MaxSupplyRelease >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::GovernanceVote*
Arena::CreateMaybeMessage< ::zera_txn::GovernanceVote >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::GovernanceVote >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::GovernanceProposal*
Arena::CreateMaybeMessage< ::zera_txn::GovernanceProposal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::GovernanceProposal >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::GovernanceTXN*
Arena::CreateMaybeMessage< ::zera_txn::GovernanceTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::GovernanceTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::SmartContractTXN*
Arena::CreateMaybeMessage< ::zera_txn::SmartContractTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::SmartContractTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Parameters*
Arena::CreateMaybeMessage< ::zera_txn::Parameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Parameters >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::SmartContractExecuteTXN*
Arena::CreateMaybeMessage< ::zera_txn::SmartContractExecuteTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::SmartContractExecuteTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::SmartContractInstantiateTXN*
Arena::CreateMaybeMessage< ::zera_txn::SmartContractInstantiateTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::SmartContractInstantiateTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Validator*
Arena::CreateMaybeMessage< ::zera_txn::Validator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Validator >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ValidatorRegistration*
Arena::CreateMaybeMessage< ::zera_txn::ValidatorRegistration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ValidatorRegistration >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ValidatorHeartbeat*
Arena::CreateMaybeMessage< ::zera_txn::ValidatorHeartbeat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ValidatorHeartbeat >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::SmartContractParameter*
Arena::CreateMaybeMessage< ::zera_txn::SmartContractParameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::SmartContractParameter >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Votes*
Arena::CreateMaybeMessage< ::zera_txn::Votes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Votes >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::VotePair*
Arena::CreateMaybeMessage< ::zera_txn::VotePair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::VotePair >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::RequiredVersion*
Arena::CreateMaybeMessage< ::zera_txn::RequiredVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::RequiredVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ProposalResult*
Arena::CreateMaybeMessage< ::zera_txn::ProposalResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ProposalResult >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::AllowanceTXN*
Arena::CreateMaybeMessage< ::zera_txn::AllowanceTXN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::AllowanceTXN >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::TXNS*
Arena::CreateMaybeMessage< ::zera_txn::TXNS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::TXNS >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::Token*
Arena::CreateMaybeMessage< ::zera_txn::Token >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::Token >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::TokenFees*
Arena::CreateMaybeMessage< ::zera_txn::TokenFees >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::TokenFees >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::DelegatedData*
Arena::CreateMaybeMessage< ::zera_txn::DelegatedData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::DelegatedData >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::TXNStatusFees*
Arena::CreateMaybeMessage< ::zera_txn::TXNStatusFees >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::TXNStatusFees >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::ProposalContract*
Arena::CreateMaybeMessage< ::zera_txn::ProposalContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::ProposalContract >(arena);
}
template<> PROTOBUF_NOINLINE ::zera_txn::TXNWrapper*
Arena::CreateMaybeMessage< ::zera_txn::TXNWrapper >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zera_txn::TXNWrapper >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
